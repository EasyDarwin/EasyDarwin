#ifndef _HC_NET_SDK_H_
#define _HC_NET_SDK_H_



#ifndef _WINDOWS_
    #if (defined(_WIN32) || defined(_WIN64))
        #include <winsock2.h>
        #include <windows.h>    
    #endif
#endif

#ifndef __PLAYRECT_defined
#define __PLAYRECT_defined
typedef struct __PLAYRECT
{
    int x;                               
    int y;                                  
    int uWidth;                            
    int uHeight;                            
}PLAYRECT;
#endif

#if (defined(_WIN32)) //windows
#define NET_DVR_API  extern "C" __declspec(dllimport)
typedef  unsigned __int64 UINT64;
typedef  signed __int64 INT64;
#elif defined(__linux__) || defined(__APPLE__) //linux
typedef     unsigned int    DWORD;
typedef     unsigned short  WORD;
typedef     unsigned short  USHORT;
typedef     short           SHORT;
typedef     int             LONG;
typedef      unsigned char    BYTE;
#define     BOOL int
typedef     unsigned int       UINT;
typedef     void*             LPVOID;
typedef     void*             HANDLE;
typedef     unsigned int*  LPDWORD; 
typedef  unsigned long long UINT64;
typedef  signed long long INT64;

#ifndef    TRUE
#define    TRUE    1
#endif
#ifndef    FALSE
#define       FALSE 0
#endif
#ifndef    NULL
#define       NULL 0
#endif

#define __stdcall 
#define CALLBACK  

#define NET_DVR_API extern "C"
typedef unsigned int   COLORKEY;
typedef unsigned int   COLORREF;

#ifndef __HWND_defined
#define __HWND_defined
#if defined(__linux__)
typedef unsigned int HWND;
#else
typedef void* HWND;
#endif
#endif


#ifndef __HDC_defined
#define __HDC_defined
#if defined(__linux__)
typedef struct __DC
{
    void*   surface;        //SDL Surface
    HWND    hWnd;           // HDC window handle
}DC;
typedef DC* HDC;
#else
typedef void* HDC;
#endif
#endif

typedef struct tagInitInfo
{
    int uWidth; 
    int uHeight; 
}INITINFO; 
#endif

//宏定义
#define MAX_NAMELEN                16        //DVR本地登陆名
#define MAX_RIGHT                32        //设备支持的权限（1-12表示本地权限，13-32表示远程权限）
#define NAME_LEN                32      //用户名长度
#define PASSWD_LEN                16      //密码长度
#define MAX_PASSWD_LEN_EX            64      //密码长度64位
#define GUID_LEN                16      //GUID长度
#define DEV_TYPE_NAME_LEN        24      //设备类型名称长度
#define SERIALNO_LEN            48      //序列号长度
#define MACADDR_LEN                6       //mac地址长度
#define MAX_ETHERNET            2       //设备可配以太网络
#define MAX_NETWORK_CARD        4       //设备可配最大网卡数目
#define PATHNAME_LEN            128     //路径长度
#define MAX_PRESET_V13          16      //预置点
#define MAX_TEST_COMMAND_NUM   32      //产线测试保留字段长度
#define MAX_NUMBER_LEN            32        //号码最大长度
#define MAX_NAME_LEN            128        //设备名称最大长度
#define MAX_INDEX_LED           8       //LED索引最大值 2013-11-19
#define    MAX_CUSTOM_DIR            64      //自定义目录最大长度
#define URL_LEN_V40             256        //最大URL长度
#define CLOUD_NAME_LEN          48      //云存储服务器用户名长度
#define CLOUD_PASSWD_LEN        48      //云存储服务器密码长度
#define MAX_SENSORNAME_LEN      64      //传感器名称长度
#define MAX_SENSORCHAN_LEN      32      //传感器通道长度
#define MAX_DESCRIPTION_LEN     32      //传感器描述长度
#define MAX_DEVNAME_LEN_EX      64      //设备名称长度扩展
#define MAX_FILE_PATH_LEN       256     //文件路径长度 
#define MAX_TMEVOICE_LEN        64      //TME语音播报内容长度

#define MAX_NUM_INPUT_BOARD     512     //输入板最大个数
#define MAX_SHIPSDETE_REGION_NUM    8 // 船只检测区域列表最大数目

//小间距LED控制器
#define  MAX_LEN_TEXT_CONTENT    128  //字符内容长度
#define  MAX_NUM_INPUT_SOURCE_TEXT    32    //信号源可叠加的文本数量
#define  MAX_NUM_OUTPUT_CHANNEL  512  //LED区域包含的输出口个数

//2013-11-19
#define MAX_DEVNAME_LEN         32      //设备名称最大长度
#define MAX_LED_INFO            256     //屏幕字体显示信息最大长度
#define MAX_TIME_LEN            32      //时间最大长度
#define MAX_CARD_LEN            24      //卡号最大长度
#define MAX_OPERATORNAME_LEN    32      //操作人员名称最大长度

#define THERMOMETRY_ALARMRULE_NUM 40     //热成像报警规则数
#define MAX_THERMOMETRY_REGION_NUM  40  //热度图检测区域最大支持数
#define MAX_THERMOMETRY_DIFFCOMPARISON_NUM  40 //热成像温差报警规则数
#define MAX_SHIPS_NUM           20      //船只检测最大船只数
#define KEY_WORD_NUM             3 //关键字个数
#define KEY_WORD_LEN            128  //关键字长度
//异步登录回调状态宏定义
#define ASYN_LOGIN_SUCC            1        //异步登录成功
#define ASYN_LOGIN_FAILED        0        //异步登录失败


#define MAX_TIMESEGMENT_V30        8       //9000设备最大时间段数
#define MAX_TIMESEGMENT            4       //8000设备最大时间段数
#define MAX_ICR_NUM             8       //抓拍机红外滤光片预置点数2013-07-09

#define MAX_SHELTERNUM            4       //8000设备最大遮挡区域数
#define MAX_DAYS                7       //每周天数
#define PHONENUMBER_LEN            32      //pppoe拨号号码最大长度

#define MAX_DISKNUM_V30            33        //9000设备最大硬盘数/* 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘) */
#define MAX_DISKNUM                16      //8000设备最大硬盘数
#define MAX_DISKNUM_V10            8       //1.2版本之前版本

#define MAX_WINDOW_V30            32      //9000设备本地显示最大播放窗口数
#define MAX_WINDOW_V40            64      //Netra 2.3.1扩展
#define MAX_WINDOW                16      //8000设备最大硬盘数
#define MAX_VGA_V30                4       //9000设备最大可接VGA数
#define MAX_VGA                    1       //8000设备最大可接VGA数

#define MAX_USERNUM_V30            32      //9000设备最大用户数
#define MAX_USERNUM                16      //8000设备最大用户数
#define MAX_EXCEPTIONNUM_V30    32      //9000设备最大异常处理数
#define MAX_EXCEPTIONNUM        16      //8000设备最大异常处理数
#define MAX_LINK                6       //8000设备单通道最大视频流连接数
#define MAX_ITC_EXCEPTIONOUT    32      //抓拍机最大报警输出
#define MAX_SCREEN_DISPLAY_LEN            512    //屏幕显示字符长度

#define MAX_DECPOOLNUM            4       //单路解码器每个解码通道最大可循环解码数
#define MAX_DECNUM                4       //单路解码器的最大解码通道数（实际只有一个，其他三个保留）
#define MAX_TRANSPARENTNUM        2       //单路解码器可配置最大透明通道数
#define MAX_CYCLE_CHAN            16      //单路解码器最大轮巡通道数
#define MAX_CYCLE_CHAN_V30      64      //最大轮巡通道数（扩展）
#define MAX_DIRNAME_LENGTH        80      //最大目录长度
#define MAX_WINDOWS                16      //最大窗口数


#define MAX_STRINGNUM_V30        8        //9000设备最大OSD字符行数数
#define MAX_STRINGNUM            4       //8000设备最大OSD字符行数数
#define MAX_STRINGNUM_EX        8       //8000定制扩展
#define MAX_AUXOUT_V30            16      //9000设备最大辅助输出数
#define MAX_AUXOUT                4       //8000设备最大辅助输出数
#define MAX_HD_GROUP            16      //9000设备最大硬盘组数
#define MAX_HD_GROUP_V40        32      //设备最大硬盘组数
#define MAX_NFS_DISK            8       //8000设备最大NFS硬盘数

#define IW_ESSID_MAX_SIZE        32      //WIFI的SSID号长度
#define IW_ENCODING_TOKEN_MAX    32      //WIFI密锁最大字节数
#define MAX_SERIAL_NUM            64        //最多支持的透明通道路数
#define MAX_DDNS_NUMS            10      //9000设备最大可配ddns数
#define MAX_DOMAIN_NAME            64        /* 最大域名长度 */
#define MAX_EMAIL_ADDR_LEN        48      //最大email地址长度
#define MAX_EMAIL_PWD_LEN        32      //最大email密码长度
#define MAX_SLAVECAMERA_NUM     8       //从摄像机个数
#define MAX_CALIB_NUM           6       //标定点的个数
#define MAX_CALIB_NUM_EX        20      //扩展标定点的个数   
#define MAX_LEDDISPLAYINFO_LEN  1024    //最大LED屏显示长度
#define MAX_PEOPLE_DETECTION_NUM    8  //最大人员检测区域数
#define MAXPROGRESS                100     //回放时的最大百分率
#define MAX_SERIALNUM            2       //8000设备支持的串口数 1-232， 2-485
#define CARDNUM_LEN                20      //卡号长度
#define CARDNUM_LEN_OUT            32      //外部结构体卡号长度
#define MAX_VIDEOOUT_V30        4       //9000设备的视频输出数
#define MAX_VIDEOOUT            2       //8000设备的视频输出数

#define MAX_PRESET_V30            256        /* 9000设备支持的云台预置点数 */
#define MAX_TRACK_V30            256        /* 9000设备支持的云台轨迹数 */
#define MAX_CRUISE_V30            256        /* 9000设备支持的云台巡航数 */
#define MAX_PRESET                128        /* 8000设备支持的云台预置点数 */
#define MAX_TRACK                128        /* 8000设备支持的云台轨迹数 */
#define MAX_CRUISE                128        /* 8000设备支持的云台巡航数 */

#define MAX_PRESET_V40            300        /* 云台支持的最大预置点数 */
#define MAX_CRUISE_POINT_NUM    128     /* 最大支持的巡航点的个数 */

#define CRUISE_MAX_PRESET_NUMS    32         /* 一条巡航最多的巡航点 */
#define MAX_FACE_PIC_NUM        30      /*人脸子图个数*/
#define LOCKGATE_TIME_NUM       4       //锁闸时间段个数

#define MAX_SERIAL_PORT         8       //9000设备支持232串口数
#define MAX_PREVIEW_MODE        8       /* 设备支持最大预览模式数目 1画面,4画面,9画面,16画面.... */
#define MAX_MATRIXOUT           16      /* 最大模拟矩阵输出个数 */
#define LOG_INFO_LEN            11840   /* 日志附加信息 */
#define DESC_LEN                16      /* 云台描述字符串长度 */
#define PTZ_PROTOCOL_NUM        200     /* 9000最大支持的云台协议数 */
#define IPC_PROTOCOL_NUM        50   //ipc 协议最大个数

#define MAX_AUDIO                1       //8000语音对讲通道数
#define MAX_AUDIO_V30            2       //9000语音对讲通道数
#define MAX_CHANNUM                16      //8000设备最大通道数
#define MAX_ALARMIN                16      //8000设备最大报警输入数
#define MAX_ALARMOUT            4       //8000设备最大报警输出数
//9000 IPC接入
#define MAX_ANALOG_CHANNUM      32      //最大32个模拟通道
#define MAX_ANALOG_ALARMOUT     32      //最大32路模拟报警输出 
#define MAX_ANALOG_ALARMIN      32      //最大32路模拟报警输入

#define MAX_IP_DEVICE           32      //允许接入的最大IP设备数
#define MAX_IP_DEVICE_V40       64      // 允许接入的最大IP设备数 最多可添加64个 IVMS 2000等新设备
#define MAX_IP_CHANNEL          32      //允许加入的最多IP通道数
#define MAX_IP_ALARMIN          128     //允许加入的最多报警输入数
#define MAX_IP_ALARMOUT         64      //允许加入的最多报警输出数
#define MAX_IP_ALARMIN_V40      4096    //允许加入的最多报警输入数
#define MAX_IP_ALARMOUT_V40     4096    //允许加入的最多报警输出数

#define MAX_RECORD_FILE_NUM     20      // 每次删除或者刻录的最大文件数
//SDK_V31 ATM
#define MAX_ACTION_TYPE            12        //自定义协议叠加交易行为最大行为个数 
#define MAX_ATM_PROTOCOL_NUM    256   //每种输入方式对应的ATM最大协议数
#define ATM_CUSTOM_PROTO        1025   //自定义协议 值为1025
#define ATM_PROTOCOL_SORT       4       //ATM协议段数 
#define ATM_DESC_LEN            32      //ATM描述字符串长度
// SDK_V31 ATM


#define MAX_IPV6_LEN              64   //IPv6地址最大长度
#define MAX_EVENTID_LEN         64   //事件ID长度

#define INVALID_VALUE_UINT32    0xffffffff   //无效值
#define MAX_CHANNUM_V40         512
#define MAX_MULTI_AREA_NUM      24

#define MAX_SINGLE_FTPPICNAME_LEN       20 //最大单个FTP通道名称
#define MAX_CAMNAME_LEN                 32 //最大通道名称
#define MAX_FTPNAME_NUM                 12 //TFP名称数
//SDK 录播主机
#define COURSE_NAME_LEN                32    //课程名称
#define INSTRUCTOR_NAME_LEN            16    //授课教师
#define COURSE_DESCRIPTION_LEN        256    //课程信息

#define MAX_TIMESEGMENT_V40            16    //每节课信息


#define MAX_MIX_CHAN_NUM        16    /*目前支持的最大混音通道数，背景通道 + MIC + LINE IN + 最多4个小画面*/ 
#define MAX_LINE_IN_CHAN_NUM    16    //最大line in通道数
#define MAX_MIC_CHAN_NUM        16    //最大MIC通道数
#define INQUEST_CASE_NO_LEN        64    //审讯案件编号长度
#define INQUEST_CASE_NAME_LEN    64    //审讯案件名称长度
#define CUSTOM_INFO_LEN            64    //自定义信息长度
#define INQUEST_CASE_LEN        64    //审讯信息长度


#define MAX_FILE_ID_LEN         128    //视图库项目中文件ID的最大长度
#define MAX_PIC_NAME_LEN        128 //图片名称长度

/* 最大支持的通道数 最大模拟加上最大IP支持 */
#define MAX_CHANNUM_V30               ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL )//64
#define MAX_ALARMOUT_V40             (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ALARMOUT_V30              ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT )//96
#define MAX_ALARMIN_V30               ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN )//160
#define MAX_ALARMIN_V40             (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ANALOG_ALARM_WITH_VOLT_LIMIT    16 //受电压限定的模拟报警最大输入数

#define MAX_ROIDETECT_NUM       8    //支持的ROI区域数
#define MAX_LANERECT_NUM        5    //最大车牌识别区域数
#define MAX_FORTIFY_NUM         10   //最大布防个数
#define MAX_INTERVAL_NUM        4    //最大时间间隔个数
#define MAX_CHJC_NUM            3    //最大车辆省份简称字符个数
#define MAX_VL_NUM              5    //最大虚拟线圈个数
#define MAX_DRIVECHAN_NUM       16   //最大车道数
#define MAX_COIL_NUM            3    //最大线圈个数
#define MAX_SIGNALLIGHT_NUM     6   //最大信号灯个数
#define LEN_16                    16
#define LEN_32                    32
#define LEN_31                    31 
#define MAX_CABINET_COUNT       8    //最大支持机柜数量
#define MAX_ID_LEN              48
#define MAX_PARKNO_LEN          16
#define MAX_ALARMREASON_LEN     32
#define MAX_UPGRADE_INFO_LEN    48 //获取升级文件匹配信息(模糊升级)
#define MAX_CUSTOMDIR_LEN       32 //自定义目录长度
#define MAX_LED_INFO_LEN        512//LED内容长度
#define MAX_VOICE_INFO_LEN      128//语音播报内容长度
#define MAX_LITLE_INFO_LEN      64 //纸票标题内容长度
#define MAX_CUSTOM_INFO_LEN     64 //纸票自定义信息内容长度
#define MAX_PHONE_NUM_LEN       16 //联系电话内容长度
#define MAX_APP_SERIALNUM_LEN   32 //应用序列号长度

#define AUDIOTALKTYPE_G722       0
#define AUDIOTALKTYPE_G711_MU    1
#define AUDIOTALKTYPE_G711_A     2
#define AUDIOTALKTYPE_MP2L2      5
#define AUDIOTALKTYPE_G726         6
#define AUDIOTALKTYPE_AAC         7
#define AUDIOTALKTYPE_PCM         8

//packet type
#define FILE_HEAD            0 //file head
#define VIDEO_I_FRAME        1 //video I frame
#define VIDEO_B_FRAME        2 //video B frame
#define VIDEO_P_FRAME        3 //video P frame
#define AUDIO_PACKET        10 //audio packet
#define PRIVT_PACKET        11 //private packet
//E frame
#define HIK_H264_E_FRAME    (1 << 6)   // 以前E帧不用了,深P帧也没用到
#define MAX_TRANSPARENT_CHAN_NUM      4   //每个串口允许建立的最大透明通道数
#define MAX_TRANSPARENT_ACCESS_NUM    4   //每个监听端口允许接入的最大主机数

//ITS
#define MAX_PARKING_STATUS       8    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位 
#define MAX_PARKING_NUM             4    //一个通道最大4个车位 (从左到右车位 数组0～3)

#define MAX_ITS_SCENE_NUM        16   //最大场景数量
#define MAX_SCENE_TIMESEG_NUM    16   //最大场景时间段数量
#define MAX_IVMS_IP_CHANNEL      128  //最大IP通道数
#define DEVICE_ID_LEN            48   //设备编号长度
#define MONITORSITE_ID_LEN       48   //监测点编号长度
#define MAX_AUXAREA_NUM          16   //辅助区域最大数目
#define MAX_SLAVE_CHANNEL_NUM    16   //最大从通道数量
#define MAX_DEVDESC_LEN          64   //设备描述信息最大长度



#define MAX_SECRETKEY_LEN           512     //最大秘钥长度
#define MAX_INDEX_CODE_LEN          64      //最大序号长度
#define MAX_ILLEGAL_LEN          64     //违法代码最大字符长度
#define CODE_LEN        64  //授权码
#define ALIAS_LEN       32  //别名，只读
#define MAX_SCH_TASKS_NUM        10

#define MAX_SERVERID_LEN            64 //最大服务器ID的长度
#define MAX_SERVERDOMAIN_LEN        128 //服务器域名最大长度
#define MAX_AUTHENTICATEID_LEN      64 //认证ID最大长度
#define MAX_AUTHENTICATEPASSWD_LEN  32 //认证密码最大长度
#define MAX_SERVERNAME_LEN          64 //最大服务器用户名 
#define MAX_COMPRESSIONID_LEN       64 //编码ID的最大长度
#define MAX_SIPSERVER_ADDRESS_LEN   128 //SIP服务器地址支持域名和IP地址
//压线报警
#define MAX_PlATE_NO_LEN            32   //车牌号码最大长度 2013-09-27
#define UPNP_PORT_NUM                12      //upnp端口映射端口数目

#define MAX_PEOPLE_DETECTION_NUM    8  //最大人员检测区域数

#define MAX_NOTICE_NUMBER_LEN       32   //公告编号最大长度
#define MAX_NOTICE_THEME_LEN        64   //公告主题最大长度
#define MAX_NOTICE_DETAIL_LEN       1024 //公告详情最大长度
#define MAX_NOTICE_PIC_NUM          6    //公告信息最大图片数量
#define MAX_DEV_NUMBER_LEN          32   //设备编号最大长度



#define HOLIDAY_GROUP_NAME_LEN          32  //假日组名称长度
#define MAX_HOLIDAY_PLAN_NUM            16  //假日组最大假日计划数
#define TEMPLATE_NAME_LEN               32  //计划模板名称长度
#define MAX_HOLIDAY_GROUP_NUM           16   //计划模板最大假日组数
#define DOOR_NAME_LEN                   32  //门名称
#define STRESS_PASSWORD_LEN             8   //胁迫密码长度
#define SUPER_PASSWORD_LEN              8   //胁迫密码长度
#define GROUP_NAME_LEN                  32  //群组名称长度
#define GROUP_COMBINATION_NUM           8   //群组组合数
#define MULTI_CARD_GROUP_NUM            4   //单门最大多重卡组数
#define ACS_CARD_NO_LEN                 32  //门禁卡号长度
#define CARD_PASSWORD_LEN               8   //卡密码长度
#define MAX_DOOR_NUM                    32  //最大门数
#define MAX_CARD_RIGHT_PLAN_NUM         4   //卡权限最大计划个数
#define MAX_CARD_READER_NUM             64  //最大读卡器数
#define MAX_SNEAK_PATH_NODE             8   //最大后续读卡器数
#define MAX_MULTI_DOOR_INTERLOCK_GROUP  8   //最大多门互锁组数
#define MAX_INTER_LOCK_DOOR_NUM         8   //一个多门互锁组中最大互锁门数
#define MAX_CASE_SENSOR_NUM             8   //最大case sensor触发器数
#define MAX_DOOR_NUM_256                256 //最大门数
#define MAX_READER_ROUTE_NUM            16  //最大刷卡循序路径 
#define MAX_FINGER_PRINT_NUM            10  //最大指纹个数
#define MAX_CARD_READER_NUM_512            512 //最大读卡器数

#define ERROR_MSG_LEN      32 //下发错误信息

#define PER_RING_PORT_NUM                2   //每个环的端口数
#define SENSORNAME_LEN                  32  //传感器名称长度
#define MAX_SENSORDESCR_LEN             64  //传感器描述长度
#define MAX_DNS_SERVER_NUM              2 //最大DNS个数

#define WEP_KEY_MAX_SIZE                32 //最大WEP加密密钥长度
#define WEP_KEY_MAX_NUM                 4  //最大WEP加密密钥个数
#define WPA_KEY_MAX_SIZE                64 //最大WPA共享密钥长度



#define MAX_IDCODE_LEN      128 //  识别码最大长度
#define MAX_VERSIIN_LEN     64  //版本最大长度
#define MAX_IDCODE_NUM      32  // 识别码个数
#define SDK_LEN_2048        2048

#define RECT_POINT_NUM                    4    //矩形角数

#define MAX_PUBLIC_KEY_LEN 512 // 最大公钥长度
#define CHIP_SERIALNO_LEN 32 //加密芯片序列号长度
#define ENCRYPT_DEV_ID_LEN        20  //设备ID长度

//MCU相关的
#define MAX_SEARCH_ID_LEN               36  //搜索标识符最大长度
#define TERMINAL_NAME_LEN               64  //终端名称长度
#define MAX_URL_LEN                     512 //URL长度
#define REGISTER_NAME_LEN               64 //终端注册GK名称最大长度

//光纤
#define MAX_PORT_NUM            64  //最大端口数
#define MAX_SINGLE_CARD_PORT_NO 4   //光纤收发器单卡最大端口数
#define MAX_FUNC_CARD_NUM       32  //光纤收发器最大功能卡数
#define MAX_FC_CARD_NUM         33  //光纤收发器最大卡数
#define MAX_REMARKS_LEN         128 //注释最大长度
#define MAX_OUTPUT_PORT_NUM                32    //单路输出包含的最大输出端口数
#define MAX_SINGLE_PORT_RECVCARD_NUM    64    //单个端口连接的最大接收卡数
#define MAX_GAMMA_X_VALUE                256    //GAMMA表X轴取值个数


#define PLAYLIST_NAME_LEN                64            //播放表名称长度 
#define PLAYLIST_ITEM_NUM                64            //播放项数目  
/*******************全局错误码 begin**********************/    
#define NET_DVR_NOERROR                     0    //没有错误
#define NET_DVR_PASSWORD_ERROR                 1    //用户名密码错误
#define NET_DVR_NOENOUGHPRI                 2    //权限不足
#define NET_DVR_NOINIT                         3    //没有初始化
#define NET_DVR_CHANNEL_ERROR                 4    //通道号错误
#define NET_DVR_OVER_MAXLINK                 5    //连接到DVR的客户端个数超过最大
#define NET_DVR_VERSIONNOMATCH                6    //版本不匹配
#define NET_DVR_NETWORK_FAIL_CONNECT        7    //连接服务器失败
#define NET_DVR_NETWORK_SEND_ERROR            8    //向服务器发送失败
#define NET_DVR_NETWORK_RECV_ERROR            9    //从服务器接收数据失败
#define NET_DVR_NETWORK_RECV_TIMEOUT        10    //从服务器接收数据超时
#define NET_DVR_NETWORK_ERRORDATA            11    //传送的数据有误
#define NET_DVR_ORDER_ERROR                    12    //调用次序错误
#define NET_DVR_OPERNOPERMIT                13    //无此权限
#define NET_DVR_COMMANDTIMEOUT                14    //DVR命令执行超时
#define NET_DVR_ERRORSERIALPORT                15    //串口号错误
#define NET_DVR_ERRORALARMPORT                16    //报警端口错误
#define NET_DVR_PARAMETER_ERROR             17  //参数错误
#define NET_DVR_CHAN_EXCEPTION                18    //服务器通道处于错误状态
#define NET_DVR_NODISK                        19    //没有硬盘
#define NET_DVR_ERRORDISKNUM                20    //硬盘号错误
#define NET_DVR_DISK_FULL                    21    //服务器硬盘满
#define NET_DVR_DISK_ERROR                    22    //服务器硬盘出错
#define NET_DVR_NOSUPPORT                    23    //服务器不支持
#define NET_DVR_BUSY                        24    //服务器忙
#define NET_DVR_MODIFY_FAIL                    25    //服务器修改不成功
#define NET_DVR_PASSWORD_FORMAT_ERROR        26    //密码输入格式不正确
#define NET_DVR_DISK_FORMATING                27    //硬盘正在格式化，不能启动操作
#define NET_DVR_DVRNORESOURCE                28    //DVR资源不足
#define    NET_DVR_DVROPRATEFAILED                29  //DVR操作失败
#define NET_DVR_OPENHOSTSOUND_FAIL             30  //打开PC声音失败
#define NET_DVR_DVRVOICEOPENED                 31  //服务器语音对讲被占用
#define    NET_DVR_TIMEINPUTERROR                32  //时间输入不正确
#define    NET_DVR_NOSPECFILE                    33  //回放时服务器没有指定的文件
#define NET_DVR_CREATEFILE_ERROR            34    //创建文件出错
#define    NET_DVR_FILEOPENFAIL                35  //打开文件出错
#define    NET_DVR_OPERNOTFINISH                36  //上次的操作还没有完成
#define    NET_DVR_GETPLAYTIMEFAIL                37  //获取当前播放的时间出错
#define    NET_DVR_PLAYFAIL                    38  //播放出错
#define NET_DVR_FILEFORMAT_ERROR            39  //文件格式不正确
#define NET_DVR_DIR_ERROR                    40    //路径错误
#define NET_DVR_ALLOC_RESOURCE_ERROR        41  //资源分配错误
#define NET_DVR_AUDIO_MODE_ERROR            42    //声卡模式错误
#define NET_DVR_NOENOUGH_BUF                43    //缓冲区太小
#define NET_DVR_CREATESOCKET_ERROR             44    //创建SOCKET出错
#define NET_DVR_SETSOCKET_ERROR                45    //设置SOCKET出错
#define NET_DVR_MAX_NUM                        46    //个数达到最大
#define NET_DVR_USERNOTEXIST                47    //用户不存在
#define NET_DVR_WRITEFLASHERROR                48  //写FLASH出错
#define NET_DVR_UPGRADEFAIL                    49  //DVR升级失败
#define NET_DVR_CARDHAVEINIT                50  //解码卡已经初始化过
#define NET_DVR_PLAYERFAILED                51    //调用播放库中某个函数失败
#define NET_DVR_MAX_USERNUM                    52  //设备端用户数达到最大
#define NET_DVR_GETLOCALIPANDMACFAIL        53  //获得客户端的IP地址或物理地址失败
#define NET_DVR_NOENCODEING                    54    //该通道没有编码
#define NET_DVR_IPMISMATCH                    55    //IP地址不匹配
#define NET_DVR_MACMISMATCH                    56    //MAC地址不匹配
#define NET_DVR_UPGRADELANGMISMATCH            57    //升级文件语言不匹配
#define NET_DVR_MAX_PLAYERPORT                58    //播放器路数达到最大
#define NET_DVR_NOSPACEBACKUP                59    //备份设备中没有足够空间进行备份
#define NET_DVR_NODEVICEBACKUP                60    //没有找到指定的备份设备
#define NET_DVR_PICTURE_BITS_ERROR            61    //图像素位数不符，限24色
#define NET_DVR_PICTURE_DIMENSION_ERROR        62    //图片高*宽超限， 限128*256
#define NET_DVR_PICTURE_SIZ_ERROR            63    //图片大小超限，限100K
#define NET_DVR_LOADPLAYERSDKFAILED            64    //载入当前目录下Player Sdk出错
#define NET_DVR_LOADPLAYERSDKPROC_ERROR        65    //找不到Player Sdk中某个函数入口
#define NET_DVR_LOADDSSDKFAILED                66    //载入当前目录下DSsdk出错
#define NET_DVR_LOADDSSDKPROC_ERROR            67    //找不到DsSdk中某个函数入口
#define NET_DVR_DSSDK_ERROR                    68    //调用硬解码库DsSdk中某个函数失败
#define NET_DVR_VOICEMONOPOLIZE                69    //声卡被独占
#define NET_DVR_JOINMULTICASTFAILED            70    //加入多播组失败
#define NET_DVR_CREATEDIR_ERROR                71    //建立日志文件目录失败
#define NET_DVR_BINDSOCKET_ERROR            72    //绑定套接字失败
#define NET_DVR_SOCKETCLOSE_ERROR            73    //socket连接中断，此错误通常是由于连接中断或目的地不可达
#define NET_DVR_USERID_ISUSING                74    //注销时用户ID正在进行某操作
#define NET_DVR_SOCKETLISTEN_ERROR            75    //监听失败
#define NET_DVR_PROGRAM_EXCEPTION            76    //程序异常
#define NET_DVR_WRITEFILE_FAILED            77    //写文件失败
#define NET_DVR_FORMAT_READONLY                78  //禁止格式化只读硬盘
#define NET_DVR_WITHSAMEUSERNAME            79  //用户配置结构中存在相同的用户名
#define NET_DVR_DEVICETYPE_ERROR            80  /*导入参数时设备型号不匹配*/
#define NET_DVR_LANGUAGE_ERROR              81  /*导入参数时语言不匹配*/
#define NET_DVR_PARAVERSION_ERROR           82  /*导入参数时软件版本不匹配*/
#define NET_DVR_IPCHAN_NOTALIVE             83  /*预览时外接IP通道不在线*/
#define NET_DVR_RTSP_SDK_ERROR                84    /*加载高清IPC通讯库StreamTransClient.dll失败*/
#define NET_DVR_CONVERT_SDK_ERROR            85    /*加载转码库失败*/
#define NET_DVR_IPC_COUNT_OVERFLOW            86  /*超出最大的ip接入通道数*/
#define NET_DVR_MAX_ADD_NUM                 87  /*添加标签(一个文件片段64)等个数达到最大*/
#define NET_DVR_PARAMMODE_ERROR             88 //图像增强仪，参数模式错误（用于硬件设置时，客户端进行软件设置时错误值）
#define NET_DVR_CODESPITTER_OFFLINE            89 //视频综合平台，码分器不在线
#define NET_DVR_BACKUP_COPYING                90  //设备正在备份
#define NET_DVR_CHAN_NOTSUPPORT             91  // 通道不支持该操作
#define NET_DVR_CALLINEINVALID              92  // 高度线位置太集中或长度线不够倾斜 
#define NET_DVR_CALCANCELCONFLICT           93  // 取消标定冲突，如果设置了规则及全局的实际大小尺寸过滤
#define NET_DVR_CALPOINTOUTRANGE            94     // 标定点超出范围 
#define NET_DVR_FILTERRECTINVALID           95  // 尺寸过滤器不符合要求
#define NET_DVR_DDNS_DEVOFFLINE             96  //设备没有注册到ddns上
#define NET_DVR_DDNS_INTER_ERROR            97  //DDNS 服务器内部错误
#define NET_DVR_FUNCTION_NOT_SUPPORT_OS     98  //此功能不支持该操作系统
#define NET_DVR_DEC_CHAN_REBIND             99  //解码通道绑定显示输出次数受限
#define NET_DVR_INTERCOM_SDK_ERROR          100 //加载当前目录下的语音对讲库失败
#define NET_DVR_NO_CURRENT_UPDATEFILE       101 //没有正确的升级包  
#define NET_DVR_USER_NOT_SUCC_LOGIN         102  //用户还没登陆成功
#define NET_DVR_USE_LOG_SWITCH_FILE            103  //正在使用日志开关文件
#define NET_DVR_POOL_PORT_EXHAUST            104  //端口池中用于绑定的端口已耗尽
#define    NET_DVR_PACKET_TYPE_NOT_SUPPORT        105    //码流封装格式错误
#define NET_DVR_IPPARA_IPID_ERROR           106  //IP接入配置时IPID有误

#define NET_DVR_LOAD_HCPREVIEW_SDK_ERROR           107         //预览组件加载失败
#define NET_DVR_LOAD_HCVOICETALK_SDK_ERROR         108         //语音组件加载失败
#define NET_DVR_LOAD_HCALARM_SDK_ERROR             109         //报警组件加载失败
#define NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR          110         //回放组件加载失败
#define NET_DVR_LOAD_HCDISPLAY_SDK_ERROR           111         //显示组件加载失败
#define NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR          112         //行业应用组件加载失败
#define NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR     113         //通用配置管理组件加载失败
#define NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR        114         //设备配置核心组件加载失败

#define NET_DVR_CORE_VER_MISMATCH                  121    //单独加载组件时，组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCPREVIEW        122    //预览组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCVOICETALK      123    //语音组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCALARM          124    //报警组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK       125    //回放组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCDISPLAY        126    //显示组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY       127    //行业应用组件与core版本不匹配
#define NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR  128    //通用配置管理组件与core版本不匹配

#define NET_DVR_COM_VER_MISMATCH_HCPREVIEW         136    //预览组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCVOICETALK       137    //语音组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCALARM           138    //报警组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCPLAYBACK        139    //回放组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCDISPLAY         140    //显示组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCINDUSTRY        141    //行业应用组件与HCNetSDK版本不匹配
#define NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR   142    //通用配置管理组件与HCNetSDK版本不匹配

#define NET_DVR_ALIAS_DUPLICATE                150    //别名重复  //2011-08-31 通过别名或者序列号来访问设备的新版本ddns的配置
#define    NET_DVR_INVALID_COMMUNICATION        151    //无效通信
#define    NET_DVR_USERNAME_NOT_EXIST            152    //用户名不存在（用户名不存在，IPC5.1.7中发布出去了，所以删不掉。后续的产品这个错误码用不上）
#define    NET_DVR_USER_LOCKED                    153 //用户被锁定
#define NET_DVR_INVALID_USERID              154 //无效用户ID
#define NET_DVR_LOW_LOGIN_VERSION           155 //登录版本低
#define NET_DVR_LOAD_LIBEAY32_DLL_ERROR     156 //加载libeay32.dll库失败
#define NET_DVR_LOAD_SSLEAY32_DLL_ERROR     157 //加载ssleay32.dll库失败
#define NET_ERR_LOAD_LIBICONV           158 //加载libiconv库失败

#define NET_DVR_SERVER_NOT_EXIST         164 //对应的服务器找不到,查找时输入的国家编号或者服务器类型错误
#define NET_DVR_TEST_SERVER_FAIL_CONNECT            165    //连接测试服务器失败
#define NET_DVR_NAS_SERVER_INVALID_DIR                166    //NAS服务器挂载目录失败，目录无效
#define NET_DVR_NAS_SERVER_NOENOUGH_PRI                167    //NAS服务器挂载目录失败，没有权限
#define NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS            168    //服务器使用域名，但是没有配置DNS，可能造成域名无效。
#define    NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY        169    //没有配置网关，可能造成发送邮件失败。
#define    NET_DVR_TEST_SERVER_PASSWORD_ERROR            170    //用户名密码不正确，测试服务器的用户名或密码错误
#define    NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP    171    //设备和smtp服务器交互异常
#define    NET_DVR_FTP_SERVER_FAIL_CREATE_DIR            172    //FTP服务器创建目录失败
#define    NET_DVR_FTP_SERVER_NO_WRITE_PIR                173    //FTP服务器没有写入权限
#define    NET_DVR_IP_CONFLICT                            174    //IP冲突
#define NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE      175  //存储池空间已满
#define NET_DVR_STORAGEPOOL_INVALID      176  //云服务器存储池无效,没有配置存储池或者存储池ID错误
#define NET_DVR_EFFECTIVENESS_REBOOT     177  //生效需要重启
#define NET_ERR_ANR_ARMING_EXIST         178  //断网续传布防连接已经存在(该错误码是在HIK私有布防连接建立的情况下，重复布防的断网续传功能时，返回。)
#define NET_ERR_UPLOADLINK_EXIST         179  //断网续传上传连接已经存在(EHOME协议和HIK SDK协议是不能同时支持断网续传的，当一个协议存在的时候，另外一个连接建立话，报错这个错误码。)
#define NET_ERR_INCORRECT_FILE_FORMAT    180  //导入文件格式不正确
#define NET_ERR_INCORRECT_FILE_CONTENT   181  //导入文件内容不正确

// 2010-5-28
// 阵列错误码
#define RAID_ERROR_INDEX                    200
#define NET_DVR_NAME_NOT_ONLY               (RAID_ERROR_INDEX + 0)  // 名称已存在
#define NET_DVR_OVER_MAX_ARRAY              (RAID_ERROR_INDEX + 1 ) // 阵列达到上限
#define NET_DVR_OVER_MAX_VD                 (RAID_ERROR_INDEX + 2 ) // 虚拟磁盘达到上限
#define NET_DVR_VD_SLOT_EXCEED              (RAID_ERROR_INDEX + 3 ) // 虚拟磁盘槽位已满
#define NET_DVR_PD_STATUS_INVALID           (RAID_ERROR_INDEX + 4 ) // 重建阵列所需物理磁盘状态错误
#define NET_DVR_PD_BE_DEDICATE_SPARE        (RAID_ERROR_INDEX + 5 ) // 重建阵列所需物理磁盘为指定热备
#define NET_DVR_PD_NOT_FREE                 (RAID_ERROR_INDEX + 6 ) // 重建阵列所需物理磁盘非空闲
#define NET_DVR_CANNOT_MIG2NEWMODE          (RAID_ERROR_INDEX + 7 ) // 不能从当前的阵列类型迁移到新的阵列类型
#define NET_DVR_MIG_PAUSE                   (RAID_ERROR_INDEX + 8 ) // 迁移操作已暂停
#define NET_DVR_MIG_CANCEL                  (RAID_ERROR_INDEX + 9 ) // 正在执行的迁移操作已取消
#define NET_DVR_EXIST_VD                    (RAID_ERROR_INDEX + 10) // 阵列上阵列上存在虚拟磁盘，无法删除阵列
#define NET_DVR_TARGET_IN_LD_FUNCTIONAL     (RAID_ERROR_INDEX + 11) // 对象物理磁盘为虚拟磁盘组成部分且工作正常
#define NET_DVR_HD_IS_ASSIGNED_ALREADY      (RAID_ERROR_INDEX + 12) // 指定的物理磁盘被分配为虚拟磁盘
#define NET_DVR_INVALID_HD_COUNT            (RAID_ERROR_INDEX + 13) // 物理磁盘数量与指定的RAID等级不匹配
#define NET_DVR_LD_IS_FUNCTIONAL            (RAID_ERROR_INDEX + 14) // 阵列正常，无法重建
#define NET_DVR_BGA_RUNNING                 (RAID_ERROR_INDEX + 15) // 存在正在执行的后台任务
#define NET_DVR_LD_NO_ATAPI                 (RAID_ERROR_INDEX + 16) // 无法用ATAPI盘创建虚拟磁盘
#define NET_DVR_MIGRATION_NOT_NEED          (RAID_ERROR_INDEX + 17) // 阵列无需迁移
#define NET_DVR_HD_TYPE_MISMATCH            (RAID_ERROR_INDEX + 18) // 物理磁盘不属于同意类型
#define NET_DVR_NO_LD_IN_DG                 (RAID_ERROR_INDEX + 19) // 无虚拟磁盘，无法进行此项操作
#define NET_DVR_NO_ROOM_FOR_SPARE           (RAID_ERROR_INDEX + 20) // 磁盘空间过小，无法被指定为热备盘
#define NET_DVR_SPARE_IS_IN_MULTI_DG        (RAID_ERROR_INDEX + 21) // 磁盘已被分配为某阵列热备盘
#define NET_DVR_DG_HAS_MISSING_PD           (RAID_ERROR_INDEX + 22) // 阵列缺少盘

// x86 64bit nvr新增 2012-02-04
#define NET_DVR_NAME_EMPTY                    (RAID_ERROR_INDEX + 23) /*名称为空*/
#define NET_DVR_INPUT_PARAM                    (RAID_ERROR_INDEX + 24) /*输入参数有误*/
#define NET_DVR_PD_NOT_AVAILABLE            (RAID_ERROR_INDEX + 25) /*物理磁盘不可用*/
#define NET_DVR_ARRAY_NOT_AVAILABLE            (RAID_ERROR_INDEX + 26) /*阵列不可用*/
#define NET_DVR_PD_COUNT                    (RAID_ERROR_INDEX + 27) /*物理磁盘数不正确*/
#define NET_DVR_VD_SMALL                    (RAID_ERROR_INDEX + 28) /*虚拟磁盘太小*/
#define NET_DVR_NO_EXIST                    (RAID_ERROR_INDEX + 29) /*不存在*/
#define NET_DVR_NOT_SUPPORT                    (RAID_ERROR_INDEX + 30) /*不支持该操作*/
#define NET_DVR_NOT_FUNCTIONAL                 (RAID_ERROR_INDEX + 31) /*阵列状态不是正常状态*/
#define NET_DVR_DEV_NODE_NOT_FOUND            (RAID_ERROR_INDEX + 32) /*虚拟磁盘设备节点不存在*/
#define NET_DVR_SLOT_EXCEED                    (RAID_ERROR_INDEX + 33) /*槽位达到上限*/ 
#define NET_DVR_NO_VD_IN_ARRAY                (RAID_ERROR_INDEX + 34) /*阵列上不存在虚拟磁盘*/
#define NET_DVR_VD_SLOT_INVALID                (RAID_ERROR_INDEX + 35) /*虚拟磁盘槽位无效*/
#define NET_DVR_PD_NO_ENOUGH_SPACE            (RAID_ERROR_INDEX + 36) /*所需物理磁盘空间不足*/
#define NET_DVR_ARRAY_NONFUNCTION            (RAID_ERROR_INDEX + 37) /*只有处于正常状态的阵列才能进行迁移*/
#define NET_DVR_ARRAY_NO_ENOUGH_SPACE        (RAID_ERROR_INDEX + 38) /*阵列空间不足*/
#define NET_DVR_STOPPING_SCANNING_ARRAY        (RAID_ERROR_INDEX + 39) /*正在执行安全拔盘或重新扫描*/
#define NET_DVR_NOT_SUPPORT_16T             (RAID_ERROR_INDEX + 40) /*不支持创建大于16T的阵列*/
#define NET_DVR_ARRAY_FORMATING             (RAID_ERROR_INDEX + 41) /*正在执行格式化的阵列无法删除*/ 
#define NET_DVR_QUICK_SETUP_PD_COUNT        (RAID_ERROR_INDEX + 42) /*一键配置至少需要三块空闲盘*/ 

//设备未激活时，登录失败，返回错误码
#define    NET_DVR_ERROR_DEVICE_NOT_ACTIVATED    250//设备未激活
//老SDK接新设备，设置用户密码或者激活的时候为风险密码时，错误码
#define  NET_DVR_ERROR_RISK_PASSWORD          251 //有风险的密码
//已激活的设备，再次激活时返回错误码
#define    NET_DVR_ERROR_DEVICE_HAS_ACTIVATED    252//设备已激活


// 智能错误码 
#define VCA_ERROR_INDEX                     300 // 智能错误码索引
#define NET_DVR_ID_ERROR                    (VCA_ERROR_INDEX + 0)   // 配置ID不合理
#define NET_DVR_POLYGON_ERROR               (VCA_ERROR_INDEX + 1)   // 多边形不符合要求
#define NET_DVR_RULE_PARAM_ERROR            (VCA_ERROR_INDEX + 2)   // 规则参数不合理
#define NET_DVR_RULE_CFG_CONFLICT           (VCA_ERROR_INDEX + 3)   // 配置信息冲突
#define NET_DVR_CALIBRATE_NOT_READY         (VCA_ERROR_INDEX + 4)   // 当前没有标定信息
#define NET_DVR_CAMERA_DATA_ERROR           (VCA_ERROR_INDEX + 5)   // 摄像机参数不合理
#define NET_DVR_CALIBRATE_DATA_UNFIT        (VCA_ERROR_INDEX + 6)    // 长度不够倾斜，不利于标定
#define NET_DVR_CALIBRATE_DATA_CONFLICT     (VCA_ERROR_INDEX + 7)    // 标定出错，以为所有点共线或者位置太集中
#define NET_DVR_CALIBRATE_CALC_FAIL         (VCA_ERROR_INDEX + 8)    // 摄像机标定参数值计算失败
#define    NET_DVR_CALIBRATE_LINE_OUT_RECT        (VCA_ERROR_INDEX + 9)    // 输入的样本标定线超出了样本外接矩形框
#define NET_DVR_ENTER_RULE_NOT_READY        (VCA_ERROR_INDEX + 10)    // 没有设置进入区域
#define NET_DVR_AID_RULE_NO_INCLUDE_LANE    (VCA_ERROR_INDEX + 11)    // 交通事件规则中没有包括车道（特值拥堵和逆行）
#define NET_DVR_LANE_NOT_READY                (VCA_ERROR_INDEX + 12)    // 当前没有设置车道
#define NET_DVR_RULE_INCLUDE_TWO_WAY        (VCA_ERROR_INDEX + 13)    // 事件规则中包含2种不同方向
#define NET_DVR_LANE_TPS_RULE_CONFLICT      (VCA_ERROR_INDEX + 14)  // 车道和数据规则冲突
#define NET_DVR_NOT_SUPPORT_EVENT_TYPE      (VCA_ERROR_INDEX + 15)  // 不支持的事件类型
#define NET_DVR_LANE_NO_WAY                 (VCA_ERROR_INDEX + 16)  // 车道没有方向
#define NET_DVR_SIZE_FILTER_ERROR           (VCA_ERROR_INDEX + 17)  // 尺寸过滤框不合理
#define NET_DVR_LIB_FFL_NO_FACE             (VCA_ERROR_INDEX + 18) // 特征点定位时输入的图像没有人脸
#define NET_DVR_LIB_FFL_IMG_TOO_SMALL       (VCA_ERROR_INDEX + 19) // 特征点定位时输入的图像太小
#define NET_DVR_LIB_FD_IMG_NO_FACE          (VCA_ERROR_INDEX + 20) // 单张图像人脸检测时输入的图像没有人脸
#define NET_DVR_LIB_FACE_TOO_SMALL          (VCA_ERROR_INDEX + 21) // 建模时人脸太小
#define NET_DVR_LIB_FACE_QUALITY_TOO_BAD    (VCA_ERROR_INDEX + 22) // 建模时人脸图像质量太差
#define NET_DVR_KEY_PARAM_ERR               (VCA_ERROR_INDEX + 23) //高级参数设置错误
#define NET_DVR_CALIBRATE_DATA_ERR          (VCA_ERROR_INDEX + 24) //标定样本数目错误，或数据值错误，或样本点超出地平线
#define NET_DVR_CALIBRATE_DISABLE_FAIL      (VCA_ERROR_INDEX + 25) //所配置规则不允许取消标定
#define NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE   (VCA_ERROR_INDEX + 26) //最大过滤框的宽高最小值超过最小过滤框的宽高最大值两倍以上
#define NET_DVR_LIB_FD_REGION_TOO_LARGE     (VCA_ERROR_INDEX + 27) //当前检测区域范围过大。检测区最大为图像的2/3
#define NET_DVR_TRIAL_OVERDUE               (VCA_ERROR_INDEX + 28) //试用版评估期已结束
#define NET_DVR_CONFIG_FILE_CONFLICT        (VCA_ERROR_INDEX + 29) //设备类型与配置文件冲突（加密狗类型与现有分析仪配置不符错误码提示）
//算法库相关错误码
#define NET_DVR_FR_FPL_FAIL                 (VCA_ERROR_INDEX + 30)   // 人脸特征点定位失败
#define NET_DVR_FR_IQA_FAIL                 (VCA_ERROR_INDEX + 31)   // 人脸评分失败
#define NET_DVR_FR_FEM_FAIL                 (VCA_ERROR_INDEX + 32)   // 人脸特征提取失败
#define NET_DVR_FPL_DT_CONF_TOO_LOW         (VCA_ERROR_INDEX + 33)   // 特征点定位时人脸检测置信度过低
#define NET_DVR_FPL_CONF_TOO_LOW            (VCA_ERROR_INDEX + 34)   // 特征点定位置信度过低
#define NET_DVR_E_DATA_SIZE                 (VCA_ERROR_INDEX + 35)  // 数据长度不匹配
#define NET_DVR_FR_MODEL_VERSION_ERR        (VCA_ERROR_INDEX + 36)  // 人脸模型数据中的模型版本错误
#define NET_DVR_FR_FD_FAIL                  (VCA_ERROR_INDEX + 37)  // 识别库中人脸检测失败
#define NET_DVR_FA_NORMALIZE_ERR            (VCA_ERROR_INDEX + 38)  // 人脸归一化出错
//其他错误码
#define NET_DVR_DOG_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 39)  // 加密狗与前端取流设备类型不匹配
#define NET_DVR_DEV_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 40)  // 前端取流设备版本不匹配
#define NET_DVR_PUSTREAM_ALREADY_EXISTS     (VCA_ERROR_INDEX + 41)  // 设备的其他通道已经添加过该前端设备
#define NET_DVR_SEARCH_CONNECT_FAILED       (VCA_ERROR_INDEX + 42)  // 连接检索服务器失败
#define NET_DVR_INSUFFICIENT_DISK_SPACE     (VCA_ERROR_INDEX + 43)  // 可存储的硬盘空间不足
#define NET_DVR_DATABASE_CONNECTION_FAILED  (VCA_ERROR_INDEX + 44)  // 数据库连接失败
#define NET_DVR_DATABASE_ADM_PW_ERROR       (VCA_ERROR_INDEX + 45)  // 数据库用户名、密码错误
#define NET_DVR_DECODE_YUV                  (VCA_ERROR_INDEX + 46)  // 解码失败
#define NET_DVR_IMAGE_RESOLUTION_ERROR      (VCA_ERROR_INDEX + 47)  //
#define NET_DVR_CHAN_WORKMODE_ERROR         (VCA_ERROR_INDEX + 48)  //

#define NET_DVR_RTSP_ERROR_NOENOUGHPRI          401  //无权限：服务器返回401时，转成这个错误码
#define NET_DVR_RTSP_ERROR_ALLOC_RESOURCE       402  //分配资源失败
#define NET_DVR_RTSP_ERROR_PARAMETER            403  //参数错误
#define NET_DVR_RTSP_ERROR_NO_URL               404  //指定的URL地址不存在：服务器返回404时，转成这个错误码
#define NET_DVR_RTSP_ERROR_FORCE_STOP           406  //用户中途强行退出

#define NET_DVR_RTSP_GETPORTFAILED                407  //rtsp 得到端口错误
#define NET_DVR_RTSP_DESCRIBERROR                410  //rtsp decribe 交互错误
#define NET_DVR_RTSP_DESCRIBESENDTIMEOUT        411  //rtsp decribe 发送超时
#define NET_DVR_RTSP_DESCRIBESENDERROR            412  //rtsp decribe 发送失败
#define NET_DVR_RTSP_DESCRIBERECVTIMEOUT        413  //rtsp decribe 接收超时
#define NET_DVR_RTSP_DESCRIBERECVDATALOST        414  //rtsp decribe 接收数据错误
#define NET_DVR_RTSP_DESCRIBERECVERROR            415  //rtsp decribe 接收失败
#define NET_DVR_RTSP_DESCRIBESERVERERR            416  //rtsp decribe 服务器返回错误状态

#define NET_DVR_RTSP_SETUPERROR                    420  //rtsp setup 交互错误
#define NET_DVR_RTSP_SETUPSENDTIMEOUT            421  //rtsp setup 发送超时
#define NET_DVR_RTSP_SETUPSENDERROR                422  //rtsp setup 发送错误
#define NET_DVR_RTSP_SETUPRECVTIMEOUT            423  //rtsp setup 接收超时
#define NET_DVR_RTSP_SETUPRECVDATALOST            424  //rtsp setup 接收数据错误
#define NET_DVR_RTSP_SETUPRECVERROR                425  //rtsp setup 接收失败
#define NET_DVR_RTSP_OVER_MAX_CHAN                426  //超过服务器最大连接数，或者服务器资源不足，服务器返回453时，转成这个错误码。
#define NET_DVR_RTSP_SETUPSERVERERR                427  //rtsp setup 服务器返回错误状态

#define NET_DVR_RTSP_PLAYERROR                    430  //rtsp play 交互错误
#define NET_DVR_RTSP_PLAYSENDTIMEOUT            431  //rtsp play 发送超时
#define NET_DVR_RTSP_PLAYSENDERROR                432  //rtsp play 发送错误
#define NET_DVR_RTSP_PLAYRECVTIMEOUT            433  //rtsp play 接收超时
#define NET_DVR_RTSP_PLAYRECVDATALOST            434  //rtsp play 接收数据错误
#define NET_DVR_RTSP_PLAYRECVERROR                435  //rtsp play 接收失败
#define NET_DVR_RTSP_PLAYSERVERERR                436  //rtsp play 服务器返回错误状态

#define NET_DVR_RTSP_TEARDOWNERROR                440  //rtsp teardown 交互错误
#define NET_DVR_RTSP_TEARDOWNSENDTIMEOUT        441  //rtsp teardown 发送超时
#define NET_DVR_RTSP_TEARDOWNSENDERROR            442  //rtsp teardown 发送错误
#define NET_DVR_RTSP_TEARDOWNRECVTIMEOUT        443  //rtsp teardown 接收超时
#define NET_DVR_RTSP_TEARDOWNRECVDATALOST        444  //rtsp teardown 接收数据错误
#define NET_DVR_RTSP_TEARDOWNRECVERROR            445  //rtsp teardown 接收失败
#define NET_DVR_RTSP_TEARDOWNSERVERERR            446  //rtsp teardown 服务器返回错误状态

#define  NET_PLAYM4_NOERROR                        500    //no error
#define     NET_PLAYM4_PARA_OVER                    501    //input parameter is invalid;
#define  NET_PLAYM4_ORDER_ERROR                    502    //The order of the function to be called is error.
#define     NET_PLAYM4_TIMER_ERROR                    503    //Create multimedia clock failed;
#define  NET_PLAYM4_DEC_VIDEO_ERROR                504    //Decode video data failed.
#define  NET_PLAYM4_DEC_AUDIO_ERROR                505    //Decode audio data failed.
#define     NET_PLAYM4_ALLOC_MEMORY_ERROR            506    //Allocate memory failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR                507    //Open the file failed.
#define  NET_PLAYM4_CREATE_OBJ_ERROR            508    //Create thread or event failed
#define  NET_PLAYM4_CREATE_DDRAW_ERROR            509    //Create DirectDraw object failed.
#define  NET_PLAYM4_CREATE_OFFSCREEN_ERROR      510    //failed when creating off-screen surface.
#define  NET_PLAYM4_BUF_OVER                    511    //buffer is overflow
#define  NET_PLAYM4_CREATE_SOUND_ERROR            512    //failed when creating audio device.    
#define     NET_PLAYM4_SET_VOLUME_ERROR            513    //Set volume failed
#define  NET_PLAYM4_SUPPORT_FILE_ONLY            514    //The function only support play file.
#define  NET_PLAYM4_SUPPORT_STREAM_ONLY            515    //The function only support play stream.
#define  NET_PLAYM4_SYS_NOT_SUPPORT                516    //System not support.
#define  NET_PLAYM4_FILEHEADER_UNKNOWN          517    //No file header.
#define  NET_PLAYM4_VERSION_INCORRECT            518    //The version of decoder and encoder is not adapted.  
#define  NET_PALYM4_INIT_DECODER_ERROR          519    //Initialize decoder failed.
#define  NET_PLAYM4_CHECK_FILE_ERROR            520    //The file data is unknown.
#define  NET_PLAYM4_INIT_TIMER_ERROR            521    //Initialize multimedia clock failed.
#define     NET_PLAYM4_BLT_ERROR                    522    //Blt failed.
#define  NET_PLAYM4_UPDATE_ERROR                523    //Update failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR_MULTI       524   //openfile error, streamtype is multi
#define  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO       525   //openfile error, streamtype is video
#define  NET_PLAYM4_JPEG_COMPRESS_ERROR         526   //JPEG compress error
#define  NET_PLAYM4_EXTRACT_NOT_SUPPORT         527    //Don't support the version of this file.
#define  NET_PLAYM4_EXTRACT_DATA_ERROR          528    //extract video data failed.

//转封装库错误码
#define  NET_CONVERT_ERROR_NOT_SUPPORT          581  //convert not support

//语音对讲库错误码
#define  NET_AUDIOINTERCOM_OK                   600  //无错误
#define  NET_AUDIOINTECOM_ERR_NOTSUPORT         601 //不支持
#define  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY      602 //内存申请错误
#define  NET_AUDIOINTECOM_ERR_PARAMETER            603 //参数错误
#define  NET_AUDIOINTECOM_ERR_CALL_ORDER        604 //调用次序错误
#define  NET_AUDIOINTECOM_ERR_FIND_DEVICE       605 //未发现设备
#define  NET_AUDIOINTECOM_ERR_OPEN_DEVICE       606 //不能打开设备诶
#define  NET_AUDIOINTECOM_ERR_NO_CONTEXT        607 //设备上下文出错
#define  NET_AUDIOINTECOM_ERR_NO_WAVFILE        608 //WAV文件出错
#define  NET_AUDIOINTECOM_ERR_INVALID_TYPE      609 //无效的WAV参数类型
#define  NET_AUDIOINTECOM_ERR_ENCODE_FAIL       610 //编码失败
#define  NET_AUDIOINTECOM_ERR_DECODE_FAIL       611 //解码失败
#define  NET_AUDIOINTECOM_ERR_NO_PLAYBACK       612 //播放失败
#define  NET_AUDIOINTECOM_ERR_DENOISE_FAIL      613 //降噪失败
#define  NET_AUDIOINTECOM_ERR_UNKOWN            619 //未知错误

#define NET_QOS_OK                                 700                    //no error
#define NET_QOS_ERROR                             (NET_QOS_OK - 1)        //qos error
#define NET_QOS_ERR_INVALID_ARGUMENTS             (NET_QOS_OK - 2)        //invalid arguments 
#define NET_QOS_ERR_SESSION_NOT_FOUND             (NET_QOS_OK - 3)        //session net found
#define NET_QOS_ERR_LIB_NOT_INITIALIZED          (NET_QOS_OK - 4)        //lib not initialized
#define NET_QOS_ERR_OUTOFMEM                     (NET_QOS_OK - 5)        //outtofmem
#define NET_QOS_ERR_PACKET_UNKNOW                (NET_QOS_OK - 10)        //packet unknow
#define NET_QOS_ERR_PACKET_VERSION               (NET_QOS_OK - 11)        //packet version error
#define NET_QOS_ERR_PACKET_LENGTH                (NET_QOS_OK - 12)        //packet length error
#define NET_QOS_ERR_PACKET_TOO_BIG               (NET_QOS_OK - 13)        //packet too big
#define NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH (NET_QOS_OK - 20)        //schedparams invalid bandwidth
#define NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION      (NET_QOS_OK - 21)        //schedparams bad fraction
#define NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL (NET_QOS_OK - 22)    //schedparams bad minimum interval

#define NET_ERROR_TRUNK_LINE                        711 //子系统已被配成干线
#define NET_ERROR_MIXED_JOINT                        712 //不能进行混合拼接
#define NET_ERROR_DISPLAY_SWITCH                    713 //不能进行显示通道切换
#define NET_ERROR_USED_BY_BIG_SCREEN                714 //解码资源被大屏占用
#define NET_ERROR_USE_OTHER_DEC_RESOURCE            715 //不能使用其他解码子系统资源
#define NET_ERROR_DISP_MODE_SWITCH                  716 //显示通道显示状态切换中
#define NET_ERROR_SCENE_USING                        717    //场景正在使用
#define NET_ERR_NO_ENOUGH_DEC_RESOURCE              718 //解码资源不足
#define NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE        719 //畅显资源不足
#define NET_ERR_NO_ENOUGH_VIDEO_MEMORY              720 //显存资源不足
#define NET_ERR_MAX_VIDEO_NUM                       721 //一拖多资源不足
#define NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL      722 //窗口跨越了畅显输出口和非畅显输出口
#define NET_ERR_FREE_SHOW_WIN_SPLIT                 723 //畅显窗口不支持分屏
#define NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW         724 //不是输出口整数倍的窗口不支持开启畅显
#define NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT   725 //开启透明度的窗口不支持分屏
#define NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT   726 //开启多分屏的窗口不支持透明度设置
#define NET_ERR_MAX_LOGO_NUM                        727 //logo数达到上限
#define NET_ERR_MAX_WIN_LOOP_NUM                    728 //轮巡窗口数达到上限
#define NET_ERR_VIRTUAL_LED_VERTICAL_CROSS          729 //虚拟LED不能纵向跨屏
#define NET_ERR_MAX_VIRTUAL_LED_HEIGHT              730 //虚拟LED高度超限
#define NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER       731 //虚拟LED内容包含非法字符
#define NET_ERR_BASEMAP_NOT_EXIST                   732 //底图图片不存在
#define NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED         733 //LED屏幕不支持虚拟LED
#define NET_ERR_LED_RESOLUTION_NOT_SUPPORT          734 //LED分辨率不支持
#define NET_ERR_PLAN_OVERDUE                        735    //预案超期，不能再调用
#define NET_ERR_PROCESSER_MAX_SCREEN_BLK            736 //单个处理器接入的信号跨越的屏幕个数超限

#define NET_ERR_TERMINAL_BUSY                        780    //终端忙，终端处于会议中

#define NET_ERR_DATA_RETURNED_ILLEGAL               790 //设备返回的数据不合法
#define NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR       791 //设备其它功能占用资源，导致该功能无法开启


#define NET_DVR_DEV_NET_OVERFLOW                    800    //网络流量超过设备能力上限
#define NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK  801 //录像文件在录像，无法被锁定 
#define NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK      802 //由于硬盘太小无法格式化

//N+1错误码
#define NET_SDK_ERR_REMOTE_DISCONNECT                803 //远端无法连接
#define NET_SDK_ERR_RD_ADD_RD                        804 //备机不能添加备机
#define NET_SDK_ERR_BACKUP_DISK_EXCEPT                805 //备份盘异常
#define NET_SDK_ERR_RD_LIMIT                        806 //备机数已达上限
#define NET_SDK_ERR_ADDED_RD_IS_WD                    807 //添加的备机是工作机
#define NET_SDK_ERR_ADD_ORDER_WRONG                    808 //添加顺序出错，比如没有被工作机添加为备机，就添加工作机
#define NET_SDK_ERR_WD_ADD_WD                        809 //工作机不能添加工作机
#define NET_SDK_ERR_WD_SERVICE_EXCETP                810 //工作机CVR服务异常
#define NET_SDK_ERR_RD_SERVICE_EXCETP                811 //备机CVR服务异常
#define NET_SDK_ERR_ADDED_WD_IS_RD                    812 //添加的工作机是备机
#define NET_SDK_ERR_PERFORMANCE_LIMIT                813 //性能达到上限
#define NET_SDK_ERR_ADDED_DEVICE_EXIST                814 //添加的设备已经存在

//审讯机错误码
#define NET_SDK_ERR_INQUEST_RESUMING                815 //审讯恢复中
#define NET_SDK_ERR_RECORD_BACKUPING                816 //审讯备份中
#define NET_SDK_ERR_DISK_PLAYING                    817 //光盘回放中
#define NET_SDK_ERR_INQUEST_STARTED                    818 //审讯已开启
#define NET_SDK_ERR_LOCAL_OPERATING                    819 //本地操作进行中
#define NET_SDK_ERR_INQUEST_NOT_START                820 //审讯未开启
//Netra3.1.0错误码                
#define NET_SDK_ERR_CHAN_AUDIO_BIND                 821  //通道未绑定或绑定语音对讲失败
//云存储错误码
#define NET_DVR_N_PLUS_ONE_MODE                     822 //设备当前处于N+1模式
#define NET_DVR_CLOUD_STORAGE_OPENED                823 //云存储模式已开启

#define NET_DVR_ERR_OPER_NOT_ALLOWED                824   //设备处于N+0被接管状态，不允许该操作
#define NET_DVR_ERR_NEED_RELOCATE                    825   //设备处于N+0被接管状态，需要获取重定向信息，再重新操作

//庭审主机错误码
#define NET_SDK_ERR_IR_PORT_ERROR                   830 //红外输出口错误
#define NET_SDK_ERR_IR_CMD_ERROR                    831 //红外输出口的命令号错误
#define NET_SDK_ERR_NOT_INQUESTING                  832 //设备处于非审讯状态
#define NET_SDK_ERR_INQUEST_NOT_PAUSED              833 //设备处于非暂停状态
//2011-10-25多屏控制器错误码（900-950）
#define  NET_ERR_CUT_INPUTSTREAM_OVERLIMIT           900 //信号源裁剪数值超限
#define  NET_ERR_WINCHAN_IDX                        901    // 开窗通道号错误
#define  NET_ERR_WIN_LAYER                            902    // 窗口层数错误，单个屏幕上最多覆盖的窗口层数
#define  NET_ERR_WIN_BLK_NUM                        903    // 窗口的块数错误，单个窗口可覆盖的屏幕个数
#define  NET_ERR_OUTPUT_RESOLUTION                    904    // 输出分辨率错误
#define  NET_ERR_LAYOUT                                905    // 布局号错误
#define  NET_ERR_INPUT_RESOLUTION                    906 // 输入分辨率不支持
#define  NET_ERR_SUBDEVICE_OFFLINE                  907 // 子设备不在线
#define  NET_ERR_NO_DECODE_CHAN                     908 // 没有空闲解码通道
#define  NET_ERR_MAX_WINDOW_ABILITY                 909 // 开窗能力上限, 分布式多屏控制器中解码子设备能力上限或者显示处理器能力上限导致
#define  NET_ERR_ORDER_ERROR                        910 // 调用顺序有误
#define  NET_ERR_PLAYING_PLAN                        911 // 正在执行预案
#define  NET_ERR_DECODER_USED                        912 // 解码板正在使用
#define     NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW            913    // 输出板数据量超限
#define     NET_ERR_SAME_USER_NAME                        914    // 用户名相同
#define     NET_ERR_INVALID_USER_NAME                    915    // 无效用户名
#define     NET_ERR_MATRIX_USING                        916    // 输入矩阵正在使用
#define     NET_ERR_DIFFERENT_CHAN_TYPE                917    // 通道类型不同（矩阵输出通道和控制器的输入为不同的类型）
#define     NET_ERR_INPUT_CHAN_BINDED                    918    // 输入通道已经被其他矩阵绑定
#define     NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW        919    // 正在使用的矩阵输出通道个数超过矩阵与控制器绑定的通道个数
#define     NET_ERR_MAX_SIGNAL_NUM                        920    // 输入信号源个数达到上限
#define  NET_ERR_INPUT_CHAN_USING                    921    // 输入通道正在使用
#define  NET_ERR_MANAGER_LOGON                         922    // 管理员已经登陆，操作失败
#define  NET_ERR_USERALREADY_LOGON                     923    // 该用户已经登陆，操作失败
#define  NET_ERR_LAYOUT_INIT                         924    // 布局正在初始化，操作失败
#define     NET_ERR_BASEMAP_SIZE_NOT_MATCH                925    // 底图大小不符 
#define  NET_ERR_WINDOW_OPERATING                    926    // 窗口正在执行其他操作，本次操作失败
#define  NET_ERR_SIGNAL_UPLIMIT                        927 // 信号源开窗个数达到上限
#define  NET_ERR_SIGNAL_MAX_ENLARGE_TIMES           928 // 信号源放大倍数超限 
#define  NET_ERR_ONE_SIGNAL_MULTI_CROSS             929 // 单个信号源不能多次跨屏
#define  NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN          930 // 超高清信号源不能重复开窗 
#define  NET_ERR_MAX_VIRTUAL_LED_WIDTH              931 //虚拟LED宽度大于限制值
#define  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN           932 //虚拟LED字符数大于限制值
#define     NET_ERR_SINGLE_OUTPUTPARAM_CONFIG            933//不支持单个显示输出参数设置
#define  NET_ERR_MULTI_WIN_BE_COVER                 934//多分屏窗口被覆盖
#define  NET_ERR_WIN_NOT_EXIST                        935 //窗口不存在
#define  NET_ERR_WIN_MAX_SIGNALSOURCE                936//窗口信号源数超过限制值
#define  NET_ERR_MULTI_WIN_MOVE                        937//对多分屏窗口移动
#define  NET_ERR_MULTI_WIN_YPBPR_SDI                938 // YPBPR 和SDI信号源不支持9/16分屏      
#define  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE            939  //不同类型输出板混插
#define  NET_ERR_SPLIT_WIN_CROSS                    940//对跨屏窗口分屏
#define  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN            941  //对未满屏窗口分屏
#define  NET_ERR_SPLIT_WIN_MANY_WIN                    942  //对单个输出口上有多个窗口的窗口分屏
#define  NET_ERR_WINDOW_SIZE_OVERLIMIT              943   //窗口大小超限
#define  NET_ERR_INPUTSTREAM_ALREADY_JOINT           944    //信号源已加入拼接 
#define  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT          945    //拼接信号源个数超限      

#define  NET_ERR_LED_RESOLUTION                        946  //LED 分辨率大于输出分辨率
#define  NET_ERR_JOINT_SCALE_OVERLIMIT              947  //拼接信号源的规模超限
#define  NET_ERR_INPUTSTREAM_ALREADY_DECODE            948  //信号源已上墙
#define  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE     949  //信号源不支持抓图
#define  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN            950  //拼接信号源不支持分屏

//解码器错误码（951-999）
#define NET_ERR_MAX_WIN_OVERLAP                        951 //达到最大窗口重叠数
#define NET_ERR_STREAMID_CHAN_BOTH_VALID            952 //stream ID和通道号同时有效
#define NET_ERR_NO_ZERO_CHAN                        953 //设备无零通道
#define NEED_RECONNECT                                955 //需要重定向（转码子系统使用）
#define NET_ERR_NO_STREAM_ID                        956 //流ID不存在
#define NET_DVR_TRANS_NOT_START                        957 //转码未启动
#define NET_ERR_MAXNUM_STREAM_ID                    958 //流ID数达到上限
#define NET_ERR_WORKMODE_MISMATCH                    959 //工作模式不匹配
#define NET_ERR_MODE_IS_USING                        960 //已工作在当前模式
#define NET_ERR_DEV_PROGRESSING                        961 //设备正在处理中
#define NET_ERR_PASSIVE_TRANSCODING                    962 //正在被动转码

#define NET_ERR_RING_NOT_CONFIGURE                   964 //环网未配置

#define NET_ERR_CLOSE_WINDOW_FIRST                    971  //切换全帧率畅显时必须先关闭对应的已上墙的窗口
#define NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT        972  //DVI/DP/HDMI/HDBase_T输入源在全帧率畅显下不支持9/16画面
#define NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK   973  //单信号源回显连接数量超限
#define NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION  974  //只有分屏窗口支持子窗口放大
#define NET_DVR_ERR_WINDOW_SIZE_PLACE  975  //窗口位置错误
#define NET_DVR_ERR_RGIONAL_RESTRICTIONS  976  //屏幕距离超限
#define NET_ERR_WNDZOOM_NOT_SUPPORT  977  //单窗口不支持子窗口全屏功能
#define NET_ERR_LED_SCREEN_SIZE  978  //LED屏宽高不正确
#define NET_ERR_OPEN_WIN_IN_ERROR_AREA  979  //在非法区域开窗(包括跨LCD/LED屏)
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE  980  //平铺模式不支持漫游
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER  981  //平铺模式不支持图层覆盖
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT  982  //平铺模式不支持分屏
#define NET_DVR_LED_WINDOWS_ALREADY_CLOSED  983  //LED区域内输出口的分辨率发生变化，设备已关闭该区域内的所有LED窗口
//能力集解析库错误码
#define XML_ABILITY_NOTSUPPORT                      1000  //不支持能力节点获取
#define    XML_ANALYZE_NOENOUGH_BUF                    1001        //输出内存不足
#define    XML_ANALYZE_FIND_LOCALXML_ERROR                1002        //无法找到对应的本地xml
#define    XML_ANALYZE_LOAD_LOCALXML_ERROR                1003        //加载本地xml出错
#define    XML_NANLYZE_DVR_DATA_FORMAT_ERROR            1004        //设备能力数据格式错误
#define    XML_ANALYZE_TYPE_ERROR                        1005        //能力集类型错误
#define    XML_ANALYZE_XML_NODE_ERROR                    1006        //XML能力节点格式错误
#define XML_INPUT_PARAM_ERROR                       1007  //输入的能力XML节点值错误

//民用错误码（1100～1200）
#define NET_ERR_PLT_USERID                          1100 //验证平台userid错误
#define NET_ERR_TRANS_CHAN_START                    1101 //透明通道已打开，当前操作无法完成
#define NET_ERR_DEV_UPGRADING                        1102 //设备正在升级
#define NET_ERR_MISMATCH_UPGRADE_PACK_TYPE          1103 //升级包类型不匹配
#define NET_ERR_DEV_FORMATTING                      1104 //设备正在格式化
#define NET_ERR_MISMATCH_UPGRADE_PACK_VERSION       1105 //升级包版本不匹配

//2012-10-16 报警设备错误码（1200~1300）
#define NET_ERR_SEARCHING_MODULE                    1201 // 正在搜索外接模块
#define NET_ERR_REGISTERING_MODULE                  1202 // 正在注册外接模块
#define NET_ERR_GETTING_ZONES                        1203 // 正在获取防区参数
#define NET_ERR_GETTING_TRIGGERS                    1204 // 正在获取触发器
#define NET_ERR_ARMED_STATUS                        1205 // 系统处于布防状态
#define    NET_ERR_PROGRAM_MODE_STATUS                    1206 // 系统处于编程模式
#define    NET_ERR_WALK_TEST_MODE_STATUS                1207 // 系统处于步测模式
#define    NET_ERR_BYPASS_STATUS                        1208 // 旁路状态
#define NET_ERR_DISABLED_MODULE_STATUS                1209 // 功能未使能
#define    NET_ERR_NOT_SUPPORT_OPERATE_ZONE            1210 // 防区不支持该操作
#define NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR            1211 // 模块地址不能被修改
#define NET_ERR_UNREGISTERED_MODULE                    1212 // 模块未注册
#define NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF        1213 // 公共子系统关联自身
#define NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM        1214 // 超过公共子系统最大关联个数
#define NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM    1215 // 子系统被其他公共子系统关联
#define    NET_ERR_ZONE_FAULT_STATUS                    1216 // 防区处于故障状态
#define NET_ERR_SAME_EVENT_TYPE                    1217 // 事件触发报警输出开启和事件触发报警输出关闭中有相同事件类型    
#define NET_ERR_ZONE_ALARM_STATUS                    1218 // 防区处于报警状态
#define NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT            1219 //扩展总线短路
#define NET_ERR_PWD_CONFLICT                        1220  //密码冲突


//信息发布主机
#define NET_ERR_GET_ALL_RETURN_OVER                    1300  //获取所有返回数目超限
#define NET_ERR_RESOURCE_USING                      1301  //信息发布资源正在使用，不能修改
#define NET_ERR_FILE_SIZE_OVERLIMIT                    1302  //文件大小超限

//信息发布服务器错误码
#define NET_ERR_MATERIAL_NAME                       1303  //素材名称非法
#define NET_ERR_MATERIAL_NAME_LEN                   1304  //素材名称长度非法
#define NET_ERR_MATERIAL_REMARK                     1305  //素材描述非法
#define NET_ERR_MATERIAL_REMARK_LEN                 1306  //素材描述长度非法
#define NET_ERR_MATERIAL_SHARE_PROPERTY             1307  //素材共享属性非法
#define NET_ERR_UNSUPPORT_MATERIAL_TYPE             1308  //素材类型不支持
#define NET_ERR_MATERIAL_NOT_EXIST                  1309  //素材不存在
#define NET_ERR_READ_FROM_DISK                      1310  //从硬盘读取素材文件失败
#define NET_ERR_WRITE_TO_DISK                       1311  //向硬盘写素材文件失败
#define NET_ERR_WRITE_DATA_BASE                     1312  //素材写数据库失败

//多屏互动错误码
#define    NET_ERR_MAX_SCREEN_CTRL_NUM                    1351    //屏幕控制连接数达到上限
#define    NET_ERR_FILE_NOT_EXIST                        1352    //文件不存在
#define NET_ERR_THUMBNAIL_NOT_EXIST                    1353    //缩略图不存在
#define NET_ERR_DEV_OPEN_FILE_FAIL                    1354    //设备端打开文件失败
#define NET_ERR_SERVER_READ_FILE_FAIL                1355    //设备端读取文件失败
#define NET_ERR_FILE_SIZE                            1356    //文件大小错误
#define    NET_ERR_FILE_NAME                            1357    //文件名称错误，为空或不合法

//2012-12-20抓拍机错误码（1400-1499）
#define NET_DVR_ERR_LANENUM_EXCEED                  1400  //车道数超出能力
#define NET_DVR_ERR_PRAREA_EXCEED                   1401  //牌识区域过大
#define NET_DVR_ERR_LIGHT_PARAM                     1402  //信号灯接入参数错误
#define NET_DVR_ERR_LANE_LINE_INVALID               1403  //车道线配置错误
#define NET_DVR_ERR_STOP_LINE_INVALID               1404  //停止线配置错误
#define NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID        1405  //左/右转分界线配置错误
#define NET_DVR_ERR_LANE_NO_REPEAT                  1406  //叠加车道号重复
#define NET_DVR_ERR_PRAREA_INVALID                  1407  //牌识多边形不符合要求
#define NET_DVR_ERR_LIGHT_NUM_EXCEED                1408  //视频检测交通灯信号灯数目超出最大值
#define NET_DVR_ERR_SUBLIGHT_NUM_INVALID            1409  //视频检测交通灯信号灯子灯数目不合法
#define NET_DVR_ERR_LIGHT_AREASIZE_INVALID          1410  //视频检测交通灯输入信号灯框大小不合法
#define NET_DVR_ERR_LIGHT_COLOR_INVALID             1411  //视频检测交通灯输入信号灯颜色不合法
#define NET_DVR_ERR_LIGHT_DIRECTION_INVALID         1412  //视频检测交通灯输入灯方向属性不合法
#define NET_DVR_ERR_LACK_IOABLITY                    1413  //IO口实际支持的能力不足

#define NET_DVR_ERR_FTP_PORT                        1414  //FTP端口号非法（端口号重复或者异常）
#define NET_DVR_ERR_FTP_CATALOGUE                   1415  //FTP目录名非法（启用多级目录，多级目录传值为空）
#define NET_DVR_ERR_FTP_UPLOAD_TYPE                 1416  //FTP上传类型非法（单ftp只支持全部/双ftp只支持卡口和违章）
#define NET_DVR_ERR_FLASH_PARAM_WRITE               1417  //配置参数时写FLASH失败
#define NET_DVR_ERR_FLASH_PARAM_READ                1418  //配置参数时读FLASH失败
#define NET_DVR_ERR_PICNAME_DELIMITER               1419  //FTP图片命名分隔符非法
#define NET_DVR_ERR_PICNAME_ITEM                    1420  //FTP图片命名项非法（例如 分隔符）
#define NET_DVR_ERR_PLATE_RECOGNIZE_TYPE            1421  //牌识区域类型非法 （矩形和多边形有效性校验）
#define NET_DVR_ERR_CAPTURE_TIMES                   1422  //抓拍次数非法 （有效值是0～5）
#define NET_DVR_ERR_LOOP_DISTANCE                   1423  //线圈距离非法 （有效值是0～2000ms）
#define NET_DVR_ERR_LOOP_INPUT_STATUS               1424  //线圈输入状态非法 （有效值）
#define NET_DVR_ERR_RELATE_IO_CONFLICT              1425  //测速组IO关联冲突
#define NET_DVR_ERR_INTERVAL_TIME                   1426  //连拍间隔时间非法 （0～6000ms）
#define NET_DVR_ERR_SIGN_SPEED                      1427  //标志限速值非法（大车标志限速不能大于小车标志限速 ）
#define NET_DVR_ERR_PIC_FLIP                        1428  //图像配置翻转 （配置交互影响）
#define NET_DVR_ERR_RELATE_LANE_NUMBER              1429  //关联车道数错误 (重复 有效值校验1～99)
#define NET_DVR_ERR_TRIGGER_MODE                    1430  //配置抓拍机触发模式非法
#define NET_DVR_ERR_DELAY_TIME                      1431  //触发延时时间错误(2000ms)
#define NET_DVR_ERR_EXCEED_RS485_COUNT              1432  //超过最大485个数限制
#define NET_DVR_ERR_RADAR_TYPE                      1433  //雷达类型错误
#define NET_DVR_ERR_RADAR_ANGLE                     1434  //雷达角度错误
#define NET_DVR_ERR_RADAR_SPEED_VALID_TIME          1435  //雷达有效时间错误
#define NET_DVR_ERR_RADAR_LINE_CORRECT              1436  //雷达线性矫正参数错误
#define NET_DVR_ERR_RADAR_CONST_CORRECT             1437  //雷达常量矫正参数错误
#define NET_DVR_ERR_RECORD_PARAM                    1438  //录像参数无效（预录时间不超过10s）
#define NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION 1439   //视频检测信号灯配置信号灯个数，但是没有勾选信号灯方向和颜色的
#define NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION   1440   //视频检测信号灯配置信号灯个数，但是没有画检测区域
#define NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM         1441   //牌识参数省份参数的合法性

#define NET_DVR_ERR_SPEED_TIMEOUT                 1442    //IO测速超时时间非法（有效值大于0）
#define NET_DVR_ERR_NTP_TIMEZONE                  1443    //ntp时区参数错误
#define NET_DVR_ERR_NTP_INTERVAL_TIME             1444    //ntp校时间隔错误
#define NET_DVR_ERR_NETWORK_CARD_NUM              1445    //可配置网卡数目错误
#define NET_DVR_ERR_DEFAULT_ROUTE                 1446    //默认路由错误
#define NET_DVR_ERR_BONDING_WORK_MODE             1447    //bonding网卡工作模式错误
#define NET_DVR_ERR_SLAVE_CARD                    1448    //slave网卡错误
#define NET_DVR_ERR_PRIMARY_CARD                  1449    //Primary网卡错误
#define NET_DVR_ERR_DHCP_PPOE_WORK                1450    //dhcp和pppoE不能同时启动
#define NET_DVR_ERR_NET_INTERFACE                 1451    //网络接口错误
#define NET_DVR_ERR_MTU                           1452    //MTU错误
#define NET_DVR_ERR_NETMASK                       1453    //子网掩码错误
#define NET_DVR_ERR_IP_INVALID                    1454    //IP地址不合法
#define NET_DVR_ERR_MULTICAST_IP_INVALID          1455    //多播地址不合法
#define NET_DVR_ERR_GATEWAY_INVALID               1456    //网关不合法
#define NET_DVR_ERR_DNS_INVALID                   1457    //DNS不合法
#define NET_DVR_ERR_ALARMHOST_IP_INVALID          1458    //告警主机地址不合法
#define NET_DVR_ERR_IP_CONFLICT                   1459    //IP冲突
#define NET_DVR_ERR_NETWORK_SEGMENT               1460    //IP不支持同网段
#define NET_DVR_ERR_NETPORT                       1461    //端口错误

#define NET_DVR_ERR_PPPOE_NOSUPPORT               1462  //PPPOE不支持
#define NET_DVR_ERR_DOMAINNAME_NOSUPPORT          1463  //域名不支持
#define NET_DVR_ERR_NO_SPEED                      1464  //未启用测速功能 
#define NET_DVR_ERR_IOSTATUS_INVALID              1465  //IO状态错误
#define NET_DVR_ERR_BURST_INTERVAL_INVALID        1466  //连拍间隔非法    
#define NET_DVR_ERR_RESERVE_MODE                  1467  //备用模式错误

#define NET_DVR_ERR_LANE_NO                       1468  //叠加车道号错误
#define NET_DVR_ERR_COIL_AREA_TYPE                1469  //线圈区域类型错误
#define NET_DVR_ERR_TRIGGER_AREA_PARAM            1470  //触发区域参数错误
#define NET_DVR_ERR_SPEED_LIMIT_PARAM             1471  //违章限速参数错误
#define NET_DVR_ERR_LANE_PROTOCOL_TYPE            1472  //车道关联协议类型错误

#define NET_DVR_ERR_INTERVAL_TYPE                 1473  //连拍间隔类型非法
#define NET_DVR_ERR_INTERVAL_DISTANCE             1474  //连拍间隔距离非法
#define NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE       1475  //RS485关联类型非法
#define NET_DVR_ERR_RS485_ASSOCIATE_LANENO        1476  //RS485关联车道号非法
#define NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485   1477  //车道号关联多个RS485口
#define NET_DVR_ERR_LIGHT_DETECTION_REGION        1478  //视频检测信号灯配置信号灯个数，但是检测区域宽或高为0

#define NET_DVR_ERR_DN2D_NOSUPPORT            1479  //不支持抓拍帧2D降噪
#define NET_DVR_ERR_IRISMODE_NOSUPPORT        1480  //不支持的镜头类型
#define NET_DVR_ERR_WB_NOSUPPORT              1481  //不支持的白平衡模式
#define NET_DVR_ERR_IO_EFFECTIVENESS          1482  //IO口的有效性
#define NET_DVR_ERR_LIGHTNO_MAX               1483  //信号灯检测器接入红/黄灯超限(16)
#define NET_DVR_ERR_LIGHTNO_CONFLICT          1484  //信号灯检测器接入红/黄灯冲突      

#define NET_DVR_ERR_CANCEL_LINE                1485  //直行触发线
#define NET_DVR_ERR_STOP_LINE               1486  //待行区停止线
#define NET_DVR_ERR_RUSH_REDLIGHT_LINE      1487  //闯红灯触发线 
#define NET_DVR_ERR_IOOUTNO_MAX             1488  //IO输出口编号越界

#define NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX    1489  //IO输出口提前时间超限
#define NET_DVR_ERR_IOOUTNO_IOWORKTIME      1490  //IO输出口有效持续时间超限
#define NET_DVR_ERR_IOOUTNO_FREQMULTI       1491  //IO输出口脉冲模式下倍频出错
#define NET_DVR_ERR_IOOUTNO_DUTYRATE        1492  //IO输出口脉冲模式下占空比出错
#define NET_DVR_ERR_VIDEO_WITH_EXPOSURE     1493  //以曝闪起效，工作方式不支持视频
#define NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET   1494  //车牌亮度自动使能闪光灯仅在车牌亮度补偿模式下起效

#define NET_DVR_ERR_RECOGNIZE_TYPE_PARAM            1495 //识别类型非法 车牌识别参数（如大车、小车、背向、正向、车标识别等）
#define NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM      1496 //牌识参数非法 牌识区域配置时判断出错
#define NET_DVR_ERR_PORT_CONFLICT                   1497 //端口有冲突
#define NET_DVR_ERR_LOOP_IP                         1498 //IP不能设置为回环地址
#define NET_DVR_ERR_DRIVELINE_SENSITIVE             1499 //压线灵敏度出错(视频电警模式下)


//2013-3-6VQD错误码（1500～1550）
#define NET_ERR_VQD_TIME_CONFLICT                    1500 //VQD诊断时间段冲突
#define NET_ERR_VQD_PLAN_NO_EXIST                    1501 //VQD诊断计划不存在
#define NET_ERR_VQD_CHAN_NO_EXIST                    1502 //VQD监控点不存在
#define NET_ERR_VQD_CHAN_MAX                        1503 //VQD计划数已达上限
#define NET_ERR_VQD_TASK_MAX                        1504 //VQD任务数已达上限

//抓拍机错误码新增扩展(1600~1900)
#define NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES        1600 //抓拍模式为频闪时最大抓拍张数为2张(IVT模式下)
#define NET_DVR_ERR_REDAR_TYPE_CONFLICT             1601 //相同485口关联雷达类型冲突 
#define NET_DVR_ERR_LICENSE_PLATE_NULL              1602 //车牌号为空
#define NET_DVR_ERR_WRITE_DATABASE                  1603 //写入数据库失败
#define NET_DVR_ERR_LICENSE_EFFECTIVE_TIME          1604 //车牌有效时间错误
//视频电警
#define NET_DVR_ERR_PRERECORDED_STARTTIME_LONG      1605 //预录开始时间大于违法抓拍张数
//混合卡口
#define NET_DVR_ERR_TRIGGER_RULE_LINE               1606 //触发规则线错误
#define NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL 1607 //左/右触发线不垂直
#define NET_DVR_ERR_FLASH_LAMP_MODE                 1608 //闪光灯闪烁模式错误
#define NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM            1609 //违章抓拍张数错误
#define NET_DVR_ERR_ILLEGAL_DETECTION_TYPE          1610 //违章检测类型错误
#define NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH   1611 //正背向触发线高度错误
#define NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS    1612 //混合模式下只支持机非人抓拍类型

#define NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED  1613//小车标志限速大于限速值
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED  1614//大车标志限速大于限速值
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED  1615//大车标志限速大于小车标志限速值
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED  1616//大车限速值大于小车限速值
#define NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT  1617//大车低速限速值大于小车低速限速值
#define NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1618//小车限速大于异常高速值
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1619//大车限速大于异常高速值
#define NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE  1620//停止线超过直行触发线

//门禁主机错误码
#define NET_ERR_TIME_OVERLAP                        1900 //时间段重叠
#define NET_ERR_HOLIDAY_PLAN_OVERLAP                1901 //假日计划重叠
#define NET_ERR_CARDNO_NOT_SORT                     1902 //卡号未排序
#define NET_ERR_CARDNO_NOT_EXIST                    1903 //卡号不存在
#define NET_ERR_ILLEGAL_CARDNO                      1904 //卡号错误
#define NET_ERR_ZONE_ALARM                          1905 //防区处于布防状态(参数修改不允许)
#define NET_ERR_ZONE_OPERATION_NOT_SUPPORT          1906 //防区不支持该操作
#define NET_ERR_INTERLOCK_ANTI_CONFLICT             1907 //多门互锁和反潜回同时配置错误
#define NET_ERR_DEVICE_CARD_FULL                    1908 //卡已满（卡达到10W后返回）


//可视对讲错误码
#define NET_DVR_ERR_OUTDOOR_COMMUNICATION            1950 //与门口机通信异常
#define NET_DVR_ERR_ROOMNO_UNDEFINED                1951 //未设置房间号
#define NET_DVR_ERR_NO_CALLING            1952 //无呼叫
#define NET_DVR_ERR_RINGING                1953 //响铃
#define NET_DVR_ERR_IS_CALLING_NOW        1954 //正在通话

//后端错误码 （2100 - 3000）
#define NET_DVR_ERR_FILE_NOT_COMPLETE               2100    //下载的文件不完整
#define NET_DVR_ERR_IPC_EXIST                       2101    //该IPC已经存在
#define NET_DVR_ERR_ADD_IPC                         2102    //该通道已添加IPC
#define NET_DVR_ERR_OUT_OF_RES                      2103    //网络带宽能力不足
#define NET_DVR_ERR_CONFLICT_TO_LOCALIP             2104    //IPC的ip地址跟DVR的ip地址冲突
#define NET_DVR_ERR_IP_SET                          2105    //非法ip地址
#define NET_DVR_ERR_PORT_SET                        2106    //非法的端口号

//热成像产线相关错误码（3001 - 3500）
#define NET_DVR_ERR_NOTSUPPORT_DEICING    3001    //设备当前状态不支持除冰功能

/*******************全局错误码 end**********************/

/*************************************************
NET_DVR_IsSupport()返回值
1－9位分别表示以下信息（位与是TRUE)表示支持；
**************************************************/
#define NET_DVR_SUPPORT_DDRAW            0x01//支持DIRECTDRAW，如果不支持，则播放器不能工作；
#define NET_DVR_SUPPORT_BLT                0x02//显卡支持BLT操作，如果不支持，则播放器不能工作；
#define NET_DVR_SUPPORT_BLTFOURCC        0x04//显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换；
#define NET_DVR_SUPPORT_BLTSHRINKX        0x08//显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换；
#define NET_DVR_SUPPORT_BLTSHRINKY        0x10//显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换；
#define NET_DVR_SUPPORT_BLTSTRETCHX        0x20//显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换；
#define NET_DVR_SUPPORT_BLTSTRETCHY        0x40//显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换；
#define NET_DVR_SUPPORT_SSE                0x80//CPU支持SSE指令，Intel Pentium3以上支持SSE指令；
#define NET_DVR_SUPPORT_MMX                0x100//CPU支持MMX指令集，Intel Pentium3以上支持SSE指令；

/**********************云台控制命令 begin*************************/    
#define LIGHT_PWRON        2    /* 接通灯光电源 */
#define WIPER_PWRON        3    /* 接通雨刷开关 */
#define FAN_PWRON        4    /* 接通风扇开关 */
#define HEATER_PWRON    5    /* 接通加热器开关 */
#define AUX_PWRON1        6    /* 接通辅助设备开关 */
#define AUX_PWRON2        7    /* 接通辅助设备开关 */
#define SET_PRESET        8    /* 设置预置点 */
#define CLE_PRESET        9    /* 清除预置点 */

#define ZOOM_IN            11    /* 焦距以速度SS变大(倍率变大) */
#define ZOOM_OUT        12    /* 焦距以速度SS变小(倍率变小) */
#define FOCUS_NEAR      13  /* 焦点以速度SS前调 */
#define FOCUS_FAR       14  /* 焦点以速度SS后调 */
#define IRIS_OPEN       15  /* 光圈以速度SS扩大 */
#define IRIS_CLOSE      16  /* 光圈以速度SS缩小 */

#define TILT_UP            21    /* 云台以SS的速度上仰 */
#define TILT_DOWN        22    /* 云台以SS的速度下俯 */
#define PAN_LEFT        23    /* 云台以SS的速度左转 */
#define PAN_RIGHT        24    /* 云台以SS的速度右转 */
#define UP_LEFT            25    /* 云台以SS的速度上仰和左转 */
#define UP_RIGHT        26    /* 云台以SS的速度上仰和右转 */
#define DOWN_LEFT        27    /* 云台以SS的速度下俯和左转 */
#define DOWN_RIGHT        28    /* 云台以SS的速度下俯和右转 */
#define PAN_AUTO        29    /* 云台以SS的速度左右自动扫描 */

#define FILL_PRE_SEQ    30    /* 将预置点加入巡航序列 */
#define SET_SEQ_DWELL    31    /* 设置巡航点停顿时间 */
#define SET_SEQ_SPEED    32    /* 设置巡航速度 */
#define CLE_PRE_SEQ        33    /* 将预置点从巡航序列中删除 */
#define STA_MEM_CRUISE    34    /* 开始记录轨迹 */
#define STO_MEM_CRUISE    35    /* 停止记录轨迹 */
#define RUN_CRUISE        36    /* 开始轨迹 */
#define RUN_SEQ            37    /* 开始巡航 */
#define STOP_SEQ        38    /* 停止巡航 */
#define GOTO_PRESET        39    /* 快球转到预置点 */

#define DEL_SEQ         43  /* 删除巡航路径 */
#define STOP_CRUISE        44    /* 停止轨迹 */
#define DELETE_CRUISE    45    /* 删除单条轨迹 */
#define DELETE_ALL_CRUISE 46/* 删除所有轨迹 */

#define PAN_CIRCLE      50   /* 云台以SS的速度自动圆周扫描 */
#define DRAG_PTZ        51   /* 拖动PTZ */
#define LINEAR_SCAN     52   /* 区域扫描 */ //2014-03-15 
#define CLE_ALL_PRESET  53   /* 预置点全部清除 */ 
#define CLE_ALL_SEQ     54   /* 巡航全部清除 */ 
#define CLE_ALL_CRUISE  55   /* 轨迹全部清除 */ 

#define POPUP_MENU      56   /* 显示操作菜单 */

#define TILT_DOWN_ZOOM_IN    58    /* 云台以SS的速度下俯&&焦距以速度SS变大(倍率变大) */
#define TILT_DOWN_ZOOM_OUT  59  /* 云台以SS的速度下俯&&焦距以速度SS变小(倍率变小) */
#define PAN_LEFT_ZOOM_IN    60  /* 云台以SS的速度左转&&焦距以速度SS变大(倍率变大)*/
#define PAN_LEFT_ZOOM_OUT   61  /* 云台以SS的速度左转&&焦距以速度SS变小(倍率变小)*/
#define PAN_RIGHT_ZOOM_IN    62  /* 云台以SS的速度右转&&焦距以速度SS变大(倍率变大) */
#define PAN_RIGHT_ZOOM_OUT  63  /* 云台以SS的速度右转&&焦距以速度SS变小(倍率变小) */
#define UP_LEFT_ZOOM_IN     64  /* 云台以SS的速度上仰和左转&&焦距以速度SS变大(倍率变大)*/
#define UP_LEFT_ZOOM_OUT    65  /* 云台以SS的速度上仰和左转&&焦距以速度SS变小(倍率变小)*/
#define UP_RIGHT_ZOOM_IN    66  /* 云台以SS的速度上仰和右转&&焦距以速度SS变大(倍率变大)*/
#define UP_RIGHT_ZOOM_OUT   67  /* 云台以SS的速度上仰和右转&&焦距以速度SS变小(倍率变小)*/
#define DOWN_LEFT_ZOOM_IN   68  /* 云台以SS的速度下俯和左转&&焦距以速度SS变大(倍率变大) */
#define DOWN_LEFT_ZOOM_OUT  69  /* 云台以SS的速度下俯和左转&&焦距以速度SS变小(倍率变小) */
#define DOWN_RIGHT_ZOOM_IN    70  /* 云台以SS的速度下俯和右转&&焦距以速度SS变大(倍率变大) */
#define DOWN_RIGHT_ZOOM_OUT    71  /* 云台以SS的速度下俯和右转&&焦距以速度SS变小(倍率变小) */
#define TILT_UP_ZOOM_IN        72    /* 云台以SS的速度上仰&&焦距以速度SS变大(倍率变大) */
#define TILT_UP_ZOOM_OUT    73    /* 云台以SS的速度上仰&&焦距以速度SS变小(倍率变小) */
/**********************云台控制命令 end*************************/

#define DVR_VEHICLE_CONTROL_LIST   0x1 //车辆黑白名单数据类型(发送的数据类型)2013-11-04
    

/*************************************************
回放时播放控制命令宏定义 
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl的宏定义
具体支持查看函数说明和代码
**************************************************/    
#define NET_DVR_PLAYSTART        1//开始播放
#define NET_DVR_PLAYSTOP        2//停止播放
#define NET_DVR_PLAYPAUSE        3//暂停播放
#define NET_DVR_PLAYRESTART        4//恢复播放
#define NET_DVR_PLAYFAST        5//快放
#define NET_DVR_PLAYSLOW        6//慢放
#define NET_DVR_PLAYNORMAL        7//正常速度
#define NET_DVR_PLAYFRAME        8//单帧放
#define NET_DVR_PLAYSTARTAUDIO    9//打开声音
#define NET_DVR_PLAYSTOPAUDIO    10//关闭声音
#define NET_DVR_PLAYAUDIOVOLUME    11//调节音量
#define NET_DVR_PLAYSETPOS        12//改变文件回放的进度
#define NET_DVR_PLAYGETPOS        13//获取文件回放的进度
#define NET_DVR_PLAYGETTIME        14//获取当前已经播放的时间(按文件回放的时候有效)
#define NET_DVR_PLAYGETFRAME    15//获取当前已经播放的帧数(按文件回放的时候有效)
#define NET_DVR_GETTOTALFRAMES  16//获取当前播放文件总的帧数(按文件回放的时候有效)
#define NET_DVR_GETTOTALTIME    17//获取当前播放文件总的时间(按文件回放的时候有效)
#define NET_DVR_THROWBFRAME        20//丢B帧
#define NET_DVR_SETSPEED        24//设置码流速度
#define NET_DVR_KEEPALIVE        25//保持与设备的心跳(如果回调阻塞，建议2秒发送一次)
#define NET_DVR_PLAYSETTIME        26//按绝对时间定位
#define NET_DVR_PLAYGETTOTALLEN    27//获取按时间回放对应时间段内的所有文件的总长度
#define NET_DVR_PLAY_FORWARD    29 //倒放切换为正放
#define NET_DVR_PLAY_REVERSE    30 //正放切换为倒放
#define NET_DVR_SET_DECODEFFRAMETYPE 31 
#define NET_DVR_SET_TRANS_TYPE    32 //设置转码格式
#define NET_DVR_PLAY_CONVERT    33 //回放转码
#define NET_DVR_START_DRAWFRAME 34 //开始抽帧回放
#define NET_DVR_STOP_DRAWFRAME  35 //停止抽帧回放


#define PLAYM4_DECODE_NORMAIL              0   //正常解码
#define PLAYM4_DECODE_KEY_FRAME            1   //只解I帧
#define PLAYM4_DECODE_NONE                 2   //全不解
#define PLAYM4_DECODE_TEMPORAL_LAYER_0     3   //解1/2
#define PLAYM4_DECODE_TEMPORAL_LAYER_1     4   //解1/4


//远程按键定义如下：
/* key value send to CONFIG program */
#define KEY_CODE_1      1
#define KEY_CODE_2      2
#define KEY_CODE_3      3
#define KEY_CODE_4      4
#define KEY_CODE_5      5
#define KEY_CODE_6      6
#define KEY_CODE_7      7
#define KEY_CODE_8      8
#define KEY_CODE_9      9
#define KEY_CODE_0      10
#define KEY_CODE_POWER  11
#define KEY_CODE_MENU   12
#define KEY_CODE_ENTER  13
#define KEY_CODE_CANCEL 14
#define KEY_CODE_UP     15
#define KEY_CODE_DOWN   16
#define KEY_CODE_LEFT   17
#define KEY_CODE_RIGHT  18
#define KEY_CODE_EDIT   19
#define KEY_CODE_ADD    20
#define KEY_CODE_MINUS  21
#define KEY_CODE_PLAY   22
#define KEY_CODE_REC    23
#define KEY_CODE_PAN    24
#define KEY_CODE_M      25
#define KEY_CODE_A      26
#define KEY_CODE_F1     27
#define KEY_CODE_F2     28

/* for PTZ control */
#define KEY_PTZ_UP_START        KEY_CODE_UP
#define KEY_PTZ_UP_STOP         32

#define KEY_PTZ_DOWN_START      KEY_CODE_DOWN
#define KEY_PTZ_DOWN_STOP       33

#define KEY_PTZ_LEFT_START      KEY_CODE_LEFT
#define KEY_PTZ_LEFT_STOP       34

#define KEY_PTZ_RIGHT_START     KEY_CODE_RIGHT
#define KEY_PTZ_RIGHT_STOP      35

#define KEY_PTZ_AP1_START       KEY_CODE_EDIT /*光圈+*/
#define KEY_PTZ_AP1_STOP        36

#define KEY_PTZ_AP2_START       KEY_CODE_PAN /*光圈-*/
#define KEY_PTZ_AP2_STOP        37

#define KEY_PTZ_FOCUS1_START    KEY_CODE_A /*聚焦+*/
#define KEY_PTZ_FOCUS1_STOP     38

#define KEY_PTZ_FOCUS2_START    KEY_CODE_M /*聚焦-*/
#define KEY_PTZ_FOCUS2_STOP     39

#define KEY_PTZ_B1_START        40 /*变倍+*/
#define KEY_PTZ_B1_STOP         41

#define KEY_PTZ_B2_START        42 /*变倍-*/
#define KEY_PTZ_B2_STOP         43

//9000新增
#define KEY_CODE_11             44
#define KEY_CODE_12             45
#define KEY_CODE_13             46
#define KEY_CODE_14             47
#define KEY_CODE_15             48
#define KEY_CODE_16             49



/*************************参数配置命令 begin*******************************/
//用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构

#define NET_DVR_GET_DEVICECFG        100        //获取设备参数
#define NET_DVR_SET_DEVICECFG        101        //设置设备参数
#define NET_DVR_GET_NETCFG            102        //获取网络参数
#define NET_DVR_SET_NETCFG            103        //设置网络参数
#define NET_DVR_GET_PICCFG            104        //获取图象参数
#define NET_DVR_SET_PICCFG            105        //设置图象参数
#define NET_DVR_GET_COMPRESSCFG        106        //获取压缩参数
#define NET_DVR_SET_COMPRESSCFG        107        //设置压缩参数
#define NET_DVR_GET_RECORDCFG        108        //获取录像时间参数
#define NET_DVR_SET_RECORDCFG        109        //设置录像时间参数
#define NET_DVR_GET_DECODERCFG        110        //获取解码器参数
#define NET_DVR_SET_DECODERCFG        111        //设置解码器参数
#define NET_DVR_GET_RS232CFG         112        //获取232串口参数
#define NET_DVR_SET_RS232CFG        113        //设置232串口参数
#define NET_DVR_GET_ALARMINCFG         114        //获取报警输入参数
#define NET_DVR_SET_ALARMINCFG        115        //设置报警输入参数
#define NET_DVR_GET_ALARMOUTCFG     116        //获取报警输出参数
#define NET_DVR_SET_ALARMOUTCFG        117        //设置报警输出参数
#define NET_DVR_GET_TIMECFG         118        //获取DVR时间
#define NET_DVR_SET_TIMECFG            119        //设置DVR时间
#define NET_DVR_GET_PREVIEWCFG         120        //获取预览参数
#define NET_DVR_SET_PREVIEWCFG        121        //设置预览参数
#define NET_DVR_GET_VIDEOOUTCFG     122        //获取视频输出参数
#define NET_DVR_SET_VIDEOOUTCFG        123        //设置视频输出参数
#define NET_DVR_GET_USERCFG         124        //获取用户参数
#define NET_DVR_SET_USERCFG            125        //设置用户参数
#define NET_DVR_GET_EXCEPTIONCFG     126        //获取异常参数
#define NET_DVR_SET_EXCEPTIONCFG    127        //设置异常参数
#define NET_DVR_GET_ZONEANDDST        128        //获取时区和夏时制参数
#define NET_DVR_SET_ZONEANDDST        129        //设置时区和夏时制参数

//注：该命令只支持4条OSD的类型，通常用于V30以下的设备版本。
#define NET_DVR_GET_SHOWSTRING        130        //获取叠加字符参数
#define NET_DVR_SET_SHOWSTRING        131        //设置叠加字符参数

#define NET_DVR_GET_EVENTCOMPCFG    132        //获取事件触发录像参数
#define NET_DVR_SET_EVENTCOMPCFG    133        //设置事件触发录像参数
#define NET_DVR_GET_FTPCFG            134        //获取抓图的FTP参数(基线)
#define NET_DVR_SET_FTPCFG            135        //设置抓图的FTP参数(基线)
#define NET_DVR_GET_AUXOUTCFG        140        //获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)
#define NET_DVR_SET_AUXOUTCFG        141        //设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)
#define NET_DVR_GET_PREVIEWCFG_AUX     142        //获取-s系列双输出预览参数(-s系列双输出2006-04-13)
#define NET_DVR_SET_PREVIEWCFG_AUX    143        //设置-s系列双输出预览参数(-s系列双输出2006-04-13)

#define NET_DVR_GET_PASSWORD_MANAGE_CFG 144        //获取密码管理配置
#define NET_DVR_SET_PASSWORD_MANAGE_CFG    145        //设置密码管理配置
#define NET_DVR_UNLOCK_USER             146        //用户解锁
#define NET_DVR_GET_SECURITY_CFG         147        //获取安全认证配置
#define NET_DVR_SET_SECURITY_CFG         148        //设置安全认证配置
#define    NET_DVR_GET_LOCKED_INFO_LIST    149        //获取所有被锁定信息


/*********************************智能部分接口 begin***************************************/
//行为对应（NET_VCA_RULECFG）
#define NET_DVR_SET_RULECFG            152    //设置行为分析规则
#define NET_DVR_GET_RULECFG            153    //获取行为分析规则
//球机标定参数（NET_DVR_TRACK_CFG ）
#define NET_DVR_SET_TRACK_CFG       160//设置球机的配置参数 
#define NET_DVR_GET_TRACK_CFG       161//获取球机的配置参数

//智能分析仪取流配置结构
#define NET_DVR_SET_IVMS_STREAMCFG    162        //设置智能分析仪取流参数
#define NET_DVR_GET_IVMS_STREAMCFG    163        //获取智能分析仪取流参数
//智能控制参数结构
#define NET_DVR_SET_VCA_CTRLCFG        164     //设置智能控制参数
#define NET_DVR_GET_VCA_CTRLCFG        165     //获取智能控制参数
//屏蔽区域NET_VCA_MASK_REGION_LIST
#define NET_DVR_SET_VCA_MASK_REGION    166     //设置屏蔽区域参数
#define NET_DVR_GET_VCA_MASK_REGION    167     //获取屏蔽区域参数

//ATM进入区域 NET_VCA_ENTER_REGION
#define NET_DVR_SET_VCA_ENTER_REGION 168     //设置进入区域参数
#define NET_DVR_GET_VCA_ENTER_REGION 169     //获取进入区域参数

//标定线配置NET_VCA_LINE_SEGMENT_LIST
#define NET_DVR_SET_VCA_LINE_SEGMENT 170     //设置标定线
#define NET_DVR_GET_VCA_LINE_SEGMENT 171     //获取标定线

// ivms屏蔽区域NET_IVMS_MASK_REGION_LIST
#define NET_DVR_SET_IVMS_MASK_REGION 172     //设置IVMS屏蔽区域参数
#define NET_DVR_GET_IVMS_MASK_REGION 173     //获取IVMS屏蔽区域参数
// ivms进入检测区域NET_IVMS_ENTER_REGION
#define NET_DVR_SET_IVMS_ENTER_REGION 174     //设置IVMS进入区域参数
#define NET_DVR_GET_IVMS_ENTER_REGION 175     //获取IVMS进入区域参数

#define NET_DVR_SET_IVMS_BEHAVIORCFG  176    //设置智能分析仪行为规则参数
#define NET_DVR_GET_IVMS_BEHAVIORCFG  177    //获取智能分析仪行为规则参数

// IVMS 回放检索
#define NET_DVR_IVMS_SET_SEARCHCFG        178    //设置IVMS回放检索参数
#define NET_DVR_IVMS_GET_SEARCHCFG        179    //获取IVMS回放检索参数

#define NET_DVR_SET_POSITION_TRACK      180     // 设置场景跟踪配置信息
#define NET_DVR_GET_POSITION_TRACK      181     // 获取场景跟踪配置信息

#define NET_DVR_SET_CALIBRATION         182    // 设置标定信息
#define NET_DVR_GET_CALIBRATION         183    // 获取标定信息

#define NET_DVR_SET_PDC_RULECFG         184    // 设置人流量统计规则
#define NET_DVR_GET_PDC_RULECFG         185    // 获取人流量统计规则

#define NET_DVR_SET_PU_STREAMCFG        186     // 设置前段取流设备信息
#define NET_DVR_GET_PU_STREAMCFG        187     // 获取前段取流设备信息

#define NET_VCA_SET_IVMS_BEHAVIOR_CFG        192  // 设置IVMS行为规则配置 不带时间段
#define NET_VCA_GET_IVMS_BEHAVIOR_CFG        193  // 获取IVMS行为规则配置 不带时间段

#define NET_VCA_SET_SIZE_FILTER         194     // 设置全局尺寸过滤器
#define NET_VCA_GET_SIZE_FILTER         195     // 获取全局尺寸过滤器

#define NET_DVR_SET_TRACK_PARAMCFG      196     // 设置球机本地菜单规则
#define NET_DVR_GET_TRACK_PARAMCFG      197     // 获取球机本地菜单规则

#define NET_DVR_SET_DOME_MOVEMENT_PARAM 198     // 设置球机机芯参数
#define NET_DVR_GET_DOME_MOVEMENT_PARAM 199     // 获取球机机芯参数

#define NET_DVR_GET_PICCFG_EX        200        //获取图象参数(SDK_V14扩展命令)
#define NET_DVR_SET_PICCFG_EX        201        //设置图象参数(SDK_V14扩展命令)
#define NET_DVR_GET_USERCFG_EX         202        //获取用户参数(SDK_V15扩展命令)
#define NET_DVR_SET_USERCFG_EX        203        //设置用户参数(SDK_V15扩展命令)
#define NET_DVR_GET_COMPRESSCFG_EX    204        //获取压缩参数(SDK_V15扩展命令2006-05-15)
#define NET_DVR_SET_COMPRESSCFG_EX    205        //设置压缩参数(SDK_V15扩展命令2006-05-15)


#define NET_DVR_GET_NETAPPCFG        222        //获取网络应用参数 NTP/DDNS/EMAIL
#define NET_DVR_SET_NETAPPCFG        223        //设置网络应用参数 NTP/DDNS/EMAIL
#define NET_DVR_GET_NTPCFG            224        //获取网络应用参数 NTP
#define NET_DVR_SET_NTPCFG            225        //设置网络应用参数 NTP
#define NET_DVR_GET_DDNSCFG            226        //获取网络应用参数 DDNS
#define NET_DVR_SET_DDNSCFG            227        //设置网络应用参数 DDNS
//对应NET_DVR_EMAILPARA
#define NET_DVR_GET_EMAILCFG        228        //获取网络应用参数 EMAIL
#define NET_DVR_SET_EMAILCFG        229        //设置网络应用参数 EMAIL

#define NET_DVR_GET_NFSCFG            230        /* NFS disk config */
#define NET_DVR_SET_NFSCFG            231        /* NFS disk config */

/*注：该命令为定制，只支持8条OSD的类型，不会兼容V30设备版本之前的
NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（不建议使用）*/
#define NET_DVR_GET_SHOWSTRING_EX    238        //获取叠加字符参数扩展(支持8条字符)
#define NET_DVR_SET_SHOWSTRING_EX    239        //设置叠加字符参数扩展(支持8条字符)
#define NET_DVR_GET_NETCFG_OTHER    244        //获取网络参数
#define NET_DVR_SET_NETCFG_OTHER    245        //设置网络参数

//对应NET_DVR_EMAILCFG结构
#define NET_DVR_GET_EMAILPARACFG    250        //Get EMAIL parameters
#define NET_DVR_SET_EMAILPARACFG    251        //Setup EMAIL parameters


#define NET_DVR_GET_DDNSCFG_EX        274    //获取扩展DDNS参数
#define NET_DVR_SET_DDNSCFG_EX        275    //设置扩展DDNS参数

#define    NET_DVR_SET_PTZPOS            292        //云台设置PTZ位置
#define    NET_DVR_GET_PTZPOS            293        //云台获取PTZ位置
#define    NET_DVR_GET_PTZSCOPE        294        //云台获取PTZ范围

#define NET_DVR_GET_AP_INFO_LIST    305//获取无线网络资源参数
#define NET_DVR_SET_WIFI_CFG        306    //设置IP监控设备无线参数
#define NET_DVR_GET_WIFI_CFG        307    //获取IP监控设备无线参数
#define NET_DVR_SET_WIFI_WORKMODE    308    //设置IP监控设备网口工作模式参数
#define NET_DVR_GET_WIFI_WORKMODE    309    //获取IP监控设备网口工作模式参数
#define    NET_DVR_GET_WIFI_STATUS        310    //获取设备当前wifi连接状态
/*********************************智能交通事件begin***************************************/
#define NET_DVR_GET_REFERENCE_REGION            400      //获取参考区域
#define NET_DVR_SET_REFERENCE_REGION            401      //设置参考区域

#define NET_DVR_GET_TRAFFIC_MASK_REGION         402     //获取交通事件屏蔽区域
#define NET_DVR_SET_TRAFFIC_MASK_REGION         403     //设置交通事件屏蔽区域
#define NET_DVR_SET_AID_RULECFG                 404     //设置交通事件规则参数
#define NET_DVR_GET_AID_RULECFG                 405     //获取交通事件规则参数

#define NET_DVR_SET_TPS_RULECFG                 406     //设置交通统计规则参数
#define NET_DVR_GET_TPS_RULECFG                 407     //获取交通统计规则参数

#define NET_DVR_SET_LANECFG                        408        //设置车道规则
#define    NET_DVR_GET_LANECFG                        409        //获取车道规则
#define NET_DVR_GET_VCA_RULE_COLOR_CFG          410     //获取智能规则关联的颜色参数
#define NET_DVR_SET_VCA_RULE_COLOR_CFG          411     //设置智能规则关联的颜色参数
#define NET_DVR_GET_SWITCH_LAMP_CFG             412     //获取开关灯检测规则配置参数
#define NET_DVR_SET_SWITCH_LAMP_CFG             413     //设置开关灯检测规则配置参数 


/*********************************智能交通事件end***************************************/
#define NET_DVR_SET_FACEDETECT_RULECFG          420         // 设置人脸检测规则
#define NET_DVR_GET_FACEDETECT_RULECFG          421         // 获取人脸检测规则

#define NET_DVR_SET_VEHICLE_RECOG_TASK          422      //车辆二次识别任务提交
#define NET_DVR_GET_VEHICLE_RECOG_TASK          423      //车辆二次识别任务获取

#define NET_DVR_SET_TIMECORRECT                    432      //校时配置（只做校时操作，不记录校时配置）
#define    NET_DVR_GET_CONNECT_LIST                433         //获取连接设备列表信息

/***************************DS9000新增命令(_V30) begin *****************************/
//网络(NET_DVR_NETCFG_V30结构)
#define NET_DVR_GET_NETCFG_V30                    1000        //获取网络参数
#define NET_DVR_SET_NETCFG_V30                    1001        //设置网络参数

//图象(NET_DVR_PICCFG_V30结构)
#define NET_DVR_GET_PICCFG_V30                    1002        //获取图象参数
#define NET_DVR_SET_PICCFG_V30                    1003        //设置图象参数

//录像时间(NET_DVR_RECORD_V30结构)
#define NET_DVR_GET_RECORDCFG_V30                1004        //获取录像参数
#define NET_DVR_SET_RECORDCFG_V30                1005        //设置录像参数

//用户(NET_DVR_USER_V30结构)
#define NET_DVR_GET_USERCFG_V30                 1006        //获取用户参数
#define NET_DVR_SET_USERCFG_V30                    1007        //设置用户参数

//录像时间(NET_DVR_RECORD_V40结构)
#define NET_DVR_GET_RECORDCFG_V40                1008        //获取录像参数(扩展)
#define NET_DVR_SET_RECORDCFG_V40                1009        //设置录像参数(扩展)

//9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构)
#define     NET_DVR_GET_DDNSCFG_V30                1010        //获取DDNS(9000扩展)
#define     NET_DVR_SET_DDNSCFG_V30                1011        //设置DDNS(9000扩展)

//EMAIL功能(NET_DVR_EMAILCFG_V30结构)
#define NET_DVR_GET_EMAILCFG_V30                1012     //获取EMAIL参数 
#define NET_DVR_SET_EMAILCFG_V30                1013     //设置EMAIL参数 

#define NET_GET_CRUISEPOINT_V40                    1018     //获取巡航路径配置

//巡航参数 (NET_DVR_CRUISE_PARA结构)
#define     NET_DVR_GET_CRUISE                    1020        
#define     NET_DVR_SET_CRUISE                    1021        


//报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构)
#define     NET_DVR_GET_ALARMINCFG_V30            1024        
#define     NET_DVR_SET_ALARMINCFG_V30            1025

//报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构)
#define     NET_DVR_GET_ALARMOUTCFG_V30            1026        
#define     NET_DVR_SET_ALARMOUTCFG_V30            1027

//视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构)
#define     NET_DVR_GET_VIDEOOUTCFG_V30            1028        
#define     NET_DVR_SET_VIDEOOUTCFG_V30            1029


/*该命令支持8条OSD的类型（即设备版本为V30以上时），并会通过设备版本的匹配，
同时兼容之前的NET_DVR_GET_SHOWSTRING 、NET_DVR_SET_SHOWSTRING 命令。（建议使用）*/
//叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构)
#define     NET_DVR_GET_SHOWSTRING_V30            1030        
#define     NET_DVR_SET_SHOWSTRING_V30            1031

//异常结构参数 (NET_DVR_EXCEPTION_V30结构)
#define     NET_DVR_GET_EXCEPTIONCFG_V30        1034        
#define     NET_DVR_SET_EXCEPTIONCFG_V30        1035

//串口232结构参数 (NET_DVR_RS232CFG_V30结构)
#define     NET_DVR_GET_RS232CFG_V30            1036        
#define     NET_DVR_SET_RS232CFG_V30            1037

//网络硬盘接入结构参数 (NET_DVR_NET_DISKCFG结构)
#define        NET_DVR_GET_NET_DISKCFG                1038        //网络硬盘接入获取
#define        NET_DVR_SET_NET_DISKCFG                1039        //网络硬盘接入设置
//压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构)
#define     NET_DVR_GET_COMPRESSCFG_V30            1040        
#define     NET_DVR_SET_COMPRESSCFG_V30            1041        

//获取485解码器参数 (NET_DVR_DECODERCFG_V30结构)
#define     NET_DVR_GET_DECODERCFG_V30            1042        //获取解码器参数
#define     NET_DVR_SET_DECODERCFG_V30            1043        //设置解码器参数

//获取预览参数 (NET_DVR_PREVIEWCFG_V30结构)
#define     NET_DVR_GET_PREVIEWCFG_V30            1044        //获取预览参数
#define     NET_DVR_SET_PREVIEWCFG_V30            1045        //设置预览参数

//辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构)
#define     NET_DVR_GET_PREVIEWCFG_AUX_V30        1046        //获取辅助预览参数
#define     NET_DVR_SET_PREVIEWCFG_AUX_V30        1047        //设置辅助预览参数

//IP接入配置参数 （NET_DVR_IPPARACFG结构）
#define     NET_DVR_GET_IPPARACFG               1048        //获取IP接入配置信息 
#define     NET_DVR_SET_IPPARACFG               1049        //设置IP接入配置信息

//IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构）
#define     NET_DVR_GET_IPALARMINCFG            1050        //获取IP报警输入接入配置信息 
#define     NET_DVR_SET_IPALARMINCFG            1051        //设置IP报警输入接入配置信息

//IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构）
#define     NET_DVR_GET_IPALARMOUTCFG           1052        //获取IP报警输出接入配置信息 
#define     NET_DVR_SET_IPALARMOUTCFG           1053        //设置IP报警输出接入配置信息

//硬盘管理的参数获取 (NET_DVR_HDCFG结构)
#define     NET_DVR_GET_HDCFG                    1054        //获取硬盘管理配置参数
#define     NET_DVR_SET_HDCFG                    1055        //设置硬盘管理配置参数
//盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构)
#define     NET_DVR_GET_HDGROUP_CFG                1056        //获取盘组管理配置参数
#define     NET_DVR_SET_HDGROUP_CFG                1057        //设置盘组管理配置参数

//设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构)
#define     NET_DVR_GET_COMPRESSCFG_AUD         1058        //获取设备语音对讲编码参数
#define     NET_DVR_SET_COMPRESSCFG_AUD         1059        //设置设备语音对讲编码参数

//IP接入配置参数 （NET_DVR_IPPARACFG_V31结构）
#define     NET_DVR_GET_IPPARACFG_V31           1060        //获取IP接入配置信息 
#define     NET_DVR_SET_IPPARACFG_V31           1061        //设置IP接入配置信息

// 通道资源配置 (NET_DVR_IPPARACFG_V40结构)
#define NET_DVR_GET_IPPARACFG_V40               1062        // 获取IP接入配置
#define NET_DVR_SET_IPPARACFG_V40               1063        // 设置IP接入配置

#define NET_DVR_GET_CCDPARAMCFG                 1067       //IPC获取CCD参数配置
#define NET_DVR_SET_CCDPARAMCFG                 1068       //IPC设置CCD参数配置

#define NET_DVR_GET_IOINCFG                        1070    //获取抓拍机IO输入参数
#define NET_DVR_SET_IOINCFG                        1071     //设置抓拍机IO输入参数

#define NET_DVR_GET_IOOUTCFG                    1072    //获取抓拍机IO输出参数
#define NET_DVR_SET_IOOUTCFG                    1073     //设置抓拍机IO输出参数

#define NET_DVR_GET_FLASHCFG                    1074    //获取IO闪光灯输出参数
#define NET_DVR_SET_FLASHCFG                    1075     //设置IO闪光灯输出参数

#define NET_DVR_GET_LIGHTSNAPCFG                1076    //获取抓拍机红绿灯参数
#define NET_DVR_SET_LIGHTSNAPCFG                1077     //设置抓拍机红绿灯参数

#define NET_DVR_GET_MEASURESPEEDCFG                1078    //获取抓拍机测速参数
#define NET_DVR_SET_MEASURESPEEDCFG                1079     //设置抓拍机测速参数

#define NET_DVR_GET_IMAGEOVERLAYCFG                1080//获取抓拍机图像叠加信息参数
#define NET_DVR_SET_IMAGEOVERLAYCFG                1081//设置抓拍机图像叠加信息参数

#define NET_DVR_GET_SNAPCFG                        1082//获取单IO触发抓拍功能配置
#define NET_DVR_SET_SNAPCFG                        1083//设置单IO触发抓拍功能配置

#define NET_DVR_GET_VTPPARAM                    1084//获取虚拟线圈参数
#define NET_DVR_SET_VTPPARAM                    1085//设置虚拟线圈参数

#define NET_DVR_GET_SNAPENABLECFG                1086//获取抓拍机使能参数
#define NET_DVR_SET_SNAPENABLECFG                1087//设置抓拍机使能参数

#define NET_DVR_GET_POSTEPOLICECFG              1088//获取卡口电警参数
#define NET_DVR_SET_POSTEPOLICECFG              1089//设置卡口电警参数

#define NET_DVR_GET_JPEGCFG_V30                    1090//获取抓图的JPEG参数(基线)
#define NET_DVR_SET_JPEGCFG_V30                    1091//设置抓图的JPEG参数(基线)

#define NET_DVR_GET_SPRCFG                        1092//获取车牌识别参数
#define NET_DVR_SET_SPRCFG                        1093//设置车牌识别参数
#define NET_DVR_GET_PLCCFG                      1094//获取车牌亮度补偿参数
#define NET_DVR_SET_PLCCFG                      1095//设置车牌亮度补偿参数

#define NET_DVR_GET_DEVICESTATECFG              1096//获取设备当前状态参数
#define NET_DVR_SET_CALIBRATE_TIME              1097//设置扩展时间校时
#define NET_DVR_GET_CALIBRATE_TIME              1098//获取扩展时间校时

#define NET_DVR_GET_DEVICECFG_V40                1100//获取扩展设备参数 
#define NET_DVR_SET_DEVICECFG_V40                1101//设置扩展设备参数

#define NET_DVR_GET_ZEROCHANCFG                   1102    //获取零通道压缩参数 
#define NET_DVR_SET_ZEROCHANCFG                  1103    //设置零通道压缩参数

#define NET_DVR_GET_ZERO_PREVIEWCFG_V30         1104    // 获取零通道预览参数配置
#define NET_DVR_SET_ZERO_PREVIEWCFG_V30         1105    // 设置零通道预览参数配置

#define NET_DVR_SET_ZERO_ZOOM                    1106     //设置零通道的缩放配置 
#define NET_DVR_GET_ZERO_ZOOM                    1107     //获取零通道的缩放配置

#define    NET_DVR_NATASSOCIATECFG_GET                1110    //获取NAT功能相关信息
#define    NET_DVR_NATASSOCIATECFG_SET                1111     //设置NAT功能相关信息

#define NET_DVR_GET_SNMPCFG                       1112    //获取SNMP参数 
#define NET_DVR_SET_SNMPCFG                      1113    //设置SNMP参数

#define NET_DVR_GET_SNMPCFG_V30                   1114        //获取SNMPv30参数 
#define NET_DVR_SET_SNMPCFG_V30                  1115        //设置SNMPv30参数

#define    NET_DVR_VIDEOPLATFORMALARMCFG_GET        1130  //获取视频综合平台报警配置
#define    NET_DVR_VIDEOPLATFORMALARMCFG_SET        1131  //设置视频综合平台报警配置

#define NET_DVR_GET_RAID_ADAPTER_INFO           1134    // 获取适配器信息
#define NET_DVR_SET_RAID_ADAPTER_INFO           1135    // 设置适配器信息   

#define    NET_DVR_MATRIX_BIGSCREENCFG_GET            1140//获取大屏拼接参数
#define    NET_DVR_MATRIX_BIGSCREENCFG_SET            1141//设置大屏拼接参数

#define NET_DVR_GET_MB_PLATFORMPARA                1145 //获取平台登录参数
#define NET_DVR_SET_MB_PLATFORMPARA                1146 //设置平台登录参数
#define NET_DVR_GET_MB_DEVSTATUS                1147 //获取移动设备状态

#define  NET_DVR_GET_DECODER_JOINT_CHAN            1151//获取解码关联通道
#define  NET_DVR_SET_DECODER_JOINT_CHAN            1152//设置解码关联通道

//多网卡配置
#define NET_DVR_GET_NETCFG_MULTI                1161        //获取多网卡配置
#define NET_DVR_SET_NETCFG_MULTI                1162        //设置多网卡配置

#define NET_DVR_GET_CMSPARA                        1170//获取平台参数
#define NET_DVR_SET_CMSPARA                        1171//设置平台参数
#define NET_DVR_GET_DIALSTATUS                    1172//获取拨号状态参数
#define NET_DVR_GET_SMSRELATIVEPARA                1173//获取短信相关参数
#define NET_DVR_SET_SMSRELATIVEPARA                1174//设置短信相关参数
#define NET_DVR_GET_PINSTATUS                    1175//获取Pin状态
#define NET_DVR_SET_PINCMD                        1176//设置PIN命令
#define NET_DVR_SET_SENSOR_CFG                    1180//设置模拟量参数
#define NET_DVR_GET_SENSOR_CFG                    1181//获取模拟量参数
#define NET_DVR_SET_ALARMIN_PARAM                1182//设置报警输入参数
#define NET_DVR_GET_ALARMIN_PARAM                1183//获取报警输入参数
#define NET_DVR_SET_ALARMOUT_PARAM                1184//设置报警输出参数
#define NET_DVR_GET_ALARMOUT_PARAM                1185//获取报警输出参数
#define NET_DVR_SET_SIREN_PARAM                    1186//设置警号参数
#define NET_DVR_GET_SIREN_PARAM                    1187//获取警号参数
#define NET_DVR_SET_ALARM_RS485CFG                1188//设置报警主机485参数
#define NET_DVR_GET_ALARM_RS485CFG                1189//获取报警主机485参数
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS        1190//获取报警主机主要状态
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS        1191//获取报警主机其他状态
#define NET_DVR_SET_ALARMHOST_ENABLECFG            1192//获取报警主机使能状态
#define NET_DVR_GET_ALARMHOST_ENABLECFG            1193//设置报警主机使能状态
#define NET_DVR_SET_ALARM_CAMCFG                1194//设置视频综合平台报警触发CAM操作配置
#define NET_DVR_GET_ALARM_CAMCFG                1195//设置视频综合平台报警触发CAM操作配置
#define NET_DVR_GET_GATEWAY_CFG                 1196//获取门禁参数配置
#define NET_DVR_SET_GATEWAY_CFG                 1197//设置门禁参数配置

#define NET_DVR_GET_ALARMDIALMODECFG            1198//获取报警主机拨号参数
#define NET_DVR_SET_ALARMDIALMODECFG            1199//设置报警主机拨号参数
#define    NET_DVR_SET_WINCFG                        1202//窗口参数设置
#define NET_DVR_GET_ALARMHOSTDIALSETUPMODE        1204//获取报警主机拨号启用方式
#define NET_DVR_SET_ALARMHOSTDIALSETUPMODE        1205//设置报警主机拨号启用方式

//视频报警主机海外版命令(视频报警主机 V1.3)
#define NET_DVR_SET_SUBSYSTEM_ALARM                1210    //设置子系统布/撤防
#define NET_DVR_GET_SUBSYSTEM_ALARM                1211    //获取子系统布/撤防
#define NET_DVR_GET_WHITELIST_ALARM                1215    //获取白名单参数
#define NET_DVR_SET_WHITELIST_ALARM                1216    //设置白名单参数
#define    NET_DVR_GET_ALARMHOST_MODULE_LIST        1222    //获取所有模块
#define NET_DVR_SET_PRIOR_ALARM                    1223    //设置子系统布/撤防
#define NET_DVR_GET_PRIOR_ALARM                    1224    //获取子系统布/撤防    
#define NET_DVR_SET_TAMPER_ALARMIN_PARAM        1225    // 设置防区防拆参数
#define NET_DVR_GET_TAMPER_ALARMIN_PARAM        1226    // 获取防区防拆参数

#define NET_DVR_GET_HOLIDAY_PARAM_CFG           1240// 获取节假日参数
#define NET_DVR_SET_HOLIDAY_PARAM_CFG           1241// 设置节假日参数

#define NET_DVR_GET_MOTION_HOLIDAY_HANDLE       1242// 获取移动侦测假日报警处理方式
#define NET_DVR_SET_MOTION_HOLIDAY_HANDLE       1243// 获取移动侦测假日报警处理方式

#define NET_DVR_GET_VILOST_HOLIDAY_HANDLE       1244// 获取视频信号丢失假日报警处理方式
#define NET_DVR_SET_VILOST_HOLIDAY_HANDLE       1245// 获取视频信号丢失假日报警处理方式

#define NET_DVR_GET_HIDE_HOLIDAY_HANDLE         1246// 获取遮盖假日报警处理方式
#define NET_DVR_SET_HIDE_HOLIDAY_HANDLE         1247// 设置遮盖假日报警处理方式

#define NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE      1248// 获取报警输入假日报警处理方式
#define NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE      1249// 设置报警输入假日报警处理方式
#define NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE     1250// 获取报警输出假日报警处理方式
#define NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE     1251// 设置报警输出假日报警处理方式
#define NET_DVR_GET_HOLIDAY_RECORD              1252// 获取假日录像参数
#define NET_DVR_SET_HOLIDAY_RECORD              1253// 设置假日录像参数
#define NET_DVR_GET_NETWORK_BONDING             1254// 获取BONDING网络参数
#define NET_DVR_SET_NETWORK_BONDING             1255// 设置BONDING网络参数
#define NET_DVR_GET_LINK_STATUS                 1256// 获取通道IP工作状态
#define NET_DVR_GET_DISK_QUOTA_CFG              1278// 获取磁盘配额信息
#define NET_DVR_SET_DISK_QUOTA_CFG              1279// 设置磁盘配额信息
#define NET_DVR_GET_JPEG_CAPTURE_CFG            1280// 获取DVR抓图配置
#define NET_DVR_SET_JPEG_CAPTURE_CFG            1281// 设置DVR抓图配置
#define NET_DVR_GET_SCHED_CAPTURECFG            1282// 获取抓图计划
#define NET_DVR_SET_SCHED_CAPTURECFG            1283// 设置抓图计划
#define NET_DVR_GET_VGA_PREVIEWCFG              1284// 获取VGA预览配置
#define NET_DVR_SET_VGA_PREVIEWCFG              1285// 设置VGA预览配置 
#define NET_DVR_GET_VIDEO_INPUT_EFFECT          1286// 获取通道视频输入图像参数
#define NET_DVR_SET_VIDEO_INPUT_EFFECT          1287// 设置通道视频输入图像参数

#define NET_DVR_GET_STORAGE_SERVER_SWITCH        1290//获取存储服务器开关状态
#define NET_DVR_SET_STORAGE_SERVER_SWITCH        1291//设置存储服务器开关状态


#define NET_DVR_GET_OPTICAL_CHANNEL                1300//获取光端子系统通道关联信息
#define NET_DVR_SET_OPTICAL_CHANNEL                1301//设置光端子系统通道关联信息
#define NET_DVR_GET_FIBER_CASCADE                1302//获取光纤级联模式
#define NET_DVR_SET_FIBER_CASCADE                1303//设置光纤级联模式
#define NET_DVR_GET_SPARTAN_STATUS                1304//获取畅显状态
#define NET_DVR_SET_SPARTAN_STATUS                1305//设置畅显状态
#define NET_DVR_GET_ETHERNET_CHANNEL            1306//获取端口聚合参数
#define NET_DVR_SET_ETHERMET_CHANNEL            1307//设置端口聚合参数
#define NET_DVR_OPTICAL_REBOOT                    1320//光端机重启
#define NET_DVR_SET_AUDIOCHAN_CFG                1321//设置音频切换参数
#define NET_DVR_GET_AUDIOCHAN_CFG                1322//获取音频切换参数
//SDI矩阵1.0
#define NET_DVR_SET_MATRIX_BASE_CFG             1332 //设置矩阵基本参数
#define NET_DVR_GET_MATRIX_BASE_CFG             1333 //获取矩阵基本参数
#define NET_DVR_SWITCH_MATRIX_IO                1334 //矩阵输入输出切换 
#define NET_DVR_GET_MATRIX_IO_RELATION          1335 //获取矩阵输入输入关联关系

#define    NET_DVR_V6PSUBSYSTEMARAM_GET            1501//获取V6子系统配置
#define    NET_DVR_V6PSUBSYSTEMARAM_SET            1502//设置V6子系统配置
#define    NET_DVR_GET_ALLWINCFG                    1503 //窗口参数获取

#define    NET_DVR_BIGSCREENASSOCIATECFG_GET        1511 //获取大屏关联配置
#define    NET_DVR_BIGSCREENASSOCIATECFG_SET        1512 //设置大屏关联配置

//1200起
#define    NET_DVR_GETSCREENINFO                    1601 //获取大屏信息配置
#define    NET_DVR_SETSCREENINFO                    1602 //设置大屏信息配置
#define    NET_DVR_GET_SCREEN_WINCFG                1603//单个窗口参数获取
#define    NET_DVR_LAYOUTLIST_GET                     1605//获取布局列表
#define    NET_DVR_SET_LAYOUTCFG                    1606 //布局设置
#define    NET_DVR_LAYOUTCTRL                        1607//布局控制，1-open，2-close
#define    NET_DVR_INPUTLIST_GET                    1608 //获取输入信号源列表
#define    NET_DVR_SET_INPUTSTREAMCFG                1609 //输入信号源设置 
#define    NET_DVR_OUTPUT_SET                        1610 //输出参数设置
#define    NET_DVR_OUTPUT_GET                        1611 //输出参数获取
#define    NET_DVR_SET_OSDCFG                        1612 //OSD参数设置
#define    NET_DVR_GET_OSDCFG                        1613 //OSD参数获取
#define    NET_DVR_BIGSCREEN_GETSERIAL             1614//获取大屏串口信息
#define    NET_DVR_GET_PLANLIST                    1615//获取预案列表
#define    NET_DVR_SET_PLAN                        1616//设置预案
#define    NET_DVR_CTRL_PLAN                        1617//控制预案
#define    NET_DVR_GET_DEVICE_RUN_STATUS           1618//获取设备运行状态
#define NET_DVR_GET_EXTERNAL_MATRIX_CFG            1619//获取矩阵信息
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG            1620//设置矩阵信息
#define    NET_DVR_GET_OUTPUT_SCREEN_RELATION        1621//获取输出和屏幕的绑定关系
#define    NET_DVR_SET_OUTPUT_SCREEN_RELATION        1622//设置输出和屏幕的绑定关系
#define NET_DVR_GET_VCS_USER_CFG                1623//获取用户信息配置
#define    NET_DVR_SET_VCS_USER_CFG                1624//设置用户信息配置
#define    NET_DVR_CONTROL_SCREEN                    1625//屏幕控制

#define NET_DVR_GET_DEV_BASEINFO                1650//获取单个设备信息
#define NET_DVR_SET_DEV_BASEINFO                1651//设置单个设备信息
#define NET_DVR_GET_DEV_NETINFO                    1652//获取设备的网络信息
#define NET_DVR_SET_DEV_NETINFO                    1653//设置设备的网络信息
#define NET_DVR_GET_SIGNAL_SOURCE_INFO            1654//获取信号源信息
#define NET_DVR_SET_SIGNAL_SOURCE_INFO            1655//设置信号源信息
#define NET_DVR_ADJUST_PIC_V40                    1656//图像微调
#define NET_DVR_RESTORE_V40                        1657//恢复默认参数
#define    NET_DVR_SET_NET_SIGNAL                    1658//设置网络信号源
#define NET_DVR_REBOOT_V40                        1659//重启
#define NET_DVR_CONTROL_PICTURE_V41                1660//图片控制V41

#define NET_DVR_GET_AUTO_REBOOT_CFG             1710//获取自动重启参数
#define NET_DVR_SET_AUTO_REBOOT_CFG             1711//设置自动重启参数
#define NET_DVR_GET_TRUNK_USE_STATE             1713//获取指定干线使用状态
#define NET_DVR_SET_PTZ_CTRL_INFO                 1714//设置PTZ控制参数
#define NET_DVR_GET_PTZ_CTRL_INFO                 1715//获取PTZ控制参数
#define NET_DVR_GET_PTZ_STATUS                     1716//获取PTZ状态
#define    NET_DVR_GET_DISP_ROUTE_LIST                1717//获取显示路径列表

#define NET_DVR_GET_DEC_RESOURCE_LIST            1720//获取可用解码资源列表
#define NET_DVR_SET_DEC_RESOURCE_LIST            1721//预分配解码资源 
#define NET_DVR_GET_DEC_YUV                        1722//获取解码通道关联YUV输出参数
#define NET_DVR_SET_DEC_YUV                        1723//设置解码通道关联YUV输出参数
#define NET_DVR_GET_DEC_RESOUCE                    1724//向视频综合平台申请解码资源
#define NET_DVR_FREE_DEC_RESOURCE                1725//释放解码资源

#define NET_DVR_SET_VIDEOWALLDISPLAYMODE        1730//设置电视墙拼接模式
#define NET_DVR_GET_VIDEOWALLDISPLAYMODE        1731//获取电视墙拼接模式
#define NET_DVR_GET_VIDEOWALLDISPLAYNO          1732//获取设备显示输出号
#define    NET_DVR_SET_VIDEOWALLDISPLAYPOSITION    1733//设置显示输出位置参数
#define    NET_DVR_GET_VIDEOWALLDISPLAYPOSITION    1734//获取显示输出位置参数
#define NET_DVR_GET_VIDEOWALLWINDOWPOSITION     1735//获取电视墙窗口参数
#define NET_DVR_SET_VIDEOWALLWINDOWPOSITION     1736//设置电视墙窗口参数
#define    NET_DVR_VIDEOWALLWINDOW_CLOSEALL        1737//电视墙关闭所有窗口
#define    NET_DVR_SET_VIRTUALLED                    1738//虚拟LED设置
#define    NET_DVR_GET_VIRTUALLED                    1739//虚拟LED获取
#define NET_DVR_GET_IMAGE_CUT_MODE              1740//获取图像切割模式
#define NET_DVR_SET_IMAGE_CUT_MODE              1741//设置图像切割模式
#define NET_DVR_GET_USING_SERIALPORT            1742//获取当前使用串口
#define NET_DVR_SET_USING_SERIALPORT            1743//设置当前使用串口
#define NET_DVR_SCENE_CONTROL                   1744//场景控制
#define NET_DVR_GET_CURRENT_SCENE               1745//获取当前场景号
#define NET_DVR_GET_VW_SCENE_PARAM              1746//获取电视墙场景模式参数
#define NET_DVR_SET_VW_SCENE_PARAM              1747//设置电视墙场景模式参数
#define NET_DVR_DISPLAY_CHANNO_CONTROL          1748//电视墙显示编号控制
#define NET_DVR_GET_WIN_DEC_INFO                1749//获取窗口解码信息（批量）
#define NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION  1750  //解除电视墙输出接口绑定 
#define NET_DVR_SET_VW_AUDIO_CFG                1752    //设置音频切换参数
#define    NET_DVR_GET_VW_AUDIO_CFG                1753    //获取音频切换参数
#define NET_DVR_GET_GBT28181_DECCHANINFO_CFG    1754    //获取GBT28181协议接入设备的解码通道信息
#define NET_DVR_SET_GBT28181_DECCHANINFO_CFG    1755    //设置GBT28181协议接入设备的解码通道信息
#define    NET_DVR_SET_MAINBOARD_SERIAL            1756  //设置主控板串口参数
#define    NET_DVR_GET_MAINBOARD_SERIAL            1757  //获取主控板串口参数
#define NET_DVR_GET_SUBBOARD_INFO               1758  //获取子板信息
#define NET_DVR_GET_SUBBOARD_EXCEPTION          1759  //获取异常子板异常信息

#define NET_DVR_GET_CAMERACHAN_SERIALCFG    1760   //获取Camera通道绑定串口配置
#define NET_DVR_SET_CAMERACHAN_SERIALCFG    1761   //设置Camera通道绑定串口配置
#define NET_DVR_GET_MATRIX_STATUS            1762   //获取视频综合平台状态
#define    NET_SET_MULTIFUNCTION_SERIALCFG     1763  //设置多功能串口配置
#define    NET_GET_MULTIFUNCTION_SERIALCFG        1764  //获取多功能串口配置
#define NET_DVR_PTZ_3D_SPEED                1765  // 3维带速度的云台控制

#define  NET_DVR_GET_SIGNAL_JOINT            1766   //获取信号源绑定配置
#define  NET_DVR_SET_SIGNAL_JOINT            1767   //设置信号源绑定配置
#define  NET_DVR_SIGNAL_CUT                    1768   //信号源裁剪
#define  NET_DVR_DYNAMIC_DECODE_BATCH        1769     //批量动态解码
#define  NET_DVR_DECSWITCH_SET_BATCH        1770    //批量设置解码通道开关
#define  NET_DVR_DECSWITCH_GET_BATCH        1771    //批量获取解码通道开关
#define  NET_DVR_GET_ALL_SIGNAL_JOINT        1772   //获取所有信号源绑定配置
#define     NET_DVR_GET_PLAYING_PLAN            1773    //获取正在执行预案
#define  NET_DVR_WALL_RELATION_GET            1774   //获取设备墙与物理墙的关联
#define  NET_DVR_WALL_RELATION_SET            1775   //设置设备墙与物理墙的关联
#define     NET_DVR_SET_INPUTSTREAMCFG_V40        1776   //输入信号源设置
#define  NET_DVR_PTZCFG_INPUTSTREAM_GET        1777  //获取输入源反向云台控制配置
#define  NET_DVR_PTZCFG_INPUTSTREAM_SET        1778  //设置输入源反向云台控制配置
#define  NET_DVR_SIGNAL_CUTPARAM_GET        1779  //获取信号源裁剪参数

#define NET_DVR_GET_SUBSYSTEM_NETCFG            1780    //获取子系统网卡参数
#define NET_DVR_SET_SUBSYSTEM_NETCFG              1781    //设置子系统网卡参数
#define    NET_DVR_DEL_SIGNAL_JOINT                1782    //删除拼接信号源

#define NET_DVR_GET_PICTURE_INFO                1783     //获取图片信息
#define NET_DVR_SET_PICTURE_INFO                1784     //设置图片信息
#define NET_DVR_GET_VIDEO_INFO                    1785     //获取视频信息
#define NET_DVR_SET_VIDEO_INFO                    1786     //设置视频信息
#define NET_DVR_SET_PLAYLIST                    1787     //设置播放列表
#define NET_DVR_GET_PLAYLIST                    1788     //获取播放列表
#define NET_DVR_GET_ALL_PLAYLIST                1789     //获取所有播放列表
#define NET_DVR_PLAYITEM_CONTROL                1790     //播放项操作
#define NET_DVR_SET_PLAYPLAN_TEMPLATE            1791     //设置播放计划模板
#define NET_DVR_GET_PLAYPLAN_TEMPLATE            1792     //获取播放计划
#define NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE        1793     //获取所有播放计划
#define NET_DVR_SET_WINDOW_PLAYPLAN                1794     //设置窗口播放计划
#define NET_DVR_GET_WINDOW_PLAYPLAN                1795     //获取窗口播放计划
#define NET_DVR_TOPLAY_ITEM                        1796     //指定播放
#define NET_DVR_DEVICE_PLAY_CONTROL                1797     //设备播放控制
#define NET_DVR_GET_PLAY_INFO                    1798     //获取当前播放信息
#define NET_DVR_GET_ALL_PICTURE_INFO            1799     //获取图片信息
#define NET_DVR_GET_ALL_VIDEO_INFO                1800     //获取视频信息
#define NET_DVR_DELETE_VIDEO_FILE                1801     //删除视频


#define NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG        2001//报警主机获取子系统参数
#define NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG        2002//报警主机设置子系统参数
#define NET_DVR_GETEXTENDALARMININFO            2003//获取防区编号信息
#define NET_DVR_MODIFYALARMINNO                 2004//修改防区编号信息
#define NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG    2005//获取无线网络参数配置
#define    NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG    2006//设置无线网络参数配置
#define    NET_DVR_GET_ALARMHOST_NETCFG            2007//获取网络参数配置
#define    NET_DVR_SET_ALARMHOST_NETCFG            2008//设置网络参数配置
#define NET_DVR_GET_LED_SCREEN_CFG                2009// 获取LED屏幕参数
#define NET_DVR_SET_LED_SCREEN_CFG                2010// 设置LED屏幕参数
#define NET_DVR_GET_LED_CONTENT_CFG                2011// 获取LED屏显内容
#define    NET_DVR_SET_LED_CONTENT_CFG                2012// 设置LED屏显内容
#define NET_DVR_TURNON_LED                        2013// 打开LED屏
#define NET_DVR_TURNOFF_LED                        2014// 关闭LED屏
#define NET_DVR_GET_LED_TIMER_SWITCH            2015// 获取LED屏定时开关参数
#define NET_DVR_SET_LED_TIMER_SWITCH            2016// 设置LED屏定时开关参数
#define NET_DVR_SET_LED_BRIGHTNESS                2017// 手动设置LED屏亮度
#define NET_DVR_GET_LED_TIMER_BRIGHTNESS            2018//设置分时LED屏亮度
#define NET_DVR_SET_LED_TIMER_BRIGHTNESS            2019//获取分时LED屏亮度
#define NET_DVR_LED_CHECKTIME                        2020//LED校时
#define NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM    2021//获取音频跟随报警事件
#define NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM    2022//设置音频跟随报警事件
#define    NET_DVR_GET_LED_STATUS                        2023//获取LED屏状态
#define NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM         2027//关闭子系统故障提示音
#define NET_DVR_SET_SUBSYSTEM_BYPASS                2028//子系统旁路
#define NET_DVR_CANCEL_SUBSYSTEM_BYPASS                2029//子系统旁路恢复

#define NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX        2030//获取子系统扩展参数
#define    NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX        2031//设置子系统扩展参数
#define NET_DVR_GET_ALARMHOST_PRINTER_CFG            2032//获取打印机打印使能
#define    NET_DVR_SET_ALARMHOST_PRINTER_CFG            2033//设置打印机打印使能
#define    NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM 2034//获取指定子系统内的所有防区
#define    NET_DVR_GET_ALARMHOST_TRIGGER_LIST            2035//获取所有触发器
#define    NET_DVR_ARM_ALARMHOST_SUBSYSTEM                2036//按布防类型对子系统布防
#define    NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2037// 获取事件触发报警输出配置
#define NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2038// 设置事件触发报警输出配置
#define    NET_DVR_GET_ALARMHOST_FAULT_CFG                2039// 获取故障处理配置
#define NET_DVR_SET_ALARMHOST_FAULT_CFG                2040// 设置故障处理配置
#define NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE         2041//自动搜索
#define    NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE    2042//自动注册
#define NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM 2043//关闭全局故障提示音

#define NET_DVR_GET_SAFETYCABIN_WORK_MODE            2044 //获取防护舱工作模式参数
#define NET_DVR_SET_SAFETYCABIN_WORK_MODE            2045 //设置防护舱工作模式参数
#define NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG   2046 //获取防护舱人信号探测参数
#define NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG   2047 //设置防护舱人信号探测参数

#define  NET_DVR_GET_ALARMHOST_MODULE_CFG            2048//获取模块信息
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG            2049//设置模块信息(预留)

#define     NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE        2050//获取485外接设备状态
#define  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2051//设置外接设备报警限值
#define  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2052//获取外接设备报警限值
#define  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG                2053// 获取模拟量关联配置
#define  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG                2054// 设置模拟量关联配置
#define     NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG                2055// 设置报警主机485槽位参数
#define  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG                2056// 获取报警主机485槽位参数

#define NET_DVR_GET_ALL_VARIABLE_INFO      2057   // 获取所有变量元素信息
#define NET_DVR_GET_ALARM_POINT_CFG       2058   // 获取点号信息
#define NET_DVR_SET_ALARM_POINT_CFG       2059   // 设置点号信息
#define NET_DVR_GET_HISTORY_VALUE          2060   // 获取历史数据
#define NET_DVR_GET_ALARMHOST_ALARM_MODE  2061   // 获取数据上传方式
#define NET_DVR_SET_ALARMHOST_ALARM_MODE  2062   // 设置数据上传方式
#define NET_DVR_GET_ALARMHOST_SENSOR_VALUE 2063   // 获取模拟量实时数据

#define NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40    2064   // 获取数据上传方式
#define NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40    2065   // 设置数据上传方式
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG        2068   // 获取时控输出参数
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG     2069   // 设置时控输出参数
#define NET_DVR_GET_CMS_CFG                     2070
#define    NET_DVR_SET_CMS_CFG                        2071

#define NET_DVR_GET_PASSTHROUGH_CAP  2073  //获取设备透传能力集

#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40    2072   // 获取主要状态V40

/*************************************视频报警主机1.3 begin*************************************/
#define NET_DVR_GET_ALARM_CAPTRUE_CFG                 2074    //获取报警抓图参数配置
#define    NET_DVR_SET_ALARM_CAPTRUE_CFG                2075    //设置报警抓图参数配置
#define NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40        2078   // 获取单个时控输出参数V40
#define NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40        2079   // 设置单个时控输出参数V40
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40        2080   // 获取时控输出参数V40
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40     2081   // 设置时控输出参数V40
/*************************************视频报警主机1.3 end**************************************/


#define NET_DVR_GET_WEEK_PLAN_CFG               2100    //获取门状态周计划参数
#define NET_DVR_SET_WEEK_PLAN_CFG               2101    //设置门状态周计划参数
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN    2102    //获取门状态假日计划参数
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN    2103    //设置门状态假日计划参数
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP   2104    //获取门状态假日组参数
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP   2105    //设置门状态假日组参数
#define NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE   2106    //获取门状态计划模板参数
#define NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE   2107    //设置门状态计划模板参数
#define NET_DVR_GET_DOOR_CFG                    2108    //获取门参数
#define NET_DVR_SET_DOOR_CFG                    2109    //设置门参数
#define NET_DVR_GET_DOOR_STATUS_PLAN            2110    //获取门状态计划参数
#define NET_DVR_SET_DOOR_STATUS_PLAN            2111    //设置门状态计划参数
#define NET_DVR_GET_GROUP_CFG                   2112    //获取群组参数
#define NET_DVR_SET_GROUP_CFG                   2113    //设置群组参数
#define NET_DVR_GET_MULTI_CARD_CFG              2114    //获取多重卡参数
#define NET_DVR_SET_MULTI_CARD_CFG              2115    //设置多重卡参数
#define NET_DVR_GET_CARD_CFG                    2116    //获取卡参数
#define NET_DVR_SET_CARD_CFG                    2117    //设置卡参数
#define NET_DVR_CLEAR_ACS_PARAM                    2118    //清空门禁主机参数
#define NET_DVR_GET_SNEAK_CFG                    2119    //获取反潜回参数
#define NET_DVR_SET_SNEAK_CFG                   2120    //设置反潜回参数
#define NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG    2121    //获取多门互锁参数
#define NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG    2122    //设置多门互锁参数
#define NET_DVR_GET_ACS_WORK_STATUS                2123    //获取门禁主机工作状态
#define NET_DVR_GET_VERIFY_WEEK_PLAN            2124    //获取读卡器验证方式周计划参数
#define NET_DVR_SET_VERIFY_WEEK_PLAN            2125    //设置读卡器验证方式周计划参数
#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN        2126    //获取卡权限周计划参数
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN        2127    //设置卡权限周计划参数
#define NET_DVR_GET_VERIFY_HOLIDAY_PLAN         2128    //获取读卡器验证方式假日计划参数
#define NET_DVR_SET_VERIFY_HOLIDAY_PLAN         2129    //设置读卡器验证方式假日计划参数
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN     2130    //获取卡权限假日计划参数
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN     2131    //设置卡权限假日计划参数
#define NET_DVR_GET_VERIFY_HOLIDAY_GROUP        2132    //获取读卡器验证方式假日组参数
#define NET_DVR_SET_VERIFY_HOLIDAY_GROUP        2133    //设置读卡器验证方式假日组参数
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP    2134    //获取卡权限假日组参数
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP    2135    //设置卡权限假日组参数
#define NET_DVR_GET_VERIFY_PLAN_TEMPLATE        2136    //获取读卡器验证方式计划模板参数
#define NET_DVR_SET_VERIFY_PLAN_TEMPLATE        2137    //设置读卡器验证方式计划模板参数
#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE    2138    //获取卡权限计划模板参数
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE    2139    //设置卡权限计划模板参数
#define NET_DVR_GET_CARD_READER_CFG                2140    //获取读卡器参数
#define NET_DVR_SET_CARD_READER_CFG             2141    //设置读卡器参数
#define NET_DVR_GET_CARD_READER_PLAN            2142    //获取读卡器验证计划参数
#define NET_DVR_SET_CARD_READER_PLAN            2143    //设置读卡器验证计划参数
#define NET_DVR_GET_CASE_SENSOR_CFG                2144    //获取事件触发器参数
#define NET_DVR_SET_CASE_SENSOR_CFG             2145    //设置事件触发器参数
#define NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG  2146    //获取读卡器反潜回参数
#define NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG  2147    //设置读卡器反潜回参数
#define NET_DVR_GET_PHONE_DOOR_RIGHT_CFG        2148    //获取手机关联门权限参数
#define NET_DVR_SET_PHONE_DOOR_RIGHT_CFG        2149    //获取手机关联门权限参数
#define NET_DVR_GET_FINGERPRINT_CFG             2150    //获取指纹参数
#define NET_DVR_SET_FINGERPRINT_CFG             2151    //设置指纹参数
#define NET_DVR_DEL_FINGERPRINT_CFG             2152    //删除指纹参数
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG      2153    //获取事件卡号联动配置参数
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG      2154    //设置事件卡号联动配置参数
#define NET_DVR_GET_ANTI_SNEAK_HOST_CFG            2155    //获取主机组反潜回参数
#define NET_DVR_SET_ANTI_SNEAK_HOST_CFG         2156    //设置主机组反潜回参数
#define NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG  2157    //获取主机组读卡器反潜回参数
#define NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG  2158    //设置主机组读卡器反潜回参数
#define NET_DVR_GET_ACS_CFG                     2159    //获取门禁主机参数
#define NET_DVR_SET_ACS_CFG                     2160    //设置门禁主机参数
#define NET_DVR_GET_CARD_PASSWD_CFG                2161    //获取卡密码开门使能配置
#define NET_DVR_SET_CARD_PASSWD_CFG             2162    //设置卡密码开门使能配置
#define NET_DVR_GET_CARD_USERINFO_CFG           2163    //获取卡号关联用户信息参数
#define NET_DVR_SET_CARD_USERINFO_CFG           2164    //设置卡号关联用户信息参数

#define NET_DVR_GET_ACS_EXTERNAL_DEV_CFG        2165    //获取门禁主机串口外设参数
#define NET_DVR_SET_ACS_EXTERNAL_DEV_CFG        2166    //设置门禁主机串口外设参数
#define NET_DVR_GET_PERSONNEL_CHANNEL_CFG       2167    //获取人员通道参数
#define NET_DVR_SET_PERSONNEL_CHANNEL_CFG       2168    //设置人员通道参数
#define NET_DVR_SET_PLATFORM_VERIFY_CFG         2169    //下发平台认证结果
#define NET_DVR_GET_PERSON_STATISTICS_CFG        2170   //获取人数统计参数
#define NET_DVR_SET_PERSON_STATISTICS_CFG        2171   //设置人数统计参数
#define NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG        2172   //获取屏幕字符串显示参数
#define NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG        2173   //设置屏幕字符串显示参数
#define NET_DVR_GET_GATE_TIME_CFG               2174  //获取人员通道闸门时间参数
#define NET_DVR_SET_GATE_TIME_CFG               2175  //设置人员通道闸门时间参数



#define NET_DVR_GET_SAFETYCABIN_STATE            2197    //获取防护舱状态
#define NET_DVR_GET_RS485_CASCADE_CFG            2198   //获取Rs485级联设备配置
#define NET_DVR_SET_RS485_CASCADE_CFG            2199   //设置Rs485级联设备配置

/*************************************视频报警主机2.0 begin*************************************/
#define NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG        2200    //获取遥控器权限参数
#define NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG        2201    //设置遥控器权限参数
#define NET_DVR_GET_KEYBOARD_CFG                        2202    //获取键盘参数配置
#define NET_DVR_SET_KEYBOARD_CFG                        2203    //设置键盘参数配置
#define    NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO    2204    //无线业务查询
#define    NET_DVR_GET_ALL_REMOTECONTROLLER_LIST            2205    //获取所有遥控器
#define    NET_DVR_GET_PREVIEW_DELAY_CFG                    2206    //获取延迟预览参数配置
#define    NET_DVR_SET_PREVIEW_DELAY_CFG                    2207    //设置延迟预览参数配置
#define NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG            2208    //获取防区联动视频通道配置
#define NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG            2209    //设置防区联动视频通道配置
#define NET_DVR_GET_CENTER_SERVER_CFG                    2210    //获取报警中心服务器
#define NET_DVR_SET_CENTER_SERVER_CFG                    2211    //设置报警中心服务器
/*************************************视频报警主机2.0 end**************************************/

/********************************一键式紧急报警产品V1.0.0 begin********************************/
#define NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP            2212    //获取一键式紧急报警产品能力
#define NET_DVR_GET_CALL_WAITTING_CFG_CAP                2213    //获取呼叫等待参数配置能力
#define NET_DVR_GET_CALL_WAITTING_CFG                    2214    //获取呼叫等待参数配置
#define NET_DVR_SET_CALL_WAITTING_CFG                    2215    //设置呼叫等待参数配置
#define NET_DVR_GET_ALARM_LAMP_CFG_CAP                    2216    //获取警灯参数配置能力
#define NET_DVR_GET_ALARM_LAMP_CFG                        2217    //获取警灯参数配置
#define NET_DVR_SET_ALARM_LAMP_CFG                        2218    //设置警灯参数配置
#define NET_DVR_GET_VOICE_PROMPTION_CFG_CAP                2219    //获取语音提示配置能力
#define NET_DVR_GET_VOICE_PROMPTION_CFG                    2220    //获取语音提示配置
#define NET_DVR_SET_VOICE_PROMPTION_CFG                    2221    //设置语音提示配置
#define NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP        2222    //获取紧急报警处理能力
#define NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL            2223    //紧急报警处理控制
/********************************一键式紧急报警产品V1.0.0 end**********************************/

//网络报警主机 V2.2
#define NET_DVR_GET_ALARMHOST_NETCFG_V50                2224    //获取报警主机网络参数配置V50
#define NET_DVR_SET_ALARMHOST_NETCFG_V50                2225    //设置报警主机网络参数配置V50
#define    NET_DVR_REGISTER_ALARM_RS485                    2226    //RS485重新注册
/**********************************动环报警主机V3.0****************************************/
#define NET_DVR_GET_ALL_ALARM_RS485CFG            2705    // 获取485参数
#define NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG        2706        // 获取所有报警主机485槽位参数
#define NET_DVR_GET_DEVICE_SELF_CHECK_STATE        2707    //获取设备自检功能
#define NET_DVR_GET_ALL_ALARM_POINT_CFG            2708    // 获取所有点号参数
#define NET_DVR_GET_ALL_ALARM_SENSOR_CFG        2709    // 获取所有模拟量参数
#define NET_DVR_GET_ALL_ALARM_SENSOR_JOINT        2710    //获取所有模拟量联动参数
#define NET_DVR_GET_AIR_CONDITION_PARAM            2711    //获取空调参数
#define NET_DVR_GET_OUT_SCALE_CFG                2712        //获取主辅口输出配置
#define NET_DVR_SET_OUT_SCALE_CFG                2713        //设置主辅口输出配置
#define NET_DVR_GET_ALARM_CHAN_ABLITITY            2714        //获取报警相关通道参
/**********************************动环报警主机V3.0****************************************/

//动环报警主机D2000 V1.0
#define NET_DVR_GET_ALARMCENTER_NETCFG            2715        //获取报警中心网络参数配置
#define NET_DVR_SET_ALARMCENTER_NETCFG            2716        //获取报警中心网络参数配置


#define NET_ITC_GET_TRIGGERCFG                  3003  //获取触发参数
#define NET_ITC_SET_TRIGGERCFG                  3004  //设置触发参数
#define NET_ITC_GET_IOOUT_PARAM_CFG                3005  //获取IO输出参数（3.1含之后版本）
#define NET_ITC_SET_IOOUT_PARAM_CFG                3006  //设置IO输出参数（3.1含之后版本）

#define NET_DVR_GET_CAMERA_SETUPCFG                3007  //获取相机架设参数
#define NET_DVR_SET_CAMERA_SETUPCFG                3008  //设置相机架设参数

#define NET_ITC_GET_TRIGGER_DEFAULTCFG          3013  //获取触发模式推荐参数
#define NET_DVR_GET_STATUS_DETECTCFG            3015  //获取状态检测使能参数
#define NET_DVR_SET_STATUS_DETECTCFG            3016  //设置状态检测使能参数
#define NET_ITC_GET_VIDEO_TRIGGERCFG            3017  //获取视频电警触发参数
#define NET_ITC_SET_VIDEO_TRIGGERCFG            3018  //设置视频电警触发参数
#define NET_DVR_GET_TPS_ALARMCFG                3019  //获取交通统计报警参数
#define NET_DVR_SET_TPS_ALARMCFG                3020  //设置交通统计报警参数


#define NET_DVR_GET_REDAREACFG                  3100   //获取红绿灯区域参数
#define NET_DVR_SET_REDAREACFG                  3101   //设置红绿灯区域参数
#define    NET_DVR_GET_TEST_SPOT                    3102   //获取SPOT口测试总步数和当前第几步
#define    NET_DVR_SET_TEST_SPOT                    3103   //设置SPOT口测试总步数和当前第几步
#define NET_DVR_GET_CABINETCFG                    3104   //机柜参数配置获取
#define NET_DVR_SET_CABINETCFG                    3105   //机柜参数配置设置
#define NET_DVR_VEHICLE_CHECK_START                3106   //黑名单稽查数据回传
#define NET_DVR_SET_CAPTUREPIC_CFG                3107   //车载抓图配置设置命令
#define NET_DVR_GET_CAPTUREPIC_CFG                3108   //车载抓图配置获取命令
#define NET_DVR_SET_MOBILEPLATE_RECOG_CFG        3109   //车载车牌识别配置设置命令
#define NET_DVR_GET_MOBILEPLATE_RECOG_CFG        3110   //车载车牌识别配置获取命令
#define NET_DVR_SET_MOBILE_RADAR_CFG            3111   //车载雷达配置设置命令
#define NET_DVR_GET_MOBILE_RADAR_CFG            3112   //车载雷达配置获取命令
#define NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG    3113   //车载黑名单本地对比配置设置命令
#define NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG    3114   //车载黑名单本地对比配置获取命令

#define  NET_ITC_GET_ICRCFG                        3115   //获取ICR配置切换
#define  NET_ITC_SET_ICRCFG                        3116   //设置ICR配置切换
#define  NET_ITC_GET_RS485_ACCESSINFO            3117   //获取Rs485关联接入设备的信息 
#define  NET_ITC_SET_RS485_ACCESSINFO            3118   //设置Rs485关联接入设备的信息
#define  NET_ITC_GET_EXCEPTIONCFG                 3119   //获取异常参数
#define  NET_ITC_SET_EXCEPTIONCFG                3120   //设置异常参数
#define  NET_ITC_GET_FTPCFG                        3121   //获取ITC  FTP设置参数
#define  NET_ITC_SET_FTPCFG                        3122   //设置ITC FTP设置参数

#define  NET_DVR_VEHICLE_CONTROL_LIST_START     3123   //设置车辆黑白名单信息
#define  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST   3124   //获取所有车辆黑白名单信息
#define  NET_DVR_VEHICLE_DELINFO_CTRL           3125   //删除设备内黑名单数据库信息
#define  NET_DVR_GET_ENTRANCE_PARAMCFG            3126   //获取出入口控制参数
#define  NET_DVR_SET_ENTRANCE_PARAMCFG            3127   //设置出入口控制参数
#define  NET_DVR_BARRIERGATE_CTRL               3128   //远程控制道闸
#define  NET_DVR_GATELAMP_CTRL                  3129   //常亮灯功能
#define  NET_DVR_GET_CURTRIGGERMODE             3130   //获取设备当前触发模式
#define  NET_DVR_GET_GPSDATACFG                    3131   //获取GPS参数
#define  NET_DVR_SET_GPSDATACFG                    3132   //设置GPS参数
#define  NET_DVR_VEHICLELIST_CTRL_START            3133   //设置车辆黑白名单信息

#define  NET_DVR_GET_GUARDCFG                   3134   //获取车牌识别检测计划 
#define  NET_DVR_SET_GUARDCFG                   3135   //设置车牌识别检测计划
#define  NET_DVR_GET_SNAPINFO_CFG               3136   //获取抓拍图片参数 
#define  NET_DVR_SET_SNAPINFO_CFG               3137   //设置抓拍图片参数
#define  NET_DVR_GET_SNAPINFO_CFG_V40           3138   //获取抓拍图片参数扩展 
#define  NET_DVR_SET_SNAPINFO_CFG_V40           3139   //设置抓拍图片参数扩展
#define  NET_DVR_SET_CURTRIGGERMODE                3140   //设置设备当前触发模式(仅IPC/D支持)
#define     NET_DVR_GET_TRAFFIC_DATA                3141   //长连接获取交通数据
#define     NET_DVR_GET_TRAFFIC_FLOW                3142   //长连接获取交通流量
#define  NET_DVR_PARKING_VEHICLE_SEND           3143   //停车车辆信息下发
#define  NET_DVR_PARKING_CARD_SEND              3144   //停车卡下发
#define     NET_DVR_PARKING_CARD_CTRL                3145   //停车场停车卡控制接口

#define    NET_DVR_GET_ALARMCTRL_CAPABILITIES        3146   //获取报警控制能力
#define    NET_DVR_SET_ALARMCTRL_CFG                3147   //设置报警控制
#define    NET_DVR_GET_ALARMCTRL_CFG                3148   //获取报警控制

#define NET_DVR_GET_AUDIO_INPUT                 3201   //获取音频输入参数
#define NET_DVR_SET_AUDIO_INPUT                 3202  //设置音频输入参数
#define NET_DVR_GET_CAMERA_DEHAZE_CFG           3203   //获取透雾参数配置
#define NET_DVR_SET_CAMERA_DEHAZE_CFG           3204  //设置透雾参数配置
#define NET_DVR_REMOTECONTROL_ALARM             3205  //远程控制遥控器布防
#define NET_DVR_REMOTECONTROL_DISALARM          3206  //远程控制遥控器撤防
#define NET_DVR_REMOTECONTROL_STUDY             3207  //远程控制遥控器学习
#define NET_DVR_WIRELESS_ALARM_STUDY            3208  //远程控制无线报警学习
#define NET_IPC_GET_AUX_ALARMCFG                3209   //获取辅助报警参数配置
#define NET_IPC_SET_AUX_ALARMCFG                3210  //设置辅助报警参数配置
#define NET_DVR_GET_PREVIEW_DISPLAYCFG            3211  //获取预览显示参数
#define NET_DVR_SET_PREVIEW_DISPLAYCFG             3212  //设置预览显示参数
#define NET_DVR_REMOTECONTROL_PTZ                3213  //远程控制PTZ
#define NET_DVR_REMOTECONTROL_PRESETPOINT       3214   //远程控制预置点
#define NET_DVR_REMOTECONTROL_CRUISE             3215   //远程控制巡航

#define NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG  3216 //远程获取多码流压缩参数
#define NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG  3217 //远程设置多码流压缩参数 

#define NET_DVR_GET_WPSCFG                        3218  //获取WPS参数
#define NET_DVR_SET_WPSCFG                        3219  //设置WPS参数
#define NET_DVR_WPS_CONNECT                     3220  //远程启用WPS连接
#define NET_DVR_GET_DEVICE_PIN                  3221  //获取设备PIN码
#define NET_DVR_UPDATE_PIN                      3223  //更新设备PIN码
#define NET_DVR_GET_PRESETCFG                   3224  //获取预置点参数
#define NET_DVR_GET_PTZCRUISECFG                3225  //获取巡航路径参数
#define NET_DVR_GET_PRESET_NUM                    3226  //获取预置点个数
#define NET_DVR_GET_PTZCRUISE_NUM                3227  //获取巡航路径个数

#define NET_DVR_GET_MOTION_TRACK_CFG            3228  //获取跟踪参数
#define NET_DVR_SET_MOTION_TRACK_CFG            3229  //设置跟踪参数
#define NET_DVR_CLEAR_IPC_PARAM                    3230  //清空前端参数
#define NET_DVR_GET_IPADDR_FILTERCFG            3232  //获取IP地址过滤参数
#define NET_DVR_SET_IPADDR_FILTERCFG            3233  //设置IP地址过滤参数

#define NET_DVR_GET_LOGO_OVERLAYCFG                3234  //获取LOGO图片叠加参数 
#define NET_DVR_SET_LOGO_OVERLAYCFG                3235  //设置LOGO图片叠加参数

#define NET_DVR_GET_IPV6_LIST                   3236  //获取网卡的全部IPV6地址信息
#define NET_DVR_GET_AUDIOOUT_VOLUME             3237  //获取输出音频大小
#define NET_DVR_SET_AUDIOOUT_VOLUME             3238  //设置输出音频大小
#define NET_DVR_GET_FUZZY_UPGRADE               3239  //获取模糊升级匹配信息

#define NET_DVR_GET_BV_CORRECT_PARAM            3240  //获取相机校正参数
#define NET_DVR_SET_BV_CORRECT_PARAM            3241  //设置相机校正参数
#define NET_DVR_GET_OUTPUT_VIDEO_TYPE           3242  //获取输出视频类型
#define NET_DVR_SET_OUTPUT_VIDEO_TYPE           3243  //设置输出视频类型

#define NET_DVR_FISHEYE_CFG                     3244  //鱼眼长连接配置
#define NET_DVR_GET_PTZ_POINT                   3245  //获取PTZ点坐标
#define NET_DVR_SET_PTZ_POINT                   3246  //设置PTZ点坐标
#define NET_DVR_REMOTECONTROL_DEV_PARAM         3247  //设置设备登录客户端参数
#define NET_DVR_GET_FISHEYE_STREAM_STATUS       3248  //获取鱼眼码流状态

#define NET_DVR_GET_GBT28181_ACCESS_CFG            3249  //获取GBT28181协议接入配置        
#define NET_DVR_SET_GBT28181_ACCESS_CFG            3250  //设置GBT28181协议接入配置
#define NET_DVR_GET_GBT28181_CHANINFO_CFG        3251  //获取GBT28181协议接入设备的通道信息
#define NET_DVR_SET_GBT28181_CHANINFO_CFG        3252  //设置GBT28181协议接入设备的通道信息
#define NET_DVR_GET_GBT28181_ALARMINCFG            3253  //获取GBT28181协议接入设备的报警信息
#define NET_DVR_SET_GBT28181_ALARMINCFG            3254  //设置GBT28181协议接入设备的报警信息
#define NET_DVR_GET_ISP_CAMERAPARAMCFG            3255  //获取ISP前端参数配置
#define NET_DVR_SET_ISP_CAMERAPARAMCFG            3256  //设置ISP前端参数配置
#define NET_DVR_GET_DEVSERVER_CFG                3257  //获取模块服务配置
#define NET_DVR_SET_DEVSERVER_CFG                3258  //设置模块服务配置

//2013-11-25
#define    NET_DVR_GET_WIPERINFO_CFG                3259     //雨刷配置获取
#define    NET_DVR_SET_WIPERINFO_CFG                3260     //雨刷配置设置
#define NET_DVR_GET_TRACK_DEV_PARAM             3261   //获取跟踪设备参数
#define NET_DVR_SET_TRACK_DEV_PARAM             3262   //设置跟踪设备参数
#define NET_DVR_GET_PTZ_TRACK_PARAM             3263   //获取PTZ跟踪参数
#define NET_DVR_SET_PTZ_TRACK_PARAM             3264   //设置PTZ跟踪参数
#define NET_DVR_GET_CENTER_POINT_CFG            3265   //获取中心点参数
#define NET_DVR_SET_CENTER_POINT_CFG            3266   //设置中心点参数
#define NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES        3267    //获取中心点参数能力
#define NET_DVR_GET_FISHEYE_CAPABILITIES        3268        //获取鱼眼能力

#define NET_DVR_GET_BASICPARAMCFG                3270 //获取PTZ配置基本参数信息        
#define NET_DVR_SET_BASICPARAMCFG                3271 //设置PTZ配置基本参数信息
#define NET_DVR_GET_PTZOSDCFG                    3272 //获取PTZ OSD配置参数信息        
#define NET_DVR_SET_PTZOSDCFG                    3273 //设置PTZ OSD配置参数信息
#define NET_DVR_GET_POWEROFFMEMCFG                3274 //获取掉电记忆模式参数信息    
#define NET_DVR_SET_POWEROFFMEMCFG                3275 //设置掉电记忆模式参数信息
#define NET_DVR_GET_LIMITCFG                    3276 //获取限位参数配置信息    
#define NET_DVR_SET_LIMITCFG                    3277 //设置限位参数配置信息
#define NET_DVR_PTZLIMIT_CTRL                    3278 //清除限位参数控制    

#define NET_DVR_PTZ_CLEARCTRL                    3279 //清除配置信息控制接口    
#define NET_DVR_GET_PRIORITIZECFG                3281 //获取云台优先配置信息    
#define NET_DVR_SET_PRIORITIZECFG                3282 //设置云台优先配置信息
#define NET_DVR_PTZ_INITIALPOSITIONCTRL            3283 //零方位角控制    
#define NET_DVR_GET_PRIVACY_MASKSCFG            3285 //获取隐私遮蔽参数
#define NET_DVR_SET_PRIVACY_MASKSCFG            3286 //设置隐私遮蔽参数
#define NET_DVR_GET_PTZLOCKCFG                    3287 //获取云台锁定信息    
#define NET_DVR_SET_PTZLOCKCFG                    3288 //设置云台锁定信息
#define NET_DVR_PTZ_ZOOMRATIOCTRL                3289 //设置跟踪倍率    
#define NET_DVR_GET_PTZLOCKINFO                    3290 //获取云台锁定剩余秒数
#define NET_DVR_GET_PRIVACY_MASKS_ENABLECFG        3291 //获取全局使能    
#define NET_DVR_SET_PRIVACY_MASKS_ENABLECFG        3292 //设置全局使能
#define NET_DVR_GET_SMARTTRACKCFG                3293 //获取智能运动跟踪配置信息    
#define NET_DVR_SET_SMARTTRACKCFG                3294 //设置智能运动跟踪配置信息
#define NET_DVR_GET_EPTZ_CFG                    3295 //获取EPTZ参数
#define NET_DVR_SET_EPTZ_CFG                    3296 //设置EPTZ参数
#define NET_DVR_GET_EPTZ_CFG_CAPABILITIES        3297 //获取EPTZ参数能力

#define NET_DVR_GET_LOW_LIGHTCFG                3303//获取快球低照度设置信息
#define NET_DVR_SET_LOW_LIGHTCFG                3304//设置快球低照度设置信息
#define NET_DVR_GET_FOCUSMODECFG                3305//获取快球聚焦模式信息
#define NET_DVR_SET_FOCUSMODECFG                3306//设置快球聚焦模式信息
#define NET_DVR_GET_INFRARECFG                  3307//获取快球红外设置信息
#define NET_DVR_SET_INFRARECFG                  3308//设置快球红外设置信息
#define NET_DVR_GET_AEMODECFG                   3309//获取快球其他设置信息
#define NET_DVR_SET_AEMODECFG                   3310//设置快球其他设置信息
#define NET_DVR_CONTROL_RESTORE_SUPPORT         3311 //恢复前端默认参数(参数能力中有的前端参数配置相关的都恢复)
#define NET_DVR_CONTROL_RESTART_SUPPORT         3312 //快球机芯重启
#define NET_DVR_CONTROL_PTZ_PATTERN             3313//云台花样扫描
#define NET_DVR_GET_PTZ_PARKACTION_CFG          3314//获取云台守望参数
#define NET_DVR_SET_PTZ_PARKACTION_CFG          3315//设置云台守望参数
#define NET_DVR_CONTROL_PTZ_MANUALTRACE         3316//手动跟踪定位
#define NET_DVR_GET_ROI_DETECT_NUM                3349 //获取ROI检测区域编号数目
#define NET_DVR_GET_ROI_DETECT                    3350 //获取ROI检测区域配置
#define NET_DVR_SET_ROI_DETECT                    3351 //设置ROI检测区域配置
#define NET_DVR_GET_FACE_DETECT                    3352 //获取人脸侦测配置
#define NET_DVR_SET_FACE_DETECT                    3353 //设置人脸侦测配置
#define NET_DVR_GET_CORRIDOR_MODE                3354 //获取走廊模式功能配置
#define NET_DVR_SET_CORRIDOR_MODE                3355 //设置走廊模式功能配置
#define NET_DVR_GET_SCENECHANGE_DETECTIONCFG    3356 //获取场景变更报警配置
#define NET_DVR_SET_SCENECHANGE_DETECTIONCFG    3357 //设置场景变更报警配置
#define NET_DVR_GET_TRAVERSE_PLANE_DETECTION    3360 
#define NET_DVR_SET_TRAVERSE_PLANE_DETECTION    3361 
#define NET_DVR_GET_FIELD_DETECTION                3362 //获取区域侦测配置
#define NET_DVR_SET_FIELD_DETECTION                3363 //设置区域侦测配置
#define NET_DVR_GET_DEFOCUSPARAM                3364 //获取虚焦侦测参数配置
#define NET_DVR_SET_DEFOCUSPARAM                3365 //设置虚焦侦测参数配置
#define NET_DVR_GET_AUDIOEXCEPTIONPARAM            3366 //获取音频异常配置
#define NET_DVR_SET_AUDIOEXCEPTIONPARAM            3367 //设置音频异常配置
#define NET_DVR_GET_CCDPARAMCFG_EX              3368 //获取CCD参数配置
#define NET_DVR_SET_CCDPARAMCFG_EX              3369 //设置CCD参数配置
#define NET_DVR_START_GET_INPUTVOLUME            3370//开始获取音量
#define NET_DVR_SET_SCH_TASK                    3380 //设置球机定时任务
#define NET_DVR_GET_SCH_TASK                    3381  //获取球机定时任务
#define NET_DVR_SET_PRESET_NAME                    3382 //设置预置点名称
#define NET_DVR_GET_PRESET_NAME                    3383 //获取预置点名称
#define NET_DVR_SET_AUDIO_NAME                    3384 //设置语音名称
#define NET_DVR_GET_AUDIO_NAME                    3385  //获取语音名称
#define NET_DVR_RESUME_INITRACKPOS              3386  //恢复跟踪初始位
#define NET_DVR_NTP_SERVER_TEST                    3387    //NTP服务器测试
#define    NET_DVR_NAS_SERVER_TEST                    3388    //NAS服务器测试
#define    NET_DVR_EMAIL_SERVER_TEST                3389    //Email服务器测试
#define    NET_DVR_FTP_SERVER_TEST                    3390    //FTP服务器测试
#define    NET_DVR_IP_TEST                            3391    //IP测试
#define NET_DVR_GET_NET_DISKCFG_V40             3392 //网络硬盘接入获取v40
#define NET_DVR_SET_NET_DISKCFG_V40                3393 //网络硬盘接入设置v40
#define    NET_DVR_GET_IOOUT_CFG                    3394//获取补光灯参数
#define    NET_DVR_SET_IOOUT_CFG                    3395//设置补光灯参数
#define    NET_DVR_GET_SIGNAL_SYNC                    3396//获取信号灯同步配置参数
#define    NET_DVR_SET_SIGNAL_SYNC                    3397//设置信号灯同步配置参数    

#define    NET_DVR_GET_EZVIZ_ACCESS_CFG            3398//获取EZVIZ接入参数
#define    NET_DVR_SET_EZVIZ_ACCESS_CFG            3399//设置EZVIZ接入参数
#define    NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG        3400//获取定时智能跟踪参数
#define    NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG        3401//设置定时智能跟踪参数
#define    NET_DVR_MAKE_I_FRAME                    3402//强制I帧
#define NET_DVR_GET_ALARM_RELATE                3403//获取报警联动通道功能参数
#define NET_DVR_SET_ALARM_RELATE                3404//设置报警联动通道功能参数
#define NET_DVR_GET_PDC_RULECFG_V42             3405  //设置人流量统计规则(扩展)
#define NET_DVR_SET_PDC_RULECFG_V42             3406  //获取人流量统计规则(扩展)
#define NET_DVR_GET_HEATMAP_CFG                 3407  //设置热度图参数配置
#define NET_DVR_SET_HEATMAP_CFG                 3408  //获取热度图参数配置
#define NET_DVR_REMOTECONTROL_LINEARSCAN        3409   //设置左右边界参数 2014-03-15
#define NET_DVR_DPC_CTRL                        3410//坏点校正控制
#define NET_DVR_FFC_MANUAL_CTRL                 3411//非均匀性校正(FFC)手动模式
#define NET_DVR_FFC_BACKCOMP_CTRL               3412//非均匀性校正(FFC)背景补偿
#define NET_DVR_GET_FOCUSING_POSITION_STATE     3413//获取聚焦到位状态参数
#define NET_DVR_GET_PRIVATE_PROTOCOL_CFG        3414   //获取 私有关键信息上传配置接口配置
#define NET_DVR_SET_PRIVATE_PROTOCOL_CFG        3415   //设置 私有关键信息上传配置接口配置
#define NET_DVR_COMPLETE_RESTORE_CTRL           3420    //设置完全恢复出厂值

#define NET_DVR_CLOUDSTORAGE_SERVER_TEST        3421  //云存储服务器测试
#define NET_DVR_PHONE_NUM_TEST                  3422  //电话号码测试
#define NET_DVR_GET_REMOTECONTROL_STATUS        3423  //获取无线布防状态
#define NET_DVR_GET_MONITOR_LOCATION_INFO        3424  //获取监测点信息
#define NET_DVR_SET_MONITOR_LOCATION_INFO        3425  //设置监测点信息


#define    NET_DVR_GET_SMART_CAPABILITIES                3500    //获取Smart能力
#define    NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES        3501    //获取事件触发能力
#define    NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES    3502    //获取进入区域侦测能力
#define    NET_DVR_GET_REGION_ENTR_DETECTION            3503    //获取进入区域配置
#define    NET_DVR_SET_REGION_ENTR_DETECTION            3504    //设置进入区域配置
#define    NET_DVR_GET_REGION_ENTR_REGION                3505    //获取进入区域的单个区域配置
#define    NET_DVR_SET_REGION_ENTR_REGION                3506    //设置进入区域的单个区域配置
#define    NET_DVR_GET_REGION_ENTR_TRIGGER                3507    //获取进入区域联动配置
#define    NET_DVR_SET_REGION_ENTR_TRIGGER                3508    //设置进入区域联动配置
#define    NET_DVR_GET_REGION_ENTR_SCHEDULE            3509    //获取进入区域布防时间配置
#define    NET_DVR_SET_REGION_ENTR_SCHEDULE            3510    //设置进入区域布防时间配置
#define    NET_DVR_GET_REGION_EXITINT_CAPABILITIES        3511    //获取离开区域侦测能力
#define    NET_DVR_GET_REGION_EXITING_DETECTION        3512    //获取离开区域配置
#define    NET_DVR_SET_REGION_EXITING_DETECTION        3513    //设置离开区域配置
#define    NET_DVR_GET_REGION_EXITING_REGION            3514    //获取离开区域的单个区域配置
#define    NET_DVR_SET_REGION_EXITING_REGION            3515    //设置离开区域的单个区域配置
#define    NET_DVR_GET_REGION_EXIT_TRIGGER                3516    //获取离开区域联动配置
#define    NET_DVR_SET_REGION_EXIT_TRIGGER                3517    //设置离开区域联动配置
#define    NET_DVR_GET_REGION_EXIT_SCHEDULE            3518    //获取离开区域布防时间配置
#define    NET_DVR_SET_REGION_EXIT_SCHEDULE            3519    //设置离开区域布防时间配置
#define    NET_DVR_GET_LOITERING_CAPABILITIES            3520    //获取徘徊侦测能力
#define    NET_DVR_GET_LOITERING_DETECTION                3521    //获取徘徊侦测配置
#define    NET_DVR_SET_LOITERING_DETECTION                3522    //设置徘徊侦测配置
#define    NET_DVR_GET_LOITERING_REGION                3523    //获取徘徊的单个区域配置
#define    NET_DVR_SET_LOITERING_REGION                3524    //设置徘徊的单个区域配置
#define    NET_DVR_GET_LOITERING_TRIGGER                3525    //获取徘徊联动配置
#define    NET_DVR_SET_LOITERING_TRIGGER                3526    //设置徘徊联动配置
#define    NET_DVR_GET_LOITERING_SCHEDULE                3527    //获取徘徊布防时间配置
#define    NET_DVR_SET_LOITERING_SCHEDULE                3528    //设置徘徊布防时间配置
#define    NET_DVR_GET_GROUPDETECTION_CAPABILITIES        3529    //获取人员聚集侦测能力
#define    NET_DVR_GET_GROUP_DETECTION                    3530    //获取人员聚集侦测配置
#define    NET_DVR_SET_GROUP_DETECTION                    3531    //设置人员聚集侦测配置
#define    NET_DVR_GET_GROUPDETECTION_REGION            3532    //获取人员聚集的单个区域配置
#define    NET_DVR_SET_GROUPDETECTION_REGION            3533    //设置人员聚集的单个区域配置
#define    NET_DVR_GET_GROUPDETECTION_TRIGGER            3534    //获取人员聚集联动配置
#define    NET_DVR_SET_GROUPDETECTION_TRIGGER            3535    //设置人员聚集联动配置
#define    NET_DVR_GET_GROUPDETECTION_SCHEDULE            3536    //获取人员聚集布防时间配置
#define    NET_DVR_SET_GROUPDETECTION_SCHEDULE            3537    //设置人员聚集布防时间配置
#define    NET_DVR_GET_RAPIDMOVE_CAPABILITIES            3538    //获取快速运动侦测能力
#define    NET_DVR_GET_RAPIDMOVE_DETECTION                3539    //获取快速运动侦测配置
#define    NET_DVR_SET_RAPIDMOVE_DETECTION                3540    //设置快速运动侦测配置
#define    NET_DVR_GET_RAPIDMOVE_REGION                3541    //获取快速运动的单个区域配置
#define    NET_DVR_SET_RAPIDMOVE_REGION                3542    //设置快速运动的单个区域配置
#define    NET_DVR_GET_RAPIDMOVE_TRIGGER                3543    //获取快速运动联动配置
#define    NET_DVR_SET_RAPIDMOVE_TRIGGER                3544    //设置快速运动联动配置
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE                3545    //获取快速运动的布防时间配置
#define    NET_DVR_SET_RAPIDMOVE_SCHEDULE                3546    //设置快速运动的布防时间配置
#define    NET_DVR_GET_PATKING_CAPABILITIES            3547    //获取停车侦测能力
#define    NET_DVR_GET_PARKING_DETECTION               3548    //获取停车侦测配置
#define    NET_DVR_SET_PARKING_DETECTION                3549    //设置停车侦测配置
#define    NET_DVR_GET_PARKING_REGION                    3550    //获取停车侦测的单个区域配置
#define    NET_DVR_SET_PARKING_REGION                    3551    //设置停车侦测的单个区域配置
#define    NET_DVR_GET_PARKING_TRIGGER                    3552    //获取停车侦测联动配置
#define    NET_DVR_SET_PARKING_TRIGGER                    3553    //设置停车侦测联动配置
#define    NET_DVR_GET_PARKING_SCHEDULE                3554    //获取停车侦测的布防时间配置
#define    NET_DVR_SET_PARKING_SCHEDULE                3555    //设置停车侦测的布防时间配置
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES    3556    //获取物品遗留侦测能力
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION    3557    //获取物品遗留侦测配置
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION    3558    //设置物品遗留侦测配置
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_REGION        3559    //获取物品遗留侦测的单个区域配置
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_REGION        3560    //设置物品遗留侦测的单个区域配置
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER        3561    //获取物品遗留侦测联动配置
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER        3562    //设置物品遗留侦测联动配置
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE        3563    //获取物品遗留侦测的布防时间配置
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE        3564    //设置物品遗留侦测的布防时间配置
#define    NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES    3565    //获取物品拿取侦测能力
#define    NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION        3566    //获取物品拿取侦测配置
#define    NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION        3567    //设置物品拿取侦测配置
#define    NET_DVR_GET_ATTENDEDBAGGAGE_REGION            3568    //获取物品拿取侦测的单个区域配置
#define    NET_DVR_SET_ATTENDEDBAGGAGE_REGION            3569    //设置物品拿取侦测的单个区域配置
#define    NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER            3570    //获取物品拿取侦测联动配置
#define    NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER            3571    //设置物品拿取侦测联动配置
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE        3572    //获取物品遗留侦测的布防时间配置
#define    NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE        3573    //设置物品拿取侦测的布防时间配置
#define    NET_DVR_GET_REGIONCLIP_CAPABILITIES            3574    //获取区域裁剪能力
#define    NET_DVR_GET_REGION_CLIP                     3575    //获取区域裁剪配置
#define    NET_DVR_SET_REGION_CLIP                     3576    //设置区域裁剪配置
#define    NET_DVR_GET_NETWORK_CAPABILITIES            3577    //获取网络能力
#define    NET_DVR_GET_WIRELESS_DIAL                     3578    //获取无线参数配置
#define    NET_DVR_SET_WIRELESS_DIAL                     3579    //设置无线参数配置
#define    NET_DVR_GET_WIRELESSDIAL_CAPABILITIES        3580    //获取无线拨号参数能力
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE            3581    //获取拨号计划配置
#define    NET_DVR_SET_WIRELESSDIAL_SCHEDULE            3582    //设置拨号计划配置
#define    NET_DVR_GET_WIRELESSDIAL_STATUS             3583    //获取拨号状态
#define    NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES    3584    //获取进入区域侦测布防时间能力
#define    NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES    3585    //获取离开区域侦测布防时间能力
#define    NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES    3586    //获取徘徊侦测布防时间能力
#define    NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES    3587    //获取人员聚集侦测布防时间能力
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES    3588    //获取快速运动侦测布防时间能力
#define    NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES    3589    //获取停车侦测布防时间能力
#define    NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3590    //获取物品遗留侦测布防时间能力
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3591    //获取物品拿取侦测布防时间能力
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES    3592    //获取拨号计划能力
#define    NET_DVR_WIRELESSDIAL_CONNECT    3593    //控制无线网络连网断网

#define    NET_DVR_GET_LITESTORAGE                    3594    //获取轻存储配置
#define    NET_DVR_SET_LITESTORAGE                    3595    //设置轻存储配置
#define    NET_DVR_GET_LITESTORAGE_CAPABILITIES    3596    //获取轻存储能力

#define    NET_DVR_GET_VEHICLE_CAPABILITIES    3597    //获取车俩检测标定能力
#define    NET_DVR_GET_VEHICLE_CALIBRATION     3598    //获取车辆检测标定

#define    NET_DVR_GET_SLAVECAMERA_CAPABILITIES    3599    //获取从摄像机IP信息配置能力    
#define    NET_DVR_GET_SLAVECAMERA                    3600    //获取从摄像机IP信息配置
#define    NET_DVR_SET_SLAVECAMERA                    3601    //设置从摄像机IP信息配置
#define    NET_DVR_GET_SLAVECAMERA_STATUS            3602    //获取从摄像机连接状态
#define    NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES    3603  //获取从摄像机配置&&标定能力    
#define    NET_DVR_GET_SLAVECAMERA_CALIB            3604    //获取从摄像机标定配置
#define    NET_DVR_SET_SLAVECAMERA_CALIB            3605    //设置从摄像机标定配置
#define NET_DVR_GET_PHY_RATIO                    3606    //获取物理倍率坐标信息    
#define NET_DVR_SET_PHY_RATIO                    3607    //设置物理倍率坐标信息
#define NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES   3608  //获取主从跟踪能力
#define    NET_DVR_SET_TRACKINGRATIO                3610    //设置从摄像机跟踪倍率
#define    NET_DVR_GET_TRACKING                    3611    //获取主从跟踪功能相机跟踪配置
#define    NET_DVR_SET_TRACKING                    3612    //设置主从跟踪功能相机跟踪配置
#define    NET_DVR_GET_TRACKING_CAPABILITIES        3613    //获取主从跟踪功能相机跟踪配置能力

#define    NET_DVR_GET_SLAVECAMERA_CALIB_V50        3614    //获取从摄像机标定配置V50
#define    NET_DVR_SET_SLAVECAMERA_CALIB_V50        3615    //设置从摄像机标定配置V50
#define    NET_DVR_SET_TRACKINGRATIO_MANUAL        3616    //设置从摄像机手动跟踪倍率
#define    NET_DVR_GET_TRACKINGRATIO_MANUAL        3617    //获取从摄像机手动跟踪倍率
#define    NET_DVR_SET_TRACK_INITPOSTION            3618    //设置从摄像机初始跟踪位置
#define    NET_DVR_GET_PTZ_CAPABILITIES            3619    //获取ptz球机控制能力

#define    NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES    3620 //获取测温配置能力
#define    NET_DVR_GET_THERMOMETRY_BASICPARAM      3621    //获取测温配置参数
#define    NET_DVR_SET_THERMOMETRY_BASICPARAM        3622    //设置测温配置参数
#define    NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES    3623 //获取测温预置点关联配置能力
#define    NET_DVR_GET_THERMOMETRY_PRESETINFO      3624    //获取测温预置点关联配置参数
#define    NET_DVR_SET_THERMOMETRY_PRESETINFO        3625    //设置测温预置点关联配置参数
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES    3626//获取测温报警方式配置能力
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE       3627    //获取测温预置点报警规则配置参数
#define    NET_DVR_SET_THERMOMETRY_ALARMRULE        3628    //设置测温预置点报警规则配置参数
#define    NET_DVR_GET_REALTIME_THERMOMETRY        3629    //实时温度检测
#define    NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON  3630    //获取测温预置点温差规则配置参数
#define    NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON    3631    //设置测温预置点温差规则配置参数
#define    NET_DVR_GET_THERMOMETRY_TRIGGER            3632    //获取测温联动配置
#define    NET_DVR_SET_THERMOMETRY_TRIGGER            3633    //设置测温联动配置

#define    NET_DVR_GET_THERMAL_CAPABILITIES        3634    //获取热成像（Thermal）能力
#define    NET_DVR_GET_FIREDETECTION_CAPABILITIES    3635    //获取火点检测配置能力
#define    NET_DVR_GET_FIREDETECTION               3636    //获取火点检测参数
#define    NET_DVR_SET_FIREDETECTION               3637    //设置火点检测参数
#define    NET_DVR_GET_FIREDETECTION_TRIGGER       3638    //获取火点检测联动配置
#define    NET_DVR_SET_FIREDETECTION_TRIGGER        3639    //设置火点检测联动配置

#define    NET_DVR_GET_PXOFFLINE_CAPABILITIES      3652    //获取停车场票箱脱机下参数配置 能力
#define    NET_DVR_SET_PXOFFLINE_CFG                3653    //设置停车场票箱脱机下参数配置信息
#define    NET_DVR_GET_PXOFFLINE_CFG                3654    //获取停车场票箱脱机下参数配置信息
#define    NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES  3655  //获取停车场出入口纸票信息下发 能力
#define    NET_DVR_SET_PAPERCHARGEINFO                3656    //设置停车场出入口纸票信息下发
#define    NET_DVR_GET_PARKINGSAPCE_CAPABILITIES    3657    //获取停车场出入口停车位信息下发 能力
#define    NET_DVR_SET_PARKINGSAPCE_INFO            3658    //设置停车场出入口停车位信息下发
#define    NET_DVR_GET_PXMULTICTRL_CAPABILITIES    3659    //获取停车场票箱从属设备多角度参数配置 能力
#define    NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES    3661    //获取停车场票箱参数配置能力
#define    NET_DVR_SET_CHARGE_ACCOUNTINFO          3662    //设置缴费金额信息
#define    NET_DVR_SET_PXMULTICTRL_CFG                3663    //设置停车场票箱从属设备多角度参数配置信息
#define    NET_DVR_GET_PXMULTICTRL_CFG                3664    //获取停车场票箱从属设备多角度参数配置信息
#define    NET_DVR_GET_TME_CHARGERULE              3665    //获取停车场出入口车卡收费规则规则
#define    NET_DVR_SET_TME_CHARGERULE                3666    //设置停车场出入口车卡收费规则规则
#define    NET_DVR_GET_TME_CHARGERULE_CAPABILITIES 3667    //获取停车场出入口 车卡收费信息配置能力
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES  3668    //获取停车场票箱参数配置能力
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CFG    3669    //获取停车场票箱参数配置
#define    NET_DVR_SET_ILLEGALCARDFILTERING_CFG    3670    //设置停车场票箱参数配置
#define    NET_DVR_GET_LEDDISPLAY_CAPABILITIES        3671    //获取LED屏幕显示参数配置参数能力
#define    NET_DVR_SET_LEDDISPLAY_CFG              3672    //设置LED屏幕显示参数
#define    NET_DVR_GET_LEDDISPLAY_CFG              3673    //获取LED屏幕显示参数
#define    NET_DVR_GET_VOICEBROADCAST_CAPABILITIES    3674    //获取语音播报控制参数配置参数能力
#define    NET_DVR_SET_VOICEBROADCAST_CFG          3675    //设置语音播报控制参数
#define    NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES    3676//获取纸票打印格式配置能力
#define    NET_DVR_GET_PAPERPRINTFORMAT_CFG        3677    //获取纸票打印格式参数配置
#define    NET_DVR_SET_PAPERPRINTFORMAT_CFG        3678    //设置纸票打印格式参数配置
#define    NET_DVR_GET_LOCkGATE_CAPABILITIES       3679    //获取智能锁闸配置能力
#define    NET_DVR_GET_LOCKGATE_CFG                3680    //获取智能锁闸参数配置
#define    NET_DVR_SET_LOCKGATE_CFG                3681    //设置智能锁闸参数配置
#define NET_DVR_GET_PARKING_DATASTATE            3682    //获取数据同步状态
#define NET_DVR_SET_PARKING_DATASTATE           3683    //设置数据同步状态
#define    NET_DVR_GET_TME_CAPABILITIES            3684    //获取停车场出入口设备 能力

#define    NET_DVR_GET_TMEVOICE_CAPABILITIES       3686    //获取语音配置信息能力
#define    NET_DVR_SET_TMEVOICE_CFG                3687    //设置语音参数配置
#define    NET_DVR_GET_TMEVOICE_CFG                3688    //获取语音参数配置

#define    NET_DVR_GET_POSITION                    3698    // 获取方位矫正配置参数
#define    NET_DVR_SET_POSITION                    3699    // 设置方位矫正配置参数
#define    NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES    3700//获取集中布控能力
#define    NET_DVR_GET_CENTRALIZEDCTRL                3701//获取集中布控参数配置
#define    NET_DVR_SET_CENTRALIZEDCTRL              3702//设置集中布控参数配置
#define    NET_DVR_GET_COMPASS_CAPABILITIES        3703//获取电子罗盘能力
#define    NET_DVR_GET_VANDALPROOFALARM              3704//获取防破坏报警参数配置
#define    NET_DVR_SET_VANDALPROOFALARM            3705//设置防破坏报警参数配置
#define    NET_DVR_COMPASS_CALIBRATE_CTRL            3706//电子罗盘矫正控制接口
#define    NET_DVR_COMPASS_NORTH_CTRL                3707//电子罗盘指向正北控制接口
#define    NET_DVR_GET_AZIMUTHINFO                    3708//获取方位角度参数配置


#define    NET_DVR_GET_SATELLITETIME                3709//获取卫星定位参数配置
#define    NET_DVR_SET_SATELLITETIME                3710//设置卫星定位参数配置
#define    NET_DVR_GET_GISINFO                     3711//获取当前球机的GIS信息数据
#define    NET_DVR_GET_STREAMING_CAPABILITIES        3712//获取视频流的能力
#define    NET_DVR_GET_REFRESHFRAME_CAPABILITIES    3713//获取刷新帧的能力
#define    NET_DVR_STREAMING_REFRESH_FRAME            3714//取流预览的强制刷新帧
#define    NET_DVR_FACECAPTURE_STATISTICS            3715//长连接人员统计
#define    NET_DVR_GET_WIRELESSSERVER_CAPABILITIES    3716    //获取热点功能配置协议的能力
#define    NET_DVR_GET_WIRELESSSERVER                3717    //获取热点功能配置协议
#define    NET_DVR_SET_WIRELESSSERVER                3718    //设置热点功能配置协议
#define    NET_DVR_GET_CONNECT_LIST_CAPABILITIES    3719    //获取连接设备列表信息的能力
#define    NET_DVR_GET_THSCREEN_CAPABILITIES        3720 //获取温湿度配置协议的能力
#define    NET_DVR_GET_THSCREEN                    3721 //获取温湿度配置协议
#define    NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES    3722//获取外设配置协议的能力
#define    NET_DVR_GET_EXTERNALDEVICE              3723//获取外设配置协议
#define    NET_DVR_SET_EXTERNALDEVICE                3724//设置外设配置协议
#define    NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES     3725   //获取LED显示信息的能力
#define    NET_DVR_SET_LEDDISPLAYINFO                 3726   //设置LED显示信息
#define    NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES 3727   //获取内置补光灯配置协议的能力 (球机支持，软件实现，补光灯是设计在设备内部的)
#define    NET_DVR_GET_SUPPLEMENTLIGHT                 3728    //获取内置补光灯配置协议
#define    NET_DVR_SET_SUPPLEMENTLIGHT                 3729    //设置内置补光灯配置协议
#define    NET_DVR_SET_THSCREEN                     3730 //设置温湿度配置协议
#define    NET_DVR_GET_LOWPOWER_CAPABILITIES        3731   //获取低功耗配置协议的能力
#define    NET_DVR_GET_LOWPOWER                     3732    //获取低功耗配置协议
#define    NET_DVR_SET_LOWPOWER                     3733    //设置低功耗配置协议
#define    NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES     3734   //获取变倍联动配置协议的能力
#define    NET_DVR_GET_ZOOMLINKAGE                     3735    //获取变倍联动配置协议
#define    NET_DVR_SET_ZOOMLINKAGE                     3736    //设置变倍联动配置协议
#define    NET_DVR_THSCREEN_TIMING                     3737    //温湿度
#define NET_DVR_GET_OSD_BATTERY_POWER_CFG        3741        //获取OSD电池电量显示参数
#define NET_DVR_SET_OSD_BATTERY_POWER_CFG        3742        //设置OSD电池电量显示参数
#define    NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES    3743//OSD电池电量显示参数的能力
#define    NET_DVR_GET_VANDALPROOFALARM_TRIGGER    3744    //获取防破坏报警联动配置
#define    NET_DVR_SET_VANDALPROOFALARM_TRIGGER    3745    //设置防破坏报警联动配置
#define    NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES    3746    //获取全景图像的能力
#define    NET_DVR_GET_PANORAMAIMAGE                3747    //获取全景图像参数的协议
#define    NET_DVR_SET_PANORAMAIMAGE                3748    //设置全景图像参数的协议
#define    NET_DVR_GET_STREAMENCRYPTION            3749    //获取码流加密配置
#define    NET_DVR_SET_STREAMENCRYPTION            3750    //设置码流加密配置
#define    NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES 3751  //获取码流加密能力
#define    NET_DVR_GET_REVISE_GPS_CAPABILITIES     3752    //获取校准GPS经纬度能力
#define    NET_DVR_GET_REVISE_GPS                  3753    //获取校准GPS经纬度能力
#define    NET_DVR_SET_REVISE_GPS                  3754    //设置校准GPS经纬度能力
#define NET_DVR_GET_PDC_RECOMMEND                3755    //获取客流统计表示推荐值
#define NET_DVR_REMOVE_FLASHSTORAGE                3756    //客流数据清除操作
#define    NET_DVR_GET_COUNTING_CAPABILITIES        3757    //获取客流量统计能力
#define    NET_DVR_SET_SENSOR_ADJUSTMENT            3758    //设置Sensor 调节参数的协议
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES        3759    //获取Sensor 调节参数的协议的能力
#define    NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG         3760    //获取wifi热点参数配置(完整版)
#define    NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG         3761    //设置wifi热点参数配置(完整版)
#define    NET_DVR_GET_ONLINEUSER_INFO                3762    //长连接获取用户在线信息
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_INFO        3763    //获取指定sensor调节参数
#define NET_DVR_SENSOR_RESET_CTRL               3764    //Sensor 调节复位

#define    NET_DVR_GET_POSTRADAR_CAPABILITIES        3765    //获取雷达测速配置能力
#define    NET_DVR_GET_POSTRADARSPEED_CFG          3766    //获取雷达测速配置
#define    NET_DVR_SET_POSTRADARSPEED_CFG          3767    //设置雷达测速配置
#define    NET_DVR_GET_POSTRADARSPEED_RECOM_CFG    3768    //获取雷达测速推荐值
#define    NET_DVR_GET_POSTRADARPARAM_CFG          3769    //获取雷达参数配置
#define    NET_DVR_SET_POSTRADARPARAM_CFG          3770    //设置雷达参数配置
#define    NET_DVR_GET_POSTRADARPARAM_RECOM_CFG    3771    //获取雷达参数推荐值

#define NET_DVR_GET_ENCRYPT_DEVICE_INFO        3772   //获取加密设备信息
#define NET_DVR_GET_ANR_ARMING_HOST            3773  //获取断网续传的主机信息

/********************************IPC基线FF车牌****************************/
#define    NET_DVR_GET_FTP_CAPABILITIES            3782    //获取ftp能力
#define    NET_DVR_GET_FTPUPLOAD_CFG                3783    //获取ftp上传信息规整参数
#define    NET_DVR_SET_FTPUPLOAD_CFG                3784    //设置ftp上传信息规整参数

#define    NET_DVR_GET_DDNS_COUNTRY_ABILITY        3800//获取设备支持的DDNS国家能力列表

/********************************智能人脸识别****************************/
#define NET_DVR_GET_FACESNAPCFG                 5001  //获取人脸抓拍参数
#define NET_DVR_SET_FACESNAPCFG                 5002  //设置人脸抓拍参数
#define NET_DVR_GET_DEVACCESS_CFG               5005  //获取接入设备参数
#define NET_DVR_SET_DEVACCESS_CFG               5006  //设置接入设备参数
#define NET_DVR_GET_SAVE_PATH_CFG               5007  //获取存储信息参数
#define NET_DVR_SET_SAVE_PATH_CFG               5008  //设置存储信息参数
#define NET_VCA_GET_RULECFG_V41                    5011  //获取行为分析参数(扩展)
#define NET_VCA_SET_RULECFG_V41                    5012  //设置行为分析参数(扩展)
#define NET_DVR_GET_AID_RULECFG_V41             5013  //获取交通事件规则参数
#define NET_DVR_SET_AID_RULECFG_V41             5014  //设置交通事件规则参数
#define NET_DVR_GET_TPS_RULECFG_V41             5015  //获取交通统计规则参数(扩展)
#define NET_DVR_SET_TPS_RULECFG_V41             5016  //设置交通统计规则参数(扩展)
#define NET_VCA_GET_FACEDETECT_RULECFG_V41      5017  //获取ATM人脸检测规则(扩展) 
#define NET_VCA_SET_FACEDETECT_RULECFG_V41      5018  //设置ATM人脸检测规则(扩展)
#define NET_DVR_GET_PDC_RULECFG_V41             5019  //设置人流量统计规则(扩展)
#define NET_DVR_SET_PDC_RULECFG_V41             5020  //获取人流量统计规则(扩展)
#define NET_DVR_GET_TRIAL_VERSION_CFG           5021  //获取试用版信息
#define NET_DVR_GET_VCA_CTRLINFO_CFG            5022  //批量获取智能控制参数
#define NET_DVR_SET_VCA_CTRLINFO_CFG            5023  //批量设置智能控制参数
#define NET_DVR_SYN_CHANNEL_NAME                5024  //同步通道名
#define NET_DVR_GET_RESET_COUNTER               5025  //获取统计数据清零参数（人流量、交通统计）
#define NET_DVR_SET_RESET_COUNTER               5026  //设置统计数据清零参数（人流量、交通统计）
#define NET_DVR_GET_OBJECT_COLOR                5027  //获取物体颜色属性
#define NET_DVR_SET_OBJECT_COLOR                5028  //设置物体颜色属性
#define NET_DVR_GET_AUX_AREA                    5029  //获取辅助区域
#define NET_DVR_SET_AUX_AREA                    5030  //设置辅助区域
#define NET_DVR_GET_CHAN_WORKMODE               5031  //获取通道工作模式
#define NET_DVR_SET_CHAN_WORKMODE               5032  //设置通道工作模式
#define NET_DVR_GET_SLAVE_CHANNEL               5033  //获取从通道参数
#define NET_DVR_SET_SLAVE_CHANNEL               5034  //设置从通道参数
#define NET_DVR_GET_VQD_EVENT_RULE              5035  //获取视频质量诊断事件规则
#define NET_DVR_SET_VQD_EVENT_RULE              5036  //设置视频质量诊断事件规则
#define NET_DVR_GET_BASELINE_SCENE              5037  //获取基准场景参数
#define NET_DVR_SET_BASELINE_SCENE              5038  //设置基准场景参数
#define NET_DVR_CONTROL_BASELINE_SCENE          5039  //基准场景操作
#define NET_DVR_SET_VCA_DETION_CFG                5040  //设置智能移动参数配置
#define NET_DVR_GET_VCA_DETION_CFG                5041  //获取智能移动参数配置
#define NET_DVR_GET_STREAM_ATTACHINFO_CFG       5042  //获取码流附加信息配置
#define NET_DVR_SET_STREAM_ATTACHINFO_CFG       5043  //设置码流附加信息配置

#define NET_DVR_GET_BV_CALIB_TYPE               5044  //获取双目标定类型
#define NET_DVR_CONTROL_BV_SAMPLE_CALIB         5045  //双目样本标定
#define NET_DVR_GET_BV_SAMPLE_CALIB_CFG         5046  //获取双目标定参数
#define NET_DVR_GET_RULECFG_V42                    5049  //获取行为分析参数(支持16条规则扩展)
#define NET_DVR_SET_RULECFG_V42                    5050  //设置行为分析参数(支持16条规则扩展)
#define NET_DVR_SET_VCA_DETION_CFG_V40            5051  //设置智能移动参数配置
#define NET_DVR_GET_VCA_DETION_CFG_V40          5052  //获取智能移动参数配置
/********************************智能人脸识别 end****************************/

//2014-12-03  
#define    NET_DVR_GET_T1TEST_CFG   5053     //产线测试配置接口（获取）
#define    NET_DVR_SET_T1TEST_CFG   5054     ////产线测试配置接口（设置）

/********************************ITS****************************/
#define NET_ITS_GET_OVERLAP_CFG_V50                5055  //获取字符叠加参数配置扩展
#define NET_ITS_SET_OVERLAP_CFG_V50                5056  //设置字符叠加参数配置扩展

#define NET_DVR_GET_PARKLAMP_STATE                5057  //获取停车场信号灯状态信息
#define NET_DVR_GET_CLOUDSTORAGE_CFG            5058  //获取云存储配置参数
#define NET_DVR_SET_CLOUDSTORAGE_CFG            5059  //设置云存储配置参数

#define NET_ITS_GET_BASE_INFO                    5060  //获取终端基本信息
#define NET_DVR_GET_SENSOR_INFO                 5061  //传感器信息查询
#define    NET_DVR_SET_SENSOR_SWITCH                5062  //传感器远程控制
#define NET_ITS_GET_IMGMERGE_CFG                5063  //获取图片合成配置参数
#define NET_ITS_SET_IMGMERGE_CFG                5064  //设置图片合成配置参数
#define NET_ITS_GET_UPLOAD_CFG                    5065  //获取数据上传配置
#define NET_ITS_SET_UPLOAD_CFG                    5066  //设置数据上传配置
#define    NET_DVR_GET_SENSOR_PORT_CAPABILITIES    5067  //获取传感器能力
#define NET_ITS_GET_WORKSTATE                    5069  //获取终端工作状态
#define NET_ITS_GET_IPC_CHAN_CFG                5070  //获取通道IPC信息
#define NET_ITS_SET_IPC_CHAN_CFG                5071  //设置通道IPC信息
#define NET_ITS_GET_OVERLAP_CFG                    5072  //获取字符叠加参数配置
#define NET_ITS_SET_OVERLAP_CFG                    5073  //设置字符叠加参数配置
#define NET_DVR_GET_TRIGGEREX_CFG               5074  //获取ITC扩展配置
#define NET_DVR_SET_TRIGGEREX_CFG               5075  //设置ITC扩展配置
#define NET_ITS_GET_ROAD_INFO                    5076  //获取路口信息

#define NET_ITS_REMOTE_DEVICE_CONTROL            5077//设置远程设备控制
#define NET_ITS_GET_GATEIPC_CHAN_CFG            5078//获取出入口参数
#define NET_ITS_SET_GATEIPC_CHAN_CFG            5079//设置出入口参数
#define NET_ITS_TRANSCHAN_START                    5080//同步数据服务器建立连接
#define NET_ITS_GET_ECTWORKSTATE                5081//获取出入口终端工作状态
#define NET_ITS_GET_ECT_CHAN_INFO                5082//获取出入口终端通道状态
#define NET_DVR_GET_HEATMAP_RESULT              5083//热度图数据查找
#define NET_DVR_SET_ITS_EXDEVCFG                5084 //设置ITS外接设备信息
#define NET_DVR_GET_ITS_EXDEVCFG                5085 //获取ITS外接设备信息
#define NET_DVR_GET_ITS_EXDEVSTATUS                5086 //获取ITS所有外接设备信息
#define NET_DVR_SET_ITS_ENDEVCMD                5087 //设置ITS终端出入口控制命令
#define NET_DVR_SET_ENISSUED_DATADEL            5088 //设置ITS终端出入口控制清除
#define NET_DVR_GET_PDC_RESULT                  5089//客流量数据查询 2014-03-21
#define NET_ITS_GET_LAMP_CTRLCFG                5090  //获取内外置灯参数
#define NET_ITS_SET_LAMP_CTRLCFG                5091  //设置内外置灯参数
#define NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG     5092  //获取特殊车位参数
#define NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG     5093  //设置特殊车位参数
#define NET_ITS_SET_LAMP_EXTERNAL_CFG            5095  //设置外控配置参数
#define NET_ITS_SET_COMPEL_CAPTURE                5096  //设置车位强制抓图
#define NET_DVR_SET_TIMESIGN_CFG                5097  //设置扩展校时自定义标记
#define NET_DVR_GET_TIMESIGN_CFG                5098  //获取扩展校时自定义标记
#define NET_DVR_GET_SIGNALLAMP_STATUS           5099  //信号灯检测
/********************************ITS end****************************/

#define NET_DVR_GET_MONITOR_PLAN_VQD            5100  //长连接获取诊断服务器计划
#define NET_DVR_GET_MONITORID_VQD               5101  //长连接获取对应计划内的监控点信息
#define NET_DVR_SET_MONITOR_INFO                5102  //批量设置计划内的监控点信息 
#define NET_DVR_DEL_MONITOR_PLAN_VQD            5103  //删除计划
#define NET_DVR_GET_MONITOR_VQD_STATUS          5104  //平台查询诊断服务器的状态
#define NET_DVR_GET_RECORD_INFO                 5105  //获取资源图片查询
#define NET_DVR_GET_MONITOR_VQDCFG              5106  //获取服务器的监控点信息
#define NET_DVR_SET_MONITOR_VQDCFG              5107  //设置服务器的监控点信息
#define NET_DVR_SET_MONITOR_PLAN_VQDCFG         5108  //设置管理计划(单独的计划)

#define NET_DVR_SCENE_CHANGE_UPDATE                5109   //场景变更数据更新

#define NET_DVR_GET_CALIBRATE_POINT             5153  //归一化坐标转换（枪球联动设备 外部交互命令码 基线代码不实现，防止冲突，提交基线）/*************************智能多场景********************************/
#define NET_DVR_GET_SCENE_CFG                   5201  //获取场景信息
#define NET_DVR_SET_SCENE_CFG                   5202  //设置场景信息
#define NET_DVR_GET_SCENE_REFERENCE_REGION      5203  //获取参考区域
#define NET_DVR_SET_SCENE_REFERENCE_REGION      5204  //设置参考区域
#define NET_DVR_GET_SCENE_CALIBRATION           5205  //获取标定信息
#define NET_DVR_SET_SCENE_CALIBRATION           5206  //设置标定信息
#define NET_DVR_GET_SCENE_MASK_REGION           5207  //获取屏蔽区域
#define NET_DVR_SET_SCENE_MASK_REGION           5208  //设置屏蔽区域
#define    NET_DVR_GET_SCENE_LANECFG                5209  //获取车道规则
#define NET_DVR_SET_SCENE_LANECFG                5210  //设置车道规则
#define NET_DVR_GET_SCENE_AID_RULECFG           5211  //获取交通事件规则参数
#define NET_DVR_SET_SCENE_AID_RULECFG           5212  //设置交通事件规则参数
#define NET_DVR_GET_SCENE_TPS_RULECFG           5213  //获取交通统计规则参数
#define NET_DVR_SET_SCENE_TPS_RULECFG           5214  //设置交通统计规则参数
#define NET_DVR_GET_SCENE_TIME_CFG              5215  //获取通道的场景时间段配置
#define NET_DVR_SET_SCENE_TIME_CFG              5216  //设置通道的场景时间段配置
#define NET_DVR_GET_FORENSICS_MODE              5217  //获取取证方式参数
#define NET_DVR_SET_FORENSICS_MODE              5218  //设置取证方式参数
#define NET_DVR_FORCESTOP_FORENSICS_CTRL        5219  //强制停止取证
#define NET_DVR_GET_ALARM_PROCESS_CFG           5220   //获取报警处理参数
#define NET_DVR_SET_ALARM_PROCESS_CFG           5221   //设置报警处理参数
#define NET_DVR_GET_BLACKLIST_ALARM_INFO        5222   //获取黑白名单报警轨迹
#define NET_DVR_GET_STORAGE_RESOURCE_CFG        5225   //获取存储资源参数
#define NET_DVR_SET_STORAGE_RESOURCE_CFG        5226   //设置存储资源参数
#define NET_DVR_DEL_BLACKLIST_ALARM_RECORD        5227   //远程删除名单报警记录
#define NET_DVR_SET_BLACKLIST_GROUP_INFO        5229   //远程分组列表参数配置
#define NET_DVR_DEL_BLACKLIST_GROUP_INFO        5230   //远程删除分组列表
#define NET_DVR_GET_BLACKLIST_GROUP_INFO        5231   //远程获取全部分组列表
#define NET_DVR_SET_BLACKLIST_GROUP_RECORD_CFG    5232   //分组记录参数配置
#define NET_DVR_GET_BLACKLIST_GROUP_RECORD_CFG    5234   //远程获取分组记录参数
#define NET_DVR_DEL_BLACKLIST_GROUP_RECORD_CFG    5235   //远程删除分组记录参数
#define    NET_DVR_GET_AREA_MONITOR_CFG            5236   //获取区域监控点参数
#define    NET_DVR_SET_AREA_MONITOR_CFG            5237   //设置区域监控点参数
#define    NET_DVR_DEL_AREA_MONITOR_CFG            5238   //删除区域监控点
#define NET_DVR_RETRIEVAL_SNAP_RECORD            5240   //抓拍库检索
#define NET_DVR_GET_ALARMLIST                    5241   //获取名单报警列表
#define NET_DVR_DETECT_IMAGE                    5242   //单张图片检测
#define NET_DVR_GET_SNAP_RECORD                 5243   //获取抓拍记录
#define NET_DVR_DEL_SNAP_RECORD                 5244   //删除抓拍记录
#define NET_DVR_GET_FACE_RECORD                 5245   //远程获取人脸记录列表
#define NET_DVR_SET_FACE_RECORD                    5246   //添加人脸记录
#define NET_DVR_DEL_FACE_RECORD                    5247   //删除人脸记录
#define NET_DVR_GET_FACE_DATABASE                5248   //获取人脸库配置参数
#define NET_DVR_SET_FACE_DATABASE                5249   //设置人脸库配置参数
#define NET_DVR_DEL_FACE_DATABASE                5250   //删除人脸库
#define NET_DVR_RETRIEVAL_FACE_DATABASE            5251   //人脸库检索
#define NET_DVR_SET_BLACKLIST_REL_DEV_CFG        5252   //设备关联名单分组关联
#define NET_DVR_DEL_BLACKLIST_REL_DEV            5253   //删除 设备关联名单分组信息
/*************************智能多场景end*****************************/

#define NET_DVR_GET_DISK_RAID_INFO              6001  //获取磁盘Raid信息
#define NET_DVR_SET_DISK_RAID_INFO              6002  //设置磁盘Raid信息

#define NET_DVR_GET_DVR_SYNCHRONOUS_IPC         6005  //获取：是否为前端IPC同步设备参数
#define NET_DVR_SET_DVR_SYNCHRONOUS_IPC         6006  //设置：是否为前端IPC同步设备参数

#define NET_DVR_SET_DVR_IPC_PASSWD              6008  //设置：IPC用户名密码
#define NET_DVR_GET_DEVICE_NET_USING_INFO       6009  //获取：当前设备网络资源使用情况

#define NET_DVR_SET_DVR_IPC_NET                 6012  //设置：设置前端IPC的网络地址

#define NET_DVR_GET_RECORD_CHANNEL_INFO         6013  //获取：录像通道信息
#define NET_DVR_SET_RECORD_CHANNEL_INFO         6014  //设置：录像通道信息


#define NET_DVR_MOUNT_DISK                        6015     // 加载磁盘
#define NET_DVR_UNMOUNT_DISK                    6016     // 卸载磁盘

// CVR 
#define NET_DVR_GET_STREAM_SRC_INFO                6017  //获取：流来源信息
#define NET_DVR_SET_STREAM_SRC_INFO                6018  //设置：流来源信息
#define NET_DVR_GET_STREAM_RECORD_INFO            6019  //获取：流录像信息
#define NET_DVR_SET_STREAM_RECORD_INFO            6020  //设置：流录像信息
#define NET_DVR_GET_STREAM_RECORD_STATUS        6021  //获取：流录像状态
#define NET_DVR_SET_STREAM_RECORD_STATUS        6022  //设置：流录像状态
#define NET_DVR_GET_STREAM_INFO                    6023  //获取已添加的流ID信息
#define NET_DVR_GET_STREAM_SRC_INFO_V40            6024  //获取：流来源信息
#define NET_DVR_SET_STREAM_SRC_INFO_V40          6025  //设置：流来源信息
#define NET_DVR_GET_RELOCATE_INFO               6026  //获取N+0模式下重定向信息
#define NET_DVR_START_GOP_INFO_PASSBACK         6032  //智能信息回填
#define NET_DVR_GET_CHANS_RECORD_STATUS_CFG     6035    //获取通道录像状态信息
#define NET_DVR_SET_CHANS_RECORD_STATUS_CFG     6036    //设置通道录像状态信息
//NVR：96xx
#define NET_DVR_GET_IP_ALARM_GROUP_NUM          6100  //获取：IP通道报警输入输出组数
#define NET_DVR_GET_IP_ALARM_IN                 6101  //获取：IP通道报警输入信息
#define NET_DVR_GET_IP_ALARM_OUT                6102  //获取：IP通道报警输出信息

//9000 v2.2
#define NET_DVR_GET_FTPCFG_SECOND                6103      //获取图片上传FTP参数
#define NET_DVR_SET_FTPCFG_SECOND                6104      //设置图片上传FTP参数

#define NET_DVR_GET_DEFAULT_VIDEO_EFFECT        6105       // 获取视频输入效果参数默认值
#define NET_DVR_SET_VIDEO_EFFECT                6106       // 设置通道视频输入图像参数
#define NET_DVR_DEL_INVALID_DISK                6107       // 删除无效磁盘

#define NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG    6109    //获取抽帧通道磁盘配额
#define NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG    6110    //设置抽帧通道磁盘配额

#define NET_DVR_GET_NAT_CFG                     6111     //获取NAT映射参数
#define NET_DVR_SET_NAT_CFG                     6112     //设置NAT映射参数  
#define NET_DVR_GET_AES_KEY                     6113     //获取设备AES加密密钥
#define NET_DVR_GET_POE_CFG                     6114     //获取POE参数
#define NET_DVR_SET_POE_CFG                     6115     //设置POE参数
#define NET_DVR_GET_CUSTOM_PRO_CFG              6116     //获取自定义协议参数
#define NET_DVR_SET_CUSTOM_PRO_CFG              6117     //设置自定义协议参数
#define NET_DVR_GET_STREAM_CABAC                6118     //获取码流压缩性能选项
#define NET_DVR_SET_STREAM_CABAC                6119     //设置码流压缩性能选项   
#define NET_DVR_GET_ESATA_MINISAS_USAGE_CFG        6120  //获取eSATA和miniSAS用途
#define NET_DVR_SET_ESATA_MINISAS_USAGE_CFG        6121  //设置eSATA和miniSAS用途 

#define NET_DVR_GET_HDCFG_V40                    6122  //获取硬盘信息参数
#define NET_DVR_SET_HDCFG_V40                    6123  //设置硬盘信息参数
#define NET_DVR_GET_POE_CHANNEL_ADD_MODE        6124     //获取POE通道添加方式
#define NET_DVR_SET_POE_CHANNEL_ADD_MODE        6125     //设置POE通道添加方式
#define NET_DVR_GET_DIGITAL_CHANNEL_STATE       6126     //获取设备数字通道状态
#define   NET_DVR_GET_BONJOUR_CFG               6127 // 获取Bonjour信息
#define   NET_DVR_SET_BONJOUR_CFG               6128 // 设置Bonjour信息


#define NET_DVR_GET_SOCKS_CFG                    6130//获取SOCKS信息 
#define NET_DVR_SET_SOCKS_CFG                      6131//设置SOCKS信息

#define    NET_DVR_GET_QOS_CFG                        6132//获取QoS信息
#define NET_DVR_SET_QOS_CFG                        6133//设置QoS信息

#define NET_DVR_GET_HTTPS_CFG                    6134//获取HTTPS信息
#define NET_DVR_SET_HTTPS_CFG                    6135//设置HTTPS信息

#define NET_DVR_GET_WD1_CFG                     6136//远程获取WD1使能开关
#define NET_DVR_SET_WD1_CFG                     6137//远程设置WD1使能开关

#define NET_DVR_CREATE_CERT                     6138//创建证书
#define NET_DVR_DELETE_CERT                     6139//删除证书


#define NET_DVR_GET_RECORD_LOCK_PERCENTAGE        6140  //获取录像段锁定比例
#define NET_DVR_SET_RECORD_LOCK_PERCENTAGE      6141  //设置录像段锁定比例

#define NET_DVR_CMD_TRIGGER_PERIOD_RECORD        6144 //外部命令触发指定时间录像
#define NET_DVR_UPLOAD_CERT                     6145    //上传证书
#define NET_DVR_DOWNLOAD_CERT                   6146     //下载证书
#define NET_DVR_GET_CERT                        6147     //获取证书

#define NET_DVR_GET_POS_FILTER_CFG                6148    //获取POS过滤规则
#define NET_DVR_SET_POS_FILTER_CFG                6149    //设置POS过滤规则
#define NET_DVR_GET_CONNECT_POS_CFG                6150    //获取DVR与POS连接方式
#define NET_DVR_SET_CONNECT_POS_CFG                6151    //设置DVR与POS连接方式
#define NET_DVR_GET_CHAN_FILTER_CFG                6152    //获取规则与通道关联信息
#define NET_DVR_SET_CHAN_FILTER_CFG                6153    //设置规则与通道关联信息


#define NET_DVR_GET_FTPCFG_V40                    6162    //获取FTP信息
#define NET_DVR_SET_FTPCFG_V40                    6163    //设置FTP信息

#define NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION 6164   //获取月历录像分布
#define NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO  6165   //获取待接入设备通道信息
#define NET_DVR_GET_PREVIEW_SWITCH_CFG            6166   //获取设备本地预览切换参数
#define NET_DVR_SET_PREVIEW_SWITCH_CFG            6167   //设置设备本地预览切换参数

//Netra3.0.0
#define NET_DVR_GET_N_PLUS_ONE_WORK_MODE            6168    //获取N+1工作模式
#define NET_DVR_SET_N_PLUS_ONE_WORK_MODE            6169    //设置N+1工作模式

#define NET_DVR_GET_HD_STATUS                         6170    //获取硬盘状态
#define NET_DVR_SET_HD_STATUS                         6171    //设置硬盘状态

#define NET_DVR_IMPORT_IPC_CFG_FILE                    6172    //导入IPC配置文件
#define NET_DVR_EXPORT_IPC_CFG_FILE                    6173    //导出IPC配置文件
#define NET_DVR_UPGRADE_IPC                            6174    //升级IP通道

#define NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED        6175    //获取RAID后台任务速度
#define NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED        6176    //设置RAID后台任务速度

//marvell 256路NVR
#define NET_DVR_GET_EXCEPTIONCFG_V40                6177    //获取异常参数配置
#define NET_DVR_SET_EXCEPTIONCFG_V40                6178    //设置异常参数配置
#define NET_DVR_GET_PICCFG_V40                      6179    //获取图象参数 支持变长    NetSDK_
#define NET_DVR_SET_PICCFG_V40                      6180    //设置图象参数， 支持变长
#define NET_DVR_GET_ALARMINCFG_V40                  6181    //获取报警输入参数，支持变长
#define NET_DVR_SET_ALARMINCFG_V40                  6182    //获取报警输入参数，支持变长
#define NET_DVR_GET_IPALARMINCFG_V40                6183    //获取IP报警输入接入配置信息 
#define NET_DVR_GET_IPALARMOUTCFG_V40               6185    //获取IP报警输出接入配置信息 
#define NET_DVR_GET_USERCFG_V40                     6187    //获取用户参数
#define NET_DVR_SET_USERCFG_V40                     6188    //设置用户参数
#define NET_DVR_GET_WORK_STATUS                     6189    //获取设备工作状态
#define NET_DVR_GET_JPEG_CAPTURE_CFG_V40            6190    //获取DVR抓图配置
#define NET_DVR_SET_JPEG_CAPTURE_CFG_V40            6191    //设置DVR抓图配置
#define NET_DVR_GET_HDGROUP_CFG_V40                 6192    //获取盘组管理配置参数
#define NET_DVR_SET_HDGROUP_CFG_V40                 6193    //设置盘组管理配置参数
#define NET_DVR_GET_SMD_HOLIDAY_HANDLE              6194    //获取简易智能假日计划
#define NET_DVR_SET_SMD_HOLIDAY_HANDLE              6195    //设置简易智能假日计划
#define NET_DVR_GET_PIC_MODEL_CFG                   6196    //获取图片建模配置参数
#define NET_DVR_SET_PIC_MODEL_CFG                   6197    //设置图片建模配置参数
#define NET_DVR_START_LOCAL_MOUSE_EVENT             6198    //开启设备本地鼠标事件记录
#define NET_DVR_START_SIMULARE_MOUSE_EVENT          6199    //远程模拟鼠标事件

//91系列HD-SDI高清DVR
#define NET_DVR_GET_ACCESS_CAMERA_INFO          6201 // 获取前端相机信息
#define NET_DVR_SET_ACCESS_CAMERA_INFO          6202 // 设置前端相机信息
#define NET_DVR_PULL_DISK                        6203 // 安全拔盘
#define NET_DVR_SCAN_RAID                        6204 // 扫描阵列
// CVR 2.0.X
#define NET_DVR_GET_USER_RIGHT_CFG                6210        // 获取用户权限
#define NET_DVR_SET_USER_RIGHT_CFG                6211        // 设置用户权限

#define NET_DVR_ONE_KEY_CONFIG                    6212        // 一键配置CVR
#define NET_DVR_RESTART_SERVICE                    6213        // 重启CVR服务

#define NET_DVR_GET_MAX_MACHINE_NUM_CFG            6214        // 获取备机最大个数
#define NET_DVR_SET_MAX_MACHINE_NUM_CFG            6215        // 设置备机最大个数

#define NET_DVR_ADD_DEVICE                        6216        //N+1模式添加设备
#define NET_DVR_DEL_DEVICE                        6217        //N+1模式删除设备

#define NET_DVR_GET_DATA_CALLBACK_CFG            6218        // 获取数据回迁状态
#define NET_DVR_SET_DATA_CALLBACK_CFG            6219        // 设置数据回迁状态

#define NET_DVR_CLONE_LUN                        6220    //克隆LUN卷
#define NET_DVR_EXPAND_LUN                        6221    //扩展和重命名LUN卷

#define NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO        6222    //获取N+1设备信息
#define NET_DVR_MODIFY_DVR_NET_DISK                6223    //修改DVR网盘
//#define NET_DVR_DEL_DVR_NET_DISK                6224    //删除DVR网盘

#define NET_DVR_CREATE_NAS                        6225    //创建NAS
#define NET_DVR_DELETE_NAS                        6226    //删除NAS 

#define NET_DVR_OPEN_ISCSI                         6227    //开启iSCSI
#define NET_DVR_CLOSE_ISCSI                        6228    //关闭iSCSI 

#define NET_DVR_GET_FC                            6229    //获取光纤信息
#define NET_DVR_OPEN_FC                             6230    //开启FC
#define NET_DVR_CLOSE_FC                         6231    //关闭FC
#define NET_DVR_ONE_KEY_CONFIG_SAN                6232   // 一键配置SAN, 与一键配置CVR逻辑一样

//CVR2.3.2
#define NET_DVR_RECORD_CHECK                        6233  //录像完整性检测
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL        6234  //手动添加录像回传任务
#define NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL    6235  //获取所有手动添加录像回传任务
#define NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL    6236  //控制手动录像回传任务
#define NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL        6237  //删除手动录像回传任务
#define NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG        6238  //获取录像回传计划配置
#define NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG        6239  //设置录像回传计划配置
#define NET_DVR_GET_DEV_STORAGE_CFG                    6240  //获取设备存储信息
#define NET_DVR_GET_ONLINE_USER_CFG                    6241  //获取在线用户参数
#define NET_DVR_GET_RECORD_SEGMENT_CFG                6242  //获取录像段总量

#define NET_DVR_GET_RECORD_PACK                    6301    //获取录像打包参数
#define NET_DVR_SET_RECORD_PACK                    6302    //设置录像打包参数

#define NET_DVR_GET_CLOUD_STORAGE_CFG           6303     //获取设备当前工作模式
#define NET_DVR_SET_CLOUD_STORAGE_CFG           6304    //设置设备当前工作模式
#define NET_DVR_GET_GOP_INFO                    6305    //获取GOP信息 
#define NET_DVR_GET_PHY_DISK_INFO               6306     //获取物理磁盘信息
//录播主机外部命令
#define NET_DVR_GET_RECORDING_AUTO_TRACK_CFG    6307    //获取SDI自动跟踪配置信息
#define NET_DVR_SET_RECORDING_AUTO_TRACK_CFG    6308    //设置SDI自动跟踪配置信息

#define NET_DVR_GET_RECORDING_PUBLISH_CFG        6309  //获取一键发布信息 
#define NET_DVR_SET_RECORDING_PUBLISH_CFG        6310  //设置一键发布信息


#define NET_DVR_RECORDING_ONEKEY_CONTROL        6311  //录播主机控制

#define NET_DVR_GET_RECORDING_END_TIME    6312  //获取录播剩余时间

#define NET_DVR_RECORDING_PUBLISH                6313  //一键发布录像

#define NET_DVR_GET_CURRICULUM_CFG            6314    //获取课表配置信息
#define NET_DVR_SET_CURRICULUM_CFG            6315  //设置课表配置信息

#define NET_DVR_GET_COURSE_INDEX_CFG        6316    //获取课程信息索引
#define NET_DVR_SET_COURSE_INDEX_CFG        6317  //设置课程信息索引

#define    NET_DVR_GET_PPT_CHANNEL                6318    //获取PPT支持通道号
#define    NET_DVR_GET_PPT_DETECT_CFG            6319    //获取PPT检测参数
#define    NET_DVR_SET_PPT_DETECT_CFG            6320    //设置PPT检测参数

#define NET_DVR_GET_RECORDINGHOST_CFG            6321    //获取录播主机配置信息
#define NET_DVR_SET_RECORDINGHOST_CFG            6322    //设置录播主机配置信息
#define NET_DVR_GET_BACKUP_RECORD_CFG           6323    //获取一键备份配置信息
#define NET_DVR_SET_BACKUP_RECORD_CFG           6324    //设置一键备份配置信息

//庭审主机
#define NET_DVR_GET_AUDIO_ACTIVATION_CFG        6326    //获取语音激励配置参数
#define NET_DVR_SET_AUDIO_ACTIVATION_CFG        6327    //设置语音激励配置参数
#define NET_DVR_GET_DECODERCFG_V40              6328    //获取解码器参数信息
#define NET_DVR_SET_DECODERCFG_V40                6329    //设置解码器参数信息

#define NET_DVR_INFRARED_OUTPUT_CONTROL         6330   //红外输出控制
#define NET_DVR_GET_INFRARED_CMD_NAME_CFG       6331   //获取红外命令名称参数配置
#define NET_DVR_SET_INFRARED_CMD_NAME_CFG       6332   //设置红外命令名称参数配置
#define NET_DVR_START_INFRARED_LEARN            6333   //远程红外学码

#define NET_DVR_GET_TRIAL_SYSTEM_CFG            6334   //获取庭审主机系统信息
#define NET_DVR_SET_CASE_INFO                    6335    //案件信息录入
#define NET_DVR_GET_TRIAL_MICROPHONE_STATUS        6336  //获取麦克风状态信息
#define NET_DVR_SET_TRIAL_MICROPHONE_STATUS        6337  //获取麦克风状态信息
#define NET_DVR_GET_TRIAL_HOST_STATUS            6338  //获取庭审主机状态信息
#define NET_DVR_GET_LAMP_OUT                    6339  //获取LAMP输出口信息
#define NET_DVR_SET_LAMP_OUT                    6340  //设置LAMP输出口信息
#define NET_DVR_LAMP_REMOTE_CONTROL                6341  // LAMP控制
#define NET_DVR_REMOTE_CONTROL_PLAY                6342  //远程控制本地回放
#define NET_DVR_GET_LOCAL_INPUT_CFG                6343  //获取庭审主机状态信息庭审主机本地输入信息
#define NET_DVR_SET_LOCAL_INPUT_CFG                6344  //设置庭审主机本地输入信息
#define NET_DVR_GET_CASE_INFO                    6345  //获取当前案件信息

//审讯机外部命令
#define NET_DVR_INQUEST_GET_CDW_STATUS             6350  //获取审讯机刻录状态-长连接
#define NET_DVR_GET_MIX_AUDIOIN_CFG             6351  //获取混音输入口参数配置
#define NET_DVR_SET_MIX_AUDIOIN_CFG             6352  //设置混音输入口参数配置
#define NET_DVR_GET_MIX_AUDIOOUT_CFG            6353  //获取混音输出口参数配置
#define NET_DVR_SET_MIX_AUDIOOUT_CFG            6354  //设置混音输出口参数配置
#define NET_DVR_GET_AUDIOIN_VOLUME_CFG          6355  //获取音频输入口音量调节参数配置
#define NET_DVR_SET_AUDIOIN_VOLUME_CFG          6356  //设置音频输入口音量调节参数配置
#define NET_DVR_GET_AREA_MASK_CFG               6357  //获取马赛克区域配置
#define NET_DVR_SET_AREA_MASK_CFG               6358  //设置马赛克区域配置
#define NET_DVR_GET_AUDIO_DIACRITICAL_CFG       6359  //获取音频变音配置
#define NET_DVR_SET_AUDIO_DIACRITICAL_CFG       6360  //设置音频变音配置
#define NET_DVR_GET_WIFI_DHCP_ADDR_CFG          6361  //获WIFI DHCP 地址范围参数配置
#define NET_DVR_SET_WIFI_DHCP_ADDR_CFG          6362  //设WIFI DHCP 地址范围参数配置
#define NET_DVR_GET_WIFI_CLIENT_LIST_INFO       6363  //获取wifi热点下连接的设备信息
#define NET_DVR_REMOTECONTROL_POWER_ON            6364  //远程开机
#define NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG      6365  //获取多码流关联通道参数配置
#define NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG     6366  //设置多码流关联通道参数配置
#define NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG        6367  //获取设备本地视频输出口分辨率
#define NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG        6368  //设置设备本地视频输出口分辨率
#define NET_DVR_GET_AUDIOOUT_VOLUME_CFG         6369  //获取音频输出口音量调节参数配置
#define NET_DVR_SET_AUDIOOUT_VOLUME_CFG         6370  //设置音频输出口音量调节参数配置
#define NET_DVR_INQUEST_PAUSE_CDW               6371  //暂停刻录
#define NET_DVR_INQUEST_RESUME_CDW              6372  //恢复刻录
#define NET_DVR_GET_INPUT_CHAN_CFG              6373  //获取输入通道配置
#define NET_DVR_SET_INPUT_CHAN_CFG              6374  //设置输入通道配置
#define  NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG    6375    //获取审讯机音频输入混音配置
#define  NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG    6376    //设置审讯机音频输入混音配置
#define     NET_DVR_CASE_INFO_CTRL                    6377    //案件信息显示控制
#define  NET_DVR_GET_INQUEST_USER_RIGHT            6378    //获取审讯机用户权限
#define  NET_DVR_SET_INQUEST_USER_RIGHT            6379    //设置审讯机用户权限
#define NET_DVR_GET_INQUEST_CASE_INFO            6380    //获取审讯案件信息配置
#define NET_DVR_SET_INQUEST_CASE_INFO            6381    //设置审讯案件信息配置

#define    NET_DVR_GET_FILM_MODE_CFG               6387    //获取电影模式
#define    NET_DVR_SET_FILM_MODE_CFG               6388    //设置电影模式
#define    NET_DVR_GET_FILM_MODE_CFG_CAP            6389    //获取电影模式配置能力

#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG       6390    //获取导播策略类型
#define    NET_DVR_SET_DIRECTED_STRATEGY_CFG        6391    //设置导播策略类型
#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP    6392    //获取电影模式配置能力
#define    NET_DVR_GET_FRAME_CFG                    6393    //获取画面边框
#define    NET_DVR_SET_FRAME_CFG                    6394    //设置画面边框
#define    NET_DVR_GET_FRAME_CFG_CAP                6395    //获取画面边框配置能力
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG            6396    //获取音频优化参数
#define    NET_DVR_SET_AUDIO_EFFECTIVE_CFG            6397    //设置音频效果参数
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP        6398    //获取音频效果优化配置能力
#define    NET_DVR_GET_RECORD_VIDEO_CFG              6399    //获取录制视频参数
#define    NET_DVR_SET_RECORD_VIDEO_CFG            6400    //设置录制视频参数


#define NET_DVR_GET_OUTPUT_CFG                  6401        //获取显示输出参数
#define NET_DVR_SET_OUTPUT_CFG                  6402        //设置显示输出参数
#define NET_DVR_CODER_DISPLAY_START             6403        //开始输出
#define NET_DVR_CODER_DISPLAY_STOP              6404        //停止输出
#define NET_DVR_GET_WINDOW_STATUS               6405        //获取显示窗口状态

//VQD功能接口
#define NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG       6406        //获取VQD循环诊断配置参数
#define NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG       6407        //设置VQD循环诊断配置参数
#define NET_DVR_GET_VQD_DIAGNOSE_INFO           6408        //手动获取VQD诊断信息

#define    NET_DVR_RECORDING_PUBLISH_FILE            6421        //文件发布
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP    6422        //获取文件发布能力
#define    NET_DVR_GET_PUBLISH_PROGRESS            6423           //获取发布进度
#define    NET_DVR_GET_RECORD_VIDEO_CFG_CAP        6424        //获取录制视频配置能力
#define    NET_DVR_GET_RTMP_CFG                    6425        //获取RTMP参数
#define    NET_DVR_SET_RTMP_CFG                    6426        //设置RTMP参数
#define    NET_DVR_GET_RTMP_CFG_CAP                  6427        //获取RTMP配置能力
#define    NET_DVR_DEL_BACKGROUND_PIC                6428        //删除背景图片文件
#define    NET_DVR_GET_BACKGROUND_PIC_CFG            6429        //查询背景图片文件
#define    NET_DVR_GET_BACKGROUND_PIC_INFO            6430        //获取哪张图片作为背景图片
#define    NET_DVR_SET_BACKGROUND_PIC_INFO            6431        //设置哪张图片作为背景图片
#define    NET_DVR_GET_BACKGROUND_PIC_INFO_CAP      6432           //获取哪张图片作为背景图片配置能力
#define    NET_DVR_GET_RECORD_HOST_CAP                6433        //获取录播主机总能力
#define NET_DVR_GET_COURSE_LIST                 6434    //获取课程列表
#define    NET_DVR_GET_RECORD_STATUS                6435 //查询录播主机当前状态
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL        6436    //手动课表控制
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG        6437    //获取图像差分检测参数
#define    NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG        6438    //设置图像差分检测参数
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP    6439    //获取图像差分检测配置能力
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO    6440    //获取发布文件信息参数
#define    NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO    6441    //设置发布文件信息参数
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP        6442    //获取发布文件信息配置能力
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP        6443    //获取手动课程录像的能力
#define NET_DVR_GET_STATISTIC_DATA_LIST             6444    //获取统计数据列表

#define    NET_DVR_GET_DEVICE_LAN_ENCODE            6501        //获取设备的语言编码
#define NET_DVR_GET_GBT28181_SERVICE_CFG        6503        //获取GB28181服务器参数
#define NET_DVR_SET_GBT28181_SERVICE_CFG        6504        //设置GB28181服务器参数
#define NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES 6505      //获取GB28181服务器能力

#define NET_DVR_GET_CLOUD_URL               6506    //获取云存储URL
#define NET_DVR_GET_CLOUD_URL_CAP           6507    //获取云存储URL-能力集
#define NET_DVR_GET_CLOUD_CFG               6508    //获取云存储配置参数
#define NET_DVR_SET_CLOUD_CFG               6509    //设置云存储配置参数
#define NET_DVR_GET_CLOUD_CFG_CAP           6510    //获取云存储配置-能力集
#define NET_DVR_GET_CLOUD_UPLOADSTRATEGY    6511    //获取云存储上传策略
#define NET_DVR_SET_CLOUD_UPLOADSTRATEGY    6512    //设置云存储上传策略
#define NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP     6513    //云存储上传策略配置-能力集

#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG        6601        //获取视图库信息
#define    NET_DVR_SET_VIDEO_IMAGE_DB_CFG        6602        //设置视图库信息
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP    6603        //获取视图库相关能力
#define    NET_DVR_GET_FILE_INFO_BY_ID            6604        //根据文件ID获取视图库中文件信息
#define    NET_DVR_QUERY_FILE_INFO_CAP            6605        //根据文件名查询文件信息能力
#define    NET_DVR_DEL_FILE_FROM_DB            6606        //从视图库中删除文件
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CAP        6607        //获取视图库总能力

#define NET_DVR_GET_FIGURE                    6610        //获取缩略图

#define    NET_DVR_SYNC_IPC_PASSWD                  6621        //同步IPC密码与NVR一致

#define    NET_DVR_GET_VEHICLE_BLACKLST_SCHEDULE 6622    //获取黑名单布防时间配置
#define    NET_DVR_SET_VEHICLE_BLACKLST_SCHEDULE 6623    //设置黑名单布防时间配置

#define    NET_DVR_GET_VEHICLE_WHITELST_SCHEDULE 6624    //获取白名单布防时间配置
#define    NET_DVR_SET_VEHICLE_WHITELST_SCHEDULE 6625    //设置白名单布防时间配置

#define    NET_DVR_GET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6626    //获取黑名单布防联动配置
#define    NET_DVR_SET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6627    //设置黑名单布防联动配置

#define    NET_DVR_GET_VEHICLE_WHITELIST_EVENT_TRIGGER     6628    //获取白名单布防联动配置
#define    NET_DVR_SET_VEHICLE_WHITELIST_EVENT_TRIGGER     6629    //设置白名单布防联动配置

#define    NET_DVR_GET_TRAFFIC_CAP    6630    //获取抓拍相关能力集
#define    NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER     6631    //获取全部车辆检测布防联动配置
#define    NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER     6632    //设置全部车辆检测布防联动配置
#define    NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6633    //获取其他单布防联动配置
#define    NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6634    //设置其他单布防联动配置

#define    NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER     6635    //获取存储健康检测联动配置
#define    NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER     6636    //设置存储健康检测联动配置
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES    6637    //获取存储健康检测布防时间能力
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE         6638    //获取存储健康布防时间配置
#define    NET_DVR_SET_STORAGEDETECTION_SCHEDULE         6639    //设置存储健康布防时间配置
#define    NET_DVR_GET_STORAGEDETECTION_STATE             6640    //获取存储健康状态


#define    NET_DVR_GET_FACECAPTURE_EVENT_TRIGGER         6641    //获取人脸抓拍联动配置
#define    NET_DVR_SET_FACECAPTURE_EVENT_TRIGGER         6642    //设置人脸抓拍联动配置
#define    NET_DVR_GET_FACECAPTURE_SCHEDULE_CAPABILITIES 6643    //获取人脸抓拍布防时间能力
#define    NET_DVR_GET_FACECAPTURE_SCHEDULE             6644    //获取人脸抓拍布防时间配置
#define    NET_DVR_SET_FACECAPTURE_SCHEDULE             6645    //设置人脸抓拍布防时间配置
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK             6646    //获取存储侦测的读写锁配置
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES    6647    //获取存储侦测的读写锁配置能力
#define    NET_DVR_SET_STORAGEDETECTION_RWLOCK             6648    //设置存储侦测的读写锁配置
#define    NET_DVR_GET_PTZTRACKSTATUS                     6649    //获取球机联动跟踪状态

#define    NET_DVR_SET_STORAGEDETECTION_UNLOCK             6653    //设置存储侦测的解锁配置
#define    NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES    6654    //获取存储侦测的解锁配置能力

#define    NET_DVR_SET_SHIPSDETECTION_CFG                 6655    //设置船只检测参数配置
#define    NET_DVR_GET_SHIPSDETECTION_CFG                 6656    //获取船只检测参数配置
#define    NET_DVR_GET_SHIPSDETECTION_CAPABILITIES         6657    //获取船只检测参数配置能力
#define    NET_DVR_GET_SHIPSDETECTION_COUNT               6658    //获取船只计数信息
#define    NET_DVR_SHIPSCOUNT_DELETE_CTRL                  6659   //清空船只计数信息

#define    NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES     6660   //获取裸数据叠加能力
#define    NET_DVR_SET_BAREDATAOVERLAY_CFG                 6661    //设置裸数据叠加
#define    NET_DVR_GET_BAREDATAOVERLAY_CFG                 6662    //获取裸数据叠加
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE             6663    //获取船只检测布防时间配置
#define    NET_DVR_SET_SHIPSDETECTION_SCHEDULE             6664    //设置船只检测布防时间配置
#define    NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER     6665    //获取船只检测联动配置
#define    NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER     6666    //设置船只检测联动配置
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES    6667    //获取船只检测布防时间能力

#define    NET_DVR_FIRE_FOCUSZOOM_CTRL         6670        //火点可见光镜头聚焦变倍

#define    NET_DVR_GET_MANUALRANGING_CAPABILITIES    6675    //获取手动测距配置能力

#define    NET_DVR_SET_MANUALRANGING           6677        //设置手动测距参数
#define    NET_DVR_GET_MANUALDEICING_CAPABILITIES    6678//获取手动除冰配置能力
#define    NET_DVR_SET_MANUALDEICING           6679        //设置手动除冰
#define    NET_DVR_GET_MANUALDEICING           6680        //获取手动除冰

#define NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES    6720 //隐藏信息配置能力
#define NET_DVR_GET_HIDDEN_INFORMATION                 6721 //获取隐藏信息参数
#define NET_DVR_SET_HIDDEN_INFORMATION                 6722 //设置隐藏信息参数
#define NET_DVR_GET_MB_POWERCTRLPARA            8000//获取启动控制参数
#define    NET_DVR_SET_MB_POWERCTRLPARA            8001 //设置启动控制参数
#define NET_DVR_GET_AUTOBACKUPPARA                8002//获取自动备份参数
#define NET_DVR_SET_AUTOBACKUPPARA                8003 //设置自动备份参数
#define NET_DVR_GET_MB_GPSPARA                    8004//获取GPS参数
#define NET_DVR_SET_MB_GPSPARA                    8005 //设置GPS参数
#define NET_DVR_GET_MB_SENSORINPARA                8006//获取SENSOR参数
#define NET_DVR_SET_MB_SENSORINPARA                8007 //设置SENSOR参数
#define NET_DVR_GET_GSENSORPARA                    8008//获取GSENSOR参数
#define NET_DVR_SET_GSENSORPARA                    8009 //设置GSENSOR参数
#define NET_DVR_GET_MB_DOWNLOADSVRPARA            8010//获取下载服务器参数
#define NET_DVR_SET_MB_DOWNLOADSVRPARA            8011//设置下载服务器参数
#define NET_DVR_GET_PLATERECOG_PARA                8012//获取车牌识别参数
#define NET_DVR_SET_PLATERECOG_PARA                8013//设置车牌识别参数
#define NET_DVR_GET_ENFORCESYS_PARA                8014//获取车辆稽查参数
#define NET_DVR_SET_ENFORCESYS_PARA                8015//设置车辆稽查参数
#define NET_DVR_GET_GPS_DATA                    8016 //获取GPS数据
#define NET_DVR_GET_ANALOG_ALARMINCFG            8017//获取模拟报警输入参数
#define NET_DVR_SET_ANALOG_ALARMINCFG            8018//设置模拟报警输入参数

/*****************************电视墙 start****************************/
#define    NET_DVR_MATRIX_WALL_SET                    9001  //设置电视墙中屏幕参数
#define    NET_DVR_MATRIX_WALL_GET                    9002  //获取电视墙中屏幕参数
#define    NET_DVR_WALLWIN_GET                        9003  //电视墙中获取窗口参数
#define    NET_DVR_WALLWIN_SET                        9004  //电视墙中设置窗口参数
#define    NET_DVR_WALLWINPARAM_SET                9005  //设置电视墙窗口相关参数
#define    NET_DVR_WALLWINPARAM_GET                9006  //获取电视墙窗口相关参数
#define NET_DVR_WALLSCENEPARAM_GET                9007  //设置场景模式参数
#define NET_DVR_WALLSCENEPARAM_SET                9008  //获取场景模式参数
#define NET_DVR_MATRIX_GETWINSTATUS             9009  //获取窗口解码状态
#define    NET_DVR_GET_WINASSOCIATEDDEVINFO        9010  //电视墙中获取对应资源信息
#define    NET_DVR_WALLOUTPUT_GET                    9011  //电视墙中获取显示输出参数
#define    NET_DVR_WALLOUTPUT_SET                    9012  //电视墙中设置显示输出参数
#define NET_DVR_GET_UNITEDMATRIXSYSTEM          9013  //电视墙中获取对应资源
#define NET_DVR_GET_WALL_CFG                    9014  //获取电视墙全局参数
#define NET_DVR_SET_WALL_CFG                    9015  //设置电视墙全局参数
#define NET_DVR_CLOSE_ALL_WND                    9016  //关闭所有窗口
#define NET_DVR_SWITCH_WIN_TOP                  9017  //窗口置顶
#define NET_DVR_SWITCH_WIN_BOTTOM               9018  //窗口置底

#define    NET_DVR_CLOSE_ALL_WND_V41                9019  //电视墙关闭所有窗口v41（有多个电视墙）
#define    NET_DVR_GET_WALL_WINDOW_V41                9020  //获取电视墙中的窗口v41
#define    NET_DVR_SET_WALL_WINDOW_V41                9021  //设置电视墙中的窗口v41
#define    NET_DVR_GET_CURRENT_SCENE_V41            9022  //获取当前电视墙中正在使用的场景v41
#define    NET_DVR_GET_WALL_SCENE_PARAM_V41        9023  //获取当前电视墙中正在使用的场景v41
#define    NET_DVR_SET_WALL_SCENE_PARAM_V41        9024  //设置当前电视墙中正在使用的场景v41
#define NET_DVR_GET_MATRIX_LOGO_CFG             9025  //获取logo参数
#define NET_DVR_SET_MATRIX_LOGO_CFG             9026  //设置logo参数
#define NET_DVR_GET_WIN_LOGO_CFG                9027  //获取窗口logo参数
#define NET_DVR_SET_WIN_LOGO_CFG                9028  //设置窗口logo参数
#define NET_DVR_DELETE_LOGO                     9029  //删除logo
#define NET_DVR_SET_DISPLAY_EFFECT_CFG            9030  //设置显示输出效果参数v41
#define NET_DVR_GET_DISPLAY_EFFECT_CFG            9031  //获取显示输出效果参数v41
#define NET_DVR_DEC_PLAY_REMOTE_FILE            9032  //解码播放远程文件
#define NET_DVR_GET_WIN_ZOOM_STATUS             9033  //获取窗口电子放大状态
#define NET_DVR_GET_ALL_MATRIX_LOGOCFG          9034  //获取所有logo参数

/*****************************电视墙 end******************************/

/*******************************LCD拼接屏 begin******************************************/
#define NET_DVR_SIMULATE_REMOTE_CONTROL         9035    //模拟遥控按键 2013-09-05
#define NET_DVR_SET_SCREEN_SIGNAL_CFG            9036    //设置屏幕信号源参数
#define    NET_DVR_GET_SCREEN_SIGNAL_CFG            9037    //获取屏幕信号源参数
#define NET_DVR_SET_SCREEN_SPLICE_CFG              9038    //设置屏幕拼接
#define    NET_DVR_GET_SCREEN_SPLICE_CFG            9039    //获取屏幕拼接
#define NET_DVR_GET_SCREEN_FAN_WORK_MODE         9040    //获取风扇工作方式
#define NET_DVR_SET_SCREEN_FAN_WORK_MODE         9041    //设置风扇工作方式
#define NET_DVR_SHOW_SCREEN_WORK_STATUS          9044    //显示屏幕状态
#define NET_DVR_GET_VGA_CFG                      9045    //获取VGA信号配置
#define NET_DVR_SET_VGA_CFG                      9046    //设置VGA信号配置
#define NET_DVR_GET_SCREEN_MENU_CFG                9048   //获取屏幕菜单配置
#define NET_DVR_SET_SCREEN_MENU_CFG              9049    //设置屏幕菜单配置
#define NET_DVR_SET_SCREEN_DISPLAY_CFG          9050    //设置显示参数 2013-08-28
#define    NET_DVR_GET_SCREEN_DISPLAY_CFG            9051    //获取显示参数 2013-08-28

#define NET_DVR_SET_FUSION_CFG                    9052    //设置图像融合参数
#define NET_DVR_GET_FUSION_CFG                    9053    //获取图像融合参数

#define NET_DVR_SET_PIP_CFG                      9060    //设置画中画参数
#define    NET_DVR_GET_PIP_CFG                        9061    //获取画中画参数
#define NET_DVR_SET_DEFOG_LCD                      9073    //设置透雾参数
#define    NET_DVR_GET_DEFOG_LCD                    9074    //获取透雾参数
#define NET_DVR_SHOW_IP                          9075    //显示IP
#define NET_DVR_SCREEN_MAINTENANCE_WALL            9076    //屏幕维墙
#define NET_DVR_SET_SCREEN_POS                  9077    //设置屏幕位置参数
#define    NET_DVR_GET_SCREEN_POS                    9078    //获取屏幕位置参数
/*******************************LCD拼接屏 end******************************************/

/*******************************LCD拼接屏V1.2 begin******************************************/
#define    NET_DVR_SCREEN_INDEX_SET                9079    //屏幕索引相关参数设置
#define    NET_DVR_SCREEN_INDEX_GET                9080    //屏幕索引相关参数获取
#define NET_DVR_SCREEN_SPLICE_SET               9081    //设置屏幕拼接参数
#define NET_DVR_SCREEN_SPLICE_GET               9082    //获取屏幕拼接参数
#define NET_DVR_SET_SCREEN_PARAM                9083    //设置屏幕相关参数
#define NET_DVR_GET_SCREEN_PARAM                9084    //获取屏幕相关参数
#define NET_DVR_SET_SWITCH_CFG                  9085    //设置定时开关机参数
#define NET_DVR_GET_SWITCH_CFG                  9086    //获取定时开关机参数
#define NET_DVR_SET_POWERON_DELAY_CFG           9087    //设置延时开机参数
#define NET_DVR_GET_POWERON_DELAY_CFG           9088    //获取延时开机参数
#define    NET_DVR_SET_SCREEN_POSITION                9089    //设置屏幕位置参数
#define    NET_DVR_GET_SCREEN_POSITION                9090    //获取屏幕位置参数
#define NET_DVR_SCREEN_SCENE_CONTROL            9091    //屏幕场景控制
#define NET_DVR_GET_CURRENT_SCREEN_SCENE        9092    //获取当前屏幕场景号
#define NET_DVR_GET_SCREEN_SCENE_PARAM          9093    //获取屏幕场景模式参数
#define NET_DVR_SET_SCREEN_SCENE_PARAM          9094    //设置屏幕场景模式参数
#define NET_DVR_GET_EXTERNAL_MATRIX_RELATION    9095    //获取外接矩阵输入输出关联关系
#define NET_DVR_GET_LCD_AUDIO_CFG                9096     //获取LCD屏幕音频参数
#define NET_DVR_SET_LCD_AUDIO_CFG                9097     //设置LCD屏幕音频参数
#define NET_DVR_GET_LCD_WORK_STATE                9098     //获取LCD屏幕工作状态
#define NET_DVR_GET_BOOT_LOGO_CFG                9099    //获取LCD屏幕开机logo显示参数
#define NET_DVR_SET_BOOT_LOGO_CFG                9100    //设置LCD屏幕开机logo显示参数

/*******************************LCD拼接屏V1.2 end ******************************************/



#define NET_DVR_GET_STREAM_DST_COMPRESSIONINFO    9101  //获取目标压缩参数
#define NET_DVR_SET_STREAM_DST_COMPRESSIONINFO  9102  //设置目标压缩参数
#define NET_DVR_GET_STREAM_TRANS_STATUS            9103  //获取流状态
#define NET_DVR_GET_DEVICE_TRANS_STATUS            9104  //获取设备转码状态
#define NET_DVR_GET_ALLSTREAM_SRC_INFO          9105  //获取所有流信息
#define NET_DVR_GET_BIG_SCREEN_AUDIO            9106  //获取大屏音频信息
#define NET_DVR_SET_BIG_SCREEN_AUDIO            9107  //设置大屏音频信息
#define NET_DVR_GET_DEV_WORK_MODE                9108  //获取转码设备工作模式
#define NET_DVR_SET_DEV_WORK_MODE                9109  //设置转码设备工作模式
#define NET_DVR_APPLY_TRANS_CHAN                9110  //按流ID申请转码通道
#define NET_DVR_GET_DISPCHAN_CFG                9111  //批量获取显示通道参数
#define NET_DVR_SET_DISPCHAN_CFG                9112  //批量设置显示通道参数

#define NET_DVR_GET_DEC_CHAN_STATUS                9113  //获取解码通道解码状态
#define NET_DVR_GET_DISP_CHAN_STATUS            9114  //获取显示通道状态        
#define NET_DVR_GET_ALARMIN_STATUS                9115  //获取报警输入状态
#define NET_DVR_GET_ALARMOUT_STATUS                9116  //获取报警输出状态
#define NET_DVR_GET_AUDIO_CHAN_STATUS            9117  //获取语音对讲状态

#define    NET_DVR_GET_VIDEO_AUDIOIN_CFG            9118   //获取视频的音频输入参数
#define NET_DVR_SET_VIDEO_AUDIOIN_CFG            9119   //设置视频的音频输入参数

#define    NET_DVR_SET_BASEMAP_CFG                    9120  //设置底图参数
#define NET_DVR_GET_BASEMAP_CFG                    9121  //获取底图参数
#define NET_DVR_GET_VIRTUAL_SCREEN_CFG          9122  //获取超高清输入子系统参数
#define NET_DVR_SET_VIRTUAL_SCREEN_CFG          9123  //设置超高清输入子系统参数
#define NET_DVR_GET_BASEMAP_WIN_CFG                9124  //获取底图窗口参数
#define NET_DVR_SET_BASEMAP_WIN_CFG                9125  //设置底图窗口参数
#define NET_DVR_DELETE_PICTURE                    9126  //删除底图
#define NET_DVR_GET_BASEMAP_PIC_INFO            9127  //获取底图图片信息
#define    NET_DVR_SET_BASEMAP_WIN_CFG_V40         9128  //设置底图窗口参数V40
#define NET_DVR_GET_BASEMAP_WIN_CFG_V40         9129  //获取底图窗口参数V40

#define NET_DVR_GET_DEC_VCA_CFG                    9130    //获取解码器智能报警参数
#define NET_DVR_SET_DEC_VCA_CFG                    9131    //设置解码器智能报警参数

#define NET_DVR_GET_TERMINAL_CONFERENCE_STATUS    9136    //获取终端会议状态
#define NET_DVR_GET_TERMINAL_INPUT_CFG_CAP        9137    //获取终端输入参数能力
#define NET_DVR_GET_TERMINAL_INPUT_CFG            9138    //获取终端视频会议输入参数
#define NET_DVR_SET_TERMINAL_INPUT_CFG            9139    //设置终端视频会议输入参数

#define NET_DVR_GET_CONFERENCE_REGION_CAP        9140    //获取终端会议区域能力
#define NET_DVR_GET_CONFERENCE_REGION            9141    //获取终端会议区域参数
#define NET_DVR_SET_CONFERENCE_REGION            9142    //设置终端会议区域参数
#define NET_DVR_GET_TERMINAL_CALL_CFG_CAP        9143    //获取终端呼叫配置能力
#define NET_DVR_GET_TERMINAL_CALL_CFG            9144    //获取终端呼叫参数
#define NET_DVR_SET_TERMINAL_CALL_CFG            9145    //设置终端呼叫参数
#define NET_DVR_GET_TERMINAL_CTRL_CAP            9146    //获取终端呼叫控制能力
#define NET_DVR_TERMINAL_CTRL                    9147    //终端呼叫控制
#define    NET_DVR_GET_CALL_QUERY_CAP                9148    //获取会议查找能力
#define NET_DVR_GET_CALLINFO_BY_COND            9149    //按条件查询呼叫记录

#define    NET_DVR_SET_FUSION_SCALE                9150    //设置图像融合规模
#define NET_DVR_GET_FUSION_SCALE                9151    //获取图像融合规模

#define NET_DVR_GET_VCS_CAP                        9152    //获取MCU能力集


#define NET_DVR_GET_TERMINAL_GK_CFG_CAP            9153    //获取终端注册GK能力
#define NET_DVR_GET_TERMINAL_GK_CFG                9154    //获取终端注册GK参数
#define NET_DVR_SET_TERMINAL_GK_CFG                9155    //设置终端注册GK参数
#define NET_DVR_GET_MCU_CONFERENCESEARCH_CAP    9156    //获取MCU设备的能力

#define    NET_DVR_GET_LLDP_CFG                    9160    //获取LLDP参数
#define    NET_DVR_SET_LLDP_CFG                    9161    //设置LLDP参数
#define NET_DVR_GET_LLDP_CAP                    9162    //获取LLDP能力集
#define    NET_DVR_GET_FIBER_CONVERT_BASIC_INFO    9163    //获取光纤收发器基本信息
#define    NET_DVR_GET_FIBER_CONVERT_WORK_STATE    9164    //获取光纤收发器工作状
#define    NET_DVR_GET_FIBER_CONVERT_TOPOLOGY      9165    //获取光纤收发器拓扑信息
#define    NET_DVR_GET_FC_PORT_REMARKS                9166    //获取光纤收发器端口注释参数
#define    NET_DVR_SET_FC_PORT_REMARKS                9167    //设置光纤收发器端口注释参数
#define NET_DVR_GET_PORT_REMARKS_CAP            9168    //获取光纤收发器端口注释能力集

#define NET_DVR_GET_MCU_CONFERENCECONTROL_CAP   9169    //获取会议控制能力
#define NET_DVR_GET_MCU_TERMINALCONTROL_CAP     9170    //获取终端控制能力
#define NET_DVR_GET_MCU_TERIMINALGROUP_CAP      9171    //获取终端分组能力
#define NET_DVR_GET_MCU_TERMINAL_CAP            9174    //获取终端管理能力
#define NET_DVR_GET_MCU_CONFERENCE_CAP          9175    //获取会议能力
#define NET_DVR_GET_MCU_GK_CFG_CAP              9176    //获取MCUGK配置能力
#define NET_DVR_GET_MCU_GK_SERVER_CAP           9177    //获取MCUGK服务能力

#define NET_DVR_GET_OUTPUT_PIC_INFO             9200    //获取输出口图片参数
#define NET_DVR_SET_OUTPUT_PIC_INFO             9201    //设置输出口图片参数
#define NET_DVR_GET_OUTPUT_PIC_WIN_CFG          9202    //获取输出口图片窗口参数
#define NET_DVR_SET_OUTPUT_PIC_WIN_CFG          9203    //设置输出口图片窗口参数
#define NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG      9204    //获取输出口所有图片窗口参数
#define NET_DVR_DELETE_OUPUT_PIC                9205    //删除输出口图片
#define NET_DVR_GET_OUTPUT_OSD_CFG              9206    //获取输出口OSD参数
#define NET_DVR_SET_OUTPUT_OSD_CFG              9207    //设置输出口OSD参数
#define NET_DVR_GET_OUTPUT_ALL_OSD_CFG          9208    //获取输出口所有OSD参数
#define NET_DVR_GET_CHAN_RELATION               9209    //获取编码通道关联资源参数
#define NET_DVR_SET_CHAN_RELATION               9210    //设置编码通道关联资源参数
#define NET_DVR_GET_ALL_CHAN_RELATION           9211    //获取所有编码通道关联资源参数
#define NET_DVR_GET_NS_RING_CFG                    9212    //获取光纤板环网配置
#define NET_DVR_SET_NS_RING_CFG                   9213    //设置光纤板环网配置
#define NET_DVR_GET_NS_RING_STATUS              9214    //获取光纤板环网状态
#define NET_DVR_GET_OPTICAL_PORT_INFO            9220    //获取光口信息
#define NET_DVR_SET_OPTICAL_PORT_INFO            9221    //设置光口信息
#define NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG        9222    //获取编码通道关联光口输入源参数
#define NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG        9223    //设置编码通道关联光口输入源参数
#define  NET_DVR_GET_WIN_ROAM_SWITCH_CFG        9224    //获取解码器窗口漫游开关参数
#define  NET_DVR_SET_WIN_ROAM_SWITCH_CFG        9225    //设置解码器窗口漫游开关参数
#define    NET_DVR_START_SCREEN_CRTL                9226    //开始屏幕控制
#define    NET_DVR_GET_SCREEN_FLIE_LIST            9227    //获取屏幕文件列表
#define    NET_DVR_GET_SCREEN_FILEINFO                9228    //获取屏幕文件信息参数
#define    NET_DVR_SET_SCREEN_FILEINFO             9229    //设置屏幕文件信息参数

/*******************************小间距LED显示屏 begin***************************************/
#define NET_DVR_GET_LED_OUTPUT_CFG                9230    //获取发送卡输出参数
#define NET_DVR_SET_LED_OUTPUT_CFG                9231    //设置发送卡输出参数
#define NET_DVR_GET_LED_OUTPUT_PORT_CFG            9232    //获取LED发送卡输出端口参数
#define NET_DVR_SET_LED_OUTPUT_PORT_CFG            9233    //设置LED发送卡输出端口参数
#define NET_DVR_GET_LED_DISPLAY_AREA_CFG        9234    //获取LED发送卡显示区域
#define NET_DVR_SET_LED_DISPLAY_AREA_CFG        9235    //设置LED发送卡显示区域
#define NET_DVR_GET_LED_PORT_CFG                9236    //获取LED发送卡端口参数
#define NET_DVR_SET_LED_PORT_CFG                9237    //设置LED发送卡端口参数
#define NET_DVR_GET_LED_DISPLAY_CFG                9238    //获取LED发送卡显示参数
#define NET_DVR_SET_LED_DISPLAY_CFG                9239    //设置LED发送卡显示参数
#define NET_DVR_GET_ALL_LED_PORT_CFG            9240    //获取LED发送卡某个输出对应
#define NET_DVR_SAVE_LED_CONFIGURATION            9241    //参数固化
#define NET_DVR_GET_LED_TEST_SIGNAL_CFG            9242    //获取LED屏测试信号参数
#define NET_DVR_SET_LED_TEST_SIGNAL_CFG            9243    //设置LED屏测试信号参数
#define NET_DVR_GET_LED_NOSIGNAL_CFG            9244    //获取LED屏无信号显示模式参数
#define NET_DVR_SET_LED_NOSIGNAL_CFG            9245    //设置LED屏无信号显示模式参数
#define NET_DVR_GET_LED_INPUT_CFG                9246    //获取LED发送卡输入参数
#define NET_DVR_SET_LED_INPUT_CFG                9247    //设置LED发送卡输入参数
#define NET_DVR_GET_LED_RECV_GAMMA_CFG            9248    //获取接收卡GAMMA表参数
#define NET_DVR_SET_LED_RECV_GAMMA_CFG            9249    //设置接收卡GAMMA表参数
#define NET_DVR_GET_LED_RECV_CFG                9250    //获取接收卡基本参数
#define NET_DVR_SET_LED_RECV_CFG                9251    //设置接收卡基本参数
#define NET_DVR_GET_LED_RECV_ADVANCED_CFG        9252    //获取接收卡高级参数
#define NET_DVR_SET_LED_RECV_ADVANCED_CFG        9253    //设置接收卡高级参数
#define NET_DVR_GET_LED_SCREEN_DISPLAY_CFG        9254    //获取LED屏显示参数
#define NET_DVR_SET_LED_SCREEN_DISPLAY_CFG        9255    //设置LED屏显示参数
/*******************************小间距LED显示屏 end*****************************************/

#define    NET_DVR_GET_SCREEN_CONFIG               9260    //获取屏幕服务器参数
#define    NET_DVR_SET_SCREEN_CONFIG               9261    //设置屏幕服务器参数
#define NET_DVR_GET_SCREEN_CONFIG_CAP              9262    //获取屏幕服务器参数能力集

#define    NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS    9271    //获取日程发布进度
#define    NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS    9272    //获取信息发布终端升级进度

#define NET_DVR_GET_INPUT_BOARD_CFG                9281    //获取输入板配置信息
#define NET_DVR_GET_INPUT_BOARD_CFG_LIST        9282    //获取输入板配置信息列表
#define NET_DVR_SET_INPUT_BOARD_CFG                9283    //设置输入板配置信息

#define NET_DVR_GET_INPUT_SOURCE_TEXT_CAP    9284            //获取输入源字符叠加能力
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG    9285            //获取输入源字符叠加参数
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT 9286        //获取输入源字符叠加参数列表
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG    9287            //设置输入源字符叠加参数
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST 9288        //设置输入源字符叠加参数列表
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP    9289    //获取输入源自定义分辨率能力
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG    9290    //获取输入源自定义分辨率参数
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST    9291 //获取输入源自定义分辨率列表
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG    9292    //设置输入源自定义分辨率参数
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST  9293  //设置输入源自定义分辨率参数
#define NET_DVR_GET_LED_AREA_INFO_LIST  9295  //获取LED区域列表

#define NET_DVR_GET_CURRENT_VALID_PORT          9300    //获取当前有效的,可以连接的端口

#define    NET_DVR_SET_ONLINE_UPGRADE                9301    //允许在线升级
#define NET_DVR_GET_ONLINEUPGRADE_PROGRESS      9302    //获取在线升级进度
#define    NET_DVR_GET_FIRMWARECODE                9303    //获取识别码
#define NET_DVR_GET_ONLINEUPGRADE_SERVER        9304    //获取升级服务器状态
#define NET_DVR_GET_ONLINEUPGRADE_VERSION       9305    //获取新版本信息
#define NET_DVR_GET_RECOMMEN_VERSION            9306    //检测是否推荐升级到此版本
#define NET_DVR_GET_ONLINEUPGRADE_ABILITY       9309    //获取在线升级能力集

#define NET_DVR_GET_RS485_WORK_MODE             10001 //获取RS485串口工作模式
#define NET_DVR_SET_RS485_WORK_MODE             10002 //设置RS485串口工作模式
#define NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG     10003 //获取码分器透明通道参数
#define NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG     10004 //设置码分器透明通道参数

#define  NET_DVR_GET_SIP_CFG                    11001   //IP可视化机获取SIP参数
#define  NET_DVR_SET_SIP_CFG                    11002   //IP可视化机设置SIP参数
#define  NET_DVR_GET_IP_VIEW_DEVCFG                11003   //获取IP对讲分机配置
#define  NET_DVR_SET_IP_VIEW_DEVCFG                11004   //设置IP对讲分机配置
#define  NET_DVR_GET_IP_VIEW_AUDIO_CFG            11005   //获取IP对讲分机音频参数
#define  NET_DVR_SET_IP_VIEW_AUDIO_CFG            11006   //设置IP对讲分机音频参数
#define     NET_DVR_GET_IP_VIEW_CALL_CFG            11007   //获取IP对讲分机呼叫参数
#define  NET_DVR_SET_IP_VIEW_CALL_CFG            11008   //设置IP对讲分机呼叫参数
#define     NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG        11009    //获取声音超限配置参数
#define     NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG        11010    //设置声音超限配置参数
#define     NET_DVR_GET_BUTTON_DOWN_ALARM_CFG        11011    //获取按钮按下告警配置参数
#define     NET_DVR_SET_BUTTON_DOWN_ALARM_CFG        11012    //设置按钮按下告警配置参数

#define  NET_DVR_GET_ISCSI_CFG                  11070   // 获取ISCSI存储配置协议 
#define  NET_DVR_SET_ISCSI_CFG                  11071   // 获取ISCSI存储配置协议 

#define NET_DVR_GET_SECURITYMODE                12004   //获取当前安全模式
//2013-11-21 获取设备当前的温度和湿度
#define  NET_DVR_GET_TEMP_HUMI                  12005

//2014-02-15 民用IPC自动化测试项目
#define  NET_DVR_SET_ALARMSOUNDMODE             12006   //设置报警声音模式
#define  NET_DVR_GET_ALARMSOUNDMODE             12007   //获取报警声音模式

#define    NET_DVR_SET_IPDEVICE_ACTIVATED       13000//通过NVR激活前端设备
#define NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS    13001   //获取数字通道对应设备安全状态
#define    NET_DVR_GET_ACTIVATE_IPC_ABILITY     13003    //获取NVR激活IPC能力集


/*******************************楼宇可视对讲机 start***********************************/
#define NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG  16001  //获取可视对讲设备编号
#define NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG  16002  //设置可视对讲设备编号
#define NET_DVR_SET_PRIVILEGE_PASSWORD           16003  //设置权限密码配置信息
#define NET_DVR_GET_OPERATION_TIME_CFG           16004  //获取操作时间配置
#define NET_DVR_SET_OPERATION_TIME_CFG           16005  //设置操作时间配置
#define NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG 16006  //获取关联网络设备参数
#define NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG 16007  //设置关联网络设备参数
#define NET_DVR_REMOTECONTROL_NOTICE_DATA        16008  //公告信息下发
#define NET_DVR_REMOTECONTROL_GATEWAY            16009  //远程开锁
#define NET_DVR_REMOTECONTROL_OPERATION_AUTH     16010  //操作权限验证

#define NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG      16016  //获取IO输入参数
#define NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG      16017  //设置IO输入参数
#define NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG     16018  //获取IO输出参数
#define NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG     16019  //设置IO输出参数
#define NET_DVR_GET_ELEVATORCONTROL_CFG          16020  //获取梯控器参数
#define NET_DVR_SET_ELEVATORCONTROL_CFG          16021  //设置梯控器参数
#define NET_DVR_GET_VIDEOINTERCOM_STREAM         16022  //获取可视对讲流通道参数
#define NET_DVR_SET_VIDEOINTERCOM_STREAM         16023  //设置可视对讲流通道参数
#define NET_DVR_GET_WDR_CFG                      16024  //获取宽动态参数配置
#define NET_DVR_SET_WDR_CFG                      16025  //设置宽动态参数配置
#define NET_DVR_GET_VIS_DEVINFO                  16026  //获取可设备编号信息
#define NET_DVR_GET_VIS_REGISTER_INFO            16027  //获取可设备注册的设备信息
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V40      16028  //获取梯控器参数-扩展
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V40      16029  //设置梯控器参数-扩展
#define NET_DVR_GET_CALL_ROOM_CFG                 16030  //获取按键呼叫住户配置
#define NET_DVR_SET_CALL_ROOM_CFG                 16031  //设置按键呼叫住户配置
#define NET_DVR_VIDEO_CALL_SIGNAL_PROCESS        16032  //可视话对讲信令处理
#define NET_DVR_GET_CALLER_INFO                  16033  //获取主叫长号信息
#define NET_DVR_GET_CALL_STATUS                  16034  //获取通话状态
#define NET_DVR_GET_SERVER_DEVICE_INFO           16035  //获取设备列表
#define NET_DVR_SET_CALL_SIGNAL                  16036  //可视对讲手机端发送信令
#define NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG       16037    //获取可视对讲报警事件参数
#define NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG       16038    //设置可视对讲报警事件参数
#define NET_DVR_GET_RING_LIST                    16039    //查询铃音参数列表
/*******************************楼宇可视对讲机 end***********************************/

#define    NET_DVR_DEBUGINFO_START                     18000    //网传设备调试信息启动命令
#define    NET_DVR_AUTO_TEST_START                     18001    //自动测试长连接获取

#define NET_DVR_GET_SELFCHECK_RESULT        20000    //获取设备自检结果
#define NET_DVR_SET_TEST_COMMAND            20001    //设置测试控制命令
#define NET_DVR_SET_TEST_DEVMODULE          20002    //设置测试硬件模块控制命令
#define NET_DVR_GET_TEST_DEVMODULE          20003    //获取测试硬件模块控制命令

#define NET_DVR_SET_AUTOFOCUS_TEST          20004    //保存自动对焦参数 2013-10-26
#define NET_DVR_CHECK_USER_STATUS           20005    //检测用户是否在线
#define NET_DVR_GET_TEST_COMMAND            20010    //获取测试控制命令
#define NET_DVR_GET_DIAL_SWITCH_CFG         20200    //获取拨码开关信息
#define NET_DVR_SET_AGING_TRICK_SCAN          20201  //设置老化前后工具参数
#define NET_DVR_GET_ECCENTRIC_CORRECT_STATE   20202  //获取获取偏心校正状态


#define NET_DVR_T1_TEST_CMD                    131073 //当测试命令来用，通过数据区域的文本内容区分具体做什么.数据长度不得大于1024
//数据区格式为：<T1TestCmd type="0"/>//恢复设备默认参数并关机。

// 美分定制菜单输出模式外部命令
#define NET_DVR_GET_MEMU_OUTPUT_MODE            155649            // 获取菜单输出模式
#define NET_DVR_SET_MEMU_OUTPUT_MODE            155650            // 设置菜单输出模式

/***************************DS9000新增命令(_V30) end *****************************/

#define NET_DVR_GET_TEST_VERSION_HEAD           268435441   //获取测试版本头
#define NET_DVR_SET_TEST_VERSION_HEAD           268435442   //设置测试版本头
#define NET_DVR_GET_TEST_VERSION_HEAD_V1        268435443   //获取测试版本头-第二版
#define NET_DVR_SET_TEST_VERSION_HEAD_V1        268435444   //设置测试版本头-第二版
#define NET_DVR_GET_TEST_VERSION_HEAD_V2        268435445   //获取测试版本头-第三版
#define NET_DVR_SET_TEST_VERSION_HEAD_V2        268435446   //设置测试版本头-第三版

#define NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0    268435447   //获取测试版本头,当前仅有一个版本
#define NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0    268435448   //设置测试版本头,当前仅有一个版本


#define MAX_LOCAL_ADDR_LEN             96        //SOCKS最大本地网段个数
#define    MAX_COUNTRY_NAME_LEN          4        //国家简写名称长度

/************************DVR日志 begin***************************/

/* 报警 */
//主类型
#define MAJOR_ALARM                        0x1
//次类型
#define MINOR_ALARM_IN                    0x1        /* 报警输入 */
#define MINOR_ALARM_OUT                    0x2        /* 报警输出 */
#define MINOR_MOTDET_START                0x3        /* 移动侦测报警开始 */
#define MINOR_MOTDET_STOP                0x4        /* 移动侦测报警结束 */
#define MINOR_HIDE_ALARM_START            0x5        /* 遮挡报警开始 */
#define MINOR_HIDE_ALARM_STOP            0x6        /* 遮挡报警结束 */
#define MINOR_VCA_ALARM_START            0x7        /*智能报警开始*/
#define MINOR_VCA_ALARM_STOP            0x8        /*智能报警停止*/
#define MINOR_ITS_ALARM_START           0x09    // 交通事件报警开始
#define MINOR_ITS_ALARM_STOP            0x0A    // 交通事件报警结束
//2010-11-10 网络报警日志
#define MINOR_NETALARM_START            0x0b    /*网络报警开始*/
#define MINOR_NETALARM_STOP             0x0c    /*网络报警结束*/
//2010-12-16 报警板日志，与"MINOR_ALARM_IN"配对使用
#define MINOR_NETALARM_RESUME            0x0d    /*网络报警恢复*/
//2012-4-5 IPC PIR、无线、呼救报警
#define MINOR_WIRELESS_ALARM_START      0x0e  /* 无线报警开始 */
#define MINOR_WIRELESS_ALARM_STOP          0x0f /* 无线报警结束 */
#define MINOR_PIR_ALARM_START           0x10  /* 人体感应报警开始 */
#define MINOR_PIR_ALARM_STOP               0x11  /* 人体感应报警结束 */
#define MINOR_CALLHELP_ALARM_START      0x12  /* 呼救报警开始 */
#define MINOR_CALLHELP_ALARM_STOP          0x13  /* 呼救报警结束 */
#define MINOR_IPCHANNEL_ALARMIN_START   0x14  //数字通道报警输入开始：PCNVR在接收到数字通道的MINOR_ALARM_IN产生“数字通道报警输入开始”，10s，再收不到MINOR_ALARM_IN，产生“数字通道报警输入结束”
#define MINOR_IPCHANNEL_ALARMIN_STOP    0x15  //数字通道报警输入开始：同上
#define MINOR_DETECTFACE_ALARM_START    0x16  /* 人脸侦测报警开始 */
#define MINOR_DETECTFACE_ALARM_STOP      0x17  /* 人脸侦测报警结束 */
#define MINOR_VQD_ALARM_START           0x18  //VQD报警
#define MINOR_VQD_ALARM_STOP            0x19  //VQD报警结束 
#define MINOR_VCA_SECNECHANGE_DETECTION 0x1a  //场景侦测报警 2013-07-16

#define MINOR_SMART_REGION_EXITING_BEGIN            0x1b  //离开区域侦测开始
#define MINOR_SMART_REGION_EXITING_END              0x1c  //离开区域侦测结束
#define MINOR_SMART_LOITERING_BEGIN                 0x1d  //徘徊侦测开始
#define MINOR_SMART_LOITERING_END                   0x1e  //徘徊侦测结束

#define MINOR_VCA_ALARM_LINE_DETECTION_BEGIN        0x20  
#define MINOR_VCA_ALARM_LINE_DETECTION_END          0x21  
#define MINOR_VCA_ALARM_INTRUDE_BEGIN                0x22  //区域侦测开始    
#define MINOR_VCA_ALARM_INTRUDE_END                       0x23  //区域侦测结束    
#define MINOR_VCA_ALARM_AUDIOINPUT                    0x24   //音频异常输入
#define MINOR_VCA_ALARM_AUDIOABNORMAL                 0x25   //声强突变
#define MINOR_VCA_DEFOCUS_DETECTION_BEGIN           0x26  //虚焦侦测开始
#define MINOR_VCA_DEFOCUS_DETECTION_END                0x27  //虚焦侦测结束

//民用NVR
#define MINOR_EXT_ALARM                             0x28/*IPC外部报警*/
#define MINOR_VCA_FACE_ALARM_BEGIN                    0x29    /*人脸侦测开始*/
#define MINOR_SMART_REGION_ENTRANCE_BEGIN           0x2a  //进入区域侦测开始
#define MINOR_SMART_REGION_ENTRANCE_END             0x2b  //进入区域侦测结束
#define MINOR_SMART_PEOPLE_GATHERING_BEGIN          0x2c  //人员聚集侦测开始
#define MINOR_SMART_PEOPLE_GATHERING_END            0x2d  //人员聚集侦测结束
#define MINOR_SMART_FAST_MOVING_BEGIN               0x2e  //快速运动侦测开始
#define MINOR_SMART_FAST_MOVING_END                 0x2f  //快速运动侦测结束

#define MINOR_VCA_FACE_ALARM_END                    0x30    /*人脸侦测结束*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN            0x31   /*场景变更侦测开始*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_END            0x32   /*场景变更侦测结束*/
#define MINOR_VCA_ALARM_AUDIOINPUT_BEGIN            0x33   /*音频异常输入开始*/
#define MINOR_VCA_ALARM_AUDIOINPUT_END                0x34   /*音频异常输入结束*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN            0x35  /*声强突变侦测开始*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_END            0x36  /*声强突变侦测结束*/

#define MINOR_VCA_LECTURE_DETECTION_BEGIN           0x37  //授课侦测开始报警
#define MINOR_VCA_LECTURE_DETECTION_END             0x38  //授课侦测结束报警
#define MINOR_VCA_ALARM_AUDIOSTEEPDROP              0x39  //声强陡降 2014-03-21
#define MINOR_VCA_ANSWER_DETECTION_BEGIN            0x3a  //回答问题侦测开始报警
#define MINOR_VCA_ANSWER_DETECTION_END              0x3b  //回答问题侦测结束报警

#define MINOR_SMART_PARKING_BEGIN                   0x3c   //停车侦测开始
#define MINOR_SMART_PARKING_END                     0x3d   //停车侦测结束
#define MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN        0x3e   //物品遗留侦测开始
#define MINOR_SMART_UNATTENDED_BAGGAGE_END          0x3f   //物品遗留侦测结束
#define MINOR_SMART_OBJECT_REMOVAL_BEGIN            0x40   //物品拿取侦测开始
#define MINOR_SMART_OBJECT_REMOVAL_END              0x41   //物品拿取侦测结束
#define MINOR_SMART_VEHICLE_ALARM_START             0x46   //车牌检测开始
#define MINOR_SMART_VEHICLE_ALARM_STOP              0x47   //车牌检测结束
#define MINOR_THERMAL_FIREDETECTION                 0x48   //热成像火点检测侦测开始
#define MINOR_THERMAL_FIREDETECTION_END             0x49   //热成像火点检测侦测结束
#define MINOR_SMART_VANDALPROOF_BEGIN               0x50   //防破坏检测开始
#define MINOR_SMART_VANDALPROOF_END                 0x51   //防破坏检测结束

#define MINOR_THERMAL_SHIPSDETECTION                0x5a   //热成像船只检测侦测
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN 0x5b  //热成像测温预警开始
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END  0x5c   //热成像测温预警结束
#define MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN       0x5d   //热成像测温报警开始
#define MINOR_THERMAL_THERMOMETRY_ALARM_END         0x5e   //热成像测温报警结束
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN  0x5f   //热成像温差报警开始
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END    0x60   //热成像温差报警结束
//0x400-0x1000 门禁报警
#define MINOR_ALARMIN_SHORT_CIRCUIT                 0x400  //防区短路报警
#define MINOR_ALARMIN_BROKEN_CIRCUIT                0x401  //防区断路报警
#define MINOR_ALARMIN_EXCEPTION                     0x402  //防区异常报警
#define MINOR_ALARMIN_RESUME                        0x403  //防区报警恢复
#define MINOR_HOST_DESMANTLE_ALARM                  0x404  //防区防拆报警
#define MINOR_HOST_DESMANTLE_RESUME                 0x405  //防区防拆恢复
#define MINOR_CARD_READER_DESMANTLE_ALARM           0x406  //读卡器防拆报警
#define MINOR_CARD_READER_DESMANTLE_RESUME          0x407  //读卡器防拆恢复
#define MINOR_CASE_SENSOR_ALARM                     0x408  //事件输入报警
#define MINOR_CASE_SENSOR_RESUME                    0x409  //事件输入恢复
#define MINOR_STRESS_ALARM                          0x40a  //胁迫报警
#define MINOR_OFFLINE_ECENT_NEARLY_FULL             0x40b  //离线事件满90%报警
#define MINOR_CARD_MAX_AUTHENTICATE_FAIL            0x40c  //卡号认证失败超次报警
#define MINOR_SD_CARD_FULL                          0x40d  //SD卡存储满报警
#define MINOR_LINKAGE_CAPTURE_PIC                   0x40e  //联动抓拍事件报警
#define MINOR_SECURITY_MODULE_DESMANTLE_ALARM        0x40f  //门控安全模块防拆报警
#define MINOR_SECURITY_MODULE_DESMANTLE_RESUME        0x410  //门控安全模块防拆恢复

#define MINOR_POS_START_ALARM                       0x411  //POS开启
#define MINOR_POS_END_ALARM                         0x412  //POS结束
/* 异常 */
//主类型
#define MAJOR_EXCEPTION                    0x2
//次类型
#define MINOR_RAID_ERROR                0x20    /* 阵列异常 */
#define MINOR_VI_LOST                    0x21    /* 视频信号丢失 */
#define MINOR_ILLEGAL_ACCESS            0x22    /* 非法访问 */
#define MINOR_HD_FULL                    0x23    /* 硬盘满 */
#define MINOR_HD_ERROR                    0x24    /* 硬盘错误 */
#define MINOR_DCD_LOST                    0x25    /* MODEM 掉线(保留不使用) */
#define MINOR_IP_CONFLICT                0x26    /* IP地址冲突 */
#define MINOR_NET_BROKEN                0x27    /* 网络断开*/
#define MINOR_REC_ERROR                 0x28    /* 录像出错 */
#define MINOR_IPC_NO_LINK               0x29    /* IPC连接异常 */
#define MINOR_VI_EXCEPTION              0x2a    /* 视频输入异常(只针对模拟通道) */
#define MINOR_IPC_IP_CONFLICT           0x2b    /*ipc ip 地址 冲突*/
#define MINOR_SENCE_EXCEPTION           0x2c    // 场景异常

#define MINOR_PIC_REC_ERROR              0x2d    /* 抓图出错--获取图片文件失败*/
#define MINOR_VI_MISMATCH                0x2e    /* 视频制式不匹配*/
#define MINOR_RESOLUTION_MISMATCH        0x2f    /*前端/录像分辨率不匹配  */

//2009-12-16 增加视频综合平台日志类型
#define MINOR_FANABNORMAL                0x31    /* 视频综合平台：风扇状态异常 */
#define MINOR_FANRESUME                    0x32    /* 视频综合平台：风扇状态恢复正常 */
#define MINOR_SUBSYSTEM_ABNORMALREBOOT    0x33    /* 视频综合平台：6467异常重启 */
#define MINOR_MATRIX_STARTBUZZER        0x34    /* 视频综合平台：dm6467异常，启动蜂鸣器 */

//2010-01-22 增加视频综合平台异常日志次类型
#define MINOR_NET_ABNORMAL                0x35    /*网络状态异常*/
#define MINOR_MEM_ABNORMAL                0x36    /*内存状态异常*/
#define MINOR_FILE_ABNORMAL                0x37    /*文件状态异常*/
#define MINOR_PANEL_ABNORMAL            0x38 /*前面板连接异常*/
#define MINOR_PANEL_RESUME                0x39 /*前面板恢复正常*/    
#define MINOR_RS485_DEVICE_ABNORMAL        0x3a     /*RS485连接状态异常*/
#define MINOR_RS485_DEVICE_REVERT        0x3b    /*RS485连接状态异常恢复*/

//2012-2-18 增加大屏控制器异常日志次类型
#define MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT   0x3c            //子板异常启动
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT    0x3d            //子板插入
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT    0x3e            //子板拔出
#define    MINOR_SCREEN_ABNARMALTEMPERATURE        0x3f            //温度异常
//2012-07-26 视频综合平台v2.1
#define MINOR_HIGH_TEMPERATURE_PROTECT          0x40 //子板过热保护

//Netra 2.2.2
#define MINOR_RECORD_OVERFLOW                   0x41              /*缓冲区溢出*/  
#define MINOR_DSP_ABNORMAL                      0x42              //DSP异常 

//Netra 3.0.0
#define MINOR_ANR_RECORD_FAIED                 0x43         /*ANR录像失败*/ 
#define MINOR_SPARE_WORK_DEVICE_EXCEPT         0x44            /*热备设备工作机异常*/
#define MINOR_START_IPC_MAS_FAILED             0x45            /*开启IPC MAS失败*/ 
//高性能 256路NVR
#define MINOR_IPCM_CRASH                       0x46         /*IPCM异常重启*/
#define MINOR_POE_POWER_EXCEPTION              0x47         /*POE 供电异常*/
#define MINOR_UPLOAD_DATA_CS_EXCEPTION         0x48          //云存储数据上传失败/
#define MINOR_DIAL_EXCEPTION                   0x49         /*拨号异常*/
#define MINOR_DEV_EXCEPTION_OFFLINE            0x50  //设备异常下线
#define MINOR_UPGRADEFAIL                      0x51 //远程升级设备失败
#define MINOR_AI_LOST                           0x52    /* 音频信号丢失 */
#define MINOR_SYNC_IPC_PASSWD                   0x53    /* 同步IPC密码异常 */
#define MINOR_EZVIZ_OFFLINE                        0x54    /* 萤石下线异常*/
#define MINOR_VQD_ABNORMAL                        0x55 //VQD异常
#define MINOR_ACCESSORIES_PLATE                0x57 //配件板异常

//0x400-0x1000 门禁异常类型
#define MINOR_DEV_POWER_ON                     0x400  //设备上电启动
#define MINOR_DEV_POWER_OFF                    0x401  //设备掉电关闭
#define MINOR_WATCH_DOG_RESET                  0x402  //看门狗复位
#define MINOR_LOW_BATTERY                      0x403  //蓄电池电压低
#define MINOR_BATTERY_RESUME                   0x404  //蓄电池电压恢复正常
#define MINOR_AC_OFF                           0x405  //交流电断电
#define MINOR_AC_RESUME                        0x406  //交流电恢复
#define MINOR_NET_RESUME                       0x407  //网络恢复
#define MINOR_FLASH_ABNORMAL                   0x408  //FLASH读写异常
#define MINOR_CARD_READER_OFFLINE              0x409  //读卡器掉线
#define MINOR_CARD_READER_RESUME               0x40a  //读卡器掉线恢复                   
#define MINOR_INDICATOR_LIGHT_OFF              0x40b  //指示灯关闭
#define MINOR_INDICATOR_LIGHT_RESUME           0x40c  //指示灯恢复
#define MINOR_CHANNEL_CONTROLLER_OFF           0x40d  //通道控制器掉线
#define MINOR_CHANNEL_CONTROLLER_RESUME        0x40e  //通道控制器恢复
#define MINOR_SECURITY_MODULE_OFF               0x40f  //门控安全模块掉线
#define MINOR_SECURITY_MODULE_RESUME           0x410  //门控安全模块在线
//[add]by silujie 2013-3-22 14:16
//0x2000~0x3fff 为设备报警日志
//0x4000~0x5000 为设备异常日志
#define MINOR_SUBSYSTEM_IP_CONFLICT        0x4000        //子板IP冲突
#define MINOR_SUBSYSTEM_NET_BROKEN        0x4001        //子板断网
#define    MINOR_FAN_ABNORMAL                0x4002        //风扇异常
#define    MINOR_BACKPANEL_TEMPERATURE_ABNORMAL        0x4003        //背板温度异常

#define    MINOR_SDCARD_ABNORMAL            0x4004        //SD卡不健康
#define    MINOR_SDCARD_DAMAGE                0x4005        //SD卡损坏


/* 操作 */
//主类型
#define MAJOR_OPERATION                    0x3

//次类型
#define MINOR_VCA_MOTIONEXCEPTION        0x29  //智能侦测异常
#define MINOR_START_DVR                    0x41    /* 开机 */
#define MINOR_STOP_DVR                    0x42    /* 关机 */
#define MINOR_STOP_ABNORMAL                0x43    /* 异常关机 */
#define MINOR_REBOOT_DVR                0x44    /*本地重启设备*/

#define MINOR_LOCAL_LOGIN                0x50    /* 本地登陆 */
#define MINOR_LOCAL_LOGOUT                0x51    /* 本地注销登陆 */
#define MINOR_LOCAL_CFG_PARM            0x52    /* 本地配置参数 */
#define MINOR_LOCAL_PLAYBYFILE          0x53    /* 本地按文件回放或下载 */
#define MINOR_LOCAL_PLAYBYTIME          0x54    /* 本地按时间回放或下载*/
#define MINOR_LOCAL_START_REC            0x55    /* 本地开始录像 */
#define MINOR_LOCAL_STOP_REC            0x56    /* 本地停止录像 */
#define MINOR_LOCAL_PTZCTRL                0x57    /* 本地云台控制 */
#define MINOR_LOCAL_PREVIEW                0x58    /* 本地预览 (保留不使用)*/
#define MINOR_LOCAL_MODIFY_TIME         0x59    /* 本地修改时间(保留不使用) */
#define MINOR_LOCAL_UPGRADE             0x5a    /* 本地升级 */
#define MINOR_LOCAL_RECFILE_OUTPUT      0x5b    /* 本地备份录象文件 */
#define MINOR_LOCAL_FORMAT_HDD          0x5c    /* 本地初始化硬盘 */
#define MINOR_LOCAL_CFGFILE_OUTPUT      0x5d    /* 导出本地配置文件 */
#define MINOR_LOCAL_CFGFILE_INPUT       0x5e    /* 导入本地配置文件 */
#define MINOR_LOCAL_COPYFILE            0x5f    /* 本地备份文件 */
#define MINOR_LOCAL_LOCKFILE            0x60    /* 本地锁定录像文件 */
#define MINOR_LOCAL_UNLOCKFILE          0x61    /* 本地解锁录像文件 */
#define MINOR_LOCAL_DVR_ALARM           0x62    /* 本地手动清除和触发报警*/
#define MINOR_IPC_ADD                   0x63    /* 本地添加IPC */
#define MINOR_IPC_DEL                   0x64    /* 本地删除IPC */
#define MINOR_IPC_SET                   0x65    /* 本地设置IPC */
#define MINOR_LOCAL_START_BACKUP        0x66    /* 本地开始备份 */
#define MINOR_LOCAL_STOP_BACKUP            0x67    /* 本地停止备份*/
#define MINOR_LOCAL_COPYFILE_START_TIME 0x68    /* 本地备份开始时间*/
#define MINOR_LOCAL_COPYFILE_END_TIME    0x69    /* 本地备份结束时间*/
#define MINOR_LOCAL_ADD_NAS             0x6a    /*本地添加网络硬盘 （nfs、iscsi）*/
#define MINOR_LOCAL_DEL_NAS             0x6b    /* 本地删除nas盘 （nfs、iscsi）*/
#define MINOR_LOCAL_SET_NAS             0x6c    /* 本地设置nas盘 （nfs、iscsi）*/
#define MINOR_LOCAL_RESET_PASSWD        0x6d    /* 本地恢复管理员默认密码*/ 

#define MINOR_REMOTE_LOGIN                0x70    /* 远程登录 */
#define MINOR_REMOTE_LOGOUT                0x71    /* 远程注销登陆 */
#define MINOR_REMOTE_START_REC            0x72    /* 远程开始录像 */
#define MINOR_REMOTE_STOP_REC            0x73    /* 远程停止录像 */
#define MINOR_START_TRANS_CHAN            0x74    /* 开始透明传输 */
#define MINOR_STOP_TRANS_CHAN            0x75    /* 停止透明传输 */
#define MINOR_REMOTE_GET_PARM            0x76    /* 远程获取参数 */
#define MINOR_REMOTE_CFG_PARM            0x77    /* 远程配置参数 */
#define MINOR_REMOTE_GET_STATUS         0x78    /* 远程获取状态 */
#define MINOR_REMOTE_ARM                0x79    /* 远程布防 */
#define MINOR_REMOTE_DISARM                0x7a    /* 远程撤防 */
#define MINOR_REMOTE_REBOOT                0x7b    /* 远程重启 */
#define MINOR_START_VT                    0x7c    /* 开始语音对讲 */
#define MINOR_STOP_VT                    0x7d    /* 停止语音对讲 */
#define MINOR_REMOTE_UPGRADE            0x7e    /* 远程升级 */
#define MINOR_REMOTE_PLAYBYFILE         0x7f    /* 远程按文件回放 */
#define MINOR_REMOTE_PLAYBYTIME         0x80    /* 远程按时间回放 */
#define MINOR_REMOTE_PTZCTRL            0x81    /* 远程云台控制 */
#define MINOR_REMOTE_FORMAT_HDD         0x82    /* 远程格式化硬盘 */
#define MINOR_REMOTE_STOP               0x83    /* 远程关机 */
#define MINOR_REMOTE_LOCKFILE            0x84    /* 远程锁定文件 */
#define MINOR_REMOTE_UNLOCKFILE         0x85    /* 远程解锁文件 */
#define MINOR_REMOTE_CFGFILE_OUTPUT     0x86    /* 远程导出配置文件 */
#define MINOR_REMOTE_CFGFILE_INTPUT     0x87    /* 远程导入配置文件 */
#define MINOR_REMOTE_RECFILE_OUTPUT     0x88    /* 远程导出录象文件 */
#define MINOR_REMOTE_DVR_ALARM          0x89    /* 远程手动清除和触发报警*/
#define MINOR_REMOTE_IPC_ADD            0x8a    /* 远程添加IPC */
#define MINOR_REMOTE_IPC_DEL            0x8b    /* 远程删除IPC */
#define MINOR_REMOTE_IPC_SET            0x8c    /* 远程设置IPC */
#define MINOR_REBOOT_VCA_LIB            0x8d    /*重启智能库*/
#define MINOR_REMOTE_ADD_NAS            0x8e   /* 远程添加nas盘 （nfs、iscsi）*/
#define MINOR_REMOTE_DEL_NAS            0x8f   /* 远程删除nas盘 （nfs、iscsi）*/
#define MINOR_REMOTE_SET_NAS            0x90   /* 远程设置nas盘 （nfs、iscsi）*/
#define MINOR_LOCAL_OPERATE_LOCK        0x9d            /* 本地操作锁定             */
#define MINOR_LOCAL_OPERATE_UNLOCK      0x9e            /* 本地操作解除锁定         */
#define MINOR_REMOTE_DELETE_HDISK       0x9a            /* 远程删除异常不存在的硬盘 */
#define MINOR_REMOTE_LOAD_HDISK         0x9b            /* 远程加载硬盘             */
#define MINOR_REMOTE_UNLOAD_HDISK       0x9c            /* 远程卸载硬盘   */


//2010-05-26 增加审讯DVR日志类型
#define MINOR_LOCAL_START_REC_CDRW      0x91   /* 本地开始讯问 */
#define MINOR_LOCAL_STOP_REC_CDRW       0x92   /* 本地停止讯问 */
#define MINOR_REMOTE_START_REC_CDRW     0x93   /* 远程开始讯问 */
#define MINOR_REMOTE_STOP_REC_CDRW      0x94   /* 远程停止讯问 */

#define MINOR_LOCAL_PIC_OUTPUT            0x95   /* 本地备份图片文件 */ 
#define MINOR_REMOTE_PIC_OUTPUT            0x96   /* 远程备份图片文件 */

//2011-07-26 增加81审讯DVR日志类型
#define MINOR_LOCAL_INQUEST_RESUME      0x97   /* 本地恢复审讯事件*/
#define MINOR_REMOTE_INQUEST_RESUME     0x98   /* 远程恢复审讯事件*/

//2013-01-23 增加86高清审讯NVR操作日志
#define MINOR_LOCAL_ADD_FILE            0x99        /*本地导入文件*/
#define MINOR_LOCAL_DEL_FILE            0x9f        /*本地删除审讯*/
#define MINOR_REMOTE_INQUEST_ADD_FILE   0x100       /*远程导入文件*/ 
#define MINOR_REMOTE_INQUEST_DEL_FILE   0x101       /*远程删除文件*/

//2009-12-16 增加视频综合平台日志类型
#define MINOR_SUBSYSTEMREBOOT           0xa0    /*视频综合平台：dm6467 正常重启*/
#define MINOR_MATRIX_STARTTRANSFERVIDEO 0xa1    /*视频综合平台：矩阵切换开始传输图像*/
#define MINOR_MATRIX_STOPTRANSFERVIDEO    0xa2    /*视频综合平台：矩阵切换停止传输图像*/
#define MINOR_REMOTE_SET_ALLSUBSYSTEM   0xa3    /*视频综合平台：设置所有6467子系统信息*/
#define MINOR_REMOTE_GET_ALLSUBSYSTEM   0xa4    /*视频综合平台：获取所有6467子系统信息*/
#define MINOR_REMOTE_SET_PLANARRAY      0xa5    /*视频综合平台：设置计划轮巡组*/
#define MINOR_REMOTE_GET_PLANARRAY      0xa6    /*视频综合平台：获取计划轮巡组*/
#define MINOR_MATRIX_STARTTRANSFERAUDIO 0xa7    /*视频综合平台：矩阵切换开始传输音频*/
#define MINOR_MATRIX_STOPRANSFERAUDIO   0xa8    /*视频综合平台：矩阵切换停止传输音频*/
#define MINOR_LOGON_CODESPITTER         0xa9    /*视频综合平台：登陆码分器*/
#define MINOR_LOGOFF_CODESPITTER        0xaa    /*视频综合平台：退出码分器*/

//2010-01-22 增加视频综合平台中解码器操作日志
#define MINOR_START_DYNAMIC_DECODE         0xb0    /*开始动态解码*/
#define MINOR_STOP_DYNAMIC_DECODE        0xb1    /*停止动态解码*/
#define MINOR_GET_CYC_CFG                0xb2    /*获取解码器通道轮巡配置*/
#define MINOR_SET_CYC_CFG                0xb3    /*设置解码通道轮巡配置*/
#define MINOR_START_CYC_DECODE            0xb4    /*开始轮巡解码*/
#define MINOR_STOP_CYC_DECODE            0xb5    /*停止轮巡解码*/
#define MINOR_GET_DECCHAN_STATUS        0xb6    /*获取解码通道状态*/
#define MINOR_GET_DECCHAN_INFO            0xb7    /*获取解码通道当前信息*/
#define MINOR_START_PASSIVE_DEC            0xb8    /*开始被动解码*/
#define MINOR_STOP_PASSIVE_DEC            0xb9    /*停止被动解码*/
#define MINOR_CTRL_PASSIVE_DEC            0xba    /*控制被动解码*/
#define MINOR_RECON_PASSIVE_DEC            0xbb    /*被动解码重连*/
#define MINOR_GET_DEC_CHAN_SW            0xbc    /*获取解码通道总开关*/
#define MINOR_SET_DEC_CHAN_SW            0xbd    /*设置解码通道总开关*/
#define MINOR_CTRL_DEC_CHAN_SCALE        0xbe    /*解码通道缩放控制*/
#define MINOR_SET_REMOTE_REPLAY            0xbf    /*设置远程回放*/
#define MINOR_GET_REMOTE_REPLAY            0xc0    /*获取远程回放状态*/
#define MINOR_CTRL_REMOTE_REPLAY        0xc1    /*远程回放控制*/
#define MINOR_SET_DISP_CFG                0xc2    /*设置显示通道*/
#define MINOR_GET_DISP_CFG                0xc3    /*获取显示通道设置*/
#define MINOR_SET_PLANTABLE                0xc4    /*设置计划轮巡表*/
#define MINOR_GET_PLANTABLE                0xc5    /*获取计划轮巡表*/
#define MINOR_START_PPPPOE                0xc6    /*开始PPPoE连接*/
#define MINOR_STOP_PPPPOE                0xc7    /*结束PPPoE连接*/
#define MINOR_UPLOAD_LOGO                0xc8    /*上传LOGO*/
//推模式操作日志
#define MINOR_LOCAL_PIN                    0xc9    /* 本地PIN功能操作 */
#define MINOR_LOCAL_DIAL                0xca    /* 本地手动启动断开拨号 */    
#define MINOR_SMS_CONTROL                0xcb    /* 短信控制上下线 */    
#define MINOR_CALL_ONLINE                0xcc    /* 呼叫控制上线 */    
#define MINOR_REMOTE_PIN                0xcd    /* 远程PIN功能操作 */

//2010-12-16 报警板日志
#define MINOR_REMOTE_BYPASS             0xd0    /* 远程旁路*/
#define MINOR_REMOTE_UNBYPASS           0xd1    /* 远程旁路恢复*/
#define MINOR_REMOTE_SET_ALARMIN_CFG    0xd2    /* 远程设置报警输入参数*/
#define MINOR_REMOTE_GET_ALARMIN_CFG    0xd3    /* 远程获取报警输入参数*/
#define MINOR_REMOTE_SET_ALARMOUT_CFG   0xd4    /* 远程设置报警输出参数*/
#define MINOR_REMOTE_GET_ALARMOUT_CFG   0xd5    /* 远程获取报警输出参数*/
#define MINOR_REMOTE_ALARMOUT_OPEN_MAN  0xd6    /* 远程手动开启报警输出*/
#define MINOR_REMOTE_ALARMOUT_CLOSE_MAN 0xd7    /* 远程手动关闭报警输出*/
#define MINOR_REMOTE_ALARM_ENABLE_CFG   0xd8    /* 远程设置报警主机的RS485串口使能状态*/
#define MINOR_DBDATA_OUTPUT                0xd9    /* 导出数据库记录 */
#define MINOR_DBDATA_INPUT                0xda    /* 导入数据库记录 */
#define MINOR_MU_SWITCH                    0xdb    /* 级联切换 */
#define MINOR_MU_PTZ                    0xdc    /* 级联PTZ控制 */
#define MINOR_DELETE_LOGO               0xdd    /* 删除logo */

#define MINOR_LOCAL_CONF_REB_RAID       0x101           /*本地配置自动重建*/
#define MINOR_LOCAL_CONF_SPARE          0x102           /*本地配置热备*/
#define MINOR_LOCAL_ADD_RAID            0x103           /*本地创建阵列*/
#define MINOR_LOCAL_DEL_RAID            0x104           /*本地删除阵列*/
#define MINOR_LOCAL_MIG_RAID            0x105           /*本地迁移阵列*/
#define MINOR_LOCAL_REB_RAID            0x106           /* 本地手动重建阵列*/
#define MINOR_LOCAL_QUICK_CONF_RAID     0x107           /*本地一键配置*/
#define MINOR_LOCAL_ADD_VD              0x108           /*本地创建虚拟磁盘*/
#define MINOR_LOCAL_DEL_VD              0x109           /*本地删除虚拟磁盘*/
#define MINOR_LOCAL_RP_VD               0x10a           /*本地修复虚拟磁盘*/
#define MINOR_LOCAL_FORMAT_EXPANDVD     0X10b           /*本地扩展虚拟磁盘扩容*/
#define MINOR_LOCAL_RAID_UPGRADE        0X10c           /*本地raid卡升级*/  
#define MINOR_LOCAL_STOP_RAID           0x10d           /*本地暂停RAID操作(即安全拔盘)*/  
#define MINOR_REMOTE_CONF_REB_RAID      0x111           /*远程配置自动重建*/
#define MINOR_REMOTE_CONF_SPARE         0x112            /*远程配置热备*/
#define MINOR_REMOTE_ADD_RAID           0x113           /*远程创建阵列*/
#define MINOR_REMOTE_DEL_RAID           0x114           /*远程删除阵列*/
#define MINOR_REMOTE_MIG_RAID           0x115           /*远程迁移阵列*/
#define MINOR_REMOTE_REB_RAID           0x116           /* 远程手动重建阵列*/
#define MINOR_REMOTE_QUICK_CONF_RAID    0x117           /*远程一键配置*/
#define MINOR_REMOTE_ADD_VD             0x118           /*远程创建虚拟磁盘*/
#define MINOR_REMOTE_DEL_VD             0x119           /*远程删除虚拟磁盘*/
#define MINOR_REMOTE_RP_VD              0x11a           /*远程修复虚拟磁盘*/
#define MINOR_REMOTE_FORMAT_EXPANDVD    0X11b           /*远程虚拟磁盘扩容*/
#define MINOR_REMOTE_RAID_UPGRADE       0X11c           /*远程raid卡升级*/  
#define MINOR_REMOTE_STOP_RAID          0x11d           /*远程暂停RAID操作(即安全拔盘)*/
#define MINOR_LOCAL_START_PIC_REC       0x121          /*本地开始抓图*/ 
#define MINOR_LOCAL_STOP_PIC_REC        0x122          /*本地停止抓图*/
#define MINOR_LOCAL_SET_SNMP            0x125           /*本地配置SNMP*/
#define MINOR_LOCAL_TAG_OPT             0x126          /*本地标签操作*/
#define MINOR_REMOTE_START_PIC_REC      0x131          /*远程开始抓图*/
#define MINOR_REMOTE_STOP_PIC_REC       0x132           /*远程停止抓图*/
#define MINOR_REMOTE_SET_SNMP           0x135            /*远程配置SNMP*/
#define MINOR_REMOTE_TAG_OPT            0x136             /*远程标签操作*/  

// 9000 v2.2.0
#define MINOR_LOCAL_VOUT_SWITCH         0x140   /* 本地输出口切换操作*/
#define MINOR_STREAM_CABAC                 0x141   /* 码流压缩性能选项配置操作*/

//Netra 3.0.0
#define MINOR_LOCAL_SPARE_OPT           0x142   /*本地N+1 热备相关操作*/
#define MINOR_REMOTE_SPARE_OPT            0x143   /*远程N+1 热备相关操作*/
#define MINOR_LOCAL_IPCCFGFILE_OUTPUT    0x144      /* 本地导出ipc配置文件*/
#define MINOR_LOCAL_IPCCFGFILE_INPUT      0x145   /* 本地导入ipc配置文件 */
#define MINOR_LOCAL_IPC_UPGRADE         0x146   /* 本地升级IPC */
#define MINOR_REMOTE_IPCCFGFILE_OUTPUT  0x147   /* 远程导出ipc配置文件*/
#define MINOR_REMOTE_IPCCFGFILE_INPUT   0x148   /* 远程导入ipc配置文件*/
#define MINOR_REMOTE_IPC_UPGRADE        0x149   /* 远程升级IPC */
//NVR 96000
#define MINOR_VQD_CFG                   0x150    //视频质量诊断（VQD）配置



#define MINOR_SET_MULTI_MASTER          0x201    /*设置大屏主屏*/
#define MINOR_SET_MULTI_SLAVE           0x202    /*设置大屏子屏*/
#define MINOR_CANCEL_MULTI_MASTER       0x203    /*取消大屏主屏*/
#define MINOR_CANCEL_MULTI_SLAVE        0x204    /*取消大屏子屏*/

#define MINOR_DISPLAY_LOGO                0x205    /*显示LOGO*/
#define MINOR_HIDE_LOGO                 0x206    /*隐藏LOGO*/
#define MINOR_SET_DEC_DELAY_LEVEL       0x207    /*解码通道延时级别设置*/
#define MINOR_SET_BIGSCREEN_DIPLAY_AREA 0x208    /*设置大屏显示区域*/
#define MINOR_CUT_VIDEO_SOURCE          0x209    /*大屏视频源切割设置*/
#define MINOR_SET_BASEMAP_AREA          0x210    /*大屏底图区域设置*/
#define MINOR_DOWNLOAD_BASEMAP          0x211    /*下载大屏底图*/
#define MINOR_CUT_BASEMAP               0x212    /*底图切割配置*/
#define MINOR_CONTROL_ELEC_ENLARGE      0x213    /*电子放大操作(放大或还原)*/
#define MINOR_SET_OUTPUT_RESOLUTION     0x214    /*显示输出分辨率设置*/
#define MINOR_SET_TRANCSPARENCY         0X215    /*图层透明度设置*/
#define MINOR_SET_OSD                   0x216    /*显示OSD设置*/
#define MINOR_RESTORE_DEC_STATUS        0x217    /*恢复初始状态(场景切换时，解码恢复初始状态)*/

//2011-11-11 增加大屏控制器操作日志次类型
#define MINOR_SCREEN_SET_INPUT            0x251    /*修改输入源*/
#define MINOR_SCREEN_SET_OUTPUT            0x252    /*修改输出通道*/
#define MINOR_SCREEN_SET_OSD            0x253    /*修改虚拟LED*/
#define MINOR_SCREEN_SET_LOGO            0x254    /*修改LOGO*/
#define MINOR_SCREEN_SET_LAYOUT            0x255    /*设置布局*/
#define    MINOR_SCREEN_PICTUREPREVIEW        0x256     /*回显操作*/

//2012-06-14 CVCS2.0, 窗口设置等操作在V1.0， V1.1中已经有了，当时在设备日志中没有定义 
#define MINOR_SCREEN_GET_OSD            0x257   /*获取虚拟LED*/
#define MINOR_SCREEN_GET_LAYOUT            0x258   /*获取布局*/
#define MINOR_SCREEN_LAYOUT_CTRL        0x259   /*布局控制*/
#define MINOR_GET_ALL_VALID_WND            0x260    /*获取所有有效窗口*/
#define MINOR_GET_SIGNAL_WND            0x261    /*获取单个窗口信息*/
#define MINOR_WINDOW_CTRL                0x262    /*窗口控制*/
#define MINOR_GET_LAYOUT_LIST            0x263    /*获取布局列表*/
#define MINOR_LAYOUT_CTRL                0x264    /*布局控制*/
#define MINOR_SET_LAYOUT                0x265    /*设置布局*/
#define MINOR_GET_SIGNAL_LIST            0x266    /*获取输入信号源列表*/
#define MINOR_GET_PLAN_LIST                0x267    /*获取预案列表*/
#define MINOR_SET_PLAN                    0x268    /*修改预案*/
#define MINOR_CTRL_PLAN                    0x269    /*控制预案*/
#define MINOR_CTRL_SCREEN                0x270    /*屏幕控制*/
#define MINOR_ADD_NETSIG                0x271    /*添加信号源*/
#define MINOR_SET_NETSIG                0x272    /*修改信号源*/
#define MINOR_SET_DECBDCFG                0x273    /*设置解码板参数*/
#define MINOR_GET_DECBDCFG                0x274    /*获取解码板参数*/
#define MINOR_GET_DEVICE_STATUS            0x275    /*获取设备信息*/
#define MINOR_UPLOAD_PICTURE            0x276    /*底图上传*/
#define MINOR_SET_USERPWD                0x277    /*设置用户密码*/
#define MINOR_ADD_LAYOUT                0x278    /*添加布局*/
#define MINOR_DEL_LAYOUT                0x279    /*删除布局*/
#define MINOR_DEL_NETSIG                0x280    /*删除信号源*/
#define MINOR_ADD_PLAN                    0x281    /*添加预案*/
#define MINOR_DEL_PLAN                    0x282    /*删除预案*/
#define MINOR_GET_EXTERNAL_MATRIX_CFG    0x283    //获取外接矩阵配置
#define MINOR_SET_EXTERNAL_MATRIX_CFG    0x284    //设置外接矩阵配置
#define    MINOR_GET_USER_CFG                0x285    //获取用户配置
#define    MINOR_SET_USER_CFG                0x286    //设置用户配置
#define    MINOR_GET_DISPLAY_PANEL_LINK_CFG 0x287    //获取显示墙连接配置
#define    MINOR_SET_DISPLAY_PANEL_LINK_CFG 0x288    //设置显示墙连接配置

#define    MINOR_GET_WALLSCENE_PARAM        0x289        //获取电视墙场景
#define    MINOR_SET_WALLSCENE_PARAM        0x28a        //设置电视墙场景
#define    MINOR_GET_CURRENT_WALLSCENE        0x28b        //获取当前使用场景
#define    MINOR_SWITCH_WALLSCENE            0x28c        //场景切换
#define    MINOR_SIP_LOGIN                    0x28d        //SIP注册成功
#define MINOR_VOIP_START                0x28e        //VOIP对讲开始
#define MINOR_VOIP_STOP                    0x28f        //VOIP对讲停止
#define MINOR_WIN_TOP                   0x290       //电视墙窗口置顶
#define MINOR_WIN_BOTTOM                0x291       //电视墙窗口置底

// Netra 2.2.2
#define MINOR_LOCAL_LOAD_HDISK          0x300            //本地加载硬盘             
#define MINOR_LOCAL_DELETE_HDISK        0x301            //本地删除异常不存在的硬盘

//KY2013 3.0.0
#define MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH    0X302 //本地主辅口切换
#define MINOR_LOCAL_HARD_DISK_CHECK                0x303 //本地物理硬盘自检

//Netra3.1.0
#define MINOR_LOCAL_CFG_DEVICE_TYPE        0x310    //本地配置设备类型
#define MINOR_REMOTE_CFG_DEVICE_TYPE    0x311    //远程配置设备类型
#define MINOR_LOCAL_CFG_WORK_HOT_SERVER    0x312    //本地配置工作机热备服务器
#define MINOR_REMOTE_CFG_WORK_HOT_SERVER 0x313    //远程配置工作机热备服务器
#define MINOR_LOCAL_DELETE_WORK            0x314    //本地删除工作机
#define MINOR_REMOTE_DELETE_WORK        0x315    //远程删除工作机
#define    MINOR_LOCAL_ADD_WORK            0x316    //本地添加工作机
#define MINOR_REMOTE_ADD_WORK            0x317    //远程添加工作机
#define MINOR_LOCAL_IPCHEATMAP_OUTPUT   0x318            /* 本地导出热度图文件      */
#define MINOR_LOCAL_IPCHEATFLOW_OUTPUT  0x319          /* 本地导出热度流量文件      */
#define MINOR_REMOTE_SMS_SEND           0x350    /*远程发送短信*/
#define MINOR_LOCAL_SMS_SEND            0x351   /*本地发送短信*/
#define MINOR_ALARM_SMS_SEND            0x352    /*发送短信报警*/
#define MINOR_SMS_RECV                  0x353     /*接收短信*/
//（备注：0x350、0x351是指人工在GUI或IE控件上编辑并发送短信）
#define MINOR_LOCAL_SMS_SEARCH          0x354  /*本地搜索短信*/
#define MINOR_REMOTE_SMS_SEARCH         0x355   /*远程搜索短信*/
#define MINOR_LOCAL_SMS_READ            0x356   /*本地查看短信*/
#define MINOR_REMOTE_SMS_READ           0x357   /*远程查看短信*/
#define MINOR_REMOTE_DIAL_CONNECT       0x358   /*远程开启手动拨号*/
#define MINOR_REMOTE_DIAL_DISCONN       0x359   /*远程停止手动拨号*/
#define MINOR_LOCAL_WHITELIST_SET       0x35A   /*本地配置白名单*/
#define MINOR_REMOTE_WHITELIST_SET      0x35B   /*远程配置白名单*/
#define MINOR_LOCAL_DIAL_PARA_SET       0x35C   /*本地配置拨号参数*/
#define MINOR_REMOTE_DIAL_PARA_SET      0x35D   /*远程配置拨号参数*/
#define MINOR_LOCAL_DIAL_SCHEDULE_SET   0x35E   /*本地配置拨号计划*/
#define MINOR_REMOTE_DIAL_SCHEDULE_SET  0x35F   /*远程配置拨号计划*/
#define MINOR_PLAT_OPER                 0x360   /* 平台操作*/

//0x400-0x1000 门禁操作类型
#define MINOR_REMOTE_OPEN_DOOR          0x400   //远程开门
#define MINOR_REMOTE_CLOSE_DOOR         0x401   //远程关门
#define MINOR_REMOTE_ALWAYS_OPEN        0x402   //远程常开
#define MINOR_REMOTE_ALWAYS_CLOSE       0x403   //远程常关
#define MINOR_REMOTE_CHECK_TIME         0x404   //远程手动校时
#define MINOR_NTP_CHECK_TIME            0x405   //NTP自动校时
#define MINOR_REMOTE_CLEAR_CARD         0x406   //远程清空卡号
#define MINOR_REMOTE_RESTORE_CFG        0x407   //远程恢复默认参数
#define MINOR_ALARMIN_ARM               0x408   //防区布防
#define MINOR_ALARMIN_DISARM            0x409   //防区撤防
#define MINOR_LOCAL_RESTORE_CFG         0x40a   //本地恢复默认参数 
#define MINOR_REMOTE_CAPTURE_PIC        0x40b  //远程抓拍
#define MINOR_MOD_NET_REPORT_CFG        0x40c   //修改网络中心参数配置
#define MINOR_MOD_GPRS_REPORT_PARAM     0x40d   //修改GPRS中心参数配置
#define MINOR_MOD_REPORT_GROUP_PARAM    0x40e   //修改中心组参数配置
#define    MINOR_UNLOCK_PASSWORD_OPEN_DOOR  0x40f  //解除码输入

//2012-03-05 ITC操作日志类型
#define MINOR_SET_TRIGGERMODE_CFG          0x1001    /*设置触发模式参数*/
#define MINOR_GET_TRIGGERMODE_CFG          0x1002    /*获取触发模式参数*/
#define MINOR_SET_IOOUT_CFG                0x1003    /*设置IO输出参数*/
#define MINOR_GET_IOOUT_CFG                0x1004    /*获取IO输出参数*/
#define MINOR_GET_TRIGGERMODE_DEFAULT      0x1005    /*获取触发模式推荐参数*/
#define MINOR_GET_ITCSTATUS                0x1006    /*获取状态检测参数*/
#define MINOR_SET_STATUS_DETECT_CFG        0x1007    /*设置状态检测参数*/
#define MINOR_GET_STATUS_DETECT_CFG        0x1008    /*获取状态检测参数*/
#define MINOR_SET_VIDEO_TRIGGERMODE_CFG    0x1009  /*设置视频触发模式参数*/
#define MINOR_GET_VIDEO_TRIGGERMODE_CFG    0x100a   /*获取视频触发模式参数*/

//2013-04-19 ITS操作日志类型
#define MINOR_LOCAL_ADD_CAR_INFO            0x2001  /*本地添加车辆信息*/
#define MINOR_LOCAL_MOD_CAR_INFO            0x2002  /*本地修改车辆信息*/
#define MINOR_LOCAL_DEL_CAR_INFO            0x2003  /*本地删除车辆信息*/
#define MINOR_LOCAL_FIND_CAR_INFO           0x2004  /*本地查找车辆信息*/
#define MINOR_LOCAL_ADD_MONITOR_INFO        0x2005  /*本地添加布控信息*/
#define MINOR_LOCAL_MOD_MONITOR_INFO        0x2006  /*本地修改布控信息*/
#define MINOR_LOCAL_DEL_MONITOR_INFO        0x2007  /*本地删除布控信息*/
#define MINOR_LOCAL_FIND_MONITOR_INFO       0x2008  /*本地查询布控信息*/
#define MINOR_LOCAL_FIND_NORMAL_PASS_INFO   0x2009  /*本地查询正常通行信息*/
#define MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO 0x200a  /*本地查询异常通行信息*/
#define MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO   0x200b  /*本地查询正常通行信息*/
#define MINOR_LOCAL_PIC_PREVIEW             0x200c  /*本地图片预览*/
#define MINOR_LOCAL_SET_GATE_PARM_CFG       0x200d  /*设置本地配置出入口参数*/
#define MINOR_LOCAL_GET_GATE_PARM_CFG       0x200e  /*获取本地配置出入口参数*/
#define MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG 0x200f  /*设置本地配置数据上传参数*/
#define MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG 0x2010  /*获取本地配置数据上传参数*/

//2013-11-19新增日志类型
#define MINOR_LOCAL_DEVICE_CONTROL                         0x2011   /*本地设备控制(本地开关闸)*/
#define MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO               0x2012   /*本地添加外接设备信息 */
#define MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO               0x2013   /*本地修改外接设备信息 */
#define MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO               0x2014   /*本地删除外接设备信息 */
#define MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO              0x2015   /*本地查询外接设备信息 */
#define MINOR_LOCAL_ADD_CHARGE_RULE                        0x2016   /*本地添加收费规则 */
#define MINOR_LOCAL_MOD_CHARGE_RULE                        0x2017   /*本地修改收费规则 */
#define MINOR_LOCAL_DEL_CHARGE_RULE                        0x2018   /*本地删除收费规则 */
#define MINOR_LOCAL_FIND_CHARGE_RULE                       0x2019   /*本地查询收费规则 */
#define MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO               0x2020   /*本地统计正常通行信息 */
#define MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT       0x2021   /*本地导出正常通行信息统计报表 */
#define MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO             0x2022   /*本地统计异常通行信息 */
#define MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT     0x2023   /*本地导出异常通行信息统计报表 */
#define MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO           0x2024   /*本地统计行人通行信息 */
#define MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT   0x2025   /*本地导出行人通行信息统计报表 */
#define MINOR_LOCAL_FIND_CAR_CHARGEINFO                    0x2026   /*本地查询过车收费信息 */
#define MINOR_LOCAL_COUNT_CAR_CHARGEINFO                   0x2027   /*本地统计过车收费信息 */
#define MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT           0x2028   /*本地导出过车收费信息统计报表 */
#define MINOR_LOCAL_FIND_SHIFTINFO                         0x2029   /*本地查询交接班信息 */
#define MINOR_LOCAL_FIND_CARDINFO                          0x2030   /*本地查询卡片信息 */
#define MINOR_LOCAL_ADD_RELIEF_RULE                        0x2031   /*本地添加减免规则 */
#define MINOR_LOCAL_MOD_RELIEF_RULE                        0x2032   /*本地修改减免规则 */
#define MINOR_LOCAL_DEL_RELIEF_RULE                        0x2033   /*本地删除减免规则 */
#define MINOR_LOCAL_FIND_RELIEF_RULE                       0x2034   /*本地查询减免规则 */
#define MINOR_LOCAL_GET_ENDETCFG                           0x2035   /*本地获取出入口控制机离线检测配置 */ 
#define MINOR_LOCAL_SET_ENDETCFG                           0x2036   /*本地设置出入口控制机离线检测配置*/
#define MINOR_LOCAL_SET_ENDEV_ISSUEDDATA                   0x2037   /*本地设置出入口控制机下发卡片信息 */
#define MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA                   0x2038   /*本地清空出入口控制机下发卡片信息 */

#define MINOR_REMOTE_DEVICE_CONTROL                        0x2101   /*远程设备控制*/
#define MINOR_REMOTE_SET_GATE_PARM_CFG                     0x2102   /*设置远程配置出入口参数*/
#define MINOR_REMOTE_GET_GATE_PARM_CFG                     0x2103   /*获取远程配置出入口参数*/
#define MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG               0x2104   /*设置远程配置数据上传参数*/
#define MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG               0x2105   /*获取远程配置数据上传参数*/
#define MINOR_REMOTE_GET_BASE_INFO                         0x2106   /*远程获取终端基本信息*/
#define MINOR_REMOTE_GET_OVERLAP_CFG                       0x2107   /*远程获取字符叠加参数配置*/              
#define MINOR_REMOTE_SET_OVERLAP_CFG                       0x2108   /*远程设置字符叠加参数配置*/ 
#define MINOR_REMOTE_GET_ROAD_INFO                         0x2109   /*远程获取路口信息*/
#define MINOR_REMOTE_START_TRANSCHAN                       0x210a   /*远程建立同步数据服务器*/
#define MINOR_REMOTE_GET_ECTWORKSTATE                      0x210b   /*远程获取出入口终端工作状态*/
#define MINOR_REMOTE_GET_ECTCHANINFO                       0x210c   /*远程获取出入口终端通道状态*/

//远程控制 2013-11-19
#define MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO              0x210d   /*远程添加外接设备信息 */
#define MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO              0x210e   /*远程修改外接设备信息 */
#define MINOR_REMOTE_GET_ENDETCFG                          0x210f   /*远程获取出入口控制机离线检测配置 */ 
#define MINOR_REMOTE_SET_ENDETCFG                          0x2110   /*远程设置出入口控制机离线检测配置*/
#define MINOR_REMOTE_ENDEV_ISSUEDDATA                      0x2111   /*远程设置出入口控制机下发卡片信息 */
#define MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA                  0x2112   /*远程清空出入口控制机下发卡片信息 */

//ITS 0x2115~0x2120 停车场车位项目
#define MINOR_REMOTE_ON_CTRL_LAMP           0x2115  /*开启远程控制车位指示灯*/       
#define MINOR_REMOTE_OFF_CTRL_LAMP          0x2116  /*关闭远程控制车位指示灯*/
//Netra3.1.0
#define MINOR_SET_VOICE_LEVEL_PARAM         0x2117  /*设置音量大小 */
#define MINOR_SET_VOICE_INTERCOM_PARAM      0x2118  /*设置音量录音 */
#define MINOR_SET_INTELLIGENT_PARAM         0x2119  /*智能配置*/ 
#define MINOR_LOCAL_SET_RAID_SPEED          0x211a  /*本地设置raid速度*/
#define MINOR_REMOTE_SET_RAID_SPEED         0x211b /*远程设置raid速度*/
//Nerta3.1.2
#define MINOR_REMOTE_CREATE_STORAGE_POOL    0x211c   //远程添加存储池
#define MINOR_REMOTE_DEL_STORAGE_POOL       0x211d    //远程删除存储池

#define MINOR_REMOTE_DEL_PIC                0x2120   //远程删除图片数据
#define MINOR_REMOTE_DEL_RECORD             0x2121   //远程删除录像数据
#define MINOR_REMOTE_CLOUD_ENABLE           0x2123  //远程设置云系统启用
#define MINOR_REMOTE_CLOUD_DISABLE          0x2124  //远程设置云系统禁用
#define MINOR_REMOTE_CLOUD_MODIFY_PARAM     0x2125  //远程修改存储池参数
#define MINOR_REMOTE_CLOUD_MODIFY_VOLUME    0x2126  //远程修改存储池容量
#define MINOR_REMOTE_GET_GB28181_SERVICE_PARAM    0x2127  //远程获取GB28181服务参数
#define MINOR_REMOTE_SET_GB28181_SERVICE_PARAM    0x2128  //远程设置GB28181服务参数
#define MINOR_LOCAL_GET_GB28181_SERVICE_PARAM     0x2129  //本地获取GB28181服务参数
#define MINOR_LOCAL_SET_GB28181_SERVICE_PARAM     0x212a  //本地配置B28181服务参数
#define MINOR_REMOTE_SET_SIP_SERVER               0x212b  //远程配置SIP SERVER
#define MINOR_LOCAL_SET_SIP_SERVER                0x212c  //本地配置SIP SERVER
#define MINOR_LOCAL_BLACKWHITEFILE_OUTPUT         0x212d  //本地黑白名单导出
#define MINOR_LOCAL_BLACKWHITEFILE_INPUT          0x212e  //本地黑白名单导入
#define MINOR_REMOTE_BALCKWHITECFGFILE_OUTPUT     0x212f  //远程黑白名单导出
#define MINOR_REMOTE_BALCKWHITECFGFILE_INPUT      0x2130  //远程黑白名单导入


#define MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE        0x2200    /*远程创建/修改视图库空间*/
#define MINOR_REMOTE_DELETE_VIEWLIB_FILE            0x2201    /*远程删除视图库文件*/
#define MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE            0x2202    /*远程下载视图库文件*/
#define MINOR_REMOTE_UPLOAD_VIEWLIB_FILE            0x2203    /*远程上传视图库文件*/
#define MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE        0x2204    /*本地创建/修改视图库空间*/

#define MINOR_LOCAL_SET_DEVICE_ACTIVE   0x3000  //本地激活设备
#define MINOR_REMOTE_SET_DEVICE_ACTIVE  0x3001  //远程激活设备
#define MINOR_LOCAL_PARA_FACTORY_DEFAULT    0x3002  //本地回复出厂设置
#define MINOR_REMOTE_PARA_FACTORY_DEFAULT   0x3003  //远程恢复出厂设置

/*信息发布服务器操作日志*/
#define MINOR_UPLAOD_STATIC_MATERIAL                0x2401  //静态素材上传
#define MINOR_UPLOAD_DYNAMIC_MATERIAL               0x2402  //动态素材上传
#define MINOR_DELETE_MATERIAL                       0x2403  //删除素材
#define MINOR_DOWNLOAD_STATIC_MATERIAL              0x2404  //静态素材下载
#define MINOR_COVER_STATIC_MATERIAL                 0x2405  //静态素材覆盖
#define MINOR_APPROVE_MATERIAL                      0x2406  //素材审核
#define MINOR_UPLAOD_PROGRAM                        0x2407  //上传节目
#define MINOR_DOWNLOAD_PROGRAM                      0x2408  //下载节目
#define MINOR_DELETE_PROGRAM                        0x2409  //删除节目
#define MINOR_MODIFY_PROGRAM                        0x240a  //节目属性修改
#define MINOR_APPROVE_PRAGRAM                       0x240b  //节目审核
#define MINOR_UPLAOD_SCHEDULE                       0x240c  //上传日程
#define MINOR_DOWNLOAD_SCHEDULE                     0x240d  //下载日程
#define MINOR_DELETE_SCHEDULE                       0x240e  //删除日程
#define MINOR_MODIFY_SCHEDULE                       0x240f  //修改日程属性
#define MINOR_RELEASE_SCHEDULE                      0x2410  //发布日程
#define MINOR_ADD_TERMINAL                          0x2411  //添加终端
#define MINOR_DELETE_TERMINAL                       0x2412  //删除终端
#define MINOR_MODIFY_TERMIANL_PARAM                 0x2413  //修改终端参数            
#define MINOR_MODIFY_TERMIANL_PLAY_PARAM            0x2414  //配置终端播放参数
#define MINOR_ADD_TERMIANL_GROUP                    0x2415  //添加终端组
#define MINOR_MODIFY_TERMINAL_GROUP_PARAM           0x2416  //修改终端组参数
#define MINOR_DELETE_TERMIANL_GROUP                 0x2417  //删除终端组
#define MINOR_TERMINAL_PLAY_CONTROL                 0x2418  //终端播放控制
#define MINOR_TERMINAL_ON_OFF_LINE                  0x2419  //终端上下线
#define MINOR_SET_SWITCH_PLAN                       0x241a  //设置终端定时开关机计划
#define MINOR_SET_VOLUME_PLAN                       0x241b  //设置终端定时音量计划
#define MINOR_TERMINAL_SCREENSHOT                   0x241c  //终端截屏


#define MINOR_REMOTE_CONFERENCE_CONFIG             0x2501  //MCU会议配置
#define MINOR_REMOTE_TERMINAL_CONFIG               0x2502  //MCU终端配置
#define MINOR_REMOTE_GROUP_CONFIG                  0x2503  //MCU分组配置
#define MINOR_REMOTE_CONFERENCE_CTRL               0x2504  //MCU会议控制
#define MINOR_REMOTE_TERMINAL_CTRL                 0x2505  //MCU终端控制
/*日志附加信息*/
//主类型
#define MAJOR_INFORMATION               0x4     /*附加信息*/
//次类型
#define MINOR_HDD_INFO                  0xa1 /*硬盘信息*/
#define MINOR_SMART_INFO                0xa2 /*SMART信息*/
#define MINOR_REC_START                 0xa3 /*开始录像*/
#define MINOR_REC_STOP                  0xa4 /*停止录像*/
#define MINOR_REC_OVERDUE                0xa5 /*过期录像删除*/
#define MINOR_LINK_START                0xa6 //连接前端设备
#define MINOR_LINK_STOP                    0xa7 //断开前端设备　
#define MINOR_NET_DISK_INFO                0xa8 //网络硬盘信息
#define MINOR_RAID_INFO                 0xa9 //raid相关信息
#define MINOR_RUN_STATUS_INFO           0xaa /*系统运行状态信息*/

//Netra3.0.0
#define MINOR_SPARE_START_BACKUP        0xab   /*热备系统开始备份指定工作机*/
#define MINOR_SPARE_STOP_BACKUP            0xac   /*热备系统停止备份指定工作机*/
#define MINOR_SPARE_CLIENT_INFO         0xad   /*热备客户机信息*/
#define MINOR_ANR_RECORD_START            0xae   /*ANR录像开始*/
#define MINOR_ANR_RECORD_END            0xaf   /*ANR录像结束*/
#define MINOR_ANR_ADD_TIME_QUANTUM        0xb0    /*ANR添加时间段*/
#define MINOR_ANR_DEL_TIME_QUANTUM        0xb1    /*ANR删除时间段*/

#define MINOR_PIC_REC_START             0xb3  /* 开始抓图*/    
#define MINOR_PIC_REC_STOP              0xb4  /* 停止抓图*/
#define MINOR_PIC_REC_OVERDUE           0xb5  /* 过期图片文件删除 */
//Netra3.1.0
#define  MINOR_CLIENT_LOGIN             0xb6   /*登录服务器成功*/
#define  MINOR_CLIENT_RELOGIN            0xb7   /*重新登录服务器*/
#define  MINOR_CLIENT_LOGOUT            0xb8   /*退出服务器成功*/
#define  MINOR_CLIENT_SYNC_START        0xb9   /*录像同步开始*/
#define  MINOR_CLIENT_SYNC_STOP            0xba   /*录像同步终止*/
#define  MINOR_CLIENT_SYNC_SUCC            0xbb   /*录像同步成功*/
#define  MINOR_CLIENT_SYNC_EXCP            0xbc   /*录像同步异常*/
#define  MINOR_GLOBAL_RECORD_ERR_INFO   0xbd   /*全局错误记录信息*/
#define  MINOR_BUFFER_STATE             0xbe   /*缓冲区状态日志记录*/
#define  MINOR_DISK_ERRORINFO_V2        0xbf   /*硬盘错误详细信息V2*/
#define  MINOR_CS_DATA_EXPIRED          0xc0   //云存储数据过期
#define  MINOR_PLAT_INFO                0xc1   //平台操作信息
#define  MINOR_DIAL_STAT                0xc2   /*拨号状态*/

#define MINOR_UNLOCK_RECORD             0xc3   //开锁记录
#define MINOR_VIS_ALARM                 0xc4   //防区报警
#define MINOR_TALK_RECORD               0xc5   //通话记录
#define MINOR_ACCESSORIES_MESSAGE       0xc6 //配件板信息
/*事件*/
//主类型
#define MAJOR_EVENT                             0x5     /*事件*/
//次类型
#define MINOR_LEGAL_CARD_PASS                   0x01    //合法卡认证通过
#define MINOR_CARD_AND_PSW_PASS                 0x02    //刷卡加密码认证通过
#define MINOR_CARD_AND_PSW_FAIL                 0x03    //刷卡加密码认证失败
#define MINOR_CARD_AND_PSW_TIMEOUT              0x04    //数卡加密码认证超时
#define MINOR_CARD_AND_PSW_OVER_TIME            0x05    //刷卡加密码超次
#define MINOR_CARD_NO_RIGHT                     0x06    //未分配权限
#define MINOR_CARD_INVALID_PERIOD               0x07    //无效时段
#define MINOR_CARD_OUT_OF_DATE                  0x08    //卡号过期
#define MINOR_INVALID_CARD                      0x09    //无此卡号
#define MINOR_ANTI_SNEAK_FAIL                   0x0a    //反潜回认证失败
#define MINOR_INTERLOCK_DOOR_NOT_CLOSE          0x0b    //互锁门未关闭
#define MINOR_NOT_BELONG_MULTI_GROUP            0x0c    //卡不属于多重认证群组
#define MINOR_INVALID_MULTI_VERIFY_PERIOD       0x0d    //卡不在多重认证时间段内
#define MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL     0x0e    //多重认证模式超级权限认证失败
#define MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL    0x0f    //多重认证模式远程认证失败
#define MINOR_MULTI_VERIFY_SUCCESS              0x10    //多重认证成功
#define MINOR_LEADER_CARD_OPEN_BEGIN            0x11    //首卡开门开始
#define MINOR_LEADER_CARD_OPEN_END              0x12    //首卡开门结束
#define MINOR_ALWAYS_OPEN_BEGIN                 0x13    //常开状态开始
#define MINOR_ALWAYS_OPEN_END                   0x14    //常开状态结束
#define MINOR_LOCK_OPEN                         0x15    //门锁打开
#define MINOR_LOCK_CLOSE                        0x16    //门锁关闭
#define MINOR_DOOR_BUTTON_PRESS                 0x17    //开门按钮打开
#define MINOR_DOOR_BUTTON_RELEASE               0x18    //开门按钮放开
#define MINOR_DOOR_OPEN_NORMAL                  0x19    //正常开门（门磁）
#define MINOR_DOOR_CLOSE_NORMAL                 0x1a    //正常关门（门磁）
#define MINOR_DOOR_OPEN_ABNORMAL                0x1b    //门异常打开（门磁）
#define MINOR_DOOR_OPEN_TIMEOUT                 0x1c    //门打开超时（门磁）
#define MINOR_ALARMOUT_ON                       0x1d    //报警输出打开
#define MINOR_ALARMOUT_OFF                      0x1e    //报警输出关闭
#define MINOR_ALWAYS_CLOSE_BEGIN                0x1f    //常关状态开始
#define MINOR_ALWAYS_CLOSE_END                  0x20    //常关状态结束                          
#define MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN     0x21    //多重多重认证需要远程开门
#define MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS  0x22  //多重认证超级密码认证成功事件
#define MINOR_MULTI_VERIFY_REPEAT_VERIFY        0x23    //多重认证重复认证事件
#define MINOR_MULTI_VERIFY_TIMEOUT               0x24    //多重认证重复认证事件
#define MINOR_DOORBELL_RINGING                  0x25    //门铃响
#define MINOR_FINGERPRINT_COMPARE_PASS          0x26    //指纹比对通过
#define MINOR_FINGERPRINT_COMPARE_FAIL          0x27    //指纹比对失败
#define MINOR_CARD_FINGERPRINT_VERIFY_PASS              0x28    //刷卡加指纹认证通过
#define MINOR_CARD_FINGERPRINT_VERIFY_FAIL              0x29    //刷卡加指纹认证失败
#define MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT           0x2a    //刷卡加指纹认证超时
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS       0x2b    //刷卡加指纹加密码认证通过
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL       0x2c    //刷卡加指纹加密码认证失败
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT    0x2d    //刷卡加指纹加密码认证超时
#define MINOR_FINGERPRINT_PASSWD_VERIFY_PASS            0x2e    //指纹加密码认证通过
#define MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL            0x2f    //指纹加密码认证失败
#define MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT         0x30    //指纹加密码认证超时
#define MINOR_FINGERPRINT_INEXISTENCE                   0x31    //指纹不存在
#define MINOR_CARD_PLATFORM_VERIFY                      0x32    //刷卡平台认证


typedef enum tagALARMHOST_MAJOR_TYPE
{
    MAJOR_ALARMHOST_ALARM = 1,
        MAJOR_ALARMHOST_EXCEPTION,
        MAJOR_ALARMHOST_OPERATION,
        MAJ0R_ALARMHOST_EVENT
}ALARMHOST_MAJOR_TYPE;

typedef enum tagALARMHOST_MINOR_TYPE
{
    // 报警 
    MINOR_SHORT_CIRCUIT =0x01,      // 短路报警
        MINOR_BROKEN_CIRCUIT,           // 断路报警
        MINOR_ALARM_RESET,              // 报警复位
        MINOR_ALARM_NORMAL,                // 报警恢复正常
        MINOR_PASSWORD_ERROR,            // 密码错误（连续3次输入密码错误）
        MINOR_ID_CARD_ILLEGALLY,        // 非法感应卡ID
        MINOR_KEYPAD_REMOVE,            // 键盘防拆
        MINOR_KEYPAD_REMOVE_RESTORE,    // 键盘防拆复位
        MINOR_DEV_REMOVE,                // 设备防拆
        MINOR_DEV_REMOVE_RESTORE,        // 设备防拆复位
        MINOR_BELOW_ALARM_LIMIT1,        // 模拟量低于报警限1
        MINOR_BELOW_ALARM_LIMIT2,        // 模拟量低于报警限2
        MINOR_BELOW_ALARM_LIMIT3,        // 模拟量低于报警限3
        MINOR_BELOW_ALARM_LIMIT4,        // 模拟量低于报警限4
        MINOR_ABOVE_ALARM_LIMIT1,        // 模拟量高于报警限1
        MINOR_ABOVE_ALARM_LIMIT2,        // 模拟量高于报警限2
        MINOR_ABOVE_ALARM_LIMIT3,        // 模拟量高于报警限3
        MINOR_ABOVE_ALARM_LIMIT4,        // 模拟量高于报警限4
        MINOR_URGENCYBTN_ON,            // 紧急按钮按下
        MINOR_URGENCYBTN_OFF,            // 紧急按钮复位
        MINOR_VIRTUAL_DEFENCE_BANDIT,            //软防区匪警
        MINOR_VIRTUAL_DEFENCE_FIRE,                //软防区火警
        MINOR_VIRTUAL_DEFENCE_URGENT,            //软防区紧急
        MINOR_ALARMHOST_MOTDET_START,            //移动侦测报警开始
        MINOR_ALARMHOST_MOTDET_STOP,            //移动侦测报警结束
        MINOR_ALARMHOST_HIDE_ALARM_START,        //遮挡报警开始
        MINOR_ALARMHOST_HIDE_ALARM_STOP,        //遮挡报警结束
        MINOR_ALARMHOST_UPS_ALARM,                //UPS报警
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM, //电量表报警
        MINOR_ALARMHOST_SWITCH_POWER_ALARM,        //开关电源报警
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,      //气体检测系统报警
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM, //变电器温显表报警
        MINOR_ALARMHOST_TEMP_HUMI_ALARM,            //温湿度传感器报警
        MINOR_ALARMHOST_UPS_ALARM_RESTORE,    //UPS报警恢复
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE, //电量表报警恢复
        MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,      //开关电源报警恢复
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,      //气体检测系统报警恢复
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE, //变电器温显表报警恢复
        MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,          //温湿度传感器报警恢复
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,            //水位传感器报警
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,    //水位传感器报警恢复
        MINOR_ALARMHOST_DUST_NOISE_ALARM,                    //扬尘噪声传感器报警
        MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,            //扬尘噪声传感器报警恢复
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,            //环境采集仪报警
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,    //环境采集仪报警恢复
        
        MINOR_ALARMHOST_TRIGGER_TAMPER,                //探测器防拆
        MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,                //探测器防拆恢复
        MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM,            //紧急呼叫求助报警
        MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM_RESTORE,    //紧急呼叫求助报警恢复
        
        // 异常
        MINOR_POWER_ON      = 0x01,    // 上电
        MINOR_POWER_OFF,                // 掉电
        MINOR_WDT_RESET,                // WDT 复位
        MINOR_LOW_BATTERY_VOLTAGE,        // 蓄电池电压低
        MINOR_AC_LOSS,                    // 交流电断电
        MINOR_AC_RESTORE,                // 交流电恢复
        MINOR_RTC_EXCEPTION,            // RTC实时时钟异常
        MINOR_NETWORK_CONNECT_FAILURE,    // 网络连接断
        MINOR_NETWORK_CONNECT_RESTORE,    // 网络连接恢复
        MINOR_TEL_LINE_CONNECT_FAILURE,    // 电话线连接断
        MINOR_TEL_LINE_CONNECT_RESTORE,    // 电话线连接恢复
        MINOR_EXPANDER_BUS_LOSS,        // 扩展总线模块掉线
        MINOR_EXPANDER_BUS_RESTORE,        // 扩展总线模块掉线恢复
        MINOR_KEYPAD_BUS_LOSS,            // 键盘总线模块掉线
        MINOR_KEYPAD_BUS_RESTORE,        // 键盘总线模块掉线恢复
        MINOR_SENSOR_FAILURE,            // 模拟量传感器故障
        MINOR_SENSOR_RESTORE,            // 模拟量传感器恢复
        MINOR_RS485_CONNECT_FAILURE,    // RS485通道连接断
        MINOR_RS485_CONNECT_RESTORE,    // RS485通道连接断恢复
        MINOR_BATTERT_VOLTAGE_RESTORE,  // 蓄电池电压恢复正常 
        MINOR_WIRED_NETWORK_ABNORMAL,    //有线网络异常
        MINOR_WIRED_NETWORK_RESTORE,    //有线网络恢复正常
        MINOR_GPRS_ABNORMAL,            //GPRS通信异常
        MINOR_GPRS_RESTORE,                //GPRS恢复正常
        MINOR_3G_ABNORMAL,                //3G通信异常
        MINOR_3G_RESTORE,                //3G恢复正常
        MINOR_SIM_CARD_ABNORMAL,        //SIM卡异常
        MINOR_SIM_CARD_RESTORE,            //SIM卡恢复正常
        MINOR_ALARMHOST_VI_LOST,        // 视频信号丢失
        MINOR_ALARMHOST_ILLEGAL_ACCESS,    // 非法访问
        MINOR_ALARMHOST_HD_FULL,        // 硬盘满
        MINOR_ALARMHOST_HD_ERROR,        // 硬盘错误
        MINOR_ALARMHOST_DCD_LOST,        // MODEM 掉线(保留不使用)
        MINOR_ALARMHOST_IP_CONFLICT,    // IP地址冲突
        MINOR_ALARMHOST_NET_BROKEN,        // 网络断开
        MINOR_ALARMHOST_REC_ERROR,      // 录像出错
        MINOR_ALARMHOST_VI_EXCEPTION,   // 视频输入异常(只针对模拟通道)
        MINOR_ALARMHOST_FORMAT_HDD_ERROR, //远程格式化硬盘失败
        MINOR_ALARMHOST_USB_ERROR,        //USB通信故障
        MINOR_ALARMHOST_USB_RESTORE,    //USB通信故障恢复
        MINOR_ALARMHOST_PRINT_ERROR,    //打印机故障
        MINOR_ALARMHOST_PRINT_RESTORE,    //打印机故障恢复
        MINOR_SUBSYSTEM_COMMUNICATION_ERROR, //子板通讯错误
        MINOR_ALARMHOST_IPC_NO_LINK,                /* IPC连接断开  */
        MINOR_ALARMHOST_IPC_IP_CONFLICT,            /*ipc ip 地址 冲突*/
        MINOR_ALARMHOST_VI_MISMATCH,                /*视频制式不匹配*/
        MINOR_ALARMHOST_MCU_RESTART,                //MCU重启
        MINOR_ALARMHOST_GPRS_MODULE_FAULT,                     /*GPRS模块故障*/
        MINOR_ALARMHOST_TELEPHONE_MODULE_FAULT,                 /*电话模块故障*/
        
        // 操作 
        MINOR_GUARD         = 0x01,        // 普通布防
        MINOR_UNGUARD,                    // 普通撤防
        MINOR_BYPASS,                    // 旁路
        MINOR_DURESS_ACCESS,            // 挟持
        MINOR_ALARMHOST_LOCAL_REBOOT,    // 本地重启
        MINOR_ALARMHOST_REMOTE_REBOOT,    // 远程重启
        MINOR_ALARMHOST_LOCAL_UPGRADE,    // 本地升级
        MINOR_ALARMHOST_REMOTE_UPGRADE,    // 远程升级
        MINOR_RECOVERY_DEFAULT_PARAM,    // 恢复默认参数
        MINOR_ALARM_OUTPUT,                // 控制报警输出
        MINOR_ACCESS_OPEN,                // 控制门禁开
        MINOR_ACCESS_CLOSE,                // 控制门禁关
        MINOR_SIREN_OPEN,                // 控制警号开
        MINOR_SIREN_CLOSE,                // 控制警号关
        MINOR_MOD_ZONE_CONFIG,            // 修改防区设置
        MINOR_MOD_ALARMOUT_CONIFG,        // 控制报警输出配置
        MINOR_MOD_ANALOG_CONFIG,        // 修改模拟量配置
        MINOR_RS485_CONFIG,                // 修改485通道配置
        MINOR_PHONE_CONFIG,                // 修改拨号配置
        MINOR_ADD_ADMIN,                // 增加管理员
        MINOR_MOD_ADMIN_PARAM,            // 修改管理员参数
        MINOR_DEL_ADMIN,                // 删除管理员
        MINOR_ADD_NETUSER,                // 增加后端操作员
        MINOR_MOD_NETUSER_PARAM,        // 修改后端操作员参数
        MINOR_DEL_NETUSER,                // 删除后端操作员
        MINOR_ADD_OPERATORUSER,            // 增加前端操作员
        MINOR_MOD_OPERATORUSER_PW,        // 修改前端操作员密码
        MINOR_DEL_OPERATORUSER,            // 删除前端操作员
        MINOR_ADD_KEYPADUSER,            // 增加键盘/读卡器用户    
        MINOR_DEL_KEYPADUSER,            // 删除键盘/读卡器用户    
        MINOR_REMOTEUSER_LOGIN,            // 远程用户登陆
        MINOR_REMOTEUSER_LOGOUT,        // 远程用户注销
        MINOR_REMOTE_GUARD,                // 远程布防
        MINOR_REMOTE_UNGUARD,            // 远程撤防
        MINOR_MOD_HOST_CONFIG,          // 修改主机配置
        MINOR_RESTORE_BYPASS,            // 旁路恢复
        MINOR_ALARMOUT_OPEN,            // 报警输出开启
        MINOR_ALARMOUT_CLOSE,            // 报警输出关闭
        MINOR_MOD_SUBSYSTEM_PARAM,        // 修改子系统参数配置
        MINOR_GROUP_BYPASS,                // 组旁路
        MINOR_RESTORE_GROUP_BYPASS,        // 组旁路恢复
        MINOR_MOD_GRPS_PARAM,            // 修改GPRS参数
        MINOR_MOD_NET_REPORT_PARAM,        // 修改网络上报参数配置
        MINOR_MOD_REPORT_MOD,            // 修改上传方式配置
        MINOR_MOD_GATEWAY_PARAM,        // 修改门禁参数配置
        MINOR_ALARMHOST_REMOTE_START_REC,        // 远程开始录像
        MINOR_ALARMHOST_REMOTE_STOP_REC,        // 远程停止录像
        MINOR_ALARMHOST_START_TRANS_CHAN,        // 开始透明传输
        MINOR_ALARMHOST_STOP_TRANS_CHAN,        // 停止透明传输
        MINOR_ALARMHOST_START_VT,                // 开始语音对讲
        MINOR_ALARMHOST_STOP_VTM,                // 停止语音对讲
        MINOR_ALARMHOST_REMOTE_PLAYBYFILE,        // 远程按文件回放
        MINOR_ALARMHOST_REMOTE_PLAYBYTIME,      // 远程按时间回放
        MINOR_ALARMHOST_REMOTE_PTZCTRL,            // 远程云台控制
        MINOR_ALARMHOST_REMOTE_FORMAT_HDD,      // 远程格式化硬盘
        MINOR_ALARMHOST_REMOTE_LOCKFILE,        // 远程锁定文件
        MINOR_ALARMHOST_REMOTE_UNLOCKFILE,      // 远程解锁文件
        MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // 远程导出配置文件
        MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // 远程导入配置文件
        MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // 远程导出录象文件
        
        MINOR_ALARMHOST_STAY_ARM,                        //留守布防
        MINOR_ALARMHOST_QUICK_ARM,                        //即时布防
        MINOR_ALARMHOST_AUTOMATIC_ARM,                    //自动布防
        MINOR_ALARMHOST_AUTOMATIC_DISARM,                //自动撤防
        MINOR_ALARMHOST_KEYSWITCH_ARM,                    //钥匙防区布防
        MINOR_ALARMHOST_KEYSWITCH_DISARM,                //钥匙防区撤防
        MINOR_ALARMHOST_CLEAR_ALARM,                    //消警
        MINOR_ALARMHOST_MOD_FAULT_CFG,                    //修改系统故障配置
        MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,    //修改事件触发报警输出配置
        MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,            //搜索外接模块
        MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,        //重新注册外接模块
        MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,            //关闭键盘报警提示音
        MINOR_ALARMHOST_MOD_3G_PARAM,                    //修改3G参数
        MINOR_ALARMHOST_MOD_PRINT_PARAM, //修改打印机参数
        MINOR_SD_CARD_FORMAT,        //SD卡格式化
        MINOR_SUBSYSTEM_UPGRADE,        //子板固件升级
        
        MINOR_ALARMHOST_PLAN_ARM_CFG,    //计划布撤防参数配置
        MINOR_ALARMHOST_PHONE_ARM,        //手机布防
        MINOR_ALARMHOST_PHONE_STAY_ARM,    //手机留守布防
        MINOR_ALARMHOST_PHONE_QUICK_ARM,//手机即时布防
        MINOR_ALARMHOST_PHONE_DISARM,    //手机撤防
        MINOR_ALARMHOST_PHONE_CLEAR_ALARM,    //手机消警
        MINOR_ALARMHOST_WHITELIST_CFG,    //白名单配置
        MINOR_ALARMHOST_TIME_TRIGGER_CFG,            //定时开关触发器配置
        MINOR_ALARMHOST_CAPTRUE_CFG,                //抓图参数配置
        MINOR_ALARMHOST_TAMPER_CFG,                //防区防拆参数配置

        MINOR_ALARMHOST_REMOTE_KEYPAD_UPGRADE,               //远程升级键盘
        MINOR_ALARMHOST_ONETOUCH_AWAY_ARMING,                //一键外出布防 
        MINOR_ALARMHOST_ONETOUCH_STAY_ARMING,                //一键留守布防
        MINOR_ALARMHOST_SINGLE_PARTITION_ARMING_OR_DISARMING,    //单防区布撤防 
        MINOR_ALARMHOST_CARD_CONFIGURATION,         //卡参数配置
        MINOR_ALARMHOST_CARD_ARMING_OR_DISARMING,         //刷卡布撤防
        MINOR_ALARMHOST_EXPENDING_NETCENTER_CONFIGURATION,         //扩展网络中心配置
        MINOR_ALARMHOST_NETCARD_CONFIGURATION,         //网卡配置
        MINOR_ALARMHOST_DDNS_CONFIGURATION,         //DDNS配置
        MINOR_ALARMHOST_RS485BUS_CONFIGURATION,        // 485总线参数配置
         MINOR_ALARMHOST_RS485BUS_RE_REGISTRATION,            //485总线重新注册

        MINOR_ALARMHOST_REMOTE_OPEN_ELECTRIC_LOCK,    //远程打开电锁
        MINOR_ALARMHOST_REMOTE_CLOSE_ELECTRIC_LOCK,    //远程关闭电锁
        MINOR_ALARMHOST_LOCAL_OPEN_ELECTRIC_LOCK,    //本地打开电锁
        MINOR_ALARMHOST_LOCAL_CLOSE_ELECTRIC_LOCK,    //本地关闭电锁
        MINOR_ALARMHOST_OPEN_ALARM_LAMP,            //打开警灯(远程)
        MINOR_ALARMHOST_CLOSE_ALARM_LAMP,            //关闭警灯(远程)
        
        MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = 0xf0,        //本地激活设备
        MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = 0xf1,        //远程激活设备
        MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = 0xf2,    //本地回复出厂设置
        MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = 0xf3,    //远程恢复出厂设置

        
        // 事件 
        MINOR_SCHOOLTIME_IRGI_B = 0x01,        // B码校时
        MINOR_SCHOOLTIME_SDK,                // SDK校时
        MINOR_SCHOOLTIME_SELFTEST,            // 定时自检校时
        MINOR_SUBSYSTEM_ABNORMALINSERT,        //子板插入 
        MINOR_SUBSYSTEM_ABNORMALPULLOUT,        //子板拔出
        
        MINOR_AUTO_ARM,                    //自动布防
        MINOR_AUTO_DISARM,                //自动撤防
        MINOR_TIME_TIGGER_ON,            //定时开启触发器
        MINOR_TIME_TIGGER_OFF,            //定时关闭触发器
        MINOR_AUTO_ARM_FAILD,            //自动布防失败
        MINOR_AUTO_DISARM_FAILD,        //自动撤防失败
        MINOR_TIME_TIGGER_ON_FAILD,        //定时开启触发器失败
        MINOR_TIME_TIGGER_OFF_FAILD,    //定时关闭触发器失败
        MINOR_MANDATORY_ALARM,            //强制布防
        MINOR_KEYPAD_LOCKED,            //键盘锁定

}ALARMHOST_MINOR_TYPE;


//当日志的主类型为MAJOR_OPERATION=03，次类型为MINOR_LOCAL_CFG_PARM=0x52或者MINOR_REMOTE_GET_PARM=0x76
//或者MINOR_REMOTE_CFG_PARM=0x77时，dwParaType:参数类型有效，其含义如下：
#define PARA_VIDEOOUT    0x1
#define PARA_IMAGE        0x2
#define PARA_ENCODE        0x4
#define PARA_NETWORK    0x8
#define PARA_ALARM        0x10
#define PARA_EXCEPTION    0x20
#define PARA_DECODER    0x40    /*解码器*/
#define PARA_RS232        0x80
#define PARA_PREVIEW    0x100
#define PARA_SECURITY    0x200
#define PARA_DATETIME    0x400
#define PARA_FRAMETYPE    0x800    /*帧格式*/
#define PARA_DETECTION  0x1000   //侦测配置
#define PARA_VCA_RULE   0x1001  //行为规则 
#define PARA_VCA_CTRL   0x1002  //配置智能控制信息
#define PARA_VCA_PLATE  0x1003 // 车牌识别

#define PARA_CODESPLITTER 0x2000 /*码分器参数*/
//2010-01-22 增加视频综合平台日志信息次类型
#define PARA_RS485          0x2001            /* RS485配置信息*/
#define PARA_DEVICE          0x2002            /* 设备配置信息*/
#define PARA_HARDDISK      0x2003            /* 硬盘配置信息 */
#define PARA_AUTOBOOT      0x2004            /* 自动重启配置信息*/
#define PARA_HOLIDAY      0x2005            /* 节假日配置信息*/            
#define PARA_IPC          0x2006            /* IP通道配置 */    
/*************************参数配置命令 end*******************************/


/*******************查找文件和日志函数返回值*************************/
#define NET_DVR_FILE_SUCCESS            1000    //获得文件信息
#define NET_DVR_FILE_NOFIND                1001    //没有文件
#define NET_DVR_ISFINDING                1002    //正在查找文件
#define    NET_DVR_NOMOREFILE                1003    //查找文件时没有更多的文件
#define    NET_DVR_FILE_EXCEPTION            1004    //查找文件时异常

/*********************回调函数类型 begin************************/

//报警回调命令
#define COMM_ALARM                           0x1100    //8000报警信息主动上传

//对应NET_VCA_RULE_ALARM
#define COMM_ALARM_RULE                      0x1102     //行为分析报警信息
#define COMM_ALARM_PDC                       0x1103  //人数统计报警信息
#define COMM_ALARM_VIDEOPLATFORM             0x1104  //视频综合平台报警
#define COMM_ALARM_ALARMHOST                 0x1105  //网络报警主机报警
#define COMM_ALARM_FACE                      0x1106  //人脸检测识别报警信息
#define COMM_RULE_INFO_UPLOAD                0x1107  // 事件数据信息上传
#define COMM_ALARM_AID                       0x1110  //交通事件报警信息
#define COMM_ALARM_TPS                       0x1111  //交通参数统计报警信息
//智能人脸抓拍结果上传
#define COMM_UPLOAD_FACESNAP_RESULT          0x1112  //人脸识别结果上传
#define COMM_ALARM_TFS                       0x1113  //交通取证报警信息
#define COMM_ALARM_TPS_V41                   0x1114  //交通参数统计报警信息扩展
#define COMM_ALARM_AID_V41                   0x1115  //交通事件报警信息扩展
#define COMM_ALARM_VQD_EX                    0x1116     //视频质量诊断报警
#define COMM_SENSOR_VALUE_UPLOAD             0x1120  //模拟量数据实时上传
#define COMM_SENSOR_ALARM                    0x1121  //模拟量报警上传
#define COMM_SWITCH_ALARM                    0x1122     //开关量报警
#define COMM_ALARMHOST_EXCEPTION             0x1123  //报警主机故障报警
#define COMM_ALARMHOST_OPERATEEVENT_ALARM    0x1124  //操作事件报警上传
#define COMM_ALARMHOST_SAFETYCABINSTATE      0x1125     //防护舱状态
#define COMM_ALARMHOST_ALARMOUTSTATUS        0x1126     //报警输出口/警号状态
#define COMM_ALARMHOST_CID_ALARM               0x1127     //报告报警上传
#define    COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM 0x1128     //报警主机外接设备报警上传
#define COMM_ALARMHOST_DATA_UPLOAD           0x1129     //报警数据上传
#define COMM_FACECAPTURE_STATISTICS_RESULT   0x112a  //人脸抓拍统计上传
#define COMM_SCENECHANGE_DETECTION_UPLOAD     0x1130     //场景变更报警上传(布防)2013-7-16
#define COMM_CROSSLINE_ALARM                 0x1131    //压线报警(监听) 2013-09-27
#define COMM_UPLOAD_VIDEO_INTERCOM_EVENT     0x1132  //可视对讲事件记录上传
#define COMM_ALARM_VIDEO_INTERCOM               0x1133  //可视对讲报警上传
#define COMM_ALARM_AUDIOEXCEPTION             0x1150     //声音报警信息
#define COMM_ALARM_DEFOCUS                   0x1151     //虚焦报警信息
#define COMM_ALARM_BUTTON_DOWN_EXCEPTION     0x1152     //按钮按下报警信息
#define COMM_ALARM_ALARMGPS                  0x1202  //GPS报警信息上传
#define    COMM_TRADEINFO                       0x1500  //ATMDVR主动上传交易信息
#define COMM_UPLOAD_PLATE_RESULT             0x2800     //上传车牌信息
#define COMM_ITC_STATUS_DETECT_RESULT        0x2810  //实时状态检测结果上传(智能高清IPC)
#define COMM_IPC_AUXALARM_RESULT             0x2820  //PIR报警、无线报警、呼救报警上传
#define COMM_UPLOAD_PICTUREINFO              0x2900     //上传图片信息
#define COMM_SNAP_MATCH_ALARM                0x2902  //黑名单比对结果上传
#define COMM_ITS_PLATE_RESULT                0x3050  //终端图片上传
#define    COMM_ITS_TRAFFIC_COLLECT             0x3051  //终端统计数据上传
#define COMM_ITS_GATE_VEHICLE                0x3052  //出入口车辆抓拍数据上传
#define COMM_ITS_GATE_FACE                   0x3053  //出入口人脸抓拍数据上传
#define COMM_ITS_GATE_COSTITEM                 0x3054  //出入口过车收费明细 2013-11-19
#define COMM_ITS_GATE_HANDOVER                 0x3055  //出入口交接班数据 2013-11-19
#define COMM_ITS_PARK_VEHICLE                0x3056  //停车场数据上传
#define COMM_ITS_BLACKLIST_ALARM             0x3057  //黑名单报警上传

#define COMM_VEHICLE_CONTROL_LIST_DSALARM    0x3058  //黑白名单数据需要同步报警2013-11-04
#define COMM_VEHICLE_CONTROL_ALARM           0x3059  //车辆报警2013-11-04
#define COMM_FIRE_ALARM                      0x3060  //消防报警2013-11-04

#define COMM_ITS_GATE_ALARMINFO              0x3061  //出入口控制机数据上传

#define COMM_VEHICLE_RECOG_RESULT            0x3062  //车辆二次识别结果上传 2014-11-12 
#define COMM_PLATE_RESULT_V50                0x3063  //车牌上传 V50

#define COMM_GATE_CHARGEINFO_UPLOAD          0x3064  //出入口付费信息上传
#define COMM_TME_VEHICLE_INDENTIFICATION     0x3065  //TME车辆抓图上传
#define COMM_GATE_CARDINFO_UPLOAD            0x3066  //出入口卡片信息上传

#define COMM_ALARM_SENSORINFO_UPLOAD         0x3077     //传感器上传信息
#define COMM_ALARM_CAPTURE_UPLOAD             0x3078     //抓拍图片上传

#define COMM_ITS_RADARINFO                   0x3079  //雷达报警上传

#define COMM_SIGNAL_LAMP_ABNORMAL            0x3080  //信号灯异常检测上传

#define COMM_ALARM_TPS_REAL_TIME             0x3081  //TPS实时过车数据上传
#define COMM_ALARM_TPS_STATISTICS            0x3082  //TPS统计过车数据上传

#define COMM_ALARM_V30                         0x4000     //9000报警信息主动上传
#define COMM_IPCCFG                             0x4001     //9000设备IPC接入配置改变报警信息主动上传
#define COMM_IPCCFG_V31                         0x4002     //9000设备IPC接入配置改变报警信息主动上传扩展 9000_1.1
#define COMM_IPCCFG_V40                      0x4003  // IVMS 2000 编码服务器 NVR IPC接入配置改变时报警信息上传
#define COMM_ALARM_DEVICE                    0x4004  //设备报警内容，由于通道值大于256而扩展
#define COMM_ALARM_CVR                         0x4005  //CVR 2.0.X外部报警类型
#define COMM_ALARM_HOT_SPARE                 0x4006  //热备异常报警（N+1模式异常报警）
#define COMM_ALARM_V40                         0x4007    //移动侦测，视频丢失，遮挡，IO信号量等报警信息主动上传，报警数据为可变长

#define COMM_UPLOAD_HEATMAP_RESULT           0x4008 //热度图报警上传 2014-03-21
#define COMM_ALARM_DEVICE_V40                0x4009  //设备报警内容扩展
#define COMM_ALARM_FACE_DETECTION            0x4010 //人脸侦测报警
#define COMM_ALARM_TARGET_LEFT_REGION        0x4011 //检测目标离开检测区域报警(教师走向学生报警(用于联动切换录播主机控制检测学生的球机))
#define COMM_GISINFO_UPLOAD                  0x4012 //GIS信息上传
#define COMM_VANDALPROOF_ALARM               0x4013 //上传防破坏报警信息
#define COMM_PEOPLE_DETECTION_UPLOAD         0x4014 //人员侦测信息上传
#define COMM_ALARM_STORAGE_DETECTION         0x4015 //存储智能检测报警上传
#define    COMM_ITS_ROAD_EXCEPTION                 0x4500     //路口设备异常报警
#define    COMM_ITS_EXTERNAL_CONTROL_ALARM         0x4520  //外控报警
#define COMM_ALARM_SHIPSDETECTION             0x4521    // 船只检测报警信息
#define COMM_FIREDETECTION_ALARM             0x4991 //火点检测报警

#define    COMM_SCREEN_ALARM                    0x5000  //多屏控制器报警类型
#define COMM_DVCS_STATE_ALARM                 0x5001  //分布式大屏控制器报警上传
#define COMM_ALARM_ACS                         0x5002  //门禁主机报警
#define COMM_ALARM_FIBER_CONVERT             0x5003  //光纤收发器报警
#define COMM_ALARM_SWITCH_CONVERT             0x5004  //交换机报警
#define COMM_ALARM_DEC_VCA                   0x5010  //智能解码报警
#define COMM_ALARM_LCD                         0x5011     //屏幕报警
#define COMM_CONFERENCE_CALL_ALARM             0x5012     //会议呼叫告警

#define COMM_DIAGNOSIS_UPLOAD                0x5100  //诊断服务器VQD报警上传
#define COMM_HIGH_DENSITY_UPLOAD             0x5101  //人员聚集密度输出报警上传

#define COMM_ID_INFO_ALARM                   0x5200  //身份证信息上传
#define COMM_PASSNUM_INFO_ALARM              0x5201  //通行人数上报

#define COMM_THERMOMETRY_DIFF_ALARM          0x5211  //温差报警上传
#define COMM_THERMOMETRY_ALARM               0x5212  //温度报警上传

#define COMM_ALARM_VQD                         0x6000  //VQD主动报警上传 
#define COMM_PUSH_UPDATE_RECORD_INFO          0x6001  //推模式录像信息上传
#define COMM_SWITCH_LAMP_ALARM               0x6002  //开关灯检测


/*************操作异常类型(消息方式, 回调方式(保留))****************/
#define EXCEPTION_EXCHANGE                0x8000    //用户交互时异常
#define EXCEPTION_AUDIOEXCHANGE            0x8001    //语音对讲异常
#define EXCEPTION_ALARM                    0x8002    //报警异常
#define EXCEPTION_PREVIEW                0x8003    //网络预览异常
#define EXCEPTION_SERIAL                0x8004    //透明通道异常
#define EXCEPTION_RECONNECT                0x8005    //预览时重连
#define EXCEPTION_ALARMRECONNECT        0x8006    //报警时重连
#define EXCEPTION_SERIALRECONNECT        0x8007    //透明通道重连
#define SERIAL_RECONNECTSUCCESS         0x8008    //透明通道重连成功
#define EXCEPTION_PLAYBACK                0x8010    //回放异常
#define EXCEPTION_DISKFMT                0x8011    //硬盘格式化
#define EXCEPTION_PASSIVEDECODE         0x8012  //被动解码异常
#define EXCEPTION_EMAILTEST             0x8013  //邮件测试异常    
#define EXCEPTION_BACKUP                0x8014  //备份异常
#define PREVIEW_RECONNECTSUCCESS        0x8015  //预览时重连成功
#define ALARM_RECONNECTSUCCESS          0x8016  //报警时重连成功
#define RESUME_EXCHANGE                    0x8017    //用户交互恢复
#define NETWORK_FLOWTEST_EXCEPTION      0x8018  //网络流量检测异常
#define EXCEPTION_PICPREVIEWRECONNECT    0x8019    //图片预览重连
#define PICPREVIEW_RECONNECTSUCCESS        0x8020    //图片预览重连成功
#define EXCEPTION_PICPREVIEW            0x8021    //图片预览异常
#define    EXCEPTION_MAX_ALARM_INFO        0x8022    //报警信息缓存已达上限
#define    EXCEPTION_LOST_ALARM            0x8023  //报警丢失
#define EXCEPTION_PASSIVETRANSRECONNECT 0x8024  //被动转码重连
#define PASSIVETRANS_RECONNECTSUCCESS   0x8025  //被动转码重连成功
#define EXCEPTION_PASSIVETRANS          0x8026  //被动转码异常
#define SUCCESS_PUSHDEVLOGON            0x8030  //推模式设备注册成功
#define EXCEPTION_RELOGIN                0x8040    //用户重登陆
#define RELOGIN_SUCCESS                    0x8041    //用户重登陆成功
#define EXCEPTION_PASSIVEDECODE_RECONNNECT  0x8042  //被动解码重连

#define EXCEPTION_RELOGIN_FAILED                0x8044   //重登陆失败，停止重登陆
#define EXCEPTION_PREVIEW_RECONNECT_CLOSED      0x8045   //关闭预览重连功能
#define EXCEPTION_ALARM_RECONNECT_CLOSED        0x8046   //关闭报警重连功能
#define EXCEPTION_SERIAL_RECONNECT_CLOSED       0x8047   //关闭透明通道重连功能
#define EXCEPTION_PIC_RECONNECT_CLOSED          0x8048   //关闭回显重连功能
#define EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED 0x8049 //关闭被动解码重连功能
#define EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED 0x804a  //关闭被动转码重连功能 

/********************预览回调函数*********************/
#define NET_DVR_SYSHEAD            1    //系统头数据
#define NET_DVR_STREAMDATA        2    //视频流数据（包括复合流和音视频分开的视频流数据）
#define NET_DVR_AUDIOSTREAMDATA    3    //音频流数据
#define NET_DVR_STD_VIDEODATA    4    //标准视频流数据
#define NET_DVR_STD_AUDIODATA    5    //标准音频流数据
#define NET_DVR_SDP             6   //SDP信息(Rstp传输时有效)
#define NET_DVR_CHANGE_FORWARD  10  //码流改变为正放  
#define NET_DVR_CHANGE_REVERSE  11  //码流改变为倒放
#define NET_DVR_PLAYBACK_ALLFILEEND      12  //回放文件结束标记
#define NET_DVR_PRIVATE_DATA    112 //私有数据,包括智能信息

//设备型号(DVR类型)
/* 设备类型 */
#define DVR                            1                /*对尚未定义的dvr类型返回DVR*/
#define ATMDVR                        2                /*atm dvr*/
#define DVS                            3                /*DVS*/
#define DEC                            4                /* 6001D */
#define ENC_DEC                        5                /* 6001F */
#define DVR_HC                        6                /*8000HC*/
#define DVR_HT                        7                /*8000HT*/
#define DVR_HF                        8                /*8000HF*/
#define DVR_HS                        9                /* 8000HS DVR(no audio) */
#define DVR_HTS                        10              /* 8016HTS DVR(no audio) */
#define DVR_HB                        11              /* HB DVR(SATA HD) */
#define DVR_HCS                        12              /* 8000HCS DVR */
#define DVS_A                        13              /* 带ATA硬盘的DVS */
#define DVR_HC_S                    14              /* 8000HC-S */
#define DVR_HT_S                    15              /* 8000HT-S */
#define DVR_HF_S                    16              /* 8000HF-S */
#define DVR_HS_S                    17              /* 8000HS-S */
#define ATMDVR_S                    18              /* ATM-S */
#define DVR_7000H                    19                /*7000H系列*/
#define DEC_MAT                        20              /*多路解码器*/
#define DVR_MOBILE                    21                /* mobile DVR */                 
#define DVR_HD_S                    22              /* 8000HD-S */
#define DVR_HD_SL                    23                /* 8000HD-SL */
#define DVR_HC_SL                    24                /* 8000HC-SL */
#define DVR_HS_ST                    25                /* 8000HS_ST */
#define DVS_HW                        26              /* 6000HW */
#define DS630X_D                    27              /* 多路解码器 */
#define DS640X_HD                    28                /*640X高清解码器*/
#define DS610X_D                    29              /*610X解码器*/
#define IPCAM                        30                /*IP 摄像机*/
#define MEGA_IPCAM                    31                /*高清IP摄像机*/
#define IPCAM_X62MF                    32                /*862MF可以接入9000设备*/
#define ITCCAM                      35              /*智能高清网络摄像机*/
#define IVS_IPCAM                   36              /*智能分析高清网络摄像机*/
#define ZOOMCAM                     38              /*一体机*/
#define IPDOME                      40              /*IP 标清球机*/
#define IPDOME_MEGA200              41              /*IP 200万高清球机*/
#define IPDOME_MEGA130              42              /*IP 130万高清球机*/
#define IPDOME_AI                   43              /*IP 高清智能快球*/
#define TII_IPCAM                   44              /*红外热成像摄像机*/
#define IPTC_DOME                   45              /*红外热成像双目球机*/
#define DS_2DP_Z                    46              /*球型鹰眼（大）*/
#define DS_2DP                       47              /*非球型鹰眼（小）*/
#define ITS_WMS                      48              /*称重数据管理服务器*/
#define IPMOD                        50                /*IP 模块*/
#define TRAFFIC_YTDOME              51              //交通智能云台（不带雷达测速）
#define TRAFFIC_RDDOME              52              //交通智能云台（带雷达测速）
#define IDS6501_HF_P                60              // 6501 车牌 
#define IDS6101_HF_A                61              //智能ATM
#define IDS6002_HF_B                62          //双机跟踪：DS6002-HF/B
#define IDS6101_HF_B                63              //行为分析：DS6101-HF/B DS6101-HF/B_SATA
#define IDS52XX                        64          //智能分析仪IVMS
#define IDS90XX                        65                // 9000智能
#define IDS8104_AHL_S_HX            66          // 海鑫人脸识别 ATM
#define IDS8104_AHL_S_H             67              // 私有人脸识别 ATM
#define IDS91XX                        68                // 9100智能
#define IIP_CAM_B                   69              // 智能行为IP摄像机
#define IIP_CAM_F                   70              //智能人脸IP摄像机
#define DS71XX_H                    71                /* DS71XXH_S */
#define DS72XX_H_S                    72                /* DS72XXH_S */
#define DS73XX_H_S                    73                /* DS73XXH_S */
#define DS72XX_HF_S                 74              //DS72XX_HF_S
#define DS73XX_HFI_S                75              //DS73XX_HFI_S
#define DS76XX_H_S                    76                /* DVR,e.g. DS7604_HI_S */
#define DS76XX_N_S                    77                /* NVR,e.g. DS7604_NI_S */
#define DS_TP3200_EC                   78              /*机柜智能检测仪*/
#define DS81XX_HS_S                    81                /* DS81XX_HS_S */
#define DS81XX_HL_S                    82                /* DS81XX_HL_S */
#define DS81XX_HC_S                    83                /* DS81XX_HC_S */
#define DS81XX_HD_S                    84                /* DS81XX_HD_S */
#define DS81XX_HE_S                    85                /* DS81XX_HE_S */
#define DS81XX_HF_S                    86                /* DS81XX_HF_S */
#define DS81XX_AH_S                    87                /* DS81XX_AH_S */
#define DS81XX_AHF_S                88                /* DS81XX_AHF_S */
#define DS90XX_HF_S                    90              /*DS90XX_HF_S*/
#define DS91XX_HF_S                    91              /*DS91XX_HF_S*/
#define DS91XX_HD_S                    92              /*91XXHD-S(MD)*/
#define IDS90XX_A                    93                // 9000智能 ATM
#define IDS91XX_A                    94                // 9100智能 ATM
#define DS95XX_N_S                    95              /*DS95XX_N_S NVR 不带任何输出*/
#define DS96XX_N_SH                    96              /*DS96XX_N_SH NVR*/
#define DS90XX_HF_SH                97              /*DS90XX_HF_SH */   
#define DS91XX_HF_SH                98              /*DS91XX_HF_SH */
#define DS_B10_XY                   100             /*视频综合平台设备型号(X:编码板片数，Y:解码板片数)*/
#define DS_6504HF_B10               101             /*视频综合平台内部编码器*/
#define DS_6504D_B10                102             /*视频综合平台内部解码器*/
#define DS_1832_B10                 103             /*视频综合平台内部码分器*/
#define DS_6401HFH_B10              104             /*视频综合平台内部光纤板*/
#define DS_65XXHC                    105                //65XXHC DVS
#define DS_65XXHC_S                    106                //65XXHC-SATA DVS
#define DS_65XXHF                    107                //65XXHF DVS
#define DS_65XXHF_S                    108                //65XXHF-SATA DVS
#define DS_6500HF_B                 109             //65 rack DVS
#define IVMS_6200_C                 110             // iVMS-6200(/C)  
#define IVMS_6200_B                 111             // iVMS-6200(/B)
#define DS_72XXHV_ST15                112                //72XXHV_ST  海思3515平台 DVR
#define DS_72XXHV_ST20                113                //72XXHV_ST  海思3520平台 DVR
#define IVMS_6200_T                    114             // IVMS-6200(/T)
#define IVMS_6200_BP                115             // IVMS-6200(/BP)
#define DS_81XXHC_ST                116                //DS_81XXHC_ST
#define DS_81XXHS_ST                117                //DS_81XXHS_ST
#define DS_81XXAH_ST                118                //DS_81XXAH_ST
#define DS_81XXAHF_ST                119                //DS_81XXAHF_ST
#define DS_66XXDVS                    120                //66XX DVS

#define DS_1964_B10                 121             /*视频综合平台内部报警器*/
#define DS_B10N04_IN                122             /*视频综合平台内部级联输入*/
#define DS_B10N04_OUT                123             /*视频综合平台内部级联输出*/
#define DS_B10N04_INTEL             124             /*视频综合平台内部智能*/
#define DS_6408HFH_B10E_RM          125             //V6高清
#define DS_B10N64F1_RTM             126             //V6级联不带DSP
#define DS_B10N64F1D_RTM            127             //V6级联带DSP
#define DS_B10_SDS                  128             //视频综合平台子域控制器
#define DS_B10_DS                   129             //视频综合平台域控制器
#define DS_6401HFH_B10V                130             //VGA高清编码器
#define DS_6504D_B10B               131             /*视频综合平台内部标清解码器*/
#define DS_6504D_B10H               132             /*视频综合平台内部高清解码器*/
#define DS_6504D_B10V               133             /*视频综合平台内部VGA解码器*/
#define DS_6408HFH_B10S                134             //视频综合平台SDI子板 
#define DS_18XX_N                      135             /* 矩阵接入网关*/ 
#define DS_6504HF_B10F_CLASS        136                //光端机SD
#define DS_18XX_PTZ                    141                /*网络码分类产品*/
#define DS_19AXX                    142                /*通用报警主机类产品*/
#define DS_19BXX                    143                /*家用报警主机*/
#define DS_19CXX                    144                /*自助银行报警主机*/
#define DS_19DXX                    145                /*动环监控报警主机*/    
#define DS_19XX                     146             /*1900系列报警主机*/ 
#define DS_19SXX                    147                /*视频报警主机*/
#define DS_1HXX                        148                /*CS类产品*/ //防护舱
#define DS_PEAXX                    149                /*一键式紧急报警产品*/

//2011-11-30
#define    DS_C10H                        161                /*多屏控制器*/
#define DS_C10N_BI                    162                //BNC处理器
#define DS_C10N_DI                    163                //rbg处理器
#define DS_C10N_SI                    164                //码流处理器
#define DS_C10N_DO                    165                //显示处理器
#define DS_C10N_SERVER                166                //分布式服务器


#define IDS_8104_AHFL_S_H           171             // 8104ATM 
#define IDS_65XX_HF_A               172             // 65 ATM
#define IDS90XX_HF_RH               173             // 9000 智能RH
#define IDS91XX_HF_RH               174             // 9100 智能RH设备
#define IDS_65XX_HF_B               175             // 65 行为分析
#define IDS_65XX_HF_P               176             // 65 车牌识别
#define IVMS_6200_F                 177             // IVMS-6200(/F)
#define IVMS_6200_A                 178             //iVMS-6200(/A)
#define IVMS_6200_F_S                 179             // IVMS-6200(/F_S)人脸后检索分析仪

#define DS90XX_HF_RH                181             // 9000 RH    648
#define DS91XX_HF_RH                182             // 9100 RH设备 648
#define DS78XX_S                    183             // 78系列设备 6446
#define DS81XXHW_S                    185                // 81 Resolution 960 KY2011
#define DS81XXHW_ST                    186             // DS81XXHW_ST  KY2011
#define DS91XXHW_ST                    187             // DS91XXHW_ST  KY2011
#define DS91XX_ST                    188             // DS91XX_ST netra
#define DS81XX_ST                    189             // DS81XX_ST netra
#define DS81XXHX_ST                    190             // DS81XXHDI_ST,DS81XXHE_ST ky2012
#define DS73XXHX_ST                    191             // DS73XXHI_ST ky2012
#define DS81XX_SH                   192             // 审讯81SH,81SHF
#define DS81XX_SN                   193             // 审讯81SNL

#define DS96XXN_ST                  194             //NVR:DS96xxN_ST
#define DS86XXN_ST                  195             //NVR:DS86xxN_ST
#define DS80XXHF_ST                 196             //DVR:DS80xxHF_ST
#define DS90XXHF_ST                 197             //DVR:DS90xxHF_ST
#define DS76XXN_ST                  198             //NVR:DS76xxN_ST

#define DS_9664N_RX                 199         //NVR:DS_9664N_RX
#define ENCODER_SERVER                200            // 编码卡服务器
#define DECODER_SERVER              201         // 解码卡服务器
#define PCNVR_SERVER                202         // PCNVR存储服务器
#define CVR_SERVER                  203         // 邦诺CVR，他给自己定的类型为DVR_S-1
#define DS_91XXHFH_ST                204         // 91系列HD-SDI高清DVR
#define DS_66XXHFH                    205         // 66高清编码器
#define    TRAFFIC_TS_SERVER            210           //终端服务器
#define    TRAFFIC_VAR                    211           //视频分析记录仪
#define IPCALL                      212        //IP可视对讲分机
#define SAN_SERVER                  213         //与CVR_SERVER相同的程序，只是模式不同

#define DS_B11_M_CLASS                 301             /*视频综合平台设备型号*/
#define DS_B12_M_CLASS                  302             /*视频综合平台设备型号*/
#define DS_6504HF_B11_CLASS         303             /*视频综合平台内部编码器*/
#define DS_6504HF_B12_CLASS         304              /*视频综合平台内部编码器*/
#define  DS_6401HFH_B11V_CLASS         305     //VGA高清
#define  DS_6401HFH_B12V_CLASS         306     //VGA高清
#define  DS_6408HFH_B11S_CLASS         307     //SDI
#define  DS_6408HFH_B12S_CLASS      308     //SDI
#define  DS_6504D_B11H_CLASS        309   /*视频综合平台内部高清解码器*/
#define  DS_6504D_B11B_CLASS        310    /*视频综合平台内部标清解码器*/
#define  DS_6504D_B12B_CLASS        311       /*视频综合平台内部标清解码器*/
#define  DS_6504D_B11V_CLASS        312      /*视频综合平台内部VGA解码器*/
#define  DS_6504D_B12V_CLASS        313     /*视频综合平台内部VGA解码器*/
//B10新增
#define  DS_6401HFH_B10R_CLASS         314     //B10 RGB高清
#define  DS_6401HFH_B10D_CLASS         315     //B10 DVI高清
#define  DS_6401HFH_B10H_CLASS         316     //B10 HDMI高清
//B11新增
#define  DS_6401HFH_B11R_CLASS         317     //B11 RGB高清
#define  DS_6401HFH_B11D_CLASS         318     //B11 DVI高清
#define  DS_6401HFH_B11H_CLASS         319     //B11 HDMI高清
//B12新增
#define  DS_6401HFH_B12R_CLASS         320     //B12 RGB高清
#define  DS_6401HFH_B12D_CLASS         321     //B12 DVI高清
#define  DS_6401HFH_B12H_CLASS         322     //B12 HDMI高清
#define  DS_65XXD_B10Ex_CLASS        323     //netra高清解码 

//B10 V2.1新增
#define  DS_6516HW_B10_CLASS        324     //netra高线编码
#define  DS_6401HFH_B10F_RX_CLASS   326        //高清光端机接入（支持1/2路光端机接入）
#define  DS_6502HW_B10F_RX_CLASS    327        //960H光端机接入（支持1/4/8路光端机接入）
//2012-5-16新增
#define  DS_6504D_B11Ex_CLASS        328     //netra高清解码
#define  DS_6504D_B12Ex_CLASS        329     //netra高清解码
#define  DS_6512_B11_CLASS            330     //netra高线编码
#define  DS_6512_B12_CLASS            331     //netra高线编码
#define  DS_6504D_B10H_CLASS        332     //视频综合平台内部高清解码器

#define  DS_65XXT_B10_CLASS         333     //视频综合平台转码子系统
#define  DS_65XXD_B10_CLASS         335     //视频综合平台万能解码板
#define  DS_IVMSE_B10X_CLASS        336     //X86服务器子系统
#define  DS_6532D_B10ES_CLASS        337     //增强型解码板_SDI(B10)
#define  DS_6508HFH_B10ES_CLASS        338     //SDI输入编码子系统
#define  DS_82NCG_CLASS                340     //联网网关中的子系统
#define  DS_82VAG_CLASS                341     //联网网关中的子系统 
#define  DS_1802XXF_B10_CLASS       342     //光口交换子系统
#define  iDS_6504_B10EVAC_CLASS     343     //智能子系统
#define  iDS_6504_B10EDEC_CLASS     344     //智能子系统
#define  DS_6402HFH_B10EV_CLASS     345     //netra编码(VGA)
#define  DS_6402HFH_B10ED_CLASS     346     //netra编码(DVI)
#define  DS_6402HFH_B10EH_CLASS     347     //netra编码(HDMI)
#define  DS_6404HFH_B10T_RX_CLASS   348     //光纤接入编码
#define  DS_6504D_AIO_CLASS         349        //netra高清解码
#define  DS_IVMST_B10_CLASS            350        //X86转码子系统
#define  DS_6402_AIO_CLASS          351     //netra编码
#define  DS_iVMSE_AIO_CLASS         352     //x86服务器子系统
#define  DS_AIO_M_CLASS             353     //一体机


#define  DS_6508HF_B10E_CLASS        355        //BNC输入编码子系统
#define  DS_6404HFH_B10ES_CLASS        356        //SDI输入编码子系统
#define  DS_6402HFH_B10ER_CLASS        358        //RGB输入编码子系统
#define  DS_6404HFH_B10T_RM_CLASS    361        //光纤输入编码子系统
#define  DS_6516D_B10EB_CLASS        362        //BNC输出解码子系统
#define  DS_6516D_B10ES_CLASS        363        //SDI输出解码子系统

//DVI/HDMI/VGA畅显解码公用一个类型
#define  DS_6508D_B10FH_CLASS        364
#define  DS_6508D_B10FD_CLASS        364
#define  DS_6508D_B10FV_CLASS        364

#define  DS_6508_B11E_CLASS            365        //BNC输入编码子系统
#define  DS_6402_B11ES_CLASS        366        //SDI输入编码子系统
#define  DS_6402_B11EV_CLASS        367        //VGA输入编码子系统
#define  DS_6402_B11ER_CLASS        368        //RGB输入编码子系统
#define  DS_6402_B11ED_CLASS        369        //DVI输入编码子系统
#define  DS_6402_B11EH_CLASS        370        //HDMI输入编码子系统
#define  DS_6516D_B11EB_CLASS        371        //BNC输出解码子系统
#define  DS_6516D_B11ES_CLASS        372        //SDI输出解码子系统

#define  DS_6508_B12E_CLASS         373     //BNC输入编码子系统
#define     DS_6402_B12ES_CLASS        375        //SDI输入编码子系统
#define  DS_6402_B12EV_CLASS        376        //VGA输入编码子系统
#define  DS_6402_B12ER_CLASS        377        //RGB输入编码子系统
#define  DS_6402_B12ED_CLASS        378        //DVI输入编码子系统
#define  DS_6402_B12EH_CLASS        379        //HDMI输入编码子系统
#define  DS_6516D_B12EB_CLASS        380        //BNC输出解码子系统

#define  DS_iVMSE_AIO_8100x_CLASS   381     //金融行业一体机X86子系统
#define  DS_iVMSE_AIO_87x_CLASS     382     //智能楼宇一体机X86子系统
#define  DS_6532D_B11ES_CLASS        384        //增强型解码板_SDI(B11)
#define  DS_6532D_B12ES_CLASS        385        //增强型解码板_SDI(B12)
//B20新增
#define  DS_B20_MSU_NP              400     //B20主控板
#define  DS_6416HFH_B20S            401     //SDI输入编码
#define  DS_6416HFH_B20_RM          402     //光纤输入高清编码
#define  DS_6564D_B20D              403     //DVI解码
#define  DS_6564D_B20H              404     //HDMI解码
#define  DS_6564D_B20V              405     //VGA解码
#define  DS_B20_6516D_DEV_CLASS     406     //B20解码子系统
#define  DS_6408HFH_B20V            407     //VGA编码板
#define  DS_MMC_B20_CLASS           408     //B20主控
#define  DS_CARD_CHIP_B20_CLASS     409     //B20主控子板
#define  DS_6564D_B20B_DEV_CLASS    410     //BNC解码子系统
#define  DS_6564D_B20S_DEV_CLASS    411     //SDI解码子系统
#define  DS_6532HF_B20B_DEV_CLASS   412     //BNC编码子系统
#define  DS_6408HFH_B20D_DEV_CLASS  413     //DVI编码子系统
#define  DS_6408HFH_B20H_DEV_CLASS  414     //HDMI编码子系统
#define  DS_IVMSE_B20_CLASS            415     //X86服务器子系统
#define  DS_6402HFH_B20Y_DEV_CLASS  416     //YUV编码子系统
#define  DS_6508HW_B20_DEV_CLASS    417     //HW编码子系统
#define  DS_B20N128Fx_B20_DEV_CLASS 418     //DS_B20N128Fx_M级联板
#define  DS_AIO_MCU_NP_DEV_CLASS    419     //IO主控板
#define  DS_6402_AIO_EV_DEV_CLASS   420     //VGA编码
#define  DS_6508D_AIO_EV_DEV_CLASS  421     //VGA解码
#define  DS_6508D_AIO_ED_DEV_CLASS  422     //DVI解码
#define  DS_6508D_AIO_EH_DEV_CLASS  423     //HDMI解码
#define  DS_6508HD_B20F_DEV_CLASS    424     //视频增强板
#define  DS_6402HFH_B20ES_DEV_CLASS 425     //3G SID编码
#define  DS_6532D_B20_DEV_CLASS     426     //B20解码子系统            
#define  DS_IVMST_B20_DEV_CLASS     427     //X86服务器子系统
#define  DS_6416HFH_B20DD_DEV_CLASS 428     //DVI双链路
#define  DS_6441VS_B20_DEV_CLASS    429        //相机拼接类型
#define  DS_6404HFH_B20T_CLASS         431        //TVI
#define  DS_FS22_B20_DEV_CLASS         432        //交换机子系统
#define  DS_IVMSE_B20UH_DEV_CLASS   433     //超高清X86输入
#define  IDS_6524J_B20_DEV_CLASS    434
#define  IDS_6532B_B20_DEV_CLASS    435
#define DS_6404HFH_B20Fx_DEV_CLASS  436        //光端机接入子系统
#define DS_N128x_B20Fy_CLASS        437     //级联子系统
#define DS_181600F_B20_CLASS        438     //网络光纤子系统
#define  DS_6904UD_B20H_CLASS       439     //超高清解码子系统

#define DS_B21_MCU_NP_CLASS         440        //B21主控
#define DS_B21_S10_x_CLASS          441        //B21机箱 x = A/S/D
#define DS_6402HFH_B21D_CLASS        442     //B21编码子系统
#define DS_6508HD_B21D_CLASS        443     //B21解码子系统
#define DS_iVMSE_B21HW_CLASS        444     //B21 X86子系统

#define  DS_C10S                    501     //C10S 集中式大屏控制器

#define  DS_C10N_SDI                551        //SDI处理器
#define  DS_C10N_BIW                552        //8路BNC处理器
#define  DS_C10N_DON                553        //显示处理器
#define  DS_C10N_TVI                554     //TVI输入板
#define  DS_C10N_DI2                555     //DVI 2路输入板
#define  DS_C10N_AUDIO_OUT          556     //DVI，HDMI，VGA输出板带音频
#define  DS_C10N_AUDIO_IN           557     //DVI，HDMI，VGA输入板带音频

#define  DS_C20N                    570     //分布式大屏控制器
#define  DS_C20N_BNC                571     //BNC输入设备
#define  DS_C20N_DVI                572     //DVI输入设备
#define  DS_C20N_DP                 573     //DP输入设备
#define  DS_C20N_OUT                574     //输出设备


//报警设备
#define DS_19M00_MN                    601     //报警主机百兆网络模块 
#define DS_KH8302_A                 602  //室内机
#define DS_KD8101_2                 603  //门口机
#define DS_KM8301                   604  //管理机
#define DS_KVXXXX_XX                605  //别墅门口机


#define DS64XXHD_T                    701        //64-T高清解码器
#define DS_65XXD                    703     //65万能解码器
#define DS63XXD_T                    704        //63-T标清解码器
#define SCE_SERVER                  705     //抓屏服务器
#define DS_64XXHD_S                 706     //64XXHD-S高清解码器
#define DS_68XXT                    707     //多功能视音频转码器
#define DS_65XXD_T                  708     //65D-T万能解码器
#define DS_65XXHD_T                 709     //65HD-T万能解码器
#define DS_69XXUD                   710     //69XXUD超高清解码器
#define DS_65XXUD                   711     //65XXUD解码器
#define DS_65XXUD_L                 712     //65XXUD_L解码器
#define DS_65XXUD_T                 713     //65XXUD_T解码器

#define DS_D20XX                    750     //LCD屏幕 解码卡
//SDI矩阵
#define DS_C50S                     751     //SDI矩阵
#define DS_D50XX                    752     //LCD屏幕 解码卡

#define DS_D40                        760        //LED屏发送卡
#define DS_65VMXX                   770     //视频会议服务器
#define DS_65VTXX                   771     //视频会议终端
#define    DS_65VTA                    772        //视频会议一体式终端
#define DS_65VT_RX                  773     //互动教学终端
#define DS_CS_SERVER                800     //虚拟屏服务器
#define DS_K260X                    850     //门禁主机
#define DS_K1TXXX                   851     //指纹一体机
#define DS_K280X                    852     //经济型门禁主机
#define DS_K1T80X                   854     //经济型门禁一体机
#define RAC_6X00                    856     //汉军指纹门禁一体机
#define DS_K2602_AX                 857     //人员通道主机
#define DS_6800M                    900     //68M合码器
#define DS_68NTH                    901     //信息发布主机
#define DS_D60S                     902     //信息发布服务器
#define    DS_D10                        931        //背投显示设备
#define DS_3K0X_NM                    951        //光纤收发器
#define DS_3E2328                    952     //百兆交换机
#define SCREEN_LINK_SERVER          971     //屏幕服务器
#define DS_D51OPSXX             972  //OPS电脑盒
//一体化云台
#define IP_PTSYS_MEGA200            1001   //IP 200万一体化云台
#define IPCAM_FISHEYE               1002   //鱼眼摄像机
#define IPCAM_FISHEYE_E             1003   //经济型鱼眼摄像机

//68xx系列双目3D相机
#define IPCAM_BINOCULAR             1004   //双目摄像机

#define IPCAM_365                    1010    //支持365的平台的IPC CAM
#define IPCAM_R0                    1011    //支持A5S的平台的IPC CAM
#define IPCAM_R1                    1012    //支持385的平台的IPC CAM
#define IPCAM_R2                    1013    //支持R2的平台的IPC CAM
#define IPCAM_R3                    1014    //支持8127的平台的IPC CAM
#define IPCAM_R4                    1015    //支持S2的平台的IPC CAM

#define IPDOME_365                    1110    //支持365的平台的IPD CAM
#define IPDOME_R0                    1111    //支持A5S的平台的IPD CAM
#define IPDOME_R1                    1112    //支持385的平台的IPD CAM
#define IPDOME_R2                    1113    //支持R2的平台的IPD CAM
#define IPDOME_R3                    1114    //支持8127的平台的IPD CAM
#define IPDOME_R4                    1115    //支持S2的平台的IPD CAM
#define ITCCAM_R3                    1211    //支持8127的平台的ITCCAM

//新增设备类型 2013-11-19
#define TRAFFIC_ECT                    1400  //ECT设备类型
#define TRAFFIC_PARKING_SERVER        1401  //停车场服务器
#define TRAFFIC_TME                    1402  //出入口控制机
// DVR
#define DS90XXHW_ST                    2001    // DS90XXHW_ST混合DVR
#define DS72XXHX_SH                 2002    // DS-72xxHV_SH, DS-72xxHF-SH 
#define DS_92XX_HF_ST                2003    // DS-92XX-HF-ST 
#define DS_91XX_HF_XT                2004    // 9100DVR_HF_XT
#define DS_90XX_HF_XT               2005    // 9000DVR_HF_XT 
#define DS_73XXHX_SH                2006    // 7300DVR_HX_SH  
#define DS_72XXHFH_ST                2007    // 7200DVR_HFH_ST
//DS_67系列

#define DS_67XXHF_SATA              2008 // DS-67XXHF-SATA
#define DS_67XXHW                   2009 // DS-67XXHW 
#define DS_67XXHW_SATA              2010 // DS-67XXHW-SATA
#define DS_67XXHF                   2011 // DS-67XXHF

//Netra2.3
#define DS_72XXHF_SV                2012  // DS-72xxHF-SV 
#define DS_72XXHW_SV                2013   // DS-72xxHW-SV

#define DS_81XXHX_SH                2014   // 8100DVR_HX_SH

#define DS_71XXHX_SL                2015    //小型DVR

#define DS_76XXH_ST                    2016    //DS_76XXH_ST


#define DS_73XXHFH_ST               2017   //73HFH系列
#define DS_81XXHFH_ST               2018   //81HFH系列 ST

#define DS_72XXHFH_SL                2019    //hi3521 
#define DS_FDXXCGA_FLT                2020    //2盘位ATM

#define IDS_91XX_HF_ST_A            2100    //iDS-9100HF-ST/A
#define IDS_91XX_HF_ST_B            2101    //iDS-9100HF-ST/B
#define IDS_90XX_HF_ST_A            2102    //iDS-9000HF-ST/A
#define IDS_90XX_HF_ST_B            2103    //iDS-9000HF-ST/B
#define IDS_81XX_HF_ST_A            2104    //iDS-8100HF-ST/A
#define IDS_81XX_HF_ST_B            2105    //iDS-8100HF-ST/B
#define IDS_80XX_HF_ST_A            2106    //iDS-8000HF-ST/A
#define IDS_80XX_HF_ST_B            2107    //iDS-8000HF-ST/B
#define IDS_8104_AHFL_ST            2108    //智能混合ATM机

#define DS_72XXHXH_SH_21            2220   // 72HXH_SH系列_21
#define DS_72XXHXH_SH_31            2221  // 72XXHXH_SH_31
#define DS_73XXHXH_SH_31            2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31            2223  // 81XXHXH_SH_31


// NVR
#define DS_77XXN_ST                    2201    //  NVR DS-77XXHF-ST
#define DS_95XX_N_ST                2202    //  95XXN_ST NVR          
#define DS_85XX_N_ST                2203    //  85XXN_ST NVR
#define DS_96XX_N_XT                2204    // 9600NVR_N_XT
#define DS_76XX_N_SE                2205    // 7600NVR_N_SE

//高清审讯机
#define DS_86XXSN_SX                2206    // 8608NVR_SX，包括4中类型DS-8608SNL-SP、DS-8608SNL-ST、DS-8608SN-SP、DS-8608SN-ST，L表示带LCD，P表POE

//#define DS_96XX_N_RX                2207  //DS-96XX-N-RX
#define DS_71XXN_SL                    2208  //DS-71XXN-SL 民用产品
#define CS_N1_1XX                    2209  //CS_N1_1XX，民用事业部所用

#define DS_71XXN_SN                    2210    //71XX_N_SN  经济型民用产品 
#define CS_N1_2XX                    2211    //N1_2XX        民用事业部所用
#define DS_76XX_N_SHT                2212    //76XX_N_SHT  后端基线产品
#define DS_96XXX_N_E                2213    //高新性能NVR(256) 

#define    DS_76XXN_EX                    2214 /* 76 78系列NVR，注：包括 4 8 16路的E1一盘位， 8 16 32路 E2两盘位； /N /P设备*/
#define DS_77XXN_E4                    2215/* 77系列NVR，   注：包括8 16 32路， /N /P设备*/
#define DS_86XXN_E8                    2216/* 86系列NVR，   注：包括8 16 32路， /N /P设备*/
#define DS_9616N_H8                 2217   //DS_9616N_H8
#define DS_72XXHX_EX_GXY            2218   //表示72系列无线DVR产品，其中72后面的xx表示通道数，H后的X目前仅有HW,为了后续扩展保留，E后面的X表示的是盘位数，G XY表示的是无线类型
#define DS_76XXN_EX_GXY             2219   //表示是76系列无线NVR产品，其中76后面的xx表示通道数，E后面的X表示的是盘位数，G XY表示的是无线类型
#define DS_72XXHXH_SH_21            2220   //  72XXHXH_SH_21
#define DS_72XXHXH_SH_31            2221  //  72XXHXH_SH_31
#define DS_73XXHXH_SH_31            2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31            2223  //  81XXHXH_SH_31
#define DS_96XXN_FX                 2230
#define DS_86XXN_FX                 2231
#define DS_96XXXN_HX                2232  //96系列高性能设备


#define DS_86XXN_I                    2233    //DS_86XXN_I
#define DS_77XX_N_I                    2234    //DS_77XX_N_I
#define DS_76XX_N_I                    2235    //DS_76XX_N_I
#define DS_78XX_N_I                    2236    //DS_78XX_N_I

//PCNVR
#define PCNVR_IVMS_4200             2301    // PCNVR_IVMS_4200


//智能分析仪
#define IVMS_6200_TP                2401   //IVMS-6200 交通诱导分析仪
#define IVMS_6200_TF                2402   //IVMS-6200 交通取证分析仪
#define IVMS_6200_D                 2403   //iVMS-6200(/D)
#define IDS_81XXAHW_ST              2405   //iDS-81xxAHW-ST
#define IDS_81XXAHW_SP              2406   //iDS-81xxAHW-SP
#define IDS_81XXAHWL_ST             2407   //iDS-81xxAHWL-ST 
#define IDS_81XXAHWL_SP             2408   //iDS-81xxAHWL-SP
#define IDS_9616N_H8                2409   //iDS_9616N_H8
#define IVMS_6200_SMD               2500   //IVMS_6200_SMD
//HISI3531平台混合ATM DVR， 其中L表示带液晶屏，P表示带poe
#define DS_81XXAHW_ST                2501
#define DS_81XXAHW_SP                2502
#define DS_81XXAHWL_ST                2503
#define DS_81XXAHWL_SP                2504

//TVI ATM
#define DS_81XXAHGH_E4                2601    //DS_81XXAHGH_E4

#define DS_6904UD_AIOE_H_CLASS      4002    //B20一体机
#define DS_6402HFH_B21B_CLASS       4005    //B21 编码
#define DS_6902UD_B21H_CLASS        4006    //B21 HDMI解码
#define DS_6902UD_B21D_CLASS        4007    //B21 DVI解码
#define DS_6902UD_B21V_CLASS        4008    //B21 VGA解码
#define DS_6904UD_B20D_CLASS        4010    //B20 DVI解码
#define DS_6904UD_B20V_CLASS        4011    //B20 VGA解码



/**********************设备类型 end***********************/

/**********************设备大类 begin**********************/

/* dvr相关 1-50 */
#define DEV_CLASS_DVR      1          //普通dvr类型
#define DEV_CLASS_INTERROGATION  2    //审讯机
#define DEV_CLASS_SIMPLE_TRAIL  3    //简易庭审主机
#define DEV_CLASS_TRAIL  4           //标准庭审主机
#define DEV_CLASS_RECORD_PLAY  5     //录播主机
#define DEV_CLASS_ATM 6           //ATM机

/* dvs相关 51-100 */
#define DEV_CLASS_DVS 51          //普通dvs

/* nvr相关 101-150 */
#define DEV_CLASS_NVR 101          //普通nvr

/* ipc相关 151-200 */
#define DEV_CLASS_GUN 151          //ipc枪机
#define DEV_CLASS_BALL 152          //ipc球机
#define DEV_CLASS_SNAP 153          //抓拍机
#define DEV_CLASS_INTELLI_TILT 154   //智能云台

/* 其他设备类型 65534 */
#define DEV_CLASS_DEFAULT 65534   //默认设备类型
/**********************设备大类 end**********************/

/******************************能力集获取*********************************/
//能力获取命令
#define DEVICE_SOFTHARDWARE_ABILITY         0x001  //设备软硬件能力
#define DEVICE_NETWORK_ABILITY              0x002  //设备网络能力
#define DEVICE_ENCODE_ALL_ABILITY           0x003  //设备所有编码能力
#define    DEVICE_ENCODE_CURRENT               0x004  //设备当前编码能力
#define IPC_FRONT_PARAMETER                    0x005     //ipc前端参数1.0
#define IPC_UPGRADE_DESCRIPTION                0x006     //ipc升级信息
#define DEVICE_RAID_ABILITY                 0x007  //RAID能力
#define DEVICE_ENCODE_ALL_ABILITY_V20       0x008     //设备所有编码能力2.0
#define IPC_FRONT_PARAMETER_V20                0x009     //ipc前端参数2.0
#define DEVICE_ALARM_ABILITY                0x00a  //辅助报警能力
#define DEVICE_DYNCHAN_ABILITY                0x00b  //设备数字通道能力
#define DEVICE_USER_ABILITY                 0x00c  //设备用户管理参数能力
#define DEVICE_NETAPP_ABILITY               0x00d  //设备网络应用参数能力
#define DEVICE_VIDEOPIC_ABILITY             0x00e  //设备图像参数能力
#define DEVICE_JPEG_CAP_ABILITY             0x00f  //设备JPEG抓图能力
#define DEVICE_SERIAL_ABILITY               0x010  //RS232和RS485串口能力
#define DEVICE_ABILITY_INFO                    0x011     //设备通用能力类型，具体能力根据发送的能力节点来区分
#define STREAM_ABILITY                      0x012  //流能力
#define SYSTEM_MANAGEMENT_ABILITY           0x013  //设备系统管理能力
#define IP_VIEW_DEV_ABILITY                    0x014  //IP可视对讲分机能力
#define VCA_DEV_ABILITY                     0x100  //设备智能分析的总能力
#define VCA_CHAN_ABILITY                    0x110  //行为分析能力
#define MATRIXDECODER_ABILITY               0x200  //多路解码器显示、解码能力
#define VIDEOPLATFORM_ABILITY               0x210 //视频综合平台能力集
#define VIDEOPLATFORM_SBUCODESYSTEM_ABILITY 0x211 //视频综合平台编码子系统能力集
#define WALL_ABILITY                        0x212  //电视墙能力集
#define MATRIX_ABILITY                      0x213  //SDI矩阵能力 
#define DECODECARD_ABILITY                  0x220 //解码卡服务器能力集
#define VIDEOPLATFORM_ABILITY_V40           0x230 //视频综合平台能力集
#define MATRIXMANAGEDEVICE_ABILITY          0x240 //矩阵接入网关能力集
#define MATRIXDECODER_ABILITY_V41           0x260 //解码器能力集
#define DECODER_ABILITY                     0x261 //解码器xml能力集
#define DECODECARD_ABILITY_V41              0x270 //解码卡服务器能力集V41
#define CODECARD_ABILITY                    0x271  //编码卡能力集
#define SNAPCAMERA_ABILITY                  0x300  //抓拍机能力集
#define ITC_TRIGGER_MODE_ABILITY            0x301  //智能IPC设备的触发模式能力
#define COMPRESSIONCFG_ABILITY              0x400  //获取压缩参数能力集合
#define COMPRESSION_LIMIT                   0x401  //获取主子码流压缩参数能力限制
#define PIC_CAPTURE_ABILITY                    0x402  //获图片分辨率能力集合
#define ALARMHOST_ABILITY                   0x500 //网络报警主机能力集 
#define IT_DEVICE_ABILITY                   0x501  //智能交通能力集
#define    SCREENCONTROL_ABILITY                0x600     //大屏控制器能力集
#define    SCREENSERVER_ABILITY                0x610     //大屏服务器能力集
#define FISHEYE_ABILITY                     0x700   //鱼眼能力集
#define LCD_SCREEN_ABILITY                    0x800    //LCD屏幕能力 2013-10-12
#define ACS_ABILITY                         0x801   //门禁能力
#define MERGEDEV_ABILITY                    0x802   //合码器能力集
#define CAM_FUSION_ABILITY                  0x803   //相机拼接能力
#define OPTICAL_DEV_ACCESS_ABILITY          0x805   //光端机接入能力
#define NET_RING_ABILITY                    0x806    //环网能力集
#define LED_ABILITY                            0x807    //LED屏能力集
#define PUBLISHDEV_ABILITY                    0x80a    //信息发布能力
#define SCREEN_EXCHANGE_ABILITY             0x80b   //屏幕互动能力
/*************************************************
参数配置结构、参数(其中_V30为9000新增)
**************************************************/

//子板异常信息
//主类型
#define EXCEPTION_MAJOR_MAINBOARD_BOOT                    0x1  //主板启动类型
//次类型
#define EXCEPTION_MINOR_PCIE_SCAN                        0x1  // pcie链路扫描异常  
#define EXCEPTION_MINOR_DOWNLOAD_SUBBOARD                 0xa  //下载子板完成异常

//主类型
#define EXCEPTION_MAJOR_SUBBOARD_BOOT                    0x2  //子板启动类型
//次类型
#define EXCEPTION_MINOR_INEXISTENCE                       0x1  //PCI-E扫不到或当前子板不存在
#define EXCEPTION_MINOR_UBOOT_DOWNLOAD                  0xa  // uboot下载异常
#define EXCEPTION_MINOR_UBOOT_INIT                      0xe  //uboot初始化异常
#define EXCEPTION_MINOR_ROOTFS_DOWNLOAD                 0x14  //rootfs.img下载异常
#define EXCEPTION_MINOR_UIMAGE_DOWNLOAD                 0x19  //uImage下载异常
#define EXCEPTION_MINOR_UBOOT_SETBOOTFLAG               0x1e  // uboot启动标志位置位异常    
#define EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD            0x23  // rootfs启动异常
#define EXCEPTION_MINOR_NEED_FILE_FINISH                0x28  //子板所需文件传输异常

//主类型
#define EXCEPTION_MAJOR_SUBBOARD_HARDWARE                0x3  //子板硬件类型
//次类型
#define EXCEPTION_MINOR_AD                               0x1  //AD异常  
#define EXCEPTION_MINOR_DA                                 0xa  // DA异常
#define EXCEPTION_MINOR_TIMER                            0xb     //时钟异常

//主类型
#define EXCEPTION_MAJOR_FPGA                            0x4  //FPGA类型
//次类型
#define EXCEPTION_MINOR_IDLE                              0x1  //无法IDLE  
#define EXCEPTION_MINOR_LANE                             0xa  // LANE OK失败
#define EXCEPTION_MINOR_REGISTER_ALL_F                     0xe  //FPGA寄存器全F
#define EXCEPTION_MINOR_MEMORY_INIT_FAIL                 0x14 //FPGA内存初始化失败
//主类型
#define EXCEPTION_MAJOR_DSP                                0x5  //DSP类型

//主类型
#define EXCEPTION_MAJOR_ARM                                0x6  //ARM类型

//主类型
#define EXCEPTION_MAJOR_BACKBOARD                        0x7  //背板类型
//次类型
#define EXCEPTION_MINOR_BLACKBOARD_TYPE                   0x1  //获取背板类型异常
#define EXCEPTION_MINOR_SERDES                           0xa  //视频交换芯片  
#define EXCEPTION_MINOR_CLOCK                             0xe  //时钟故障
#define EXCEPTION_MINOR_SYNCH                             0x14  //同步信号故障

//主类型
#define EXCEPTION_MAJOR_SUBBOARD_NET                    0x8  //子板网络
//次类型
#define EXCEPTION_MINOR_IP_CONFLICT                       0x1  //IP冲突 
#define EXCEPTION_MINOR_DISCONNECT                         0x14  // 断网



typedef enum tagCharEncodeType
{
    ENUM_MEM_CHAR_ENCODE_ERR  = -1,         //Error   
    ENUM_MEM_CHAR_ENCODE_NO   = 0,          //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN   = 1,          //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK  = 2,          //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,          //BIG5
    ENUM_MEM_CHAR_ENCODE_JP   = 4,          //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR   = 5,          //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,          //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1  = 7,    //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
}CHAR_ENCODE_TYPE;


/////////////////////////////////////////////////////////////////////////
//校时结构参数
typedef struct
{
    DWORD dwYear;        //年
    DWORD dwMonth;        //月
    DWORD dwDay;        //日
    DWORD dwHour;        //时
    DWORD dwMinute;        //分
    DWORD dwSecond;        //秒
}NET_DVR_TIME, *LPNET_DVR_TIME;

typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
    WORD wMilliSec;
    BYTE byRes1[2];
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME,*LPNET_DVR_CALIBRATE_TIME;

#define    MAX_TIMESIGN_LEN    32 //自定义校时标记信息长度
typedef  struct tagNET_DVR_TIMESIGN_CFG
{
    DWORD  dwSize;
    BYTE  byCustomSetTimeSign[MAX_TIMESIGN_LEN/*32*/];//自定义校时标记
    BYTE  byRes[96]; 
}NET_DVR_TIMESIGN_CFG,*LPNET_DVR_TIMESIGN_CFG;


typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX,*LPNET_DVR_TIME_EX;

//时间段(子结构)
typedef struct
{
    //开始时间
    BYTE byStartHour;
    BYTE byStartMin;
    //结束时间
    BYTE byStopHour;
    BYTE byStopMin;
}NET_DVR_SCHEDTIME, *LPNET_DVR_SCHEDTIME;

/*设备报警和异常处理方式*/
/*设备报警和异常处理方式*/
#define NOACTION            0x0                /*无响应*/
#define WARNONMONITOR        0x1                /*监视器上警告*/
#define WARNONAUDIOOUT        0x2                /*声音警告*/
#define UPTOCENTER            0x4                /*上传中心*/
#define TRIGGERALARMOUT        0x8                /*触发报警输出*/
#define TRIGGERCATPIC        0x10            /*触发抓图并上传E-mail*/
#define SEND_PIC_FTP        0x200           /*抓图并上传ftp*/

typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD    wLength;        //结构长度
    BYTE    byVersion ;    /*高低4位分别代表高低版本，后续根据版本和长度进行扩展，不同的版本的长度进行限制*/
    BYTE    byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/
    /*0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0*/
    /*0x800: PTZ联动跟踪(球机跟踪目标)*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //触发报警通道  
    BYTE    byRes[64];           //保留
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V40
{    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x80: 报警触发录像(目前只有PCNVR支持) */
    /*0x100: 报警触发云台预置点 (目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0*/
    /*0x800: PTZ联动跟踪(球机跟踪目标)*/ 
    /*0x1000:抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOutChanNum; //触发的报警输出通道数 实际支持数
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //触发报警通道  
    BYTE    byRes[64];           //保留
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;

//报警和异常处理结构(子结构)(多处使用)(9000扩展)
typedef struct
{
    DWORD    dwHandleType;    /*处理方式,处理方式的"或"结果*/
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/
    BYTE byRelAlarmOut[MAX_ALARMOUT_V30];  
    //报警触发的输出通道,报警触发的输出,为1表示触发该输出
}NET_DVR_HANDLEEXCEPTION_V30, *LPNET_DVR_HANDLEEXCEPTION_V30;

//报警和异常处理结构(子结构)(多处使用)
typedef struct
{
    DWORD    dwHandleType;            /*处理方式,处理方式的"或"结果*/
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: Jpeg抓图并上传EMail*/
    BYTE byRelAlarmOut[MAX_ALARMOUT];  //报警触发的输出通道,报警触发的输出,为1表示触发该输出
}NET_DVR_HANDLEEXCEPTION, *LPNET_DVR_HANDLEEXCEPTION;

//DVR设备参数
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR名称
    DWORD dwDVRID;                //DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;        //是否循环录像,0:不是; 1:是
    //以下不可更改
    BYTE sSerialNumber[SERIALNO_LEN];  //序列号
    DWORD dwSoftwareVersion;            //软件版本号,高16位是主版本,低16位是次版本
    DWORD dwSoftwareBuildDate;            //软件生成日期,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;            //DSP软件版本,高16位是主版本,低16位是次版本
    DWORD dwDSPSoftwareBuildDate;        // DSP软件生成日期,0xYYYYMMDD
    DWORD dwPanelVersion;                // 前面板版本,高16位是主版本,低16位是次版本
    DWORD dwHardwareVersion;    // 硬件版本,高16位是主版本,低16位是次版本
    BYTE byAlarmInPortNum;        //DVR报警输入个数
    BYTE byAlarmOutPortNum;        //DVR报警输出个数
    BYTE byRS232Num;            //DVR 232串口个数
    BYTE byRS485Num;            //DVR 485串口个数
    BYTE byNetworkPortNum;        //网络口个数
    BYTE byDiskCtrlNum;            //DVR 硬盘控制器个数
    BYTE byDiskNum;                //DVR 硬盘个数
    BYTE byDVRType;                //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                //DVR 通道个数
    BYTE byStartChan;            //起始通道号,例如DVS-1,DVR - 1
    BYTE byDecordChans;            //DVR 解码路数
    BYTE byVGANum;                //VGA口的个数
    BYTE byUSBNum;                //USB口的个数
    BYTE byAuxoutNum;            //辅口的个数
    BYTE byAudioNum;            //语音口的个数
    BYTE byIPChanNum;            //最大数字通道数
}NET_DVR_DEVICECFG, *LPNET_DVR_DEVICECFG;

/*
IP地址
*/
typedef struct
{        
    char    sIpV4[16];                        /* IPv4地址 */
    BYTE    byIPv6[128];                        /* 保留 */
}NET_DVR_IPADDR, *LPNET_DVR_IPADDR;

/*
网络数据结构(子结构)(9000扩展)
*/
typedef struct 
{
    NET_DVR_IPADDR    struDVRIP;                              //DVR IP地址
    NET_DVR_IPADDR    struDVRIPMask;  //DVR IP地址掩码
    DWORD    dwNetInterface;                                   //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
    WORD    wDVRPort;                                        //端口号
    WORD    wMTU;                                            //增加MTU设置，默认1500。
    BYTE    byMACAddr[MACADDR_LEN];                            // 物理地址
    BYTE    byRes[2];              //保留
}NET_DVR_ETHERNET_V30, *LPNET_DVR_ETHERNET_V30;

/*
网络数据结构(子结构)
*/
typedef struct
{
    char sDVRIP[16];          //DVR IP地址
    char sDVRIPMask[16];      //DVR IP地址掩码
    DWORD dwNetInterface;     //网络接口 1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
    WORD wDVRPort;              //端口号
    BYTE byMACAddr[MACADDR_LEN];        //服务器的物理地址
}NET_DVR_ETHERNET;

//pppoe结构
typedef struct 
{
    DWORD    dwPPPOE;                                        //0-不启用,1-启用
    BYTE    sPPPoEUser[NAME_LEN];                            //PPPoE用户名
    char    sPPPoEPassword[PASSWD_LEN];                        // PPPoE密码
    NET_DVR_IPADDR    struPPPoEIP;                            //PPPoE IP地址
}NET_DVR_PPPOECFG, *LPNET_DVR_PPPOECFG;

//网络配置结构(9000扩展)
typedef struct
{    
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];        //以太网口
    NET_DVR_IPADDR    struRes1[2];                    /*保留*/
    NET_DVR_IPADDR    struAlarmHostIpAddr;                    /* 报警主机IP地址 */
    BYTE    byRes2[4];                                /* 保留 */
    WORD    wAlarmHostIpPort;                                /* 报警主机端口号 */
    BYTE    byUseDhcp;                                      /* 是否启用DHCP 0xff-无效 0-不启用 1-启用*/
    BYTE    byIPv6Mode;                                //IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
    NET_DVR_IPADDR    struDnsServer1IpAddr;                    /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR    struDnsServer2IpAddr;                    /* 域名服务器2的IP地址 */
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                    /* IP解析服务器域名或IP地址 */
    WORD    wIpResolverPort;                                /* IP解析服务器端口号 */
    WORD    wHttpPortNo;                                    /* HTTP端口号 */
    NET_DVR_IPADDR    struMulticastIpAddr;                    /* 多播组地址 */
    NET_DVR_IPADDR    struGatewayIpAddr;                        /* 网关地址 */
    NET_DVR_PPPOECFG struPPPoE;    
    BYTE    byEnablePrivateMulticastDiscovery;  //私有多播搜索，0~默认，1~启用，2-禁用
    BYTE    byEnableOnvifMulticastDiscovery;  //Onvif多播搜索，0~默认，1~启用，2-禁用
    BYTE    byRes[62];
} NET_DVR_NETCFG_V30, *LPNET_DVR_NETCFG_V30;

//多网卡配置网卡结构
typedef struct 
{
    NET_DVR_IPADDR struDVRIP;           //DVR IP地址
    NET_DVR_IPADDR struDVRIPMask;           //DVR IP地址掩码
    DWORD dwNetInterface;    //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M/1000M自适应
    BYTE byCardType;  //网卡类型，0-普通网卡，1-内网网卡，2-外网网卡
    BYTE byRes1; 
    WORD wMTU;             //增加MTU设置，默认1500。
    BYTE byMACAddr[MACADDR_LEN]; //物理地址，只用于显示
    BYTE byRes2[2]; //保留
    BYTE byUseDhcp;                          /* 是否启用DHCP */
    BYTE byRes3[3];
    NET_DVR_IPADDR struGatewayIpAddr;     /* 网关地址 */
    NET_DVR_IPADDR struDnsServer1IpAddr; /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR struDnsServer2IpAddr; /* 域名服务器2的IP地址 */
}NET_DVR_ETHERNET_MULTI, *LPNET_DVR_ETHERNET_MULTI;

//多网卡网络配置结构
typedef struct
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;        //默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
    BYTE   byNetworkCardNum;      //设备实际可配置的网卡数目
    BYTE   byWorkMode;   //0-普通多网卡模式，1-内外网隔离模式
    BYTE   byRes; //保留
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD]; //以太网口
    NET_DVR_IPADDR         struManageHost1IpAddr;     /* 主管理主机IP地址 */
    NET_DVR_IPADDR         struManageHost2IpAddr;     /* 辅管理主机IP地址 */
    NET_DVR_IPADDR           struAlarmHostIpAddr; /* 报警主机IP地址 */
    WORD wManageHost1Port;     /* 主管理主机端口号 */
    WORD wManageHost2Port;     /* 辅管理主机端口号 */
    WORD wAlarmHostIpPort;     /* 报警主机端口号 */
    BYTE  byIpResolver[MAX_DOMAIN_NAME];     /* IP解析服务器域名或IP地址 */
    WORD wIpResolverPort; /* IP解析服务器端口号 */
    WORD wDvrPort; //通讯端口 默认8000 
    WORD wHttpPortNo; /* HTTP端口号 */
    WORD wDvrPort2; //通讯端口2
    BYTE byRes2[4];
    NET_DVR_IPADDR   struMulticastIpAddr; /* 多播组地址 */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE byRes3[24];
}NET_DVR_NETCFG_MULTI, *LPNET_DVR_NETCFG_MULTI;

//网络配置结构
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET struEtherNet[MAX_ETHERNET];        /* 以太网口 */
    char sManageHostIP[16];        //远程管理主机地址
    WORD wManageHostPort;        //远程管理主机端口号
    char sIPServerIP[16];            //IPServer服务器地址
    char sMultiCastIP[16];     //多播组地址
    char sGatewayIP[16];           //网关地址
    char sNFSIP[16];            //NFS主机IP地址
    BYTE sNFSDirectory[PATHNAME_LEN];//NFS目录
    DWORD dwPPPOE;                //0-不启用,1-启用
    BYTE sPPPoEUser[NAME_LEN];    //PPPoE用户名
    char sPPPoEPassword[PASSWD_LEN];// PPPoE密码
    char sPPPoEIP[16];            //PPPoE IP地址(只读)
    WORD wHttpPort;                //HTTP端口号
}NET_DVR_NETCFG, *LPNET_DVR_NETCFG;

//sip配置
typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //使能自动注册，0-不使能，1-使能
    BYTE byLoginStatus;  //注册状态，0-未注册，1-已注册，此参数只能获取
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP服务器IP
    WORD wServerPort;    //SIP服务器端口
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //注册用户名
    BYTE byPassWord[PASSWD_LEN]; //注册密码
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //设备显示名称
    WORD wLocalPort;     //本地端口
    BYTE byLoginCycle;   //注册周期，1-99分钟
    BYTE byRes[129];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

//IP可视对讲分机配置
typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //默认铃音，范围1-6
    BYTE  byRingVolume;  //铃音音量，范围0-9
    BYTE  byInputVolume; //输入音量值，范围0-6
    BYTE  byOutputVolume; //输出音量值，范围0-9    
    WORD  wRtpPort;  //Rtp端口
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //预览延时配置，0-30秒
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG,*LPNET_DVR_IP_VIEW_DEVCFG;

//Ip可视对讲音频相关参数配置
typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;    
    BYTE  byAudioEncPri1; //音频编码优先级1，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    BYTE  byAudioEncPri2; //音频编码优先级2，当sip服务器不支持音频编码1时会使用音频编码2，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    WORD  wAudioPacketLen1; //音频编码1数据包长度
    WORD  wAudioPacketLen2; //音频编码2数据包长度
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG,*LPNET_DVR_IP_VIEW_AUDIO_CFG;

//IP分机呼叫对讲参数配置结构体
typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize ;
    BYTE  byEnableAutoResponse; //使能自动应答,0-不使能，1-使能
    BYTE  byAudoResponseTime; //自动应答时间，0-30秒
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //启动报警号码1，0-不启动，1-启动
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //呼叫号码1
    BYTE  byEnableAlarmNumber2; //启动报警号码2，0-不启动，1-启动
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //呼叫号码2，呼叫号码1失败会尝试呼叫号码2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG,*LPNET_DVR_IP_VIEW_CALL_CFG;

//通道图象结构
//移动侦测(子结构)(按组方式扩展)
typedef struct
{    
    DWORD     dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD     dwCurRecordChanNum;    //当前实际已配置的关联录像通道数
    DWORD     dwRelRecordChan[MAX_CHANNUM_V30];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - MAX_CHANNUM_V30-1有效，如果中间遇到0xffffffff,则后续无效*/  
    BYTE       byRes[64];          //保留
}NET_DVR_RECORDCHAN, *LPNET_DVR_RECORDCHAN;

//移动侦测(子结构)(9000扩展)
typedef struct 
{
    BYTE byMotionScope[64][96];                                    /*侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是*/
    BYTE byMotionSensitive;                                        /*移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭*/
    BYTE byEnableHandleMotion;                                    /* 是否处理移动侦测 0－否 1－是*/ 
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    char reservedData;    
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;                /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];                                    /* 报警触发的录象通道*/
}NET_DVR_MOTION_V30, *LPNET_DVR_MOTION_V30;

//移动侦测(子结构)
typedef struct 
{
    BYTE byMotionScope[18][22];    /*侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是*/
    BYTE byMotionSensitive;        /*移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭*/
    BYTE byEnableHandleMotion;    /* 是否处理移动侦测 */
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM]; //报警触发的录象通道,为1表示触发该通道
}NET_DVR_MOTION, *LPNET_DVR_MOTION;

//遮挡报警(子结构)(9000扩展)  区域大小704*576
typedef struct 
{
    DWORD dwEnableHideAlarm;                /* 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度*/
    WORD wHideAlarmAreaTopLeftX;            /* 遮挡区域的x坐标 */
    WORD wHideAlarmAreaTopLeftY;            /* 遮挡区域的y坐标 */
    WORD wHideAlarmAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAlarmAreaHeight;                /*遮挡区域的高*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
}NET_DVR_HIDEALARM_V30, *LPNET_DVR_HIDEALARM_V30;
//遮挡报警(子结构)  区域大小704*576
typedef struct 
{
    DWORD dwEnableHideAlarm;                /* 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度*/
    WORD wHideAlarmAreaTopLeftX;            /* 遮挡区域的x坐标 */
    WORD wHideAlarmAreaTopLeftY;            /* 遮挡区域的y坐标 */
    WORD wHideAlarmAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAlarmAreaHeight;                /*遮挡区域的高*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
}NET_DVR_HIDEALARM, *LPNET_DVR_HIDEALARM;

//信号丢失报警(子结构)(9000扩展)
typedef struct 
{
    BYTE byEnableHandleVILost;    /* 是否处理信号丢失报警 */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
}NET_DVR_VILOST_V30, *LPNET_DVR_VILOST_V30;

//信号丢失报警(子结构)
typedef struct 
{
    BYTE byEnableHandleVILost;    /* 是否处理信号丢失报警 */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
}NET_DVR_VILOST, *LPNET_DVR_VILOST;

//遮挡区域(子结构)
typedef struct 
{
    WORD wHideAreaTopLeftX;                /* 遮挡区域的x坐标 */
    WORD wHideAreaTopLeftY;                /* 遮挡区域的y坐标 */
    WORD wHideAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAreaHeight;                /*遮挡区域的高*/
}NET_DVR_SHELTER, *LPNET_DVR_SHELTER;

typedef struct
{
    BYTE byBrightness;      /*亮度,0-255*/
    BYTE byContrast;        /*对比度,0-255*/    
    BYTE bySaturation;      /*饱和度,0-255*/
    BYTE byHue;                /*色调,0-255*/
}NET_DVR_COLOR, *LPNET_DVR_COLOR;

typedef struct
{
    BYTE byRed;        //RGB颜色三分量中的红色
    BYTE byGreen;    //RGB颜色三分量中的绿色
    BYTE byBlue;    //RGB颜色三分量中的蓝色
    BYTE byRes;        //保留
}NET_DVR_RGB_COLOR, *LPNET_DVR_RGB_COLOR;

//坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位
//点坐标结构
typedef struct tagNET_VCA_POINT
{    
    float fX;                                // X轴坐标, 0.001~1
    float fY;                                //Y轴坐标, 0.001~1
}NET_VCA_POINT, *LPNET_VCA_POINT;

//通道图象结构(9000扩展)
typedef struct
{
    DWORD dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL*/
    BYTE  byReservedData[64];/*保留*/
    DWORD dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    WORD wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //视频信号丢失报警
    NET_DVR_VILOST_V30 struVILost;
    NET_DVR_VILOST_V30 struRes;        /*保留*/
    //    BYTE byRes1[328];
    //移动侦测
    NET_DVR_MOTION_V30 struMotion;
    //遮挡报警
    NET_DVR_HIDEALARM_V30 struHideAlarm;
    //遮挡  区域大小704*576
    DWORD dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    WORD wOSDTopLeftX;                /* OSD的x坐标 */
    WORD wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE byDispWeek;                /* 是否显示星期 */
    BYTE byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 1: 透明,闪烁 */
    /* 2: 透明,不闪烁 */
    /* 3: 闪烁,不透明 */
    /* 4: 不透明,不闪烁 */
    BYTE byHourOSDType;                /* OSD小时制:0-24小时制,1-12小时制 */
    BYTE byFontSize;//字体大小，16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 0xff-自适应(adaptive)
    BYTE byOSDColorType;    //0-默认（黑白）；1-自定义
    BYTE byAlignment;//对齐方式 0-自适应，1-右对齐, 2-左对齐
    BYTE byOSDMilliSecondEnable;//视频叠加时间支持毫秒；0~不叠加, 1-叠加
    NET_DVR_RGB_COLOR struOsdColor;//OSD颜色
    BYTE byRes[56];
}NET_DVR_PICCFG_V30, *LPNET_DVR_PICCFG_V30;

//通道图象结构SDK_V14扩展
typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*亮度,0-255*/
    BYTE byContrast;        /*对比度,0-255*/    
    BYTE bySaturation;      /*饱和度,0-255 */
    BYTE byHue;                /*色调,0-255*/
    //显示通道名
    DWORD dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    WORD wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //信号丢失报警
    NET_DVR_VILOST struVILost;
    //移动侦测
    NET_DVR_MOTION struMotion;
    //遮挡报警
    NET_DVR_HIDEALARM struHideAlarm;
    //遮挡  区域大小704*576
    DWORD dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    WORD wOSDTopLeftX;                /* OSD的x坐标 */
    WORD wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE byDispWeek;                /* 是否显示星期 */
    BYTE byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 1: 透明,闪烁 */
    /* 2: 透明,不闪烁 */
    /* 3: 闪烁,不透明 */
    /* 4: 不透明,不闪烁 */
    BYTE byHourOsdType;        /* OSD小时制:0-24小时制,1-12小时制 */
}NET_DVR_PICCFG_EX, *LPNET_DVR_PICCFG_EX;

//通道图象结构(SDK_V13及之前版本)
typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*亮度,0-255*/
    BYTE byContrast;        /*对比度,0-255*/    
    BYTE bySaturation;      /*饱和度,0-255 */
    BYTE byHue;                /*色调,0-255*/
    //显示通道名
    DWORD dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    WORD wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //信号丢失报警
    NET_DVR_VILOST struVILost;
    //移动侦测
    NET_DVR_MOTION struMotion;
    //遮挡报警
    NET_DVR_HIDEALARM struHideAlarm;
    //遮挡  区域大小704*576
    DWORD dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    WORD wHideAreaTopLeftX;                /* 遮挡区域的x坐标 */
    WORD wHideAreaTopLeftY;                /* 遮挡区域的y坐标 */
    WORD wHideAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAreaHeight;                /*遮挡区域的高*/
    //OSD
    DWORD dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    WORD wOSDTopLeftX;                /* OSD的x坐标 */
    WORD wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE byDispWeek;                /* 是否显示星期 */
    BYTE byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 1: 透明,闪烁 */
    /* 2: 透明,不闪烁 */
    /* 3: 闪烁,不透明 */
    /* 4: 不透明,不闪烁 */
    char reservedData2;
}NET_DVR_PICCFG, *LPNET_DVR_PICCFG;

typedef enum _BITRATE_ENCODE_INDEX_
{
    BITRATE_ENCODE_def = 0,
        BITRATE_ENCODE_8kps = 1,
        BITRATE_ENCODE_16kps = 2,
        BITRATE_ENCODE_32kps = 3,
        BITRATE_ENCODE_64kps = 4,
        BITRATE_ENCODE_128kps = 5,
        BITRATE_ENCODE_192kps = 6,
        BITRATE_ENCODE_40kps = 7,
        BITRATE_ENCODE_48kps = 8,
        BITRATE_ENCODE_56kps = 9,
        BITRATE_ENCODE_80kps = 10,
        BITRATE_ENCODE_96kps = 11,
        BITRATE_ENCODE_112kps = 12,
        BITRATE_ENCODE_144kps = 13,
        BITRATE_ENCODE_160kps = 14
}BITRATE_ENCODE_INDEX;

//码流压缩参数(子结构)(9000扩展)
typedef struct 
{
    BYTE byStreamType;        //码流类型 0-视频流, 1-复合流, 表示事件压缩参数时最高位表示是否启用压缩参数
                            /*分辨率0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,             
                            4-2CIF                      5（保留）,                 6-QVGA(320*240),        7-QQVGA(160*120),  
                            12-384*288                  13-576*576,                   
                            16-VGA（640*480）,          17-UXGA（1600*1200）,      18-SVGA(800*600),       19-HD720p(1280*720）,   
                            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,              
                            24-1920*1920,               27-HD1080i,                   
                            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,                
                            32-2448*1200,               33-2448*800,               34-XGA（1024*768），    35-SXGA（1280*1024）,         
                            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),  
                            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,                 
                            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,                 
                            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,                 
                            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
                            56-2304*1296                57-WXGA(1280*800),         58-1600*600,               59-1600*900,
                            60-2752*2208,                61-保留,                   62-4000*3000,           63-4096*2160,
                            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
                            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
                            72-160*128,                 73-324*240,                74-324*256,             75-336*256,             
                            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216, 
                            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
                            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
                            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
                            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
                            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
                            100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
                            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
                            108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
                            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
                            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
                            120-480*768,                121-768*480,               122-320*512,             123-512*320,
                            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
                            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
                            132-2720*1192,              133-3MP(1920*1536/2048*1536)，                     134-5MP(2560*1944)，
                            132-2720*1192,
                            0xff-Auto(使用当前码流分辨率)
    */
    BYTE byResolution;      
    BYTE byBitrateType;        //码率类型 0:变码率, 1:定码率,0xfe:自动，和源一致
    BYTE byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差,自动，和源一致
                            /*视频码率:0-保留，1-16K(保留)，2-32K，3-48k，4-64K，5-80K，6-96K，7-128K，8-160k，9-192K，10-224K，
                            11-256K，12-320K，13-384K，14-448K，15-512K，16-640K，17-768K，18-896K，19-1024K，20-1280K，21-1536K，22-1792K，23-2048K，
    24-3072K，25-4096K，26-8192K，27-16384K。最高位(31位)置成1表示是自定义码流，0～30位表示码流值，最小值16k,0xfffffffe，自动，和源一致*/
    DWORD dwVideoBitrate;      
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; V2.0版本中新加14-15; 15-18; 16-22;
    //17-25；18-30；19-35；20-40；21-45；22-50；23-55；24-60；25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,0xfffffffe-自动，和源一致
    WORD  wIntervalFrameI;  //I帧间隔,0xfffe 自动，和源一致
    BYTE  byIntervalBPFrame;//0-BBP帧; 1-BP帧; 2-单P帧(2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题)；0xfe-自动，和源一致
    BYTE  byres1;        //保留
    BYTE  byVideoEncType;   //视频编码类型 0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，9-SVAC, 10-标准h265, 0xfe-自动（和源一致），0xff-无效 
    BYTE  byAudioEncType;   //音频编码类型 0-G722;1-G711_U;2-G711_A;5-MP2L2;6-G276;7-AAC;8-PCM;0xff-无效
    BYTE  byVideoEncComplexity; //视频编码复杂度，0-低，1-中，2高,0xfe:自动，和源一致
    BYTE  byEnableSvc; //0 - 不启用SVC功能；1- 启用SVC功能; 2-自动启用SVC功能
    BYTE  byFormatType; //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP,9-RTP+PS（国标：GB28181），0xff-无效
    BYTE  byAudioBitRate; //音频码率 参考 BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;//码流平滑 1～100（1等级表示清晰(Clear)，100表示平滑(Smooth)）
    BYTE  byAudioSamplingRate;//音频采样率0-默认,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;//高性能编码 0-关闭，1-打开
    BYTE  byres;
    //平均码率（在SmartCodec使能开启下生效）, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
    //最高位(15位)置成1表示是自定义码流, 0-14位表示码流值(MIN- 0 K)。
    WORD  wAverageVideoBitrate; 
}NET_DVR_COMPRESSION_INFO_V30, *LPNET_DVR_COMPRESSION_INFO_V30;

//通道压缩参数(9000扩展)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;    //录像 对应8000的普通
    NET_DVR_COMPRESSION_INFO_V30 struRes;//保留 char reserveData[28];
    NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;       //事件触发压缩参数
    NET_DVR_COMPRESSION_INFO_V30 struNetPara;               //网传(子码流)
}NET_DVR_COMPRESSIONCFG_V30, *LPNET_DVR_COMPRESSIONCFG_V30;

//码流压缩参数(子结构)
typedef struct 
{
    BYTE byStreamType;        //码流类型0-视频流,1-复合流,表示压缩参数时最高位表示是否启用压缩参数
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    BYTE byBitrateType;        //码率类型0:变码率，1:定码率
    BYTE  byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    DWORD dwVideoBitrate;     //视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20;
}NET_DVR_COMPRESSION_INFO, *LPNET_DVR_COMPRESSION_INFO;

//通道压缩参数
typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara; //录像/事件触发录像
    NET_DVR_COMPRESSION_INFO struNetPara;    //网传/保留
}NET_DVR_COMPRESSIONCFG, *LPNET_DVR_COMPRESSIONCFG;

//码流压缩参数(子结构)(扩展) 增加I帧间隔
typedef struct 
{
    BYTE byStreamType;        //码流类型0-视频流, 1-复合流
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    BYTE byBitrateType;        //码率类型0:变码率，1:定码率
    BYTE  byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    DWORD dwVideoBitrate;     //视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    WORD  wIntervalFrameI;  //I帧间隔
    //2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
    BYTE  byIntervalBPFrame;//0-BBP帧; 1-BP帧; 2-单P帧
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX, *LPNET_DVR_COMPRESSION_INFO_EX;

//通道压缩参数(扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara; //录像
    NET_DVR_COMPRESSION_INFO_EX struNetPara;    //网传
}NET_DVR_COMPRESSIONCFG_EX, *LPNET_DVR_COMPRESSIONCFG_EX;


//时间段录像参数配置(子结构)
typedef struct 
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;    //0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警, 5:命令触发, 6: 智能录像,10-PIR报警，11-无线报警，12-呼救报警，13-所有报警,14-智能交通事件，15越界侦测，16区域入侵侦测，17音频异常侦测
    char reservedData[3];
}NET_DVR_RECORDSCHED, *LPNET_DVR_RECORDSCHED;

//全天录像参数配置(子结构)
typedef struct 
{
    WORD wAllDayRecord;                /* 是否全天录像 0-否 1-是*/
                                    BYTE byRecordType;                /* 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 智能录像,
                                                                    10-PIR报警，11-无线报警，12-呼救报警，13-移动|报警输入|PIR|无线报警|呼救报警,14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
                                    18-场景变更侦测,19-智能侦测（越界侦测|区域入侵|进入区域|离开区域|人脸识别）,20－人脸侦测, 21-POS录像*/
                                    char reservedData;
}NET_DVR_RECORDDAY, *LPNET_DVR_RECORDDAY;

//通道录像参数配置(9000扩展)
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟*/
    DWORD    dwPreRecordTime;                /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
    DWORD    dwRecorderDuration;                /* 录像保存的最长时间 */
    BYTE    byRedundancyRec;    /*是否冗余录像,重要数据双备份：0/1*/
    BYTE    byAudioRec;        /*录像时复合流编码时是否记录音频数据：国外有此法规*/
    BYTE    byStreamType;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    BYTE    byPassbackRecord;  // 0:不回传录像 1：回传录像
    WORD    wLockDuration;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    BYTE    byRecordBackup;  // 0:录像不存档 1：录像存档
    BYTE     bySVCLevel;    //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    BYTE    byRecordManage;   //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    BYTE    byExtraSaveAudio;        //音频单独另存0-非单独另存，1-单独另存
    BYTE    byReserve[2]; 
}NET_DVR_RECORD_V30, *LPNET_DVR_RECORD_V30;

//时间段录像参数配置(子结构)
typedef struct 
{
    NET_DVR_SCHEDTIME  struRecordTime;
    /*录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 
    6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件, 
    15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
    19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
    22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
    28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
    35-船只检测, 36-测温预警，37-测温报警，38-温差报警*/    
    BYTE byRecordType; 
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

//全天录像参数配置(子结构)
typedef struct 
{
    BYTE byAllDayRecord; /* 是否全天录像 0-否 1-是*/
                         /*录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 
                         6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件, 
                         15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
                         19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
                         22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
                         28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
                         35-船只检测, 36-测温预警，37-测温报警，38-温差报警*/
    BYTE byRecordType; 
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY_V40    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40 struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟*/
    DWORD    dwPreRecordTime;                /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
    DWORD    dwRecorderDuration;                /* 录像保存的最长时间 */
    BYTE    byRedundancyRec;    /*是否冗余录像,重要数据双备份：0/1*/
    BYTE    byAudioRec;        /*录像时复合流编码时是否记录音频数据：国外有此法规*/
    BYTE    byStreamType;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    BYTE    byPassbackRecord;  // 0:不回传录像 1：回传录像
    WORD    wLockDuration;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    BYTE    byRecordBackup;  // 0:录像不存档 1：录像存档
    BYTE     bySVCLevel;    //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    BYTE    byRecordManage;   //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    BYTE    byExtraSaveAudio;//音频单独存储
    BYTE    byRes[126]; 
}NET_DVR_RECORD_V40, *LPNET_DVR_RECORD_V40;

//通道录像参数配置
typedef struct 
{
    DWORD dwSize;
    DWORD dwRecord;  /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;    /* 录象时间长度 */
    DWORD dwPreRecordTime;    /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
}NET_DVR_RECORD, *LPNET_DVR_RECORD;

//云台协议表结构配置
typedef struct
{ 
    DWORD dwType;               /*解码器类型值*/    
    BYTE  byDescribe[DESC_LEN]; /*解码器的描述符，和8000中的一致*/    
}NET_DVR_PTZ_PROTOCOL;

typedef struct
{    
    DWORD   dwSize;    
    NET_DVR_PTZ_PROTOCOL struPtz[PTZ_PROTOCOL_NUM];/*最大200中PTZ协议*/    
    DWORD   dwPtzNum;           /*有效的ptz协议数目，从0开始(即计算时加1)*/
    BYTE    byRes[8];
}NET_DVR_PTZCFG, *LPNET_DVR_PTZCFG;

/***************************云台类型(end)******************************/
typedef struct tagNET_DVR_SERIALSTART_V40   //透明通道
{
    DWORD  dwSize;         //结构体大小
    DWORD  dwSerialType;    //串口号（1-232串口，2-485串口）
    BYTE   bySerialNum;   //串口编号
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40,*LPNET_DVR_SERIALSTART_V40;

//通道解码器(云台)参数配置 扩展
typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;       //结构体大小
    DWORD     dwBaudRate;       //波特率 0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k; 
    BYTE     byDataBit;       //数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE     byStopBit;       //停止位 0－1位，1－2位
    BYTE     byParity;       //校验 0－无校验，1－奇校验，2－偶校验
    BYTE     byFlowcontrol;  //0－无，1－软流控,2-硬流控
    WORD     wDecoderType;    //解码器类型*/
    WORD     wDecoderAddress;    //解码器地址，0-255
    BYTE     bySetPreset [MAX_PRESET_V30];  //预置点是否设置,0-没有设置,1-设置
    BYTE     bySetCruise[MAX_CRUISE_V30];  //巡航是否设置: 0-没有设置,1-设置
    BYTE     bySetTrack [MAX_TRACK_V30];    //轨迹是否设置,0-没有设置,1-设置
    BYTE     bySerialNO;          //串口编号
    BYTE     byWorkMode;        /*工作模式， 1-矩阵串口控制，2-屏幕控制，3-透明通道模式 4-PPP模式 5-控制台模式 6-串口直连 7-键盘控制 8-监控板管理 9-控制云台*/
    BYTE     byRes[254];         //保留
}NET_DVR_DECODERCFG_V40,*LPNET_DVR_DECODERCFG_V40;

//通道解码器(云台)参数配置(9000扩展)
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    WORD wDecoderType;//解码器类型, 从0开始，对应ptz协议列表从NET_DVR_IPC_PROTO_LIST得到
    WORD wDecoderAddress;    /*解码器地址:0 - 255*/
    BYTE bySetPreset[MAX_PRESET_V30];        /* 预置点是否设置,0-没有设置,1-设置*/
    BYTE bySetCruise[MAX_CRUISE_V30];        /* 巡航是否设置: 0-没有设置,1-设置 */
    BYTE bySetTrack[MAX_TRACK_V30];            /* 轨迹是否设置,0-没有设置,1-设置*/
}NET_DVR_DECODERCFG_V30, *LPNET_DVR_DECODERCFG_V30;

//通道解码器(云台)参数配置
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;       //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;         // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;         // 停止位 0－1位，1－2位;
    BYTE byParity;          // 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;     // 0－无，1－软流控,2-硬流控
    WORD wDecoderType;      //解码器类型  NET_DVR_IPC_PROTO_LIST中得到
    WORD wDecoderAddress;    /*解码器地址:0 - 255*/
    BYTE bySetPreset[MAX_PRESET];        /* 预置点是否设置,0-没有设置,1-设置*/
    BYTE bySetCruise[MAX_CRUISE];        /* 巡航是否设置: 0-没有设置,1-设置 */
    BYTE bySetTrack[MAX_TRACK];        /* 轨迹是否设置,0-没有设置,1-设置*/
}NET_DVR_DECODERCFG, *LPNET_DVR_DECODERCFG;

//ppp参数配置(子结构)
typedef struct 
{
    NET_DVR_IPADDR struRemoteIP;    //远端IP地址
    NET_DVR_IPADDR struLocalIP;        //本地IP地址
    char sLocalIPMask[16];            //本地IP地址掩码
    BYTE sUsername[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byPPPMode;                    //PPP模式, 0－主动，1－被动
    BYTE byRedial;                    //是否回拨 ：0-否,1-是
    BYTE byRedialMode;                //回拨模式,0-由拨入者指定,1-预置回拨号码
    BYTE byDataEncrypt;                //数据加密,0-否,1-是
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //电话号码
}NET_DVR_PPPCFG_V30, *LPNET_DVR_PPPCFG_V30;

//ppp参数配置(子结构)
typedef struct 
{
    char sRemoteIP[16];                //远端IP地址
    char sLocalIP[16];                //本地IP地址
    char sLocalIPMask[16];            //本地IP地址掩码
    BYTE sUsername[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byPPPMode;                    //PPP模式, 0－主动，1－被动
    BYTE byRedial;                    //是否回拨 ：0-否,1-是
    BYTE byRedialMode;                //回拨模式,0-由拨入者指定,1-预置回拨号码
    BYTE byDataEncrypt;                //数据加密,0-否,1-是
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //电话号码
}NET_DVR_PPPCFG, *LPNET_DVR_PPPCFG;

//RS232串口参数配置(9000扩展)
typedef struct
{
    DWORD dwBaudRate;   /*波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;*/
    BYTE byDataBit;     /* 数据有几位 0－5位，1－6位，2－7位，3－8位 */
    BYTE byStopBit;     /* 停止位 0－1位，1－2位 */
    BYTE byParity;      /* 校验 0－无校验，1－奇校验，2－偶校验 */
    BYTE byFlowcontrol; /* 0－无，1－软流控,2-硬流控 */
    DWORD dwWorkMode;   //工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道 3- ptz模式,审讯温湿度传感器, 4-报警盒模式  5-矩阵串口控制 6-屏幕控制 7-串口直连 8-键盘控制 9-监控板管理 10-控制云台
}NET_DVR_SINGLE_RS232;

typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate;   /*波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;*/
    BYTE byDataBit;     /* 数据有几位 0－5位，1－6位，2－7位，3－8位 */
    BYTE byStopBit;     /* 停止位 0－1位，1－2位 */
    BYTE byParity;      /* 校验 0－无校验，1－奇校验，2－偶校验 */
    BYTE byFlowcontrol; /* 0－无，1－软流控,2-硬流控 */
    BYTE byVirtualSerialPort;  //虚拟串口编号
    BYTE byRes[3];
}NET_DVR_USB_RS232,*LPNET_DVR_USB_RS232;

//RS232串口参数配置(9000扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*注意：此结构修改了，原来是单个结构，现在修改为了数组结构*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30, *LPNET_DVR_RS232CFG_V30;

//RS232串口参数配置
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    DWORD dwWorkMode;// 工作模式，0－窄带传输(232串口用于PPP拨号)，1－控制台(232串口用于参数控制)，2－透明通道
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG, *LPNET_DVR_RS232CFG;


typedef struct 
{
    DWORD dwEnablePresetChan;    /*启用预置点的通道, 0xfffffff表示不调用预置点*/
    DWORD dwPresetPointNo;        /*调用预置点通道对应的预置点序号, 0xfffffff表示不调用预置点。*/
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct 
{
    DWORD dwEnableCruiseChan;    /*启用巡航的通道*/
    DWORD dwCruiseNo;        /*巡航通道对应的巡航编号, 0xfffffff表示无效*/
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct 
{
    DWORD dwEnablePtzTrackChan;    /*启用云台轨迹的通道*/
    DWORD dwPtzTrackNo;        /*云台轨迹通道对应的编号, 0xfffffff表示无效*/
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;


//报警输入参数配置(256路NVR扩展)
typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;                //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byRes1;                    //保留            
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000:抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOutChanNum; //触发的报警输出通道数 实际支持数
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //触发报警通道
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    /*触发的录像通道*/
    DWORD   dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD   dwCurRecordChanNum;    //当前实际已配置的关联录像通道数
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwCurRecordChanNum -1有效，如果中间遇到0xffffffff,则后续无效*/ 
    DWORD   dwMaxEnablePtzCtrlNun; //最大可启用的云台控制总数(只读)
    DWORD   dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //启用的预置点信息
    BYTE    byRes2[516];                    /*保留*/
    DWORD   dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //启用巡航功能通道的信息
    DWORD   dwEnablePtzTrackChanNum;  //当前已启用巡航的通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //调用云台轨迹的通道信息
    BYTE    byRes[256];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

//报警输入参数配置(9000扩展)
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;                //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byRes1;            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byEnablePreset[MAX_CHANNUM_V30];        /* 是否调用预置点 0-否,1-是*/
    BYTE byPresetNo[MAX_CHANNUM_V30];            /* 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。*/
    BYTE byRes2[192];                    /*保留*/
    BYTE byEnableCruise[MAX_CHANNUM_V30];        /* 是否调用巡航 0-否,1-是*/
    BYTE byCruiseNo[MAX_CHANNUM_V30];            /* 巡航 */
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];        /* 是否调用轨迹 0-否,1-是*/
    BYTE byPTZTrack[MAX_CHANNUM_V30];            /* 调用的云台的轨迹序号 */
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30, *LPNET_DVR_ALARMINCFG_V30;


typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    /*0-信号量报警,1-硬盘满,2-信号丢失，3－移动侦测，4－硬盘未格式化,5-写硬盘出错,6-遮挡报警，
    7-制式不匹配, 8-非法访问，9-视频信号异常，10-录像异常，11-智能场景变化，12-阵列异常，13-前端/录像分辨率不匹配, 
    14-申请解码资源失败,15-智能侦测报警, 16-热备异常，17-录播主机报警，18-语音对讲请求报警*/
    DWORD dwAlarmType;//报警类型
    NET_DVR_TIME_EX struAlarmTime;    //发生报警的时间
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            DWORD    dwAlarmInputNo;        //发生报警的报警输入通道号，一次只有一个
            DWORD    dwTrigerAlarmOutNum;    /*触发的报警输出个数，用于后面计算变长数据部分中所有触发的报警输出通道号，四字节表示一个*/
            DWORD    dwTrigerRecordChanNum;    /*触发的录像通道个数，用于后面计算变长数据部分中所有触发的录像通道号，四字节表示一个*/
        }struIOAlarm;    // 报警类型dwAlarmType为0时有效
        struct
        {
            DWORD    dwAlarmChanNum;    /*发生报警通道数据个数，用于后面计算变长数据部分中所有发生的报警通道号，四字节表示一个*/
        }struAlarmChannel;    // dwAlarmType为2，3，6，9，10或13时有效
        struct
        {
            DWORD    dwAlarmHardDiskNum;    /*发生报警的硬盘数据长度，用于后面计算变长数据部分中所有发生报警的硬盘号，四节表示一个*/
        }struAlarmHardDisk;    // dwAlarmType为1,4,5时有效
        struct
        {
            BYTE       bySubAlarmType;  //报警子类型，1-一键延迟录像； 
            BYTE       byRes1[3]; //保留
            NET_DVR_TIME_EX  struRecordEndTime; //录播结束时间
            BYTE    byRes[116]; //保留
        }struRecordingHost;  //录播主机专用报警
    }uStruAlarm;
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

//上传报警信息(256路NVR扩展)
typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER     struAlarmFixedHeader;    //报警固定部分
    DWORD*                        pAlarmData;    //报警可变部分内容
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

//报警输入参数配置
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;    //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;    /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byRes;                     
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM]; //报警触发的录象通道,为1表示触发该通道
    BYTE byEnablePreset[MAX_CHANNUM];        /* 是否调用预置点 0-否,1-是*/
    BYTE byPresetNo[MAX_CHANNUM];            /* 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。*/
    BYTE byEnableCruise[MAX_CHANNUM];        /* 是否调用巡航 0-否,1-是*/
    BYTE byCruiseNo[MAX_CHANNUM];            /* 巡航 */
    BYTE byEnablePtzTrack[MAX_CHANNUM];        /* 是否调用轨迹 0-否,1-是*/
    BYTE byPTZTrack[MAX_CHANNUM];            /* 调用的云台的轨迹序号 */
}NET_DVR_ALARMINCFG, *LPNET_DVR_ALARMINCFG;

//模拟报警输入参数配置
typedef struct
{
    DWORD     dwSize;
    BYTE        byEnableAlarmHandle; //处理报警输入
    BYTE        byRes1[3];
    BYTE        byAlarmInName[NAME_LEN]; //模拟报警输入名称
    WORD        wAlarmInUpper; //模拟输入电压上限，实际值乘10，范围0~360
    WORD        wAlarmInLower; //模拟输入电压下限，实际值乘10，范围0~360 
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */ 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    BYTE        byRelRecordChan[MAX_CHANNUM_V30]; //被触发的录像通道
    BYTE        byRes2[100];
}NET_DVR_ANALOG_ALARMINCFG, *LPNET_DVR_ANALOG_ALARMINCFG;

//上传报警信息(9000扩展)
typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常,
                      10-录像异常,11- 智能场景变化,12-阵列异常,13-前端/录像分辨率不匹配,14-申请解码资源失败,15-智能侦测, 16-POE供电异常报警,17-闪光灯异常,
    18-磁盘满负荷异常报警,19-音频丢失*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*触发的输出端口，为1表示对应输出*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmType为2或3,6,9,10,14,19时，表示哪个通道，dwChannel[0]对应第1个通道*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘*/
    #ifdef SDK_CHEZAI
    NET_DVR_ADDIT_POSITION GPS_pos;  /* GPS定位信息 */
    #endif
}NET_DVR_ALARMINFO_V30, *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;   //结构体
    DWORD  dwExceptionCase;   //报警原因   0-网络异常
    NET_DVR_IPADDR  struDeviceIP;    //产生异常的设备IP地址
    BYTE    byRes[256];         //保留
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*触发的输出端口，哪一位为1表示对应哪一个输出*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmType为2或3,6,9,10时，表示哪个通道，dwChannel[0]位对应第1个通道*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘*/
}NET_DVR_ALARMINFO, *LPNET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IPC接入参数配置
/* IP设备结构 */
typedef struct 
{
    DWORD dwEnable;                    /* 该IP设备是否启用 */
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */ 
    NET_DVR_IPADDR struIP;            /* IP地址 */
    WORD wDVRPort;                     /* 端口号 */
    BYTE byRes[34];                /* 保留 */
}NET_DVR_IPDEVINFO, *LPNET_DVR_IPDEVINFO;

#define  DEV_ID_LEN           32    //设备ID长度

//ipc接入设备信息扩展，支持ip设备的域名添加
typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;                    //该IP设备是否有效
    BYTE byProType;                    //协议类型，0-私有协议，1-松下协议，2-索尼
    BYTE byEnableQuickAdd;        // 0 不支持快速添加  1 使用快速添加 
    // 快速添加需要设备IP和协议类型，其他信息由设备默认指定
    BYTE byRes1;                    //保留字段，置0
    BYTE sUserName[NAME_LEN];        //用户名
    BYTE sPassword[PASSWD_LEN];        //密码
    BYTE byDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR struIP;            //IP地址
    WORD wDVRPort;                     // 端口号
    BYTE  szDeviceID[DEV_ID_LEN];  //设备ID
    BYTE byRes2[2];                //保留字段，置0
}NET_DVR_IPDEVINFO_V31, *LPNET_DVR_IPDEVINFO_V31;

/* IP通道匹配参数 */
typedef struct 
{
    BYTE byEnable;                    /* 该通道是否在线 */
    BYTE byIPID;                    //IP设备ID低8位，当设备ID为0时表示通道不可用
    BYTE byChannel;                    /* 通道号 */
    BYTE byIPIDHigh;                // IP设备ID的高8位
    BYTE byTransProtocol;            //传输协议类型0-TCP/auto(具体有设备决定)，1-UDP 2-多播 3-仅TCP 4-auto
    BYTE byres[31];                    /* 保留 */
} NET_DVR_IPCHANINFO, *LPNET_DVR_IPCHANINFO;

/* IP接入配置结构 */
typedef struct 
{
    DWORD dwSize;                                        /* 结构大小 */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];    /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IP通道 */    
}NET_DVR_IPPARACFG, *LPNET_DVR_IPPARACFG;
/* 扩展IP接入配置结构 */
typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;                                        /* 结构大小 */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];    /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IP通道 */    
}NET_DVR_IPPARACFG_V31, *LPNET_DVR_IPPARACFG_V31;

typedef  struct tagNET_DVR_IPSERVER_STREAM
{
    BYTE    byEnable;   // 是否在线
    BYTE    byRes[3];               // 保留字节
    NET_DVR_IPADDR struIPServer;    //IPServer 地址
    WORD    wPort;                  //IPServer 端口
    WORD    wDvrNameLen;            // DVR 名称长度
    BYTE    byDVRName[NAME_LEN];    // DVR名称
    WORD    wDVRSerialLen;          // 序列号长度
    WORD    byRes1[2];              // 保留字节
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR序列号长度
    BYTE    byUserName[NAME_LEN];   // DVR 登陆用户名
    BYTE    byPassWord[PASSWD_LEN]; // DVR登陆密码
    BYTE    byChannel;              // DVR 通道
    BYTE    byRes2[11];             //  保留字节
}NET_DVR_IPSERVER_STREAM, *LPNET_DVR_IPSERVER_STREAM;

//流媒体服务器基本配置
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE    byValid;            /*是否可用*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR  struDevIP;      
    WORD    wDevPort;            /*流媒体服务器端口*/    
    BYTE    byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

//设备通道信息
typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP地址
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];    //设备域名
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO,*LPNET_DVR_DEV_CHAN_INFO;

//直接通过流媒体取流
typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD                                dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG,*LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   // 是否启用
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;            //流媒体服务器地址
    WORD   wStreamServerPort;           //流媒体服务器端口   
    BYTE   byStreamServerTransmitType;  //流媒体传输协议类型 0-TCP，1-UDP
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;          //IPSERVER地址
    WORD   wIPServerPort;        //IPserver端口号
    BYTE   byRes3[2];           
    BYTE   sDVRName[NAME_LEN];   //DVR名称
    WORD   wDVRNameLen;            // DVR名称长度
    WORD   wDVRSerialLen;          // 序列号长度
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    // DVR序列号
    BYTE   sUserName[NAME_LEN];   // DVR 登陆用户名
    BYTE   sPassWord[PASSWD_LEN]; // DVR登陆密码
    WORD   wDVRPort;   //DVR端口号
    BYTE   byRes4[2];    
    BYTE   byChannel;              // DVR 通道
    BYTE   byTransProtocol; //传输协议类型0-TCP，1-UDP
    BYTE   byTransMode; //传输码流模式 0－主码流 1－子码流
    BYTE   byFactoryType; //前端设备厂家类型,通过接口获取
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

#define URL_LEN     240   //URL长度
typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable; 
    BYTE    strURL[URL_LEN];
    BYTE    byTransPortocol ; // 传输协议类型 0-tcp  1-UDP
    WORD    wIPID;  //设备ID号，wIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE    byChannel;  //通道号
    BYTE    byRes[7];   
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;                 // 是否在线
    BYTE    byRes[3];               // 保留字节
    BYTE    byDDNSDomain[64];        // hiDDNS服务器
    WORD    wPort;                  // hiDDNS 端口
    WORD    wAliasLen;              // 别名长度
    BYTE    byAlias[NAME_LEN];         // 别名
    WORD    wDVRSerialLen;          // 序列号长度
    BYTE    byRes1[2];              // 保留字节
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR序列号
    BYTE    byUserName[NAME_LEN];   // DVR 登陆用户名
    BYTE    byPassWord[PASSWD_LEN]; // DVR登陆密码
    BYTE    byChannel;              // DVR通道
    BYTE    byRes2[11];             // 保留字    
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;                /* 该通道是否在线 */
    BYTE    byRes1;
    WORD    wIPID;                  //IP设备ID
    DWORD     dwChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byRes[241];
}NET_DVR_IPCHANINFO_V40,*LPNET_DVR_IPCHANINFO_V40;

// 邦诺CVR
#define MAX_ID_COUNT    256
#define MAX_STREAM_ID_COUNT    1024
#define STREAM_ID_LEN   32
#define PLAN_ID_LEN  32
#define DEVICE_NO_LEN  24
#define MAX_VOLUMENAME_LEN 32  //录像卷名称
#define MAX_VAG_CHANNO_LEN  32  //VAG协议取流时通道号编码长度

#define MAX_STREAM_ID_NUM    30        //最大流ID数目

// 流信息 - 72字节长
typedef struct tagNET_DVR_STREAM_INFO 
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID数据
    DWORD dwChannel;                //关联设备通道，等于0xffffffff时，表示不关联
    BYTE  byRes[32];                //保留
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{ 
    BYTE    byEnable;
    BYTE    byLocalBackUp; //是否本地备份 
    BYTE    byRes[2]; 
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;   //协议类型
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //前端IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wPort;
    BYTE    byRes1[122];             //保留
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;

typedef union tagNET_DVR_GET_STREAM_UNION
{
    NET_DVR_IPCHANINFO      struChanInfo;    /*IP通道信息*/
    NET_DVR_IPSERVER_STREAM struIPServerStream;  // IPServer去流
    NET_DVR_PU_STREAM_CFG   struPUStream;     //  通过前端设备获取流媒体去流
    NET_DVR_DDNS_STREAM_CFG struDDNSStream;     //通过IPServer和流媒体取流
    NET_DVR_PU_STREAM_URL   struStreamUrl;        //通过流媒体到url取流
    NET_DVR_HKDDNS_STREAM    struHkDDNSStream;   //通过hiDDNS去取流
    NET_DVR_IPCHANINFO_V40 struIPChan; //直接从设备取流（扩展）
}NET_DVR_GET_STREAM_UNION, *LPNET_DVR_GET_STREAM_UNION;

typedef enum
{
    NET_SDK_IP_DEVICE = 0,
        NET_SDK_STREAM_MEDIA,
        NET_SDK_IPSERVER,
        NET_SDK_DDNS_STREAM_CFG,
        NET_SDK_STREAM_MEDIA_URL,
        NET_SDK_HKDDNS,
        NET_SDK_IP_DEVICE_ADV,
        NET_SDK_IP_DEVICE_V40, 
        NET_SDK_RTSP  
}GET_STREAM_TYPE;

typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //取流方式GET_STREAM_TYPE，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流,3.通过IPServer找到设备，再通过流媒体去设备的流
    //4-通过流媒体由URL去取流,5-通过hkDDNS取流，6-直接从设备取流(扩展)，使用NET_DVR_IPCHANINFO_V40结构, 7-通过RTSP协议方式进行取流
    BYTE    byRes[3];        //保留字节
    NET_DVR_GET_STREAM_UNION uGetStream;    // 不同取流方式结构体
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;

//扩展IP接入配置设备
typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;                            /* 结构大小 */
    DWORD       dwGroupNum;                    //     设备支持的总组数    
    DWORD      dwAChanNum;                    //最大模拟通道个数
    DWORD      dwDChanNum;                  //数字通道个数
    DWORD      dwStartDChan;                    //起始数字通道
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    /* 模拟通道是否启用，从低到高表示1-64通道，0表示无效 1有效 */
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      /* IP设备 */
    NET_DVR_STREAM_MODE  struStreamMode[MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 // 保留字节
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;


//为CVR扩展的报警类型
typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;  //0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；
    //3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；
    //6-编码器(通道)移动侦测报警；7-编码器(通道)遮挡报警。；8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    NET_DVR_TIME   struTime;     //报警时间
    BYTE       byRes[32];    //保留
    DWORD      dwNumber;     //数目
    WORD       *pNO;         //dwNumber个WORD; 每个WORD表示一个通道号，或者磁盘号, 无效时为0
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

/* 报警输出参数 */
typedef struct 
{
    BYTE byIPID;                    /* IP设备ID取值1- MAX_IP_DEVICE */
    BYTE byAlarmOut;                /* 报警输出号 */
    BYTE byRes[18];                    /* 保留 */
}NET_DVR_IPALARMOUTINFO, *LPNET_DVR_IPALARMOUTINFO;

/* IP报警输出配置结构 */
typedef struct 
{
    DWORD dwSize;                                    /* 结构大小 */    
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];/* IP报警输出 */
}NET_DVR_IPALARMOUTCFG, *LPNET_DVR_IPALARMOUTCFG;

/* IP报警输出参数 */
typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;                    /* IP设备ID */
    DWORD dwAlarmOut;                /* IP设备ID对应的报警输出号 */
    BYTE  byRes[32];                /* 保留 */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;/*报警输出参数*/

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;  //结构体长度
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];/*IP报警输出*/
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40; /*IP报警输出*/

/* 报警输入参数 */
typedef struct 
{
    BYTE byIPID;                    /* IP设备ID取值1- MAX_IP_DEVICE */
    BYTE byAlarmIn;                    /* 报警输入号 */
    BYTE byRes[18];                    /* 保留 */
}NET_DVR_IPALARMININFO, *LPNET_DVR_IPALARMININFO;

/* IP报警输入配置结构 */
typedef struct 
{
    DWORD dwSize;                                    /* 结构大小 */    
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];/* IP报警输入 */
}NET_DVR_IPALARMINCFG, *LPNET_DVR_IPALARMINCFG;

/* IP报警输入参数 */
typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;                    /* IP设备ID */
    DWORD dwAlarmIn;                /* IP设备ID对应的报警输入号 */
    BYTE  byRes[32];                /* 保留 */
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;   /* 报警输入参数 */

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;  //结构体长度
    DWORD   dwCurIPAlarmInNum;  //当前报警输入口数
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];/* IP报警输入*/
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40; /*IP报警输入资源*/

//ipc alarm info
typedef struct tagNET_DVR_IPALARMINFO
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];            /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */
}NET_DVR_IPALARMINFO, *LPNET_DVR_IPALARMINFO;

//ipc配置改变报警信息扩展 9000_1.1
typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];            /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */   
}NET_DVR_IPALARMINFO_V31, *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];           // IP设备
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];           /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */   
    BYTE                    byRes[20];                          // 保留字节
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;

typedef enum _HD_STAT_
{
    HD_STAT_OK                    =    0,    /* 正常 */
        HD_STAT_UNFORMATTED            =    1,    /* 未格式化 */
        HD_STAT_ERROR               =    2,    /* 错误 */
        HD_STAT_SMART_FAILED        =    3,    /* SMART状态 */
        HD_STAT_MISMATCH            =    4,    /* 不匹配 */
        HD_STAT_IDLE                =    5,    /* 休眠*/
        NET_HD_STAT_OFFLINE         =    6,    /* 网络盘处于未连接状态 */
        HD_RIADVD_EXPAND            =   7,    /* 虚拟磁盘可扩容 */
        HD_STAT_REPARING            =   10,   /* 硬盘正在修复(9000 2.0) */
        HD_STAT_FORMATING           =   11,   /* 硬盘正在格式化(9000 2.0) */ 
}HD_STAT;


//本地硬盘信息配置
typedef struct
{
    DWORD dwHDNo;         /*硬盘号, 取值0~MAX_DISKNUM_V30-1*/
    DWORD dwCapacity;     /*硬盘容量(不可设置)*/
    DWORD dwFreeSpace;    /*硬盘剩余空间(不可设置)*/
    DWORD dwHdStatus;     //硬盘状态(不可设置) HD_STAT 0-正常, 1-未格式化, 2-错误, 3-SMART状态, 
    //4-不匹配, 5-休眠 6-网络硬盘不在线 7-虚拟磁盘可扩容 10-硬盘正在修复
    //11-硬盘正在格式化 12-硬盘正在等待格式化 13-硬盘已卸载 14-本地硬盘不存在
    //15-正在删除(网络硬盘),16-已锁定
    BYTE  byHDAttr;       /*0-普通, 1-冗余; 2-只读 3-存档（CVR专用），4-不可读写*/
    BYTE  byHDType;          /*0-本地硬盘,1-ESATA硬盘,2-NAS硬盘,3-iSCSI硬盘 4-Array虚拟磁盘,5-SD卡*/
    BYTE  byDiskDriver;   // 值 代表其ASCII字符 
    BYTE  byRes1;
    DWORD dwHdGroup;      /*属于哪个盘组 1-MAX_HD_GROUP*/
    BYTE  byRecycling;   // 是否循环利用 0：不循环利用，1：循环利用
    BYTE  byRes2[3];
    DWORD  dwStorageType;    //按位表示 0-不支持 非0-支持
    // dwStorageType & 0x1 表示是否是普通录像专用存储盘     
    // dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
    // dwStorageType & 0x4 表示是否是图片录像专用存储盘
    
    DWORD dwPictureCapacity; //硬盘图片容量(不可设置)，单位:MB
    DWORD dwFreePictureSpace; //剩余图片空间(不可设置)，单位:MB
    BYTE  byRes3[104];
}NET_DVR_SINGLE_HD, *LPNET_DVR_SINGLE_HD;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;          /*硬盘数(不可设置)*/
    NET_DVR_SINGLE_HD struHDInfo[MAX_DISKNUM_V30];//硬盘相关操作都需要重启才能生效；
}NET_DVR_HDCFG, *LPNET_DVR_HDCFG;

//本地盘组信息配置扩展
typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD     dwHDGroupNo;       /*盘组号(不可设置) 1-MAX_HD_GROUP*/        
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40];  //触发的录像通道，按值表示，遇到0xffffffff时后续视为无效     
    BYTE       byRes[64];                /* 保留 */
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD      dwSize;                //结构体大小
    DWORD     dwMaxHDGroupNum;           //设备支持的最大盘组数-只读
    DWORD     dwCurHDGroupNum;       /*当前配置的盘组数*/
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //硬盘相关操作都需要重启才能生效；
    BYTE       byRes[128]; //保留
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;

//本地盘组信息配置
typedef struct
{
    DWORD dwHDGroupNo;       /*盘组号(不可设置) 1-MAX_HD_GROUP*/        
    BYTE byHDGroupChans[MAX_CHANNUM_V30]; /*盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组*/
    BYTE byRes[8];
}NET_DVR_SINGLE_HDGROUP, *LPNET_DVR_SINGLE_HDGROUP;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDGroupCount;        /*盘组总数(不可设置)*/
    NET_DVR_SINGLE_HDGROUP struHDGroupAttr[MAX_HD_GROUP];//硬盘相关操作都需要重启才能生效；
}NET_DVR_HDGROUP_CFG, *LPNET_DVR_HDGROUP_CFG;


//配置缩放参数的结构
typedef struct
{
    DWORD dwSize;
    DWORD dwMajorScale;    /* 主显示 0-不缩放，1-缩放*/
    DWORD dwMinorScale;    /* 辅显示 0-不缩放，1-缩放*/
    DWORD dwRes[2];
}NET_DVR_SCALECFG, *LPNET_DVR_SCALECFG;



//DVR报警输出(9000扩展)
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* 名称 */
    DWORD dwAlarmOutDelay;    /* 输出保持时间(-1为无限，手动关闭) */
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30];/* 报警输出激活时间段 */
    BYTE byRes[16];
}NET_DVR_ALARMOUTCFG_V30, *LPNET_DVR_ALARMOUTCFG_V30;

//DVR报警输出
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* 名称 */
    DWORD dwAlarmOutDelay;    /* 输出保持时间(-1为无限，手动关闭) */
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动, 8-1秒, 9-3秒
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];/* 报警输出激活时间段 */
}NET_DVR_ALARMOUTCFG, *LPNET_DVR_ALARMOUTCFG;

//DVR本地预览参数(9000扩展)
/*切换是指在当前预览模式下切换显示画面，而不是切换预览模式。比如byPreviewNumber为0（1画面），bySwitchSeq[0][0] = 1,bySwitchSeq[0][1] = 2,bySwitchSeq[0][2] = 3 
则本地画面一直是1画面，然后在输出画面按1,2,3通道顺序切换*/
typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//预览模式,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    BYTE byEnableAudio;//是否声音预览,0-不预览,1-预览
    WORD wSwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30];//切换顺序,如果lSwitchSeq[i]为 0xff表示不用
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30, *LPNET_DVR_PREVIEWCFG_V30;

//DVR本地预览参数
typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    BYTE byEnableAudio;//是否声音预览,0-不预览,1-预览
    WORD wSwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_WINDOW];//切换顺序,如果lSwitchSeq[i]为 0xff表示不用
}NET_DVR_PREVIEWCFG, *LPNET_DVR_PREVIEWCFG;

//DVR视频输出
typedef struct 
{
    WORD wResolution;                            /* 分辨率 */
    WORD wFreq;                                    /* 刷新频率 */
    DWORD dwBrightness;                            /* 亮度 */
}NET_DVR_VGAPARA;

/*
* MATRIX输出参数结构
*/
typedef struct
{        
    WORD    wOrder[MAX_ANALOG_CHANNUM];        /* 预览顺序, 0xff表示相应的窗口不预览 */
    WORD    wSwitchTime;                /* 预览切换时间 */
    BYTE    res[14];
}NET_DVR_MATRIXPARA_V30, *LPNET_DVR_MATRIXPARA_V30;

typedef struct 
{
    WORD wDisplayLogo;                        /* 显示视频通道号 */
    WORD wDisplayOsd;                        /* 显示时间 */
}NET_DVR_MATRIXPARA;

typedef struct 
{
    BYTE byVideoFormat;                        /* 输出制式,0-PAL,1-NTSC */
    BYTE byMenuAlphaValue;                    /* 菜单与背景图象对比度 */
    WORD wScreenSaveTime;                    /* 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟 */
    WORD wVOffset;                            /* 视频输出偏移 */
    WORD wBrightness;                        /* 视频输出亮度 */
    BYTE byStartMode;                        /* 启动后视频输出模式(0:菜单,1:预览)*/
    BYTE byEnableScaler;                    /* 是否启动缩放 (0-不启动, 1-启动)*/
}NET_DVR_VOOUT;

//DVR视频输出(9000扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];    /* VGA参数 */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];        /* MATRIX参数 */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30, *LPNET_DVR_VIDEOOUT_V30;

//DVR视频输出
typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];    /* VGA参数 */
    NET_DVR_MATRIXPARA struMatrixPara;        /* MATRIX参数 */
}NET_DVR_VIDEOOUT, *LPNET_DVR_VIDEOOUT;


//单用户参数(子结构)(扩展)
typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE    sUserName[NAME_LEN];            /* 用户名只能用16字节 */
    BYTE    sPassword[PASSWD_LEN];            /* 密码 */
    BYTE    byLocalRight[MAX_RIGHT];    /* 本地权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    /*数组6: 本地查看参数 */
    /*数组7: 本地管理模拟和IP camera */
    /*数组8: 本地备份 */
    /*数组9: 本地关机/重启 */    
    BYTE    byRemoteRight[MAX_RIGHT];/* 远程权限 */    
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/    
    /*数组11: 远程查看参数 */
    /*数组12: 远程管理模拟和IP camera */
    /*数组13: 远程关机/重启 */    
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    NET_DVR_IPADDR    struUserIP;                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE     byMACAddr[MACADDR_LEN];    /* 物理地址 */
    BYTE     byPriority;                /* 优先级，0xff-无，0--低，1--中，2--高 */
                                        /* 无……表示不支持优先级的设置
                                        低……默认权限:包括本地和远程回放,本地和远程查看日志和
                                        状态,本地和远程关机/重启
                                        中……包括本地和远程控制云台,本地和远程手动录像,本地和
                                        远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启
    高……管理员 */
    BYTE    byAlarmOnRight;         // 报警输入口布防权限 1-有权限，0-无权限
    BYTE    byAlarmOffRight;         // 报警输入口撤防权限 1-有权限，0-无权限
    BYTE    byBypassRight;           // 报警输入口旁路权限 1-有权限，0-无权限 
    BYTE    byRes1[2];               //四字节对齐
    BYTE    byPublishRight[MAX_RIGHT];  //信息发布专有权限
    /*数组0: 素材审核权限*/
    /*数组1: 节目审核权限*/
    /*数组2: 日程审核权限*/
    /*数组3: 上传素材权限*/
    /*数组4: 新建节目权限*/
    /*数组5: 新建日程权限*/
    /*数组6: 信息播放权限*/
    /*数组7: 终端管理权限*/
    /*数组8: 商业智能权限*/    
    BYTE    byRes[84];    
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;


//单用户参数(子结构)(9000扩展)
typedef struct
{
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byLocalRight[MAX_RIGHT];    /* 本地权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    /*数组6: 本地查看参数 */
    /*数组7: 本地管理模拟和IP camera */
    /*数组8: 本地备份 */
    /*数组9: 本地关机/重启 */    
    BYTE byRemoteRight[MAX_RIGHT];/* 远程权限 */    
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/    
    /*数组11: 远程查看参数 */
    /*数组12: 远程管理模拟和IP camera */
    /*数组13: 远程关机/重启 */
    BYTE byNetPreviewRight[MAX_CHANNUM_V30];        /* 远程可以预览的通道 0-有权限，1-无权限*/
    BYTE byLocalPlaybackRight[MAX_CHANNUM_V30];    /* 本地可以回放的通道 0-有权限，1-无权限*/
    BYTE byNetPlaybackRight[MAX_CHANNUM_V30];    /* 远程可以回放的通道 0-有权限，1-无权限*/
    BYTE byLocalRecordRight[MAX_CHANNUM_V30];        /* 本地可以录像的通道 0-有权限，1-无权限*/
    BYTE byNetRecordRight[MAX_CHANNUM_V30];        /* 远程可以录像的通道 0-有权限，1-无权限*/
    BYTE byLocalPTZRight[MAX_CHANNUM_V30];        /* 本地可以PTZ的通道 0-有权限，1-无权限*/
    BYTE byNetPTZRight[MAX_CHANNUM_V30];            /* 远程可以PTZ的通道 0-有权限，1-无权限*/
    BYTE byLocalBackupRight[MAX_CHANNUM_V30];        /* 本地备份权限通道 0-有权限，1-无权限*/
    NET_DVR_IPADDR struUserIP;        /* 用户IP地址(为0时表示允许任何地址) */
    BYTE byMACAddr[MACADDR_LEN];    /* 物理地址 */
    BYTE byPriority;                /* 优先级，0xff-无，0--低，1--中，2--高 */
                                    /*
                                    无……表示不支持优先级的设置
                                    低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启
                                    中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览
                                    本地备份,本地/远程关机/重启
                                    高……管理员
    */
    BYTE    byAlarmOnRight;         // 报警输入口布防权限
    BYTE    byAlarmOffRight;        // 报警输入口撤防权限
    BYTE    byBypassRight;          // 报警输入口旁路权限
    BYTE    byRes[14];    
}NET_DVR_USER_INFO_V30, *LPNET_DVR_USER_INFO_V30;

//单用户参数(SDK_V15扩展)(子结构)
typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    DWORD dwLocalRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    DWORD dwLocalPlaybackRight;        /* 本地可以回放的通道 bit0 -- channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    DWORD dwNetPreviewRight;        /* 远程可以预览的通道 bit0 -- channel 1*/
    DWORD dwNetPlaybackRight;        /* 远程可以回放的通道 bit0 -- channel 1*/
    char sUserIP[16];                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE byMACAddr[MACADDR_LEN];    /* 物理地址 */
}NET_DVR_USER_INFO_EX, *LPNET_DVR_USER_INFO_EX;

//单用户参数(子结构)
typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    DWORD dwLocalRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    char sUserIP[16];                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE byMACAddr[MACADDR_LEN];    /* 物理地址 */
}NET_DVR_USER_INFO, *LPNET_DVR_USER_INFO;

//DVR用户参数(扩展)
typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;  //结构体大小
    DWORD dwMaxUserNum; //设备支持的最大用户数-只读
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* 用户参数 */
}NET_DVR_USER_V40,*LPNET_DVR_USER_V40;

//DVR用户参数(9000扩展)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_V30 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V30, *LPNET_DVR_USER_V30;

//DVR用户参数(SDK_V15扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX, *LPNET_DVR_USER_EX;

//DVR用户参数
typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER, *LPNET_DVR_USER;

typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize ;             //结构体大小
    DWORD             dwMaxGroupNum ;    //设备支持的最大组数
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];    
    BYTE                byRes[128];          //保留
}NET_DVR_EXCEPTION_V40,*LPNET_DVR_EXCEPTION_V40; /*异常参数配置扩展结构体*/

//DVR异常参数(9000扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突, 4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常, 7-录像异常 8-阵列异常，9-前端/录像分辨率不匹配异常，10-行车超速(车载专用) 11-热备异常（N+1使用）12-温度，13-子系统异常，14-风扇异常, 15-POE供电异常*/
}NET_DVR_EXCEPTION_V30, *LPNET_DVR_EXCEPTION_V30;



//DVR异常参数
typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常*/
}NET_DVR_EXCEPTION, *LPNET_DVR_EXCEPTION;

//通道状态(9000扩展)
typedef struct 
{
    BYTE byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    BYTE byRes1;        //保留
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    NET_DVR_IPADDR struClientIP[MAX_LINK];//客户端的IP地址
    DWORD dwIPLinkNum;//如果该通道为IP接入，那么表示IP接入当前的连接数
    BYTE byExceedMaxLink;        // 是否超出了单路6路连接数 0 - 未超出, 1-超出
    BYTE byRes[3];        // 保留字节
    DWORD dwAllBitRate;      //所有实际码率之和
    DWORD dwChannelNo;    //当前的通道号，0xffffffff表示无效
}NET_DVR_CHANNELSTATE_V30, *LPNET_DVR_CHANNELSTATE_V30;

//通道状态
typedef struct 
{
    BYTE byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    char reservedData;        //保留
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    DWORD dwClientIP[MAX_LINK];//客户端的IP地址
}NET_DVR_CHANNELSTATE, *LPNET_DVR_CHANNELSTATE;

//硬盘状态
typedef struct 
{
    DWORD dwVolume;//硬盘的容量
    DWORD dwFreeSpace;//硬盘的剩余空间
    DWORD dwHardDiskStatic; //硬盘的状态,按位:1-休眠,2-不正常,3-休眠硬盘出错,4-未格式化, 5-未连接状态(网络硬盘),6-硬盘正在格式化
}NET_DVR_DISKSTATE, *LPNET_DVR_DISKSTATE;

typedef struct tagNET_DVR_WORKSTATE_V40
{ 
    DWORD   dwSize ;            //结构体大小
    DWORD   dwDeviceStatic;      //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //硬盘状态,一次最多只能获取33个硬盘信息
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//通道的状态，从前往后顺序排列
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/]; //有报警的报警输入口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/]; //有报警输出的报警输出口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    DWORD   dwLocalDisplay;            //本地显示状态,0-正常,1-不正常
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];        //按位表示语音通道的状态 0-未使用，1-使用中，第0位表示第1个语音通道
    BYTE    byRes1[2];
    float    fHumidity;    //传感器获知的湿度,范围:0.0 ~100.0
    float    fTemperature;    //传感器获知的温度，范围：-20.0 ~ 90.0
    BYTE    byRes[116];                 //保留
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40; /*设备工作状态扩展结构体*/

typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize ;  //结构体长度
    BYTE    byFindHardByCond; /*0-查找全部磁盘(但一次最多只能查找33个)，此时dwFindHardStatusNum无效*/
    BYTE    byFindChanByCond ;  /*0-查找全部通道，此时dwFindChanNum无效*/
    BYTE    byRes1[2] ;//保留    
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/] ; /*要查找的硬盘号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/] ; /*要查找的通道号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 */
    BYTE     byRes[64] ; //保留
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

//DVR工作状态(9000扩展)
typedef struct 
{
    DWORD dwDeviceStatic;     //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30];//通道的状态
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30]; //报警端口的状态,0-没有报警,1-有报警
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD  dwLocalDisplay;//本地显示状态,0-正常,1-不正常
    BYTE  byAudioChanStatus[MAX_AUDIO_V30];//表示语音通道的状态 0-未使用，1-使用中, 0xff无效
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30, *LPNET_DVR_WORKSTATE_V30;

//DVR工作状态
typedef struct 
{
    DWORD dwDeviceStatic;     //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM];//通道的状态
    BYTE  byAlarmInStatic[MAX_ALARMIN]; //报警端口的状态,0-没有报警,1-有报警
    BYTE  byAlarmOutStatic[MAX_ALARMOUT]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD  dwLocalDisplay;//本地显示状态,0-正常,1-不正常
}NET_DVR_WORKSTATE, *LPNET_DVR_WORKSTATE;



//日志信息(9000扩展)
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    DWORD    dwMinorType;//次类型 0-全部;
    BYTE    sPanelUser[MAX_NAMELEN]; //操作面板的用户名
    BYTE    sNetUser[MAX_NAMELEN];//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr;//远程主机地址
    DWORD    dwParaType;//参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
    DWORD    dwChannel;//通道号
    DWORD    dwDiskNumber;//硬盘号
    DWORD    dwAlarmInPort;//报警输入端口
    DWORD    dwAlarmOutPort;//报警输出端口
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;

//日志信息
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    DWORD    dwMinorType;//次类型 0-全部;
    BYTE    sPanelUser[MAX_NAMELEN]; //操作面板的用户名
    BYTE    sNetUser[MAX_NAMELEN];//网络操作的用户名
    char    sRemoteHostAddr[16];//远程主机地址
    DWORD    dwParaType;//参数类型
    DWORD    dwChannel;//通道号
    DWORD    dwDiskNumber;//硬盘号
    DWORD    dwAlarmInPort;//报警输入端口
    DWORD    dwAlarmOutPort;//报警输出端口
}NET_DVR_LOG, *LPNET_DVR_LOG;

/************************DVR日志 end***************************/

/************************动环报警管理主机日志查找 begin************************************************/
typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;        // 主类型
    WORD            wMinorType;        // 次类型 
    NET_DVR_TIME    struStartTime;    // 开始时间 
    NET_DVR_TIME    struEndTime;    // 结束时间
    BYTE            byRes[8];        // 保留字节
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME    struLogTime;                //  日志时间
    BYTE            sUserName[NAME_LEN];     // 操作用户
    NET_DVR_IPADDR    struIPAddr;                 // 操作IP地址
    WORD            wMajorType;                 // 主类型 
    WORD            wMinorType;                 // 次类型
    WORD            wParam;                        // 操作参数
    BYTE            byRes[10];
    DWORD            dwInfoLen;                    // 描述信息长度
    char            sInfo[LOG_INFO_LEN];       // 描述信息
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

/*************************动环报警管理主机日志查找 end***********************************************/

//报警输出状态(9000扩展)
typedef struct 
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30, *LPNET_DVR_ALARMOUTSTATUS_V30;

//报警输出状态
typedef struct 
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS, *LPNET_DVR_ALARMOUTSTATUS;

//交易信息
typedef struct 
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];    //设备名称
    DWORD dwChannelNumer;    //通道号
    BYTE CardNumber[32];    //卡号
    char cTradeType[12];    //交易类型
    DWORD dwCash;            //交易金额
}NET_DVR_TRADEINFO, *LPNET_DVR_TRADEINFO;


//ATM专用
/****************************ATM(begin)***************************/
#define NCR        0
#define DIEBOLD    1
#define WINCOR_NIXDORF    2
#define SIEMENS    3
#define OLIVETTI    4
#define FUJITSU    5
#define HITACHI    6
#define SMI        7
#define IBM        8
#define BULL    9
#define YiHua    10
#define LiDe    11
#define GDYT    12
#define Mini_Banl    13
#define GuangLi    14
#define DongXin    15
#define ChenTong    16
#define NanTian    17
#define XiaoXing    18
#define GZYY    19
#define QHTLT    20
#define DRS918    21
#define KALATEL    22
#define NCR_2    23    
#define NXS        24


/*帧格式*/
typedef struct 
{
    BYTE code[12];        /* 代码 */
}NET_DVR_FRAMETYPECODE;


//ATM参数
typedef struct 
{
    DWORD dwSize;
    char sATMIP[16];                        /* ATM IP地址 */
    DWORD dwATMType;                        /* ATM类型 */
    DWORD dwInputMode;                        /* 输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入*/
    DWORD dwFrameSignBeginPos;              /* 报文标志位的起始位置*/
    DWORD dwFrameSignLength;                /* 报文标志位的长度 */
    BYTE  byFrameSignContent[12];            /* 报文标志位的内容 */
    DWORD dwCardLengthInfoBeginPos;            /* 卡号长度信息的起始位置 */
    DWORD dwCardLengthInfoLength;            /* 卡号长度信息的长度 */
    DWORD dwCardNumberInfoBeginPos;            /* 卡号信息的起始位置 */
    DWORD dwCardNumberInfoLength;            /* 卡号信息的长度 */
    DWORD dwBusinessTypeBeginPos;           /* 交易类型的起始位置 */
    DWORD dwBusinessTypeLength;                /* 交易类型的长度 */
    NET_DVR_FRAMETYPECODE frameTypeCode[10];/* 类型 */
}NET_DVR_FRAMEFORMAT, *LPNET_DVR_FRAMEFORMAT;
//SDK_V31 ATM

/*过滤设置*/
typedef struct    tagNET_DVR_FILTER
{    
    BYTE                    byEnable;            //0,不启用;1,启用
    BYTE                    byMode;                //0,ASCII;1,HEX    
    BYTE                    byFrameBeginPos;    // 需要过滤目标字符串起始位置     
    BYTE                    byRes;           // 保留字节
    BYTE                     byFilterText[16];    //过滤字符串
    BYTE                    byRes2[12];         // 保留字节
}NET_DVR_FILTER, *LPNET_DVR_FILTER;

//数据包分析 数据包标识
typedef struct    tagNET_DVR_IDENTIFICAT
{    
    BYTE                    byStartMode;        //起始字符模式:0,ASCII;1,HEX
    BYTE                    byEndMode;            //结束字符模式：0,ASCII;1,HEX
    BYTE                    byRes[2];           //保留字节
    NET_DVR_FRAMETYPECODE    struStartCode;        //数据包起始标识字符
    NET_DVR_FRAMETYPECODE    struEndCode;        //数据包结束标识字符
    BYTE                    byRes1[12];         //保留字节
}NET_DVR_IDENTIFICAT, *LPNET_DVR_IDENTIFICAT;

typedef struct    tagNET_DVR_PACKAGE_LOCATION/*报文信息位置*/
{    
    BYTE                     byOffsetMode;            /*报文位置信息模式 0,token(字符标志模式);1,fix（固定模式）*/
    BYTE                    byRes1[3];                // 保留字节
    DWORD                      dwOffsetPos;            /*mode为1的时候使用,固定偏移大小*/
    NET_DVR_FRAMETYPECODE    struTokenCode;            /*标志位*/
    BYTE                    byMultiplierValue;        /*标志位多少次出现*/
    BYTE                    byEternOffset;            /*附加字符偏移量*/
    BYTE                    byCodeMode;                /*0,ASCII;1,HEX*/
    BYTE                     byRes2[9];                //保留字节
}NET_DVR_PACKAGE_LOCATION, *LPNET_DVR_PACKAGE_LOCATION;


typedef struct    tagNET_DVR_PACKAGE_LENGTH//报文信息长度
{    
    BYTE                    byLengthMode;            //长度类型，0,可变长度;1,固定长度;2,自助长度(从卡号中获取)
    BYTE                    byRes1[3];              // 保留字节
    DWORD                      dwFixLength;                //mode为1的时候使用,固定长度大小
    DWORD                    dwMaxLength;            //报文信息最大长度  byLengthMode为0时使用
    DWORD                    dwMinLength;            //报文信息最小长度  byLengthMode为0时使用
    BYTE                    byEndMode;                //可变长度 终结符模式 0,ASCII;1,HEX    
    BYTE                    byRes2[3];              //保留字节
    NET_DVR_FRAMETYPECODE    struEndCode;        //可变长度终结符
    DWORD                    dwLengthPos;            //lengthMode为2的时候使用，卡号长度在报文中的位置
    DWORD                    dwLengthLen;            //lengthMode为2的时候使用，卡号长度的长度
    BYTE                    byRes3[8];              // 保留字节
}NET_DVR_PACKAGE_LENGTH,* LPNET_DVR_PACKAGE_LENGTH;

typedef struct    tagNET_DVR_OSD_POSITION//OSD 叠加的位置
{    
    BYTE                    byPositionMode;        //叠加风格，共2种；0，不显示；1，自定义
    BYTE                    byRes1[3];          // 保留字节
    DWORD                     dwPosX;                //x坐标，叠加风格为自定义时使用
    DWORD                    dwPosY;                //y坐标，叠加风格为自定义时使用
    BYTE                    byRes2[8];          //保留字节
}NET_DVR_OSD_POSITION, *LPNET_DVR_OSD_POSITION;

typedef struct    tagNET_DVR_DATE_FORMAT//日期显示格式
{    
    BYTE                    byMonth;                //Month,0.mm;1.mmm;2.mmmm                            
    BYTE                     byDay;                    //Day,0.dd;                                    
    BYTE                     byYear;                    //Year,0.yy;1.yyyy    
    BYTE                    byDateForm;                //0~5，年月日的排列组合
    BYTE                    byRes[20];              // 保留字节
    char                    chSeprator[4];            //分隔符
    char                    chDisplaySeprator[4];    //显示分隔符
    BYTE                    byDisplayForm;            //0~5，3个item的排列组合
    BYTE                    res[27];                // 保留字节
}NET_DVR_DATE_FORMAT, *LPNET_DVR_DATE_FORMAT;
typedef struct    tagNET_DVRT_TIME_FORMAT//时间显示格式
{    
    BYTE                    byTimeForm;                //1. HH MM SS;0. HH MM
    BYTE                     byRes1[23];             // 保留字节
    BYTE                    byHourMode;             //0,12;1,24 
    BYTE                    byRes2[3];              // 保留字节
    char                    chSeprator[4];             //报文分隔符，暂时没用
    char                    chDisplaySeprator[4];    //显示分隔符
    BYTE                    byDisplayForm;            //0~5，3个item的排列组合
    BYTE                    byRes3[3];              // 保留字节
    BYTE                    byDisplayHourMode;        //0,12;1,24 
    BYTE                    byRes4[19];             // 保留字节
}NET_DVR_TIME_FORMAT, *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{    
    BYTE                    byChannel[64];//叠加的通道 每个字节标识一个通道， 例如byChannel[0]值为1对应叠加通道1，0表示不叠加通道1。
    DWORD                    dwDelayTime;            //叠加延时时间
    BYTE                    byEnableDelayTime;        //是否启用叠加延时
    BYTE                    byRes[11];          // 保留字节
}NET_DVR_OVERLAY_CHANNEL, *LPNET_DVR_OVERLAY_CHANNEL;

// ATM 报文行为信息
typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// 报文位置信息
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD 叠加位置
    NET_DVR_FRAMETYPECODE        struActionCode;        //交易类型行为码
    NET_DVR_FRAMETYPECODE        struPreCode;        //叠加字符前的字符
    BYTE                    byActionCodeMode;        //交易类型行为码模式0,ASCII;1,HEX
    BYTE                    byRes[7];               // 保留字节
}NET_DVR_ATM_PACKAGE_ACTION, *LPNET_DVR_ATM_PACKAGE_ACTION;

// ATM 报文DATA信息
typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// 日期在报文中的位置信息
    NET_DVR_DATE_FORMAT            struDateForm;        //日期显示格式
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD叠加位置信息
    BYTE                        res[8];             // 保留字节
}NET_DVR_ATM_PACKAGE_DATE, *LPNET_DVR_ATM_PACKAGE_DATE;


//ATM报文时间信息
typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{    
    NET_DVR_PACKAGE_LOCATION    location;        // 时间在报文中的位置信息
    NET_DVR_TIME_FORMAT            struTimeForm;    // 时间显示格式
    NET_DVR_OSD_POSITION        struOsdPosition;// OSD 叠加位置信息
    BYTE                        byRes[8];        // 保留字节
}NET_DVR_ATM_PACKAGE_TIME, *LPNET_DVR_ATM_PACKAGE_TIME;


// ATM 其他报文信息（卡号，交易金额，交易序号）
typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; //报文位置信息
    NET_DVR_PACKAGE_LENGTH    struPackageLength;        //长度信息
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD叠加位置信息
    NET_DVR_FRAMETYPECODE        struPreCode;        //叠加字符前的字符
    BYTE                    res[8];                    //保留字节
}NET_DVR_ATM_PACKAGE_OTHERS, *LPNET_DVR_ATM_PACKAGE_OTHERS;


//用户自定义协议
typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;  //报文标志
    NET_DVR_FILTER             struFilter; //数据包过滤设置
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara; //叠加卡号设置
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE]; //叠加交易行为设置 0-9 依次对应InCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara; //叠加交易金额设置
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara; //叠加交易序号设置
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan; //叠加通道设置
    NET_DVR_ATM_PACKAGE_DATE   struRes1; //叠加日期，保留
    NET_DVR_ATM_PACKAGE_TIME   struRes2; //叠加时间，保留
    BYTE                       byRes3[124];        //保留
}NET_DVR_ATM_USER_DEFINE_PROTOCOL, *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{        
    DWORD                        dwSize;                 //结构大小
    BYTE                        byEnable;                /*是否启用0,不启用;1,启用*/
    BYTE                        byInputMode;            /**输入方式:0-网络监听、1网络协议、2-串口监听、3-串口协议*/
    BYTE                        byRes1[34];              //保留字节 
    NET_DVR_IPADDR                struAtmIp;                /*ATM 机IP 网络监听时使用 */
    WORD                        wAtmPort;                /* 网络协议方式时是使用*/
    BYTE                        byRes2[2];              // 保留字节
    DWORD                        dwAtmType;                /*ATM协议类型，从NET_DVR_ATM_PROTOCOL结构中获取，如果类型为自定义时使用用户自定义协议*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol; //用户自定义协议，当ATM类型为自定时需要使用该定义
    BYTE                        byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30, *LPNET_DVR_ATM_FRAMEFORMAT_V30;


typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType; //ATM协议类型，同时作为索引序号 ATM 配置中的dwAtmType 自定义时为1025
    char chDesc[ATM_DESC_LEN]; //ATM协议简单描述
}NET_DVR_ATM_PROTO_TYPE, *LPNET_DVR_ATM_PROTO_TYPE; //协议信息数据结构

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM 协议列表
{
    DWORD                  dwAtmProtoNum;           // 协议列表的个数
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM]; //协议列表信息
}NET_DVR_ATM_PROTO_LIST, *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList; // 网络监听协议描述
    NET_DVR_ATM_PROTO_LIST struSerialListenList; //串口监听协议描述
    NET_DVR_ATM_PROTO_LIST struNetProtoList;     //网络协议描述
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;   //串口协议描述
    NET_DVR_ATM_PROTO_TYPE struCustomProto;        //自定义协议
}NET_DVR_ATM_PROTOCOL, *LPNET_DVR_ATM_PROTOCOL;
// SDK_V31

/*****************************DS-6001D/F(begin)***************************/
//DS-6001D Decoder
typedef struct 
{
    BYTE byEncoderIP[16];        //解码设备连接的服务器IP
    BYTE byEncoderUser[16];        //解码设备连接的服务器的用户名
    BYTE byEncoderPasswd[16];    //解码设备连接的服务器的密码
    BYTE bySendMode;            //解码设备连接服务器的连接模式
    BYTE byEncoderChannel;        //解码设备连接的服务器的通道号
    WORD wEncoderPort;            //解码设备连接的服务器的端口号
    BYTE reservedData[4];        //保留
}NET_DVR_DECODERINFO, *LPNET_DVR_DECODERINFO;

typedef struct 
{
    BYTE byEncoderIP[16];        //解码设备连接的服务器IP
    BYTE byEncoderUser[16];        //解码设备连接的服务器的用户名
    BYTE byEncoderPasswd[16];    //解码设备连接的服务器的密码
    BYTE byEncoderChannel;        //解码设备连接的服务器的通道号
    BYTE bySendMode;            //解码设备连接的服务器的连接模式
    WORD wEncoderPort;            //解码设备连接的服务器的端口号
    DWORD dwConnectState;        //解码设备连接服务器的状态
    BYTE reservedData[4];        //保留
}NET_DVR_DECODERSTATE, *LPNET_DVR_DECODERSTATE;

/*解码设备控制码定义*/
#define NET_DEC_STARTDEC        1
#define NET_DEC_STOPDEC            2
#define NET_DEC_STOPCYCLE        3
#define NET_DEC_CONTINUECYCLE    4
/*连接的通道配置*/
typedef struct 
{
    char sDVRIP[16];                /* DVR IP地址 */
    WORD wDVRPort;                     /* 端口号 */
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byChannel;                    /* 通道号 */
    BYTE byLinkMode;                /* 连接模式 */
    BYTE byLinkType;                /* 连接类型 0－主码流 1－子码流 */
}NET_DVR_DECCHANINFO, *LPNET_DVR_DECCHANINFO;

/*每个解码通道的配置*/
typedef struct 
{
    BYTE    byPoolChans;            /*每路解码通道上的循环通道数量, 最多4通道 0表示没有解码*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE    byEnablePoll;            /*是否轮巡 0-否 1-是*/
    BYTE    byPoolTime;                /*轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟 */
}NET_DVR_DECINFO, *LPNET_DVR_DECINFO;

/*整个设备解码配置*/
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwDecChanNum;         /*解码通道的数量*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG, *LPNET_DVR_DECCFG;

//2005-08-01
/* 解码设备透明通道设置 */
typedef struct 
{
    DWORD dwEnableTransPort;    /* 是否启动透明通道 0－不启用 1－启用*/
    char sDecoderIP[16];        /* DVR IP地址 */
    WORD wDecoderPort;            /* 端口号 */
    WORD wDVRTransPort;            /* 配置前端DVR是从485/232输出，1表示232串口,2表示485串口 */
    char cReserve[4];
}NET_DVR_PORTINFO, *LPNET_DVR_PORTINFO;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM]; /* 数组0表示232 数组1表示485 */
}NET_DVR_PORTCFG, *LPNET_DVR_PORTCFG;

/* 控制网络文件回放 */
typedef struct 
{
    DWORD dwSize;
    char sDecoderIP[16];        /* DVR IP地址 */
    WORD wDecoderPort;            /* 端口号 */
    WORD wLoadMode;                /* 回放下载模式 1－按名字 2－按时间 */
    union
    {
        BYTE byFile[100];        /* 回放的文件名 */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE sPassword[PASSWD_LEN];    /* 密码 */
            NET_DVR_TIME struStartTime;    /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;    /* 按时间回放的结束时间 */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE, *LPNET_DVR_PLAYREMOTEFILE;

/*当前设备解码连接状态*/
typedef struct 
{
    DWORD dwWorkType;        /*工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载*/
    char sDVRIP[16];        /*连接的设备ip*/
    WORD wDVRPort;            /*连接端口号*/
    BYTE byChannel;            /* 通道号 */
    BYTE byLinkMode;        /* 连接模式 */
    DWORD    dwLinkType;        /*连接类型 0－主码流 1－子码流*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE sPassword[PASSWD_LEN];    /* 密码 */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD    dwChannel;
            BYTE    sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE    sPassword[PASSWD_LEN];    /* 密码 */
            NET_DVR_TIME struStartTime;        /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;        /* 按时间回放的结束时间 */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS, *LPNET_DVR_DECCHANSTATUS;

typedef struct 
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS, *LPNET_DVR_DECSTATUS;
/*****************************DS-6001D/F(end)***************************/

//单字符参数(子结构)
typedef struct 
{
    WORD wShowString;                // 预览的图象上是否显示字符,0-不显示,1-显示 区域大小704*576,单个字符的大小为32*32
    WORD wStringSize;                /* 该行字符的长度，不能大于44个字符 */
    WORD wShowStringTopLeftX;        /* 字符显示位置的x坐标 */
    WORD wShowStringTopLeftY;        /* 字符名称显示位置的y坐标 */
    char sString[44];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRINGINFO, *LPNET_DVR_SHOWSTRINGINFO;

//叠加字符(9000扩展)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING_V30, *LPNET_DVR_SHOWSTRING_V30;

//叠加字符扩展(8条字符)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING_EX, *LPNET_DVR_SHOWSTRING_EX;

//叠加字符
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING, *LPNET_DVR_SHOWSTRING;

/****************************DS9000新增结构(begin)******************************/
/*
EMAIL参数结构
*/
typedef struct
{        
    DWORD        dwSize;
    BYTE        sAccount[NAME_LEN];                /* 账号*/ 
    BYTE        sPassword[MAX_EMAIL_PWD_LEN];            /*密码 */
    struct
    {
        BYTE    sName[NAME_LEN];                /* 发件人姓名 */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];        /* 发件人地址 */
    }struSender;
    BYTE        sSmtpServer[MAX_EMAIL_ADDR_LEN];    /* smtp服务器 */
    BYTE        sPop3Server[MAX_EMAIL_ADDR_LEN];    /* pop3服务器 */
    struct
    {
        BYTE    sName[NAME_LEN];                /* 收件人姓名 */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];        /* 收件人地址 */
    }struReceiver[3];                            /* 最多可以设置3个收件人 */
    BYTE        byAttachment;                    /* 是否带附件 */
    BYTE        bySmtpServerVerify;                /* 发送服务器要求身份验证 */
    BYTE        byMailInterval;                 /* mail interval */
    BYTE        byEnableSSL;                    //ssl是否启用9000_1.1
    WORD        wSmtpPort;                        //gmail的465，普通的为25 
    BYTE        byEnableTLS;                    /*TLS是否启用*/
    BYTE        byStartTLS;                     /*是否启用StartTLS*/
    BYTE        byRes[72];                        /*保留*/
} NET_DVR_EMAILCFG_V30, *LPNET_DVR_EMAILCFG_V30;

/*
DVR实现巡航数据结构
*/
typedef struct
{    
    DWORD     dwSize;
    BYTE    byPresetNo[CRUISE_MAX_PRESET_NUMS];        /* 预置点号 */
    BYTE     byCruiseSpeed[CRUISE_MAX_PRESET_NUMS];    /* 巡航速度 */
    WORD    wDwellTime[CRUISE_MAX_PRESET_NUMS];        /* 停留时间 */
    BYTE    byEnableThisCruise;                        /* 是否启用 */
    BYTE    res[15];
}NET_DVR_CRUISE_PARA, *LPNET_DVR_CRUISE_PARA; 
/****************************DS9000新增结构(end)******************************/

//时间点
typedef struct 
{
    DWORD dwMonth;        //月 0-11表示1-12个月
    DWORD dwWeekNo;        //第几周 0－第1周 1－第2周 2－第3周 3－第4周 4－最后一周
    DWORD dwWeekDate;    //星期几 0－星期日 1－星期一 2－星期二 3－星期三 4－星期四 5－星期五 6－星期六
    DWORD dwHour;        //小时    开始时间0－23 结束时间1－23
    DWORD dwMin;        //分    0－59
}NET_DVR_TIMEPOINT;

//夏令时参数
typedef struct 
{
    DWORD dwSize;
    DWORD dwZoneIndex; //应用层软件使用NET_DVR_NTPPARA 中的cTimeDifferenceH 或cTimeDifferenceM 来设置时区，此处用获取的值填充，不对用户提供输入编辑框
    BYTE byRes1[12];            //保留
    DWORD dwEnableDST;        //是否启用夏时制 0－不启用 1－启用
    BYTE byDSTBias;    //夏令时偏移值，30min, 60min, 90min, 120min, 以分钟计，传递原始数值
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;    //夏时制开始时间
    NET_DVR_TIMEPOINT struEndPoint;    //夏时制停止时间
}NET_DVR_ZONEANDDST, *LPNET_DVR_ZONEANDDST;

//图片质量
typedef struct 
{
/*注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图，
当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
    仅支持当前分辨率的抓图*/
    
    /* 可以通过能力集获取
       0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
       6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
       11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，     
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       500-384*288,
       0xff-Auto(使用当前码流分辨率)
    */
    WORD    wPicSize;            
    WORD    wPicQuality;            /* 图片质量系数 0-最好 1-较好 2-一般 */
}NET_DVR_JPEGPARA, *LPNET_DVR_JPEGPARA;

/* aux video out parameter */
//辅助输出参数配置
typedef struct 
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                       /* 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4 */
    DWORD dwAlarmChanSwitchTime;                /* :1秒 - 10:10秒 */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];            /* 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s */
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];    /* 辅助输出预览顺序, 0xff表示相应的窗口不预览 */
}NET_DVR_AUXOUTCFG, *LPNET_DVR_AUXOUTCFG;


//ntp
typedef struct 
{
    BYTE sNTPServer[64];   /* Domain Name or IP addr of NTP server */
    WORD wInterval;         /* adjust time interval(hours) */
    BYTE byEnableNTP;    /* enable NPT client 0-no，1-yes*/
    signed char cTimeDifferenceH; /* 与国际标准时间的 小时偏移-12 ... +13 */
    signed char cTimeDifferenceM;/* 与国际标准时间的 分钟偏移0, 30, 45*/
    BYTE res1;
    WORD wNtpPort;         /* ntp server port 9000新增 设备默认为123*/
    BYTE res2[8];
}NET_DVR_NTPPARA, *LPNET_DVR_NTPPARA;

//ddns
typedef struct 
{
    BYTE sUsername[NAME_LEN];  /* DDNS账号用户名/密码 */
    BYTE sPassword[PASSWD_LEN];
    BYTE sDomainName[64];       /* 域名 */
    BYTE byEnableDDNS;            /*是否应用 0-否，1-是*/
    BYTE res[15];
}NET_DVR_DDNSPARA, *LPNET_DVR_DDNSPARA;


typedef struct
{
    BYTE byHostIndex;                    /* 0-私有DDNS 1－Dyndns 2－PeanutHull(花生壳)*/
    BYTE byEnableDDNS;                    /*是否应用DDNS 0-否，1-是*/
    WORD wDDNSPort;                        /* DDNS端口号 */
    BYTE sUsername[NAME_LEN];            /* DDNS用户名*/
    BYTE sPassword[PASSWD_LEN];            /* DDNS密码 */
    BYTE sDomainName[MAX_DOMAIN_NAME];    /* 设备配备的域名地址 */
    BYTE sServerName[MAX_DOMAIN_NAME];    /* DDNS 对应的服务器地址，可以是IP地址或域名 */
    BYTE byRes[16];
}NET_DVR_DDNSPARA_EX, *LPNET_DVR_DDNSPARA_EX;

//9000扩展
typedef struct
{
    BYTE byEnableDDNS;
    BYTE byHostIndex;/*0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS*/
    BYTE byRes1[2];
    struct
    {    
        BYTE sUsername[NAME_LEN];            /* DDNS账号用户名*/
        BYTE sPassword[PASSWD_LEN];            /* 密码 */
        BYTE sDomainName[MAX_DOMAIN_NAME];    /* 设备配备的域名地址 */
        BYTE sServerName[MAX_DOMAIN_NAME];    /* DDNS协议对应的服务器地址，可以是IP地址或域名 */
        WORD wDDNSPort;                        /* 端口号 */
        WORD    wCountryID;        //国家编号，仅在byHostIndex = 4时有效，0表示默认
                                BYTE byStatus;                      /* DDNS运行状态（只读），
                                                                    0-无意义
                                                                    1-连接服务器失败(connServerfail)、
                                                                    2-解析服务器消息失败(solveServerMesFail)、
                                                                    3-连接心跳服务器失败(connHeartSrvfail)、
                                                                    4-解析心跳服务器消息失败(solveHeartSrvMesFail)、
                                                                    5-连接域名服务器失败(connHostSrvfail)、
                                                                    6-解析域名服务器消息失败(solveHostSrvMesFail)、
                                                                    7-DDNS状态正常(updateSuccess)、
                                                                    8-未启用(disable)、
                                                                    9-注册域名成功(registHostSuccess)、
                                                                    10-DNS服务器配置错误(DNSSrvError)、
                                                                    11-域名被占用(DomainConflict)、
                                                                    12-别名(域名)不合法(invalidAlias)、
                                                                    13-鉴权失败(authenticationFail)
                                                                    14-注册服务器错误(registServerError)
                                                                    15-注册失败(registFail)
                                */
                                BYTE byRes[7];
    } struDDNS[MAX_DDNS_NUMS];
    BYTE byRes2[16];
}NET_DVR_DDNSPARA_V30, *LPNET_DVR_DDNSPARA_V30;

//email
typedef struct 
{
    BYTE sUsername[64];  /* 邮件账号/密码 */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];   /* email */
    BYTE sEventMailAddr1[64];  /* 上传报警/异常等的email */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA, *LPNET_DVR_EMAILPARA;

//网络参数配置
typedef struct 
{
    DWORD  dwSize;
    char  sDNSIp[16];                /* DNS服务器地址 */
    NET_DVR_NTPPARA  struNtpClientParam;      /* NTP参数 */
    NET_DVR_DDNSPARA struDDNSClientParam;     /* DDNS参数 */
    BYTE res[464];            /* 保留 */
}NET_DVR_NETAPPCFG, *LPNET_DVR_NETAPPCFG;

//nfs结构配置
typedef struct
{
    char sNfsHostIPAddr[16];
    BYTE sNfsDirectory[PATHNAME_LEN];        // PATHNAME_LEN = 128
}NET_DVR_SINGLE_NFS, *LPNET_DVR_SINGLE_NFS;

typedef struct 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG, *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{   
    DWORD dwSize;                   // 结构大小
    WORD wVrmPort;                  // VRM 监听端口
    BYTE byEnable;                  // 是否启用 ISCSI存储
    BYTE byRes[69];                 // 保留字节
    NET_DVR_IPADDR struVrmAddr;          // VRM ip地址 16位
    char chNvtIndexCode[64];        //nvt index Code 
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;  

//巡航点配置(私有IP快球专用)
typedef struct
{
    BYTE    PresetNum;    //预置点
    BYTE    Dwell;        //停留时间
    BYTE    Speed;        //速度
    BYTE    Reserve;    //保留
}NET_DVR_CRUISE_POINT, *LPNET_DVR_CRUISE_POINT;

typedef struct 
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];            //最大支持32个巡航点
}NET_DVR_CRUISE_RET, *LPNET_DVR_CRUISE_RET;

/************************************多路解码器(begin)***************************************/
typedef struct 
{
    DWORD    dwSize;
    char    sFirstDNSIP[16];
    char    sSecondDNSIP[16];
    char    sRes[32];
}NET_DVR_NETCFG_OTHER, *LPNET_DVR_NETCFG_OTHER;

typedef struct 
{
    char     sDVRIP[16];                /* DVR IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byChannel;                /* 通道号 */
    BYTE    byTransProtocol;            /* 传输协议类型 0-TCP, 1-UDP */
    BYTE    byTransMode;                /* 传输码流模式 0－主码流 1－子码流*/
    BYTE    byRes[3];
    BYTE    sUserName[NAME_LEN];            /* 监控主机登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];            /* 监控主机密码 */
}NET_DVR_MATRIX_DECINFO, *LPNET_DVR_MATRIX_DECINFO;

//启动/停止动态解码
typedef struct 
{
    DWORD    dwSize;                
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 动态解码通道信息 */
}NET_DVR_MATRIX_DYNAMIC_DEC, *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct  
{
    DWORD     dwSize;
    DWORD   dwIsLinked;         /* 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码 */
    DWORD   dwStreamCpRate;     /* Stream copy rate, X kbits/second */
    char    cRes[64];        /* 保留 */
}NET_DVR_MATRIX_DEC_CHAN_STATUS, *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct 
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 解码通道信息 */
    DWORD    dwDecState;    /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    char    sFileName[128];        /* 按文件回放文件名 */
}NET_DVR_MATRIX_DEC_CHAN_INFO, *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

//连接的通道配置 2007-11-05
typedef struct 
{
    DWORD dwEnable;                    /* 是否启用 0－否 1－启用*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 轮巡解码通道信息 */
}NET_DVR_MATRIX_DECCHANINFO, *LPNET_DVR_MATRIX_DECCHANINFO;

//2007-11-05 新增每个解码通道的配置
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPoolTime;            /*轮巡时间 */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO, *LPNET_DVR_MATRIX_LOOP_DECINFO;

//2007-12-22
typedef struct 
{
    BYTE    baudrate;     /* 波特率 */
    BYTE    databits;        /* 数据位 */
    BYTE    stopbits;        /* 停止位 */
    BYTE    parity;        /* 奇偶校验位 */
    BYTE    flowcontrol;    /* 流控 */
    BYTE    res[3];
}TTY_CONFIG, *LPTTY_CONFIG;

typedef struct  
{                    
    BYTE byTranChanEnable;    /* 当前透明通道是否打开 0：关闭 1：打开 */    
                            /*
                            *    多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                            *    0 RS485
                            *    1 RS232 Console
    */
    BYTE    byLocalSerialDevice;            /* Local serial device */
                                            /*
                                            *    远程串口输出还是两个,一个RS232，一个RS485
                                            *    1表示232串口
                                            *    2表示485串口
    */
    BYTE    byRemoteSerialDevice;            /* Remote output serial device */
    BYTE    res1;                            /* 保留 */
    char    sRemoteDevIP[16];                /* Remote Device IP */
    WORD    wRemoteDevPort;                /* Remote Net Communication Port */
    BYTE    res2[2];                        /* 保留 */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct  
{
    DWORD dwSize;
    BYTE     by232IsDualChan; /* 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE    by485IsDualChan; /* 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE    res[2];    /* 保留 */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM];/*同时支持建立MAX_SERIAL_NUM个透明通道*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007-12-24 Merry Christmas Eve...
typedef struct 
{
    DWORD    dwSize;
    char    sDVRIP[16];        /* DVR IP地址 */    
    WORD    wDVRPort;            /* 端口号 */    
    BYTE    byChannel;            /* 通道号 */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

/* 文件播放命令 */
#define NET_DVR_PLAYSTART        1//开始播放
#define NET_DVR_PLAYSTOP        2//停止播放
#define NET_DVR_PLAYPAUSE        3//暂停播放
#define NET_DVR_PLAYRESTART        4//恢复播放
#define NET_DVR_PLAYFAST        5//快放
#define NET_DVR_PLAYSLOW        6//慢放
#define NET_DVR_PLAYNORMAL        7//正常速度
#define NET_DVR_PLAYSTARTAUDIO    9//打开声音
#define NET_DVR_PLAYSTOPAUDIO    10//关闭声音
#define NET_DVR_PLAYSETPOS        12//改变文件回放的进度

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* 播放命令 见文件播放命令*/
    DWORD    dwCmdParam;        /* 播放命令参数 */
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct  
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;        /* 当前播放的媒体文件长度 */       
    DWORD dwCurMediaFilePosition;    /* 当前播放文件的播放位置 */        
    DWORD dwCurMediaFileDuration;    /* 当前播放文件的总时间 */        
    DWORD dwCurPlayTime;            /* 当前已经播放的时间 */        
    DWORD dwCurMediaFIleFrames;        /* 当前播放文件的总帧数 */        
    DWORD dwCurDataType;            /* 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志 */        
    BYTE res[72];    
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

//2009-4-11 added by likui 多路解码器new
typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD    wTransProtol;        //传输协议，0-TCP, 1-UDP, 2-MCAST
    WORD    wPassivePort;        //UDP端口, TCP时默认
    NET_DVR_IPADDR  struMcastIP;    //TCP,UDP时无效, MCAST时为多播地址
    BYTE    byStreamType;/* 数据播放模式:REAL_TIME_STREAM(1)实时流,RECORD_STREAM(2)文件流 */
    BYTE    byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE, *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30 
{                    
    BYTE  byTranChanEnable;            /* 当前透明通道是否打开 0：关闭 1：打开 */    
    BYTE  byLocalSerialDevice;      /* Local serial device */
                                    /*
                                    *  多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                                    *  0 RS485
                                    *  1 RS232 Console
                                    *  2 Dual Scom
                                    */
    BYTE  byRemoteSerialDevice;        /* Remote output serial device */
                                    /*
                                    *  远程串口输出还是两个,一个RS232，一个RS485
                                    *  1 表示232串口
                                    *  2 表示485串口
                                    */
    BYTE  byRes1;                    /* 保留 */        
    NET_DVR_IPADDR struRemoteDevIP; /* Remote Device IP */
    WORD  wRemoteDevPort;            /* Remote Net Communication Port */
    BYTE  byIsEstablished;            /* 透明通道建立成功标志，0-没有成功，1-建立成功 */
    BYTE  byRes2;                    /* 保留 */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE  byUsername[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    DWORD dwLocalSerialNo;          /* 本地串口 */
    DWORD dwRemoteSerialNo;         /* 远程串口 */
    BYTE  byRes3[8];
} NET_DVR_MATRIX_TRAN_CHAN_INFO_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG 
{
    DWORD dwSize;
    BYTE  by232IsDualChan; /* 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE  by485IsDualChan; /* 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE  byRes[2];           /* 保留 */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*同时支持建立MAX_SERIAL_NUM个透明通道*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;

typedef struct  
{
    DWORD                                dwEnable;    /* 是否启用 0－否 1－启用*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG    streamMediaServerCfg;    
    NET_DVR_DEV_CHAN_INFO         struDevChanInfo;        /* 轮巡解码通道信息 */
}NET_DVR_MATRIX_CHAN_INFO_V30,*LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔*/
    NET_DVR_MATRIX_CHAN_INFO_V30    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30,*LPNET_DVR_MATRIX_LOOP_DECINFO_V30;


typedef struct tagDEC_MATRIX_CHAN_INFO_V30
{
    DWORD    dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;    /*流媒体服务器配置*/
    NET_DVR_DEV_CHAN_INFO               struDevChanInfo;        /* 解码通道信息 */
    DWORD    dwDecState;        /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    char    sFileName[128];        /* 按文件回放文件名 */
    DWORD   dwGetStreamMode;    /*取流模式:1-主动，2-被动*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE    byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

#define MAX_RESOLUTIONNUM    64 //支持的最大分辨率数目
typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];     /*VGA支持的窗口模式，VGA1可能由混合输出*/
    BYTE  byBNCWindowMode[4];           /*BNC支持的窗口模式*/
    BYTE  byDspNums;   
    BYTE  byHDMINums;//HDMI显示通道个数（从25开始）
    BYTE  byDVINums;//DVI显示通道个数（从29开始）
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM];//按照上面的枚举定义,一个字节代表一个分辨率是//否支持，1：支持，0：不支持
    BYTE  byHDMIWindowMode[4][8];//HDMI支持的窗口模式
    BYTE  byDVIWindowMode[4][8];//DVI支持的窗口模式
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY, *LPNET_DVR_MATRIX_ABILITY;
//上传logo结构
typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD        dwCorordinateX;    //图片显示区域X坐标
    DWORD        dwCorordinateY;    //图片显示区域Y坐标
    WORD        wPicWidth; //图片宽
    WORD        wPicHeight; //图片高
    BYTE        byRes1[4];
    BYTE        byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE        byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE        byRes2[6];                //保留
    DWORD        dwLogoSize;//LOGO大小，包括BMP的文件头
}NET_DVR_DISP_LOGOCFG,*LPNET_DVR_DISP_LOGOCFG;

/*编码类型*/
#define NET_DVR_ENCODER_UNKOWN 0 /*未知编码格式*/
#define NET_DVR_ENCODER_H264   1 /*私有 264*/
#define NET_DVR_ENCODER_S264   2 /*Standard H264*/
#define NET_DVR_ENCODER_MPEG4  3 /*MPEG4*/
#define NET_DVR_ORIGINALSTREAM 4 /*Original Stream*/
#define NET_DVR_PICTURE           5/*Picture*/
#define NET_DVR_ENCODER_MJPEG  6
#define NET_DVR_ENCODER_MPEG2  7
#define NET_DVR_ENCODER_H265   8
/* 打包格式 */
#define NET_DVR_STREAM_TYPE_UNKOWN   0     /*未知打包格式*/
#define NET_DVR_STREAM_TYPE_PRIVT    1     /*私有格式*/
#define NET_DVR_STREAM_TYPE_TS       7   /* TS打包 */
#define NET_DVR_STREAM_TYPE_PS       8   /* PS打包 */
#define NET_DVR_STREAM_TYPE_RTP      9    /* RTP打包 */
#define NET_DVR_STREAM_TYPE_ORIGIN   10 //未打包(视频综合平台解码子系统用)

/*解码通道状态*/
typedef struct
{
    BYTE  byDecodeStatus; /*当前状态:0:未启动，1：启动解码*/
    BYTE  byStreamType;    /*码流类型*/
    BYTE  byPacketType;     /*打包方式*/
    BYTE  byRecvBufUsage; /*接收缓冲使用率*/
    BYTE  byDecBufUsage; /*解码缓冲使用率*/
    BYTE  byFpsDecV; /*视频解码帧率*/
    BYTE  byFpsDecA; /*音频解码帧率*/
    BYTE  byCpuLoad;     /*DSP CPU使用率*/ 
    BYTE  byRes1[4];    
    DWORD dwDecodedV; /*解码的视频帧*/
    DWORD dwDecodedA; /*解码的音频帧*/
    WORD wImgW; /*解码器当前的图像大小,宽*/
    WORD wImgH; //高
    BYTE byVideoFormat; /*视频制式:0-NON,NTSC--1,PAL--2*/
    BYTE  byRes2[3];
    DWORD  dwDecChan;       /*获取全部解码通道状态时有效，设置时可填0*/
    BYTE  byRes3[20]; 
}NET_DVR_MATRIX_CHAN_STATUS, *LPNET_DVR_MATRIX_CHAN_STATUS;

/*显示通道状态*/
#define NET_DVR_MAX_DISPREGION 16         /*每个显示通道最多可以显示的窗口*/
//分辨率
//
typedef enum
{
    /*VGA*/
    VGA_NOT_AVALIABLE,
        VGA_THS8200_MODE_SVGA_60HZ,    //(800*600)
        VGA_THS8200_MODE_SVGA_75HZ,    //(800*600)
        VGA_THS8200_MODE_XGA_60HZ,     //(1024*768)
        VGA_THS8200_MODE_XGA_75HZ,     //(1024*768)
        VGA_THS8200_MODE_SXGA_60HZ,    //(1280*1024)
        VGA_THS8200_MODE_720P_60HZ,    //(1280*720)
        VGA_THS8200_MODE_1080I_60HZ,   //(1920*1080)
        VGA_THS8200_MODE_1080P_30HZ,   //(1920*1080)
        VGA_THS8200_MODE_UXGA_30HZ,    //(1600*1200)
        /*HDMI*/    
        HDMI_SII9134_MODE_XGA_60HZ,       //(1024*768)
        HDMI_SII9134_MODE_SXGA_60HZ,   //(1280*1024)
        HDMI_SII9134_MODE_SXGA2_60HZ,  //(1280*960)
        HDMI_SII9134_MODE_720P_60HZ,   //(1280*720)    
        HDMI_SII9134_MODE_720P_50HZ,   //(1280*720)        
        HDMI_SII9134_MODE_1080I_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080I_50HZ,  //(1920*1080)    
        HDMI_SII9134_MODE_1080P_25HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_30HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_50HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_UXGA_60HZ,   //(1600*1200)
        /*DVI*/    
        DVI_SII9134_MODE_XGA_60HZ,       //(1024*768)
        DVI_SII9134_MODE_SXGA_60HZ,       //(1280*1024)
        DVI_SII9134_MODE_SXGA2_60HZ,   //(1280*960)
        DVI_SII9134_MODE_720P_60HZ,       //(1280*720)    
        DVI_SII9134_MODE_720P_50HZ,    //(1280*720)        
        DVI_SII9134_MODE_1080I_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080I_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_25HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_30HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_UXGA_60HZ,     //(1600*1200)
        VGA_DECSVR_MODE_SXGA2_60HZ,
        HDMI_DECSVR_MODE_1080P_24HZ,
        DVI_DECSVR_MODE_1080P_24HZ,
        YPbPr_DECSVR_MODE_720P_60HZ,
        YPbPr_DECSVR_MODE_1080I_60HZ
}VGA_MODE;

//低帧率定义
#define           LOW_DEC_FPS_1_2                51
#define           LOW_DEC_FPS_1_4                52
#define           LOW_DEC_FPS_1_8                53
#define           LOW_DEC_FPS_1_16               54

/*视频制式标准*/
typedef enum
{
    VS_NON = 0,
        VS_NTSC = 1,
        VS_PAL = 2
}VIDEO_STANDARD;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*音频是否开启,0-否，1-是*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE     byVgaResolution;      /*VGA的分辨率*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwWindowMode;        /*画面模式,从能力集获取,目前支持1,2,4,9,16*/       
    BYTE    byJoinDecChan[MAX_WINDOWS];/*各个子窗口关联的解码通道*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    union
    {
        BYTE byRes[16];
        struct
        {
            /*各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)*/
            BYTE     byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE     byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    BYTE        byUnionType;
    BYTE        byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
}NET_DVR_VGA_DISP_CHAN_CFG,*LPNET_DVR_VGA_DISP_CHAN_CFG;


/*显示通道状态*/
#define NET_DVR_MAX_DISPREGION 16 /*每个显示通道最多可以显示的窗口*/
typedef struct
{
    BYTE  byDispStatus;          /*显示状态：0：未显示，1：启动显示*/
    BYTE  byBVGA;                /*0-BNC，1-VGA， 2-HDMI，3-DVI*/
    BYTE  byVideoFormat;        /*视频制式:1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;        /*当前画面模式*/
    BYTE  byJoinDecChan[MAX_WINDOWS];        /*各个子窗口关联的解码通道*/
    BYTE  byFpsDisp[NET_DVR_MAX_DISPREGION]; /*每个子画面的显示帧率*/
    BYTE  byScreenMode;            //屏幕模式0-普通 1-大屏
    BYTE  byRes2[31];
}NET_DVR_DISP_CHAN_STATUS, *LPNET_DVR_DISP_CHAN_STATUS;

#define MAX_DECODECHANNUM   32//多路解码器最大解码通道数
#define MAX_DISPCHANNUM   24//多路解码器最大显示通道数

/*解码器设备状态*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM]; /*解码通道状态*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];  /*显示通道状态*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];         /*报警输入状态*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];       /*报警输出状态*/
    BYTE byAudioInChanStatus;          /*语音对讲状态*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS,*LPNET_DVR_DECODER_WORK_STATUS;

//2009-12-1 增加被动解码播放控制
typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* 播放命令 见文件播放命令*/
    DWORD    dwCmdParam;        /* 播放命令参数 */
    BYTE    byRes[16];//Reverse
}NET_DVR_PASSIVEDECODE_CONTROL,*LPNET_DVR_PASSIVEDECODE_CONTROL;

#define        PASSIVE_DEC_PAUSE            1    /*被动解码暂停(仅文件流有效)*/
#define        PASSIVE_DEC_RESUME            2    /*恢复被动解码(仅文件流有效)*/
#define     PASSIVE_DEC_FAST              3   /*快速被动解码(仅文件流有效)*/
#define     PASSIVE_DEC_SLOW            4   /*慢速被动解码(仅文件流有效)*/
#define     PASSIVE_DEC_NORMAL          5   /*正常被动解码(仅文件流有效)*/
#define     PASSIVE_DEC_ONEBYONE          6  /*被动解码单帧播放(保留)*/
#define     PASSIVE_DEC_AUDIO_ON         7   /*音频开启*/
#define     PASSIVE_DEC_AUDIO_OFF        8       /*音频关闭*/
#define        PASSIVE_DEC_RESETBUFFER        9    /*清空缓冲区*/
//2009-12-16 增加控制解码器解码通道缩放
typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{        
    DWORD    dwSize;
    BYTE    byDecChanScaleStatus;/*解码通道显示缩放控制,1表示缩放显示，0表示真实显示*/
    BYTE    byDecodeDelay;//解码延时，0-默认，1-实时性好，2-实时性较好，3-实时性中，流畅性中，4-流畅性较好，5-流畅性好，0xff-自动调整   
    BYTE    byEnableSpartan;//畅显使能，0-关，1-开
    BYTE    byLowLight;      //低照度。0-关，1-8代表低照度等级，等级越高强度越大
    BYTE    byNoiseReduction; //3D降噪，0-关，1-开，2-自动
    BYTE    byDefog;         //透雾，0-关，1-7代表透雾等级，等级越高强度越大
    BYTE    byEnableVcaDec; //是否启用智能解码，0-不启用，非0-启用
    BYTE    byRes1;
    DWORD   dwAllCtrlType;    //所有子窗口一起操作的类型，设置时有效，按位表示
    //dwAllCtrlType & 0x01,开启关闭智能解码
    BYTE    byRes[56];
}NET_DVR_MATRIX_DECCHAN_CONTROL,*LPNET_DVR_MATRIX_DECCHAN_CONTROL;

/************************************多路解码器(end)***************************************/
//2009-8-19 视频综合平台接口函数
/************************************视频综合平台(begin)***************************************/
#define MAX_SUBSYSTEM_NUM    80   //一个矩阵系统中最多子系统数量
#define MAX_SERIALLEN        36  //最大序列号长度
#define MAX_LOOPPLANNUM        16//最大计划切换组
#define DECODE_TIMESEGMENT 4//计划解码每天时间段数
typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE        bySubSystemType;//子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，0-NULL（此参数只能获取）        
    BYTE        byChan;//子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）                    
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP地址（可修改）*/
    WORD        wSubSystemPort;        //子系统端口号（可修改）
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask;//子网掩码
    NET_DVR_IPADDR    struGatewayIpAddr;    /* 网关地址*/   
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码（此参数只能获取）*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
}NET_DVR_SUBSYSTEMINFO, *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO, *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct  tagNET_DVR_LOOPPLAN_SUBCFG
{
    DWORD                             dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔，单位：秒*/      
    NET_DVR_MATRIX_CHAN_INFO_V30 struChanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
}NET_DVR_LOOPPLAN_SUBCFG,*LPNET_DVR_LOOPPLAN_SUBCFG;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD     dwSize;
    BYTE    byAlarmMode;//报警触发类型，1-轮巡，2-保持        
    WORD    wLoopTime;//轮巡时间, 单位：秒            
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG,*LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD            dwSize;
    NET_DVR_IPADDR   struIP;        /*码分器IP地址*/
    WORD        wPort;                    //码分器端口号
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名 */
    BYTE        sPassword[PASSWD_LEN];    /*密码 */
    BYTE        byChan;//码分器485号
    BYTE        by485Port;//485口地址
    BYTE        byRes2[14];
} NET_DVR_CODESPLITTERINFO, *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE    byAssociateType;//关联类型，1-报警
    WORD    wAlarmDelay;//报警延时，0－5秒；1－10秒；2－30秒；3－1分钟；4－2分钟；5－5分钟；6－10分钟；
    BYTE    byAlarmNum;//报警号，具体的值由应用赋，相同的报警赋相同的值
    BYTE    byRes[8];
} NET_DVR_ASSOCIATECFG,*LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD                            dwSize;
    NET_DVR_ASSOCIATECFG           struAssociateCfg;//触发动态解码关联结构
    NET_DVR_PU_STREAM_CFG        struPuStreamCfg;//动态解码结构
    BYTE                            byRes[8];
}NET_DVR_DYNAMICDECODE,*LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime;//
    BYTE  byDecodeType;/*0-无，1-轮巡解码，2-动态解码*/
    BYTE  byLoopGroup;//轮巡组号
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec;//动态解码
} NET_DVR_DECODESCHED, *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT];//周一作为开始，和9000一致
    BYTE byRes[8];
} NET_DVR_PLANDECODE,*LPNET_DVR_PLANDECODE;

//end
/************************************视频综合平台(end)***************************************/
typedef struct 
{    /* 12 bytes */
    DWORD    dwSize;
    char    sUserName[32];
    char     sPassWord[32];
    char     sFromName[32];            /* Sender *///字符串中的第一个字符和最后一个字符不能是"@",并且字符串中要有"@"字符
    char     sFromAddr[48];            /* Sender address */
    char     sToName1[32];            /* Receiver1 */
    char     sToName2[32];            /* Receiver2 */
    char     sToAddr1[48];            /* Receiver address1 */
    char     sToAddr2[48];            /* Receiver address2 */
    char    sEmailServer[32];        /* Email server address */
    BYTE    byServerType;            /* Email server type: 0-SMTP, 1-POP, 2-IMTP…*/
    BYTE    byUseAuthen;            /* Email server authentication method: 1-enable, 0-disable */
    BYTE    byAttachment;            /* enable attachment */
    BYTE    byMailinterval;            /* mail interval 0-2s, 1-3s, 2-4s. 3-5s*/
} NET_DVR_EMAILCFG, *LPNET_DVR_EMAILCFG;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;    //定时录像
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;    //事件触发录像
}NET_DVR_COMPRESSIONCFG_NEW, *LPNET_DVR_COMPRESSIONCFG_NEW;

//球机位置信息
typedef struct
{
    WORD wAction;//获取时该字段无效
    WORD wPanPos;//水平参数
    WORD wTiltPos;//垂直参数
    WORD wZoomPos;//变倍参数
}NET_DVR_PTZPOS, *LPNET_DVR_PTZPOS;

//球机范围信息
typedef struct
{
    WORD wPanPosMin;//水平参数min
    WORD wPanPosMax;//水平参数max
    WORD wTiltPosMin;//垂直参数min
    WORD wTiltPosMax;//垂直参数max
    WORD wZoomPosMin;//变倍参数min
    WORD wZoomPosMax;//变倍参数max
}NET_DVR_PTZSCOPE, *LPNET_DVR_PTZSCOPE;

//rtsp配置 ipcamera专用
typedef struct
{
    DWORD dwSize;         //长度
    WORD  wPort;          //rtsp服务器侦听端口
    BYTE  byReserve[54];  //预留
}NET_DVR_RTSPCFG, *LPNET_DVR_RTSPCFG;

/********************************接口参数结构(begin)*********************************/

//NET_DVR_Login()参数结构
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];   //序列号
    BYTE byAlarmInPortNum;                //DVR报警输入个数
    BYTE byAlarmOutPortNum;                //DVR报警输出个数
    BYTE byDiskNum;                        //DVR硬盘个数
    BYTE byDVRType;                        //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                        //DVR 通道个数
    BYTE byStartChan;                    //起始通道号,例如DVS-1,DVR - 1
}NET_DVR_DEVICEINFO, *LPNET_DVR_DEVICEINFO;

//NET_DVR_Login_V30()参数结构
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];  //序列号
    BYTE byAlarmInPortNum;                //报警输入个数
    BYTE byAlarmOutPortNum;                //报警输出个数
    BYTE byDiskNum;                    //硬盘个数
    BYTE byDVRType;                    //设备类型, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                    //模拟通道个数
    BYTE byStartChan;                    //起始通道号,例如DVS-1,DVR - 1
    BYTE byAudioChanNum;                //语音通道数
    BYTE byIPChanNum;                    //最大数字通道个数，低位  
    BYTE byZeroChanNum;            //零通道编码个数 //2010-01-16
    BYTE byMainProto;            //主码流传输协议类型 0-private, 1-rtsp,2-同时支持private和rtsp
    BYTE bySubProto;                //子码流传输协议类型0-private, 1-rtsp,2-同时支持private和rtsp
    BYTE bySupport;        //能力，位与结果为0表示不支持，1表示支持，
    //bySupport & 0x1, 表示是否支持智能搜索
    //bySupport & 0x2, 表示是否支持备份
    //bySupport & 0x4, 表示是否支持压缩参数能力获取
    //bySupport & 0x8, 表示是否支持多网卡
    //bySupport & 0x10, 表示支持远程SADP
    //bySupport & 0x20, 表示支持Raid卡功能
    //bySupport & 0x40, 表示支持IPSAN 目录查找
    //bySupport & 0x80, 表示支持rtp over rtsp
    BYTE bySupport1;        // 能力集扩充，位与结果为0表示不支持，1表示支持
    //bySupport1 & 0x1, 表示是否支持snmp v30
    //bySupport1 & 0x2, 支持区分回放和下载
    //bySupport1 & 0x4, 是否支持布防优先级    
    //bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
    //bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
    //bySupport1 & 0x20, 表示是否支持rtsp over http    
    //bySupport1 & 0x80, 表示是否支持车牌新报警信息2012-9-28, 且还表示是否支持NET_DVR_IPPARACFG_V40结构体
    BYTE bySupport2; /*能力，位与结果为0表示不支持，非0表示支持                            
                     bySupport2 & 0x1, 表示解码器是否支持通过URL取流解码
                     bySupport2 & 0x2,  表示支持FTPV40
                     bySupport2 & 0x4,  表示支持ANR
                     bySupport2 & 0x8,  表示支持CCD的通道参数配置
                     bySupport2 & 0x10,  表示支持布防报警回传信息（仅支持抓拍机报警 新老报警结构）
                     bySupport2 & 0x20,  表示是否支持单独获取设备状态子项
    bySupport2 & 0x40,  表示是否是码流加密设备*/
    WORD wDevType;              //设备型号
    BYTE bySupport3; //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport3 & 0x1, 表示是否多码流
    // bySupport3 & 0x4 表示支持按组配置， 具体包含 通道图像参数、报警输入参数、IP报警输入、输出接入参数、
    // 用户参数、设备工作状态、JPEG抓图、定时和时间抓图、硬盘盘组管理 
    //bySupport3 & 0x8为1 表示支持使用TCP预览、UDP预览、多播预览中的"延时预览"字段来请求延时预览（后续都将使用这种方式请求延时预览）。而当bySupport3 & 0x8为0时，将使用 "私有延时预览"协议。
    //bySupport3 & 0x10 表示支持"获取报警主机主要状态（V40）"。
    //bySupport3 & 0x20 表示是否支持通过DDNS域名解析取流
    
    BYTE byMultiStreamProto;//是否支持多码流,按位表示,0-不支持,1-支持,bit1-码流3,bit2-码流4,bit7-主码流，bit-8子码流
    BYTE byStartDChan;        //起始数字通道号,0表示无效
    BYTE byStartDTalkChan;    //起始数字对讲通道号，区别于模拟对讲通道号，0表示无效
    BYTE byHighDChanNum;        //数字通道个数，高位
    BYTE bySupport4;        //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport4 & 0x4表示是否支持拼控统一接口
    // bySupport4 & 0x80 支持设备上传中心报警使能。表示判断调用接口是 NET_DVR_PDC_RULE_CFG_V42还是 NET_DVR_PDC_RULE_CFG_V41
    BYTE byLanguageType;// 支持语种能力,按位表示,每一位0-不支持,1-支持  
    //  byLanguageType 等于0 表示 老设备
    //  byLanguageType & 0x1表示支持中文
    //  byLanguageType & 0x2表示支持英文
    BYTE byVoiceInChanNum;   //音频输入通道数 
    BYTE byStartVoiceInChanNo; //音频输入起始通道号 0表示无效
    BYTE  bySupport5;  //按位表示,0-不支持,1-支持,bit0-支持多码流
    //bySupport5 &0x01表示支持wEventTypeEx ,兼容dwEventType 的事件类型（支持行为事件扩展）--先占住，防止冲突
    //bySupport5 &0x04表示是否支持使用扩展的场景模式接口
    /*
       bySupport5 &0x08 设备返回该值表示是否支持计划录像类型V40接口协议(DVR_SET_RECORDCFG_V40/ DVR_GET_RECORDCFG_V40)(在该协议中设备支持类型类型13的配置)
       之前的部分发布的设备，支持录像类型13，则配置录像类型13。如果不支持，统一转换成录像类型3兼容处理。SDK通过命令探测处理)
    */
    BYTE  bySupport6;   //能力，按位表示，0-不支持,1-支持
    //bySupport6 0x1  表示设备是否支持压缩 
    //bySupport6 0x2 表示是否支持流ID方式配置流来源扩展命令，DVR_SET_STREAM_SRC_INFO_V40
    //bySupport6 0x4 表示是否支持事件搜索V40接口
    //bySupport6 0x8 表示是否支持扩展智能侦测配置命令
    //bySupport6 0x40表示图片查询结果V40扩展
    BYTE  byMirrorChanNum;    //镜像通道个数，<录播主机中用于表示导播通道>
    WORD wStartMirrorChanNo;  //起始镜像通道号
    BYTE bySupport7;   //能力,按位表示,0-不支持,1-支持
    // bySupport7 & 0x1  表示设备是否支持 INTER_VCA_RULECFG_V42 扩展
    // bySupport7 & 0x2  表示设备是否支持 IPC HVT 模式扩展
    // bySupport7 & 0x04  表示设备是否支持 返回锁定时间
    // bySupport7 & 0x08  表示设置云台PTZ位置时，是否支持带通道号
    // bySupport7 & 0x10  表示设备是否支持双系统升级备份
    // bySupport7 & 0x20  表示设备是否支持 OSD字符叠加 V50
    // bySupport7 & 0x40  表示设备是否支持 主从跟踪（从摄像机）
    // bySupport7 & 0x80  表示设备是否支持 报文加密
    BYTE  byRes2;        //保留
}NET_DVR_DEVICEINFO_V30, *LPNET_DVR_DEVICEINFO_V30;

typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //设备支持锁定功能，该字段由SDK根据设备返回值来赋值的。bySupportLock为1时，dwSurplusLockTime和byRetryLoginTime有效
    BYTE  byRetryLoginTime;        //剩余可尝试登陆的次数，用户名，密码错误时，此参数有效
    BYTE  byPasswordLevel;      //admin密码安全等级0-无效，1-默认密码，2-有效密码,3-风险较高的密码。当用户的密码为出厂默认密码（12345）或者风险较高的密码时，上层客户端需要提示用户更改密码。      
    BYTE  byRes1;
    DWORD dwSurplusLockTime;    //剩余时间，单位秒，用户锁定时，此参数有效
    BYTE  byCharEncodeType;     //字符编码类型
    BYTE byRes2[255];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

typedef void (CALLBACK *fLoginResultCallBack) (LONG lUserID, DWORD dwResult, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo , void* pUser);

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64


typedef struct  
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byRes1;
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType; //0:不使用代理，1：使用标准代理，2：使用EHome代理
    BYTE byUseUTCTime;    //0-不进行转换，默认,1-接口上输入输出全部使用UTC时间,SDK完成UTC时间与设备时区的转换,2-接口上输入输出全部使用平台本地时间，SDK完成平台本地时间与设备时区的转换
    BYTE byRes2[2];
    LONG iProxyID;    //代理服务器序号，添加代理服务器信息时，相对应的服务器数组下表值    
    BYTE byRes3[120];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;

//sdk网络环境枚举变量，用于远程升级
typedef enum _SDK_NET_ENV
{
    LOCAL_AREA_NETWORK = 0,
        WIDE_AREA_NETWORK
}SDK_NETWORK_ENVIRONMENT;

//显示模式
typedef enum
{
    NORMALMODE = 0,
        OVERLAYMODE
}DISPLAY_MODE;

//发送模式
typedef enum
{
    PTOPTCPMODE = 0,
        PTOPUDPMODE,
        MULTIMODE,
        RTPMODE,
        RESERVEDMODE
}SEND_MODE;

//抓图模式
typedef enum 
{
    BMP_MODE = 0,        //BMP模式
        JPEG_MODE = 1        //JPEG模式 
}CAPTURE_MODE;

//实时声音模式
typedef enum
{
    MONOPOLIZE_MODE = 1,//独占模式
        SHARE_MODE = 2        //共享模式
}REALSOUND_MODE;

//软解码预览参数
typedef struct
{
    LONG lChannel;//通道号
    LONG lLinkMode;//最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式: 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;//播放窗口的句柄,为NULL表示不播放图象
    char* sMultiCastIP;//多播组地址
    BYTE byProtoType; //应用层取流协议，0-私有协议，1-RTSP协议
    BYTE byRes[3];
}NET_DVR_CLIENTINFO, *LPNET_DVR_CLIENTINFO;

//SDK状态信息(9000新增)
typedef struct 
{
    DWORD dwTotalLoginNum;        //当前login用户数
    DWORD dwTotalRealPlayNum;    //当前realplay路数
    DWORD dwTotalPlayBackNum;    //当前回放或下载路数
    DWORD dwTotalAlarmChanNum;    //当前建立报警通道路数
    DWORD dwTotalFormatNum;        //当前硬盘格式化路数
    DWORD dwTotalFileSearchNum;    //当前日志或文件搜索路数
    DWORD dwTotalLogSearchNum;    //当前日志或文件搜索路数
    DWORD dwTotalSerialNum;        //当前透明通道路数
    DWORD dwTotalUpgradeNum;    //当前升级路数
    DWORD dwTotalVoiceComNum;    //当前语音转发路数
    DWORD dwTotalBroadCastNum;    //当前语音广播路数
    DWORD dwTotalListenNum;        //当前网络监听路数
    DWORD dwEmailTestNum;       //当前邮件计数路数
    DWORD dwBackupNum;          // 当前文件备份路数
    DWORD dwTotalInquestUploadNum; //当前审讯上传路数
    DWORD dwRes[6];
}NET_DVR_SDKSTATE, *LPNET_DVR_SDKSTATE;

//SDK功能支持信息(9000新增)
typedef struct 
{
    DWORD dwMaxLoginNum;        //最大login用户数 MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;        //最大realplay路数 WATCH_NUM
    DWORD dwMaxPlayBackNum;        //最大回放或下载路数 WATCH_NUM
    DWORD dwMaxAlarmChanNum;    //最大建立报警通道路数 ALARM_NUM
    DWORD dwMaxFormatNum;        //最大硬盘格式化路数 SERVER_NUM
    DWORD dwMaxFileSearchNum;    //最大文件搜索路数 SERVER_NUM
    DWORD dwMaxLogSearchNum;    //最大日志搜索路数 SERVER_NUM
    DWORD dwMaxSerialNum;        //最大透明通道路数 SERVER_NUM
    DWORD dwMaxUpgradeNum;        //最大升级路数 SERVER_NUM
    DWORD dwMaxVoiceComNum;        //最大语音转发路数 SERVER_NUM
    DWORD dwMaxBroadCastNum;    //最大语音广播路数 MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL, *LPNET_DVR_SDKABL;

//报警设备信息
typedef struct
{   
    BYTE byUserIDValid;                 /* userid是否有效 0-无效，1-有效 */
    BYTE bySerialValid;                 /* 序列号是否有效 0-无效，1-有效 */
    BYTE byVersionValid;                /* 版本号是否有效 0-无效，1-有效 */
    BYTE byDeviceNameValid;             /* 设备名字是否有效 0-无效，1-有效 */
    BYTE byMacAddrValid;                /* MAC地址是否有效 0-无效，1-有效 */    
    BYTE byLinkPortValid;               /* login端口是否有效 0-无效，1-有效 */
    BYTE byDeviceIPValid;               /* 设备IP是否有效 0-无效，1-有效 */
    BYTE bySocketIPValid;               /* socket ip是否有效 0-无效，1-有效 */
    LONG lUserID;                       /* NET_DVR_Login()返回值, 布防时有效 */
    BYTE sSerialNumber[SERIALNO_LEN];    /* 序列号 */
    DWORD dwDeviceVersion;                /* 版本信息 高16位表示主版本，低16位表示次版本*/
    char sDeviceName[NAME_LEN];            /* 设备名字 */
    BYTE byMacAddr[MACADDR_LEN];        /* MAC地址 */    
    WORD wLinkPort;                     /* link port */
    char sDeviceIP[128];                /* IP地址 */
    char sSocketIP[128];                /* 报警主动上传时的socket IP地址 */
    BYTE byIpProtocol;                  /* Ip协议 0-IPV4, 1-IPV6 */
    BYTE byRes2[11];
}NET_DVR_ALARMER, *LPNET_DVR_ALARMER;

//硬解码显示区域参数(子结构)
typedef struct
{
    long bToScreen;
    long bToVideoOut;
    long nLeft;
    long nTop;
    long nWidth;
    long nHeight;
    long nReserved;
}NET_DVR_DISPLAY_PARA, *LPNET_DVR_DISPLAY_PARA;

//硬解码预览参数
typedef struct
{
    LONG lChannel;//通道号
    LONG lLinkMode; //最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式:0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-电话线，5－128k宽带，6－256k宽带，7－384k宽带，8－512k宽带；
    char* sMultiCastIP;
    NET_DVR_DISPLAY_PARA struDisplayPara;
}NET_DVR_CARDINFO, *LPNET_DVR_CARDINFO;

//录象文件参数
typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
}NET_DVR_FIND_DATA, *LPNET_DVR_FIND_DATA;

//录象文件参数(9000)
typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
    BYTE byLocked;//9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    BYTE byFileType;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30, *LPNET_DVR_FINDDATA_V30;

//录象文件参数(cvr)
typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
    BYTE byLocked;//9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    BYTE byFileType;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    BYTE byQuickSearch; //0:普通查询结果，1：快速（日历）查询结果
    BYTE byRes;
    DWORD dwFileIndex; //文件索引号
    BYTE byStreamType;
    BYTE byRes1[127];    
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;

//录象文件参数(带卡号)
typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD, *LPNET_DVR_FINDDATA_CARD;


//录象文件查找条件结构
typedef struct 
{
    LONG lChannel;//通道号
    DWORD dwFileType;//录象文件类型
       //不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    //带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    DWORD dwIsLocked;//是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    DWORD dwUseCardNo;//是否使用卡号
    BYTE sCardNumber[32];//卡号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
}NET_DVR_FILECOND, *LPNET_DVR_FILECOND;

//云台区域选择放大缩小(私有 快球专用)
typedef struct 
{
    int xTop;     //方框起始点的x坐标
    int yTop;     //方框结束点的y坐标
    int xBottom;  //方框结束点的x坐标
    int yBottom;  //方框结束点的y坐标
    int bCounter; //保留
}NET_DVR_POINT_FRAME, *LPNET_DVR_POINT_FRAME;

//语音对讲参数
typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;   //音频编码类型 0-OggVorbis;1-G711_U;2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM
    BYTE  byAudioSamplingRate;//音频采样率 0-默认，1-16kHZ，2-32kHZ，3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// 音频码率 参考 BITRATE_ENCODE_INDEX
    BYTE  byres[4];//这里保留音频的压缩参数  
    BYTE  bySupport;//bySupport Bit0表示 Mp2l2前4个字节的含义表示后面内容音频数据长度 
}NET_DVR_COMPRESSION_AUDIO, *LPNET_DVR_COMPRESSION_AUDIO;

//2009-7-22


#define IW_ESSID_MAX_SIZE                         32
#define WIFI_WEP_MAX_KEY_COUNT                     4
#define WIFI_WEP_MAX_KEY_LENGTH                     33
#define WIFI_WPA_PSK_MAX_KEY_LENGTH                 63
#define WIFI_WPA_PSK_MIN_KEY_LENGTH                 8
#define WIFI_MAX_AP_COUNT                         20
#define WIFI_WPA_PSK_MAX_HEXKEY_LENGTH           68   //WPA16进制密钥最大长度

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;                        /* 0 mange 模式;1 ad-hoc模式，参见NICMODE */
    DWORD  dwSecurity;           /*0 不加密；1 wep加密；2 wpa-psk;3 wpa-Enterprise;4-WPA2_PSK参见WIFISECURITY*/
    DWORD  dwChannel;            /*1-11表示11个通道*/
    DWORD  dwSignalStrength;    /*0-100信号由最弱变为最强*/
    DWORD  dwSpeed;               /*速率,单位是0.01mbps*/
}NET_DVR_AP_INFO,*LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;        /*无线AP数量，不超过20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST,*LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{    
    char sIpAddress[16];                /*IP地址*/
    char sIpMask[16];                    /*掩码*/    
    BYTE    byMACAddr[MACADDR_LEN];        /*物理地址，只用来显示*/
    BYTE    byCloseWifi;        //是否关闭wifi连接，0-不关闭，1-关闭
    BYTE    bRes;
    DWORD    dwEnableDhcp;                /*是否启动dhcp  0不启动 1启动*/
    DWORD    dwAutoDns;                    /*如果启动dhcp是否自动获取dns,0不自动获取 1自动获取；对于有线如果启动dhcp目前自动获取dns*/    
    char sFirstDns[16];                         /*第一个dns域名*/
    char sSecondDns[16];                     /*第二个dns域名*/
    char sGatewayIpAddr[16];                 /* 网关地址*/
    BYTE   bRes2[8];
}NET_DVR_WIFIETHERNET,*LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;        /*wifi网口*/
    char sEssid[IW_ESSID_MAX_SIZE];     /*SSID*/
    DWORD dwMode;      /* 0 mange 模式;1 ad-hoc模式，参见*/
    DWORD dwSecurity; /*0-不加密;1-WEP加密;2-WPA-personal; 3-WPA-enterprise;4-WPA2-personal;5-WPA2-enterprise */
    union 
    {
        struct 
        {
            DWORD dwAuthentication;/*0 -开放式 1-共享式*/
            DWORD dwKeyLength;/* 0 -64位；1- 128位；2-152位*/
            DWORD dwKeyType;/*0 16进制;1 ASCI */
            DWORD dwActive;/*0 索引：0---3表示用哪一个密钥*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct 
        {
            DWORD dwKeyLength;/*8-63个ASCII字符*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2模式下加密类型,0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//新密钥（支持8-63个ASCII字符以及64个十六制字符密钥）
            //当byKeyType为0时，启用sKeyInfo，当byKeyType为1时，启用sNewKeyInfo
            //密钥类型；0 ~ 老密钥类型（只支持8-63个ASCII字符），1 ~新密钥类型（支持8-63个ASCII字符以及64个十六制字符密钥）
            BYTE byKeyType; 
            BYTE byRes[7];
        }wpa_psk;
        struct 
        {
            BYTE byEncryptType;  /*加密类型,0-AES, 1-TKIP*/
            BYTE byAuthType; //认证类型，0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byAuthType; //内部认证方式，0-PAP，1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity [NAME_LEN]; //匿名身份
                    BYTE byUserName[NAME_LEN]; //用户名
                    BYTE byPassword[NAME_LEN]; //密码
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterpris模式适用
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byAuthType; //内部认证方式，0-GTC，1-MD5，2-MSCHAPV2
                    BYTE byPeapVersion; //PEAP版本，0-版本0，1-版本1
                    BYTE byPeapLabel; //PEAP标签，0-老标签，1-新标签
                    BYTE byAnonyIdentity[NAME_LEN]; //匿名身份
                    BYTE byUserName[NAME_LEN]; //用户名
                    BYTE byPassword[NAME_LEN]; //密码
                    BYTE byRes[44]; 
                }EAP_PEAP; //WPA-enterprise/WPA2-enterpris模式适用
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byRes1[3]; 
                    BYTE byIdentity[NAME_LEN]; //身份
                    BYTE byPrivateKeyPswd[NAME_LEN]; //私钥密码
                    BYTE byRes[76]; 
                }EAP_TLS; 
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterpris模式适用
    }key;    
}NET_DVR_WIFI_CFG_EX,*LPNET_DVR_WIFI_CFG_EX;

//wifi配置结构
typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG,*LPNET_DVR_WIFI_CFG;

//wifi连接状态
typedef     struct  tagNET_DVR_WIFI_CONNECT_STATUS
{
    DWORD        dwSize;
    BYTE        byCurStatus;    //1-已连接，2-未连接，3-正在连接
    BYTE        byRes1[3];        //保留
    DWORD        dwErrorCode;    // byCurStatus = 2时有效,1-用户名或密码错误,2-无此路由器,3-未知错误
    BYTE        byRes[244];
}NET_DVR_WIFI_CONNECT_STATUS,*LPNET_DVR_WIFI_CONNECT_STATUS;

//wifi工作模式
typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode; /*0 自动切换模式　1 有线模式*/
}NET_DVR_WIFI_WORKMODE,*LPNET_DVR_WIFI_WORKMODE;

//结构参数宏定义 
#define VCA_MAX_POLYGON_POINT_NUM        10        //检测区域最多支持10个点的多边形
#define MAX_RULE_NUM                    8        //最多规则条数
#define MAX_RULE_NUM_V42                16      //最多规则条数扩展
#define MAX_TARGET_NUM                    30        //最多目标个数
#define MAX_CALIB_PT                     6        //最大标定点个数
#define MIN_CALIB_PT                     4        //最小标定点个数
#define MAX_TIMESEGMENT_2                2        //最大时间段数
#define DATA_INDEX_LEN                  64      //数据流水号
#define MAX_TRAFFIC_PICTURE_NUM         8      //交通图片数量
#define MAX_LICENSE_LEN                    16        //车牌号最大长度
#define MAX_CARDNO_LEN                  48      //卡号最大长度 2013-11-04
#define MAX_OPERATE_INDEX_LEN           32      //操作数最大长度2014-03-03
#define MAX_PLATE_NUM                    3        //车牌个数
#define MAX_MASK_REGION_NUM                4       //最多四个屏蔽区域
#define MAX_SEGMENT_NUM                    6       //摄像机标定最大样本线数目
#define MIN_SEGMENT_NUM                    3       //摄像机标定最小样本线数目
#define MAX_REL_SNAPCHAN_NUM            3       //最大关联抓图通道数
#define MAX_PIC_SWITCH_STORAGE_SERVER   64      //云存储服务器存储的最大图片类型数
#define MAX_INFO_SWITCH_STORAGE_SERVER  64      //云存储服务器存储的最大附加信息类型数
#define RTMP_URL_LEN                    128     //RTMP URL 长度
#define MAX_ID_LEN_128                  128     //发布文件ID长度
#define MAX_DEBUGCMD_LEN                1024    //设备调试命令最大长度
#define MAX_DEBUGINFO_LEN               1400    //设备调试信息最大长度
#define MAX_VEHICLE_ID_LEN              32      //最大车辆标识长度

//智能控制信息
#define MAX_VCA_CHAN  16//最大智能通道数
typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;        //是否开启智能
    BYTE   byVCAType;        //智能能力类型，VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //码流中是否带智能信息
    BYTE   byMode;            //模式，ATM能力时参照VCA_CHAN_MODE_TYPE ,TFS能力时参照TFS_CHAN_MODE_TYPE
    BYTE   byControlType;   //控制类型，按位表示，0-否，1-是
    // byControlType &1 是否启用抓拍功能
    BYTE   byPicWithVCA ;// 报警抓图叠加目标信息(目标框)：0-不叠加（默认），1-叠加；
    BYTE   byRes[2];         //保留，设置为0 
}NET_VCA_CTRLINFO, * LPNET_VCA_CTRLINFO;

//智能控制信息结构
typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN];     //控制信息,数组0对应设备的起始通道
    BYTE byRes[16];
}NET_VCA_CTRLCFG, * LPNET_VCA_CTRLCFG;

//智能设备能力集
typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;              //结构长度
    BYTE byVCAChanNum;         //智能通道个数
    BYTE byPlateChanNum;       //车牌通道个数
    BYTE byBBaseChanNum;       //行为基本版个数
    BYTE byBAdvanceChanNum;    //行为高级版个数
    BYTE byBFullChanNum;       //行为完整版个数
    BYTE byATMChanNum;           //智能ATM个数
    BYTE byPDCChanNum;         //人数统计通道个数
    BYTE byITSChanNum;         //交通事件通道个数
    BYTE byBPrisonChanNum;     //行为监狱版(监舍)通道个数
    BYTE byFSnapChanNum;       //人脸抓拍通道个数
    BYTE byFSnapRecogChanNum;  //人脸抓拍和识别通道个数
    BYTE byFRetrievalChanNum;  //人脸后检索个数
    BYTE bySupport;            //能力，位与结果为0表示不支持，1表示支持
    //bySupport & 0x1，表示是否支持智能跟踪 2012-3-22
    //bySupport & 0x2，表示是否支持128路取流扩展2012-12-27
    BYTE byFRecogChanNum;      //人脸识别通道个数
    BYTE byBPPerimeterChanNum; //行为监狱版(周界)通道个数
    BYTE byTPSChanNum;         //交通诱导通道个数
    BYTE byTFSChanNum;         //道路违章取证通道个数
    BYTE byFSnapBFullChanNum;  //人脸抓拍和行为分析通道个数
    BYTE byHeatMapChanNum;     //热度图通道个数
    BYTE bySmartVehicleNum;    //SMART事件+车辆检测通道个数
    BYTE bySmartHVTNum;       //SMART事件+混行检测通道个数
    BYTE bySmartNum;          //SMART事件个数
    BYTE byVehicleNum;        //车辆检测通道个数
    BYTE bySmartRoadDetectionNum ; // SMART事件+道路监控通道个数
    BYTE bySmartFaceDetectionNum ; // SMART事件+人脸侦测通道个数
    BYTE bySmartHeatMapNum ; // SMART事件+热度图通道个数
    BYTE byRes[14];
}NET_VCA_DEV_ABILITY, *LPNET_VCA_DEV_ABILITY;


//行为分析能力类型
typedef enum _VCA_ABILITY_TYPE_
{
    TRAVERSE_PLANE_ABILITY      = 0x01,       //穿越警戒面
        ENTER_AREA_ABILITY          = 0x02,       //进入区域
        EXIT_AREA_ABILITY           = 0x04,       //离开区域
        INTRUSION_ABILITY           = 0x08,       //入侵
        LOITER_ABILITY              = 0x10,       //徘徊
        LEFT_TAKE_ABILITY           = 0x20,       //物品遗留拿取
        PARKING_ABILITY             = 0x40,       //停车
        RUN_ABILITY                 = 0x80,       //快速移动
        HIGH_DENSITY_ABILITY        = 0x100,      //人员聚集
        LF_TRACK_ABILITY            = 0x200,      //球机跟踪
        VIOLENT_MOTION_ABILITY        = 0x400,      //剧烈运动检测
        REACH_HIGHT_ABILITY            = 0x800,      //攀高检测
        GET_UP_ABILITY                = 0x1000,     //起身检测
        LEFT_ABILITY                = 0x2000,     //物品遗留
        TAKE_ABILITY                = 0x4000,     //物品拿取
        LEAVE_POSITION              = 0x8000,     //离岗
        TRAIL_ABILITY               = 0x10000,    //尾随 
        KEY_PERSON_GET_UP_ABILITY   = 0x20000,    //重点人员起身检测
        STANDUP_ABILITY             = 0x40000,   //起立
        FALL_DOWN_ABILITY           = 0x80000,    //倒地
        AUDIO_ABNORMAL_ABILITY      = 0x100000,   //声强突变
        ADV_REACH_HEIGHT_ABILITY    = 0x200000,   //折线攀高
        TOILET_TARRY_ABILITY        = 0x400000,   //如厕超时
        YARD_TARRY_ABILITY          = 0x800000,   //放风场滞留
        ADV_TRAVERSE_PLANE_ABILITY  = 0x1000000,  //折线警戒面
        LECTURE_ABILITY                = 0x2000000,  //授课
        ANSWER_ABILITY                = 0x4000000,  //回答问题
        HUMAN_ENTER_ABILITY         = 0x10000000, //人靠近ATM ,只在ATM_PANEL模式下支持
        OVER_TIME_ABILITY           = 0x20000000, //操作超时,只在ATM_PANEL模式下支持
        STICK_UP_ABILITY            = 0x40000000, //贴纸条
        INSTALL_SCANNER_ABILITY     = 0x80000000  //安装读卡器
}VCA_ABILITY_TYPE;

typedef enum _VCA_ABILITY_TYPE_EX_
{ 
    PEOPLENUM_CHANGE_ABILITY = 0x00000002, //人数变化检测
    SPACING_CHANGE_ABILITY = 0x00000004,    //间距变化检测
    EVENT_COMBINED_ABILITY = 0x00000008,    //组合事件规则
    EVENT_SIT_QUIETLY =        0x00000010,    //静坐
    EVENT_HIGH_DENSITY_STATUS_ABILITY = 0x00000020    //人员聚集状态
}VCA_ABILITY_TYPE_EX;

//智能通道类型
typedef enum _VCA_CHAN_ABILITY_TYPE_
{
    VCA_BEHAVIOR_BASE     =  1,          //行为分析基本版
    VCA_BEHAVIOR_ADVANCE  =  2,          //行为分析高级版
    VCA_BEHAVIOR_FULL     =  3,          //行为分析完整版
    VCA_PLATE               =  4,          //车牌能力
    VCA_ATM               =  5,          //ATM能力
    VCA_PDC               =  6,          //人流量统计
    VCA_ITS               =  7,          //智能 交通事件
    VCA_BEHAVIOR_PRISON   =  8,          //行为分析监狱版(监舍) 
    VCA_FACE_SNAP         =  9,          //人脸抓拍能力
    VCA_FACE_SNAPRECOG    = 10,          //人脸抓拍和识别能力
    VCA_FACE_RETRIEVAL    = 11,          //人脸后检索能力
    VCA_FACE_RECOG        = 12,          //人脸识别能力
    VCA_BEHAVIOR_PRISON_PERIMETER =  13, // 行为分析监狱版 (周界)
    VCA_TPS               = 14,          //交通诱导
    VCA_TFS               = 15,          //道路违章取证
    VCA_BEHAVIOR_FACESNAP = 16,          //人脸抓拍和行为分析能力
    VCA_HEATMAP           =  17,         //热度图
    VCA_SMART_VEHICLE_DETECTION  =  18,  // SMART事件+车辆检测
    VCA_SMART_HVT_DETECTION      =  19,  // SMART事件+混行检测
    VCA_SMART_EVENT          =  20,      // SMART事件
    VCA_VEHICLE_DETECTION    =  21,      // 车辆检测
    VCA_SMART_ROAD_DETECTION =  22,      // SMART事件+道路监控
    VCA_SMART_FACE_DETECTION =  23,      // SMART事件+人脸侦测
    VCA_SMART_HEATMAP        =  24       // SMART事件+热度图
}VCA_CHAN_ABILITY_TYPE;

//智能ATM模式类型(ATM能力特有)
typedef enum _VCA_CHAN_MODE_TYPE_
{
    VCA_ATM_PANEL     =  0,  //ATM面板
        VCA_ATM_SURROUND  =  1,  //ATM环境
        VCA_ATM_FACE      =  2,     //ATM人脸
        VCA_ATM_SAFETYCABIN = 3  //ATM防护舱
}VCA_CHAN_MODE_TYPE;

//交通取证TFS通道模式(TFS能力特有)
typedef enum _TFS_CHAN_MODE_TYPE_
{
    TFS_CITYROAD    =  0,  //TFS 城市道路
        TFS_FREEWAY     =  1   //TFS 高速道路
}TFS_CHAN_MODE_TYPE;

//行为分析场景模式
typedef enum _BEHAVIOR_SCENE_MODE_TYPE_
{
    BEHAVIOR_SCENE_DEFAULT = 0, //系统默认
        BEHAVIOR_SCENE_WALL = 1,    //围墙
        BEHAVIOR_SCENE_INDOOR = 2   //室内
}BEHAVIOR_SCENE_MODE_TYPE;

//监舍模式
typedef enum _BEHAVIOR_PRISON_MODE_TYPE_
{
    BEHAVIOR_PRISON                 = 0, //监所
        BEHAVIOR_HEARING                  = 1, //审讯室
        BEHAVIOR_RECFIELD                 = 2  //放风场
}BEHAVIOR_PRISON_MODE_TYPE,LPBEHAVIOR_PRISON_MODE_TYPE;


//通道能力输入参数
typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;        //VCA_CHAN_ABILITY_TYPE枚举值
    BYTE byMode;        //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE,TFS能力时参照TFS_CHAN_MODE_TYPE,当VCA_TYPE 为交通事件时参照TRAFFIC_SCENE_MODE
    BYTE byRes[2];         //保留，设置为0 
}NET_VCA_CHAN_IN_PARAM, *LPNET_VCA_CHAN_IN_PARAM;


//行为能力集结构
typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;         //结构长度
    DWORD dwAbilityType; //支持的能力类型，按位表示，见VCA_ABILITY_TYPE定义
    BYTE  byMaxRuleNum;     //最大规则数
    BYTE  byMaxTargetNum; //最大目标数
    BYTE  bySupport;        // 支持的功能类型   按位表示  
    // bySupport & 0x01 支持标定功能
    BYTE  byRes[5];         //保留，设置为0 
    DWORD dwAbilityTypeEx;  //支持的能力类型，按位表示，见VCA_ABILITY_TYPE_EX定义
}NET_VCA_BEHAVIOR_ABILITY, *LPNET_VCA_BEHAVIOR_ABILITY;

//场景变更数据更新参数
typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD    dwSize;
    BYTE    byIDCount;    //实际流ID数
    BYTE    byRes1[3];
    BYTE    byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// 交通能力集结构
typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD     dwSize;             // 结构体大小
    DWORD     dwAbilityType;      // 支持的能力列表  参照ITS_ABILITY_TYPE
    BYTE     byMaxRuleNum;         //最大规则数
    BYTE     byMaxTargetNum;     //最大目标数
       BYTE    byRes[10];            // 保留
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;

/***********************************end*******************************************/

/************************************智能参数结构*********************************/
//智能共用结构
//坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位

//区域框结构
typedef struct tagNET_VCA_RECT
{
    float fX;               //边界框左上角点的X轴坐标, 0.001~1
    float fY;               //边界框左上角点的Y轴坐标, 0.001~1
    float fWidth;           //边界框的宽度, 0.001~1
    float fHeight;          //边界框的高度, 0.001~1
}NET_VCA_RECT, *LPNET_VCA_RECT;

//行为分析事件类型
typedef enum _VCA_EVENT_TYPE_
{
    VCA_TRAVERSE_PLANE     = 0x1,        //穿越警戒面
        VCA_ENTER_AREA         = 0x2,        //目标进入区域,支持区域规则
        VCA_EXIT_AREA           = 0x4,        //目标离开区域,支持区域规则
        VCA_INTRUSION          = 0x8,        //周界入侵,支持区域规则
        VCA_LOITER             = 0x10,       //徘徊,支持区域规则
        VCA_LEFT_TAKE          = 0x20,       //物品遗留拿取,支持区域规则
        VCA_PARKING               = 0x40,       //停车,支持区域规则
        VCA_RUN                   = 0x80,       //快速移动,支持区域规则
        VCA_HIGH_DENSITY       = 0x100,      //区域内人员聚集,支持区域规则
        VCA_VIOLENT_MOTION     = 0x200,         //剧烈运动检测
        VCA_REACH_HIGHT        = 0x400,         //攀高检测
        VCA_GET_UP             = 0x800,         //起身检测
        VCA_LEFT               = 0x1000,     //物品遗留
        VCA_TAKE               = 0x2000,     //物品拿取
        VCA_LEAVE_POSITION     = 0x4000,     //离岗
        VCA_TRAIL              = 0x8000,     //尾随
        VCA_KEY_PERSON_GET_UP  = 0x10000,    //重点人员起身检测
        VCA_STANDUP            = 0x20000,    //起立
        VCA_FALL_DOWN          = 0x80000,    //倒地检测
        VCA_AUDIO_ABNORMAL     = 0x100000,   //声强突变检测
        VCA_ADV_REACH_HEIGHT   = 0x200000,   //折线攀高
        VCA_TOILET_TARRY       = 0x400000,   //如厕超时
        VCA_YARD_TARRY         = 0x800000,   //放风场滞留
        VCA_ADV_TRAVERSE_PLANE = 0x1000000,  //折线警戒面
        VCA_LECTURE            = 0x2000000,  //授课
        VCA_ANSWER             = 0x4000000,  //回答问题
        VCA_HUMAN_ENTER        = 0x10000000, //人靠近ATM           只在ATM_PANEL模式下支持
        VCA_OVER_TIME          = 0x20000000, //操作超时            只在ATM_PANEL模式下支持
        VCA_STICK_UP           = 0x40000000, //贴纸条,支持区域规则
        VCA_INSTALL_SCANNER    = 0x80000000  //安装读卡器,支持区域规则
}VCA_EVENT_TYPE;

//行为分析事件类型扩展
typedef enum _VCA_RULE_EVENT_TYPE_EX_
{
    ENUM_VCA_EVENT_TRAVERSE_PLANE     = 1,   //穿越警戒面
        ENUM_VCA_EVENT_ENTER_AREA         = 2,   //目标进入区域,支持区域规则
        ENUM_VCA_EVENT_EXIT_AREA          = 3,   //目标离开区域,支持区域规则
        ENUM_VCA_EVENT_INTRUSION          = 4,   //周界入侵,支持区域规则
        ENUM_VCA_EVENT_LOITER             = 5,   //徘徊,支持区域规则
        ENUM_VCA_EVENT_LEFT_TAKE          = 6,   //物品遗留拿取,支持区域规则
        ENUM_VCA_EVENT_PARKING            = 7,   //停车,支持区域规则
        ENUM_VCA_EVENT_RUN                = 8,   //快速移动,支持区域规则
        ENUM_VCA_EVENT_HIGH_DENSITY       = 9,   //区域内人员聚集,支持区域规则
        ENUM_VCA_EVENT_VIOLENT_MOTION     = 10,  //剧烈运动检测
        ENUM_VCA_EVENT_REACH_HIGHT        = 11,  //攀高检测
        ENUM_VCA_EVENT_GET_UP             = 12,  //起身检测
        ENUM_VCA_EVENT_LEFT               = 13,  //物品遗留
        ENUM_VCA_EVENT_TAKE               = 14,  //物品拿取
        ENUM_VCA_EVENT_LEAVE_POSITION     = 15,  //离岗
        ENUM_VCA_EVENT_TRAIL              = 16,  //尾随
        ENUM_VCA_EVENT_KEY_PERSON_GET_UP  = 17,  //重点人员起身检测
        ENUM_VCA_EVENT_STANDUP            = 18,  //起立
        ENUM_VCA_EVENT_FALL_DOWN          = 20,  //倒地检测
        ENUM_VCA_EVENT_AUDIO_ABNORMAL     = 21,  //声强突变检测
        ENUM_VCA_EVENT_ADV_REACH_HEIGHT   = 22,  //折线攀高
        ENUM_VCA_EVENT_TOILET_TARRY       = 23,  //如厕超时
        ENUM_VCA_EVENT_YARD_TARRY         = 24,  //放风场滞留
        ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //折线警戒面
        ENUM_VCA_EVENT_LECTURE            = 26,  //授课（文教）
        ENUM_VCA_EVENT_ANSWER             = 27,  //回答问题（文教）
        ENUM_VCA_EVENT_HUMAN_ENTER        = 29,  //人靠近ATM,只在ATM_PANEL模式下支持   
        ENUM_VCA_EVENT_OVER_TIME          = 30,  //操作超时,只在ATM_PANEL模式下支持
        ENUM_VCA_EVENT_STICK_UP           = 31,  //贴纸条,支持区域规则
        ENUM_VCA_EVENT_INSTALL_SCANNER    = 32,  //安装读卡器,支持区域规则
        ENUM_VCA_EVENT_PEOPLENUM_CHANGE   = 35,  //人数变化事件
        ENUM_VCA_EVENT_SPACING_CHANGE     = 36,  //间距变化事件
        ENUM_VCA_EVENT_COMBINED_RULE      = 37,   //组合规则事件
        ENUM_VCA_EVENT_SIT_QUIETLY        = 38,   //一动不动（静坐）    则事件
        ENUM_VCA_EVENT_HIGH_DENSITY_STATUS= 39   //区域内人员聚集状态
} VCA_RULE_EVENT_TYPE_EX;

//警戒面穿越方向类型
typedef enum _VCA_CROSS_DIRECTION_
{
    VCA_BOTH_DIRECTION,  // 双向 
        VCA_LEFT_GO_RIGHT,   // 由左至右 
        VCA_RIGHT_GO_LEFT    // 由右至左 
}VCA_CROSS_DIRECTION;

//线结构
typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;    //起点 
    NET_VCA_POINT struEnd;      //终点
}NET_VCA_LINE, *LPNET_VCA_LINE;

//多边型结构体
typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                  //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域 
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM]; //多边形边界点,最多十个 
}NET_VCA_POLYGON, *LPNET_VCA_POLYGON;

//警戒面参数
typedef struct tagNET_VCA_TRAVERSE_PLANE
{    
    NET_VCA_LINE struPlaneBottom;          //警戒面底边
    VCA_CROSS_DIRECTION dwCrossDirection;  //穿越方向: 0-双向，1-从左到右，2-从右到左
    BYTE bySensitivity;                    //灵敏度参数，范围[1,5]
    BYTE byPlaneHeight;                    //警戒面高度
    BYTE byDetectionTarget;    //0-所有目标，1-人，2-车
    BYTE byRes2[37];                       //保留留
}NET_VCA_TRAVERSE_PLANE, *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//区域范围
    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    DWORD   dwDuration;         //持续时间  单位s 范围1-3600
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

//进入/离开区域参数
typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1,5]
    BYTE byDetectionTarget;    //0-所有目标，1-人，2-车
    BYTE byRes[6];
}NET_VCA_AREA, *LPNET_VCA_AREA;

//根据报警延迟时间来标识报警中带图片，报警间隔和IO报警一致，1秒发送一个。
//入侵参数
typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration;            //行为事件触发时间阈值: 1-120秒，建议5秒，判断是有效报警的时间  在ATM系统中触发文件阈值为 1-1000秒
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byRate;               //占比：区域内所有未报警目标尺寸目标占区域面积的比重，归一化为－；
    BYTE byDetectionTarget;    //0-所有目标，1-人，2-车
    BYTE byRes[3];             //保留
}NET_VCA_INTRUSION, *LPNET_VCA_INTRUSION;

//徘徊参数
typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：1-120秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_LOITER, *LPNET_VCA_LOITER;

//物品遗留/物品拿取参数
typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：1-120秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT, *LPNET_VCA_TAKE_LEFT;

//停车参数
typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;    //区域范围
    WORD wDuration;                //触发时间阈值：1-100秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_PARKING, *LPNET_VCA_PARKING;

//快速移动参数
typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion;    //区域范围
    float  fRunDistance;        //人快速移动最大距离, 范围: [0.1, 1.00] 像素模式 实际模式(1,20)m/s
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byMode;     // 0 像素模式  1 实际模式
    BYTE byDetectionTarget;    //0-所有目标，1-人，2-车
    BYTE byRes;
}NET_VCA_RUN, *LPNET_VCA_RUN;

//人员聚集参数
typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;        //区域范围
    float           fDensity;       //聚集比率, 范围: [0.1, 1.0]
    BYTE            bySensitivity;    //灵敏度参数，范围[1,5]
    BYTE            byRes;          // 保留字节
    WORD            wDuration;      // 触发人员聚集参数报警阈值 20-360s
}NET_VCA_HIGH_DENSITY, *LPNET_VCA_HIGH_DENSITY; 

//剧烈运动参数
typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wDuration;           //触发剧烈运动报警阈值：1-50秒
    BYTE  bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE  byMode;              //0-纯视频模式，1-音视频联合模式，2-纯音频模式
    BYTE  byRes[4];            //保留
}NET_VCA_VIOLENT_MOTION, *LPNET_VCA_VIOLENT_MOTION; 

// 攀高参数
typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;   //攀高警戒面
    WORD wDuration; //触发攀高报警阈值：1-120秒
    BYTE    byRes[6];           // 保留字节
}NET_VCA_REACH_HIGHT, *LPNET_VCA_REACH_HIGHT;

// 起床参数
typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion; //区域范围
    WORD    wDuration;            //触发起床报警阈值1-100 秒
    BYTE    byMode;             //起身检测模式,0-大床通铺模式,1-高低铺模式,2-大床通铺坐立起身模式
    BYTE    bySensitivity;      //灵敏度参数，范围[1,10]
    BYTE    byRes[4];            //保留字节
}NET_VCA_GET_UP, * LPNET_VCA_GET_UP;

// 物品遗留
typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion; // 区域范围
    WORD       wDuration;       // 触发物品遗留报警阈值 10-100秒
    BYTE       bySensitivity;   // 灵敏度参数，范围[1,5] 
    BYTE       byRes[5];        // 保留字节
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

// 物品拿取
typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // 区域范围
    WORD            wDuration;      // 触发物品拿取报警阈值10-100秒
    BYTE            bySensitivity;  // 灵敏度参数，范围[1,5] 
    BYTE            byRes[5];       // 保留字节
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion;    // 区域范围
    WORD               wDuration;  // 操作报警时间阈值 4s-60000s
    BYTE   byRes[6];   // 保留字节
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];            //保留字节
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

//贴纸条参数
typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：4-60秒，建议10秒
    BYTE  bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_STICK_UP, *LPNET_VCA_STICK_UP; 

//读卡器参数
typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //读卡持续时间：4-60秒
    BYTE bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_SCANNER, *LPNET_VCA_SCANNER; 

//离岗事件
typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //区域范围
    WORD   wLeaveDelay;  //无人报警时间，单位：s，取值1-1800
    WORD   wStaticDelay; //睡觉报警时间，单位：s，取值1-1800
    BYTE   byMode;       //模式，0-离岗事件，1-睡岗事件，2-离岗睡岗事件
    BYTE   byPersonType; //值岗人数类型，0-单人值岗，1-双人值岗
    BYTE   byRes[2];     //保留
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

//尾随参数
typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wRes;      /* 保留 */
    BYTE  bySensitivity;       /* 灵敏度参数，范围[1,5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

//倒地参数
typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wDuration;      /* 触发事件阈值 1-60s*/
    BYTE  bySensitivity;       /* 灵敏度参数，范围[1,5] */
    BYTE  byHeightThreshold; //高度阈值，范围[0,250]，默认90，单位：厘米
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

//起立
typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //区域范围
    BYTE  bySensitivity;     //灵敏度参数，范围[1,100]
    BYTE  byHeightThreshold; //高度阈值，范围[0,250]，默认130，单位：厘米
    WORD  wDuration;         //触发事件阈值[1,3600]，默认2，单位：秒
    BYTE  byRes[4];          //保留
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;


//人数变化
typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //区域范围
    BYTE  bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE  byPeopleNumThreshold; //人数阈值，范围[0,5]，默认1 
    BYTE  byDetectMode; //检测方式，与人数阈值相比较。1-大于，2-小于，3-等于，4-不等于
    BYTE  byNoneStateEffective; //无人状态是否有效，0-无效，1-有效
    WORD  wDuration;  //触发时间阈值[1,3600]，默认2，单位：秒
    BYTE  byRes[2];   //保留
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

//间距变化
typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //区域范围
    float fSpacingThreshold; //间距阈值，范围[0,10.0]，默认1.0，单位：米
    BYTE  bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE  byDetectMode; //检测方式，与间距阈值相比较。1-大于，2-小于
    WORD  wDuration;  //触发时间阈值[1,3600]，默认2，单位：秒
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;


//声强突变参数
typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //声音强度
    BYTE bySensitivity;  //灵敏度参数，范围[1,100] 
    BYTE byAudioMode;    //声音检测模式，0-灵敏度检测，1-分贝阈值检测，2-灵敏度与分贝阈值检测 
    BYTE byEnable;       //使能，是否开启(声强突变，陡升)
    BYTE byThreshold;    //声音阈值[1,100]
    BYTE byRes[54];      //保留   
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

//声强陡降 2014-03-21
typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* 灵敏度参数，范围[1,100] */
    BYTE  byEnable;        //使能，是否开启(声强突变，陡降)
    BYTE  byRes[6];    
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;


typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;//使能，是否开启
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;  
    NET_DVR_SCHEDTIME            struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //布防时间
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;     //异常处理方式
    DWORD                       dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD                       dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //声强陡降
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDelay;        //如厕超时时间[1,3600]，单位：秒
    BYTE byRes[6];    
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDelay;        //放风场滞留时间[1,120]，单位：秒
    BYTE byRes[6];    
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //攀高折线
    DWORD   dwCrossDirection;   //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    BYTE    byRes[4];            // 保留字节
}NET_VCA_ADV_REACH_HEIGHT, * LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //警戒面折线
    DWORD   dwCrossDirection;   //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    BYTE    bySensitivity;      //灵敏度参数，范围[1,5] 
    BYTE    byRes[3];            //保留字节
} NET_VCA_ADV_TRAVERSE_PLANE,*LPNET_VCA_ADV_TRAVERSE_PLANE;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //行为事件触发时间阈值: 1-10秒，建议1秒，判断是有效报警的时间
    BYTE bySensitivity; //灵敏度参数，范围[1-100]
    BYTE byAlarmState;//只读字段界面不显示；0-保留,1-报警开始,2-报警结束 
    BYTE byTrackingMode ;//跟踪模式，0-自动(默认) , 1-水平, 2-垂直
    BYTE byZoomMode;//变倍模式, 0-固定(默认), 1-自动
    BYTE byZoomOver;//0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    BYTE byRes;
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;//灵敏度参数，范围[1-100]
    BYTE byAlarmState;//只读字段界面不显示；0-保留,1-报警开始,2-报警结束
    BYTE byZoomOver;//0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    BYTE byRes[5];             //保留
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

//关联规则结构体
typedef struct tagNET_VCA_RELATE_RULE_PARAM
{   
    BYTE  byRuleID;  //规则序号 0-表示无
    BYTE  byRes;  //保留
    WORD  wEventType;        //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX留
}NET_VCA_RELATE_RULE_PARAM,*LPNET_VCA_RELATE_RULE_PARAM;

typedef struct tagNET_VCA_COMBINED_RULE_
{
    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    BYTE    byRuleSequence; 
    BYTE    byRes[7];
    DWORD  dwMinInterval;    //最小时间间隔，单位：秒
    DWORD  dwMaxInterval;  //最大时间间隔，单位：秒
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//规则1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//规则2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;

//人员聚集状态
typedef struct tagNET_VCA_HIGH_DENSITY_STATUS
{
    NET_VCA_POLYGON struRegion;        //区域范围
    float           fDensity;       //聚集比率, 范围: [0.1, 1.0]
    BYTE            bySensitivity;    //灵敏度参数，范围[1,5]
    BYTE            byRes[3];          // 保留字节
}NET_VCA_HIGH_DENSITY_STATUS, *LPNET_VCA_HIGH_DENSITY_STATUS; 


//警戒事件参数
typedef union tagNET_VCA_EVENT_UNION
{
    DWORD                      uLen[23];            //参数
    NET_VCA_TRAVERSE_PLANE     struTraversePlane;   //穿越警戒面参数 
    NET_VCA_AREA               struArea;            //进入/离开区域参数
    NET_VCA_INTRUSION          struIntrusion;       //入侵参数
    NET_VCA_LOITER             struLoiter;          //徘徊参数
    NET_VCA_TAKE_LEFT          struTakeTeft;        //物品遗留/物品拿取参数
    NET_VCA_PARKING            struParking;            //停车参数
    NET_VCA_RUN                struRun;                //快速移动参数
    NET_VCA_HIGH_DENSITY       struHighDensity;        //人员聚集参数  
    NET_VCA_VIOLENT_MOTION     struViolentMotion;    //剧烈运动
    NET_VCA_REACH_HIGHT           struReachHight;      //攀高
    NET_VCA_GET_UP               struGetUp;           //起床
    NET_VCA_LEFT               struLeft;            //物品遗留
    NET_VCA_TAKE               struTake;            // 物品拿取
    NET_VCA_HUMAN_ENTER        struHumanEnter;      //人员进入
    NET_VCA_OVER_TIME          struOvertime;        //操作超时
    NET_VCA_STICK_UP            struStickUp;            //贴纸条
    NET_VCA_SCANNER            struScanner;            //读卡器参数     
    NET_VCA_LEAVE_POSITION     struLeavePos;        //离岗参数
    NET_VCA_TRAIL              struTrail;           //尾随参数
    NET_VCA_FALL_DOWN          struFallDown;        //倒地参数
    NET_VCA_AUDIO_ABNORMAL     struAudioAbnormal;   //声强突变
    NET_VCA_ADV_REACH_HEIGHT   struReachHeight;     //折线攀高参数
    NET_VCA_TOILET_TARRY       struToiletTarry;     //如厕超时参数
    NET_VCA_YARD_TARRY         struYardTarry;       //放风场滞留参数
    NET_VCA_ADV_TRAVERSE_PLANE struAdvTraversePlane;//折线警戒面参数
    NET_VCA_LECTURE            struLecture;            //授课事件
    NET_VCA_ANSWER             struAnswer;            //回答问题事件
    NET_VCA_STANDUP               struStandUp;         //起立参数
    NET_VCA_PEOPLENUM_CHANGE   struPeopleNumChange; //人数变化参数
    NET_VCA_SPACING_CHANGE     struSpacingChange;   //间距变化参数
    NET_VCA_COMBINED_RULE      struCombinedRule;    //组合规则参数
    NET_VCA_SIT_QUIETLY        struSitQuietly;      //静坐参数
    NET_VCA_HIGH_DENSITY_STATUS       struHighDensityStatus;        //人员聚集状态 
}NET_VCA_EVENT_UNION, *LPNET_VCA_EVENT_UNION;

// 尺寸过滤器类型
typedef enum _VCA_SIZE_FILTER_MODE_
{
    IMAGE_PIX_MODE, //根据像素大小设置
        REAL_WORLD_MODE, //根据实际大小设置
        DEFAULT_MODE     // 默认模式
}SIZE_FILTER_MODE;
//尺寸过滤器
typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;            //是否激活尺寸过滤器 0-否 非0-是
    BYTE    byMode;         //过滤器模式SIZE_FILTER_MODE
    BYTE    byRes[2];        //保留，置0
    NET_VCA_RECT struMiniRect;    //最小目标框,全0表示不设置
    NET_VCA_RECT struMaxRect;      //最大目标框,全0表示不设置
}NET_VCA_SIZE_FILTER, *LPNET_VCA_SIZE_FILTER;

//警戒规则结构
typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;                    //是否激活规则,0-否,非0-是
    BYTE   byRes[7];                     //保留，设置为0字段
    BYTE   byRuleName[NAME_LEN];        //规则名称
    VCA_EVENT_TYPE dwEventType;            //行为分析事件类型
    NET_VCA_EVENT_UNION uEventParam;    //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
}NET_VCA_ONE_RULE, *LPNET_VCA_ONE_RULE;

//行为分析配置结构体
typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;            //结构长度
    BYTE   byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE   byUpLastAlarm; //2011-04-06 是否先上传最近一次的报警
    BYTE   byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE   byRes;
    NET_DVR_JPEGPARA  struPictureParam;         //图片规格结构
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];  //规则数组
}NET_VCA_RULECFG, *LPNET_VCA_RULECFG;

//前端设备地址信息，智能分析仪表示的是前端设备的地址信息，其他设备表示本机的地址
/*
当接入设备模拟通道(IPC/DVR/DVS/IVMS)报警的时候，下面字段填写设备的IP地址，端口，byChannel和byIvmsChannel 均为当前的模拟通道号
eg:
struDevIP =  模拟通道对应设备的IP地址
wPort  =  模拟通道对应设备的端口
byChannel =  报警对应模拟通道的通道号
byIvmsChannel = 报警对应模拟通道的通道号

  当接入设备数字通道(DVR/DVS/IVMS)报警的时候，下面字段填写数字通道接入设备的IP地址，端口，byChannel为数字通道接入设备的通道号，byIvmsChannel为数字通道号
  eg:
  struDevIP =  数字通道接入设备的IP地址
  wPort  =  数字通道接入设备的端口
  byChannel =  数字通道接入设备的通道号
  byIvmsChannel = 数字通道号    
*/
typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP; //前端设备地址， 
    WORD wPort;             //前端设备端口号， 
    BYTE byChannel;          //前端设备通道， 
    BYTE byIvmsChannel;        // Ivms 通道 
}NET_VCA_DEV_INFO, *LPNET_VCA_DEV_INFO;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize; //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD        dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    BYTE     byTargetType;//检测目标类型 0-无效目标，1-教师    
    BYTE     byLeftDirection;//检测目标离开方向类型0-保留,1-上,2-下,3-左,4-右
    BYTE     byRes[126];
}NET_DVR_TARGET_LEFT_REGION_ALARM,*LPNET_DVR_TARGET_LEFT_REGION_ALARM;

//尺寸过滤策略
typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //尺寸过滤策略 0 - 不启用 1-高度和宽度过滤,2-面积过滤
    BYTE    byRes[11];       //保留
}NET_VCA_FILTER_STRATEGY,*LPNET_VCA_FILTER_STRATEGY;

//规则触发参数
typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //规则的触发方式，0- 不启用，1- 轨迹点 2- 目标面积 
    BYTE   byTriggerPoint;  //触发点，触发方式为轨迹点时有效 0- 中,1-上,2-下
    BYTE   byRes1[2];       //保留
    float  fTriggerArea;    //触发目标面积百分比 [0,100]，触发方式为目标面积时有效
    BYTE   byRes2[4];       //保留
}NET_VCA_RULE_TRIGGER_PARAM,*LPNET_VCA_RULE_TRIGGER_PARAM;

//警戒规则结构
typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //是否激活规则,0-否,非0-是
    BYTE   byRes1[4];  //保留，设置为0字段
    BYTE   byEventTypeFlag;  //标志行为事件类型字段的有效性，0-dwEventType有效，1-wEventTypeEx有效
    //注：此字段byEventTypeFlag只在设置参数时有效，从设备获取参数时，可直接从wEventTypeEx获取事件类型，无需判断此字段的值
    WORD   wEventTypeEx; //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //规则名称
    VCA_EVENT_TYPE dwEventType;    //行为事件类型，保留是为了兼容，后续建议使用wEventTypeEx获取事件类型
    NET_VCA_EVENT_UNION uEventParam; //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //处理方式 
    BYTE   byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    WORD   wAlarmDelay; //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2]; //保留
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //尺寸过滤策略
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //规则触发参数
    BYTE   byRes[32];
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

//行为分析配置结构体
typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;            //结构长度
    BYTE    byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byUpLastAlarm; //2011-04-06 是否先上传最近一次的报警
    BYTE    byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE    byRes1;
    NET_DVR_JPEGPARA struPictureParam;         //图片规格结构
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //规则数组
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE   byRes[26];
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

//警戒规则结构
typedef struct NET_VCA_ONE_RULE_V42_  
{
    BYTE           byActive;       //是否激活规则, 0-否，非0-是
    BYTE        byEventPriority;//事件优先级 0-低，1-中，2-高
    BYTE           byRes1[4];           //保留，设置为0字段
    WORD          wEventType;        //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX
    BYTE        byRuleName[NAME_LEN/*32*/];        //规则名称
    NET_VCA_EVENT_UNION  uEventParam;            //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;          //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*处理方式*/
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];    /* 报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）*/
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的关联通道号无效
    WORD          wAlarmDelay; //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE           byRes2[2];           //保留
    NET_VCA_FILTER_STRATEGY     struFilterStrategy;  //尺寸过滤策略
    NET_VCA_RULE_TRIGGER_PARAM     struTriggerParam; //规则触发参数
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;


typedef struct    tagNET_DVR_PTZ_POSITION
{
    // 是否启用场景，在设置场景行为规则的时候该字段无效，在设置球机本地配置场景位置信息时作为使能位
    BYTE byEnable;
    BYTE byRes1[3];  //保留
    BYTE byPtzPositionName[NAME_LEN]; //场景位置名称
    NET_DVR_PTZPOS struPtzPos; //ptz 坐标
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION, *LPNET_DVR_PTZ_POSITION;

//行为分析配置结构体
typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD            dwSize;             //结构图大小
    BYTE                byPicProType;            //报警时图片处理方式 0-不处理 1-上传
    BYTE            byUpLastAlarm;         //是否先上传最近一次的报警，0-否，1-是
    BYTE             byPicRecordEnable;   //是否启用图片存储, 0-不启用, 1-启用
    BYTE            byRes1;
    NET_DVR_JPEGPARA     struPicParam;         //图片规格结构
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42 /*16*/];       /* 规则数组*/
    WORD            wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE            byTrackEnable; //是否启用跟踪
    BYTE            byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //场景位置信息
    WORD            wTrackDuration; //跟踪持续时间，单位s
    BYTE            byRes[62];//保留
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;


//简化目标结构体
typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;                //目标ID ,人员聚集过高报警时为0
    NET_VCA_RECT struRect;      //目标边界框 
    BYTE      byRes[4];            //保留
}NET_VCA_TARGET_INFO, *LPNET_VCA_TARGET_INFO;

//简化的规则信息, 包含规则的基本信息
typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;                //规则ID,0-7
    BYTE   byRes;                //保留
    WORD   wEventTypeEx;            //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN];    //规则名称
    VCA_EVENT_TYPE  dwEventType;    //行为事件类型，保留是为了兼容，后续建议使wEventTypeEx获取事件类型
    NET_VCA_EVENT_UNION uEventParam;//事件参数
}NET_VCA_RULE_INFO, *LPNET_VCA_RULE_INFO;

//行为分析结果上报结构
typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;                        //结构长度
    DWORD    dwRelativeTime;                //相对时标
    DWORD    dwAbsTime;                        //绝对时标
    NET_VCA_RULE_INFO     struRuleInfo;        //事件规则信息
    NET_VCA_TARGET_INFO  struTargetInfo;    //报警目标信息
    NET_VCA_DEV_INFO       struDevInfo;        //前端设备信息
    DWORD dwPicDataLen;                        //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    BYTE       byPicType;        //  0-普通图片 1-对比图片
    BYTE       byRelAlarmPicNum; //关联通道报警图片数量
    BYTE       bySmart;//IDS设备返回0(默认值)，Smart Functiom Return 1
    BYTE       byRes;        // 保留字节
    DWORD      dwAlarmID;     //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    BYTE       byRes2[8];        //保留
    BYTE       *pImage;       //指向图片的指针
}NET_VCA_RULE_ALARM, *LPNET_VCA_RULE_ALARM;

//行为分析规则DSP信息叠加结构
typedef struct tagNET_VCA_DRAW_MODE
{ 
    DWORD  dwSize;
    BYTE    byDspAddTarget;            //编码是否叠加目标
    BYTE    byDspAddRule;            //编码是否叠加规则
    BYTE    byDspPicAddTarget;        //抓图是否叠加目标
    BYTE    byDspPicAddRule;        //抓图是否叠加规则
    BYTE    byRes[4];            
}NET_VCA_DRAW_MODE, *LPNET_VCA_DRAW_MODE;

//物体类型
typedef enum tagOBJECT_TYPE_ENUM
{    
    ENUM_OBJECT_TYPE_COAT  = 1  //上衣
}OBJECT_TYPE_ENUM;

//物体颜色条件结构体
typedef struct tagNET_DVR_OBJECT_COLOR_COND
{   
    DWORD  dwChannel;   //通道号
    DWORD  dwObjType;   //物体类型，参见OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //保留
}NET_DVR_OBJECT_COLOR_COND,*LPNET_DVR_OBJECT_COLOR_COND;

//图片参数
typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //图片类型，1-jpg
    BYTE   byRes1[3];        //保留
    DWORD  dwPicWidth;       //图片宽度
    DWORD  dwPicHeight;      //图片高度
    DWORD  dwPicDataLen;     //图片数据实际大小
    DWORD  dwPicDataBuffLen; //图片数据缓冲区大小
    BYTE*  byPicDataBuff;    //图片数据缓冲区
    BYTE   byRes2[40];       //保留
}NET_DVR_PIC,*LPNET_DVR_PIC;

//颜色联合体
typedef union tagNET_DVR_OBJECT_COLOR_UNION
{    
    NET_DVR_COLOR  struColor;   //颜色值
    NET_DVR_PIC    struPicture; //图片
    BYTE           byRes[64];   //保留
}NET_DVR_OBJECT_COLOR_UNION,*LPNET_DVR_OBJECT_COLOR_UNION;

//物体颜色参数结构体
typedef struct tagNET_DVR_OBJECT_COLOR
{    
    DWORD  dwSize;       //结构体大小
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byColorMode;  //取色方式，1-颜色值，2-图片
    BYTE   byRes1[2];    //保留
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //物体颜色联合体，取值依赖于取色方式
    BYTE   byRes2[64];   //保留
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;

//区域类型
typedef enum tagAREA_TYPE_ENUM
{    
    ENUM_OVERLAP_REGION  = 1,//共同区域
        ENUM_BED_LOCATION  = 2   //床铺位置
}AREA_TYPE_ENUM;

//辅助区域
typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //区域类型，参见AREA_TYPE_ENUM
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byRes1[3];     //保留
    NET_VCA_POLYGON struPolygon; //区域
    BYTE   byRes2[16];   //保留
}NET_DVR_AUXAREA,*LPNET_DVR_AUXAREA;

//辅助区域列表
typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD     dwSize;    // 结构体大小
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //辅助区域
    BYTE    byRes2[64];    // 保留
}NET_DVR_AUXAREA_LIST,*LPNET_DVR_AUXAREA_LIST;

//通道工作模式
typedef enum tagCHAN_WORKMODE_ENUM
{    
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //独立模式
        ENUM_CHAN_WORKMODE_MASTER  = 2,      //主模式
        ENUM_CHAN_WORKMODE_SLAVE  = 3        //从模式
}CHAN_WORKMODE_ENUM;

//通道工作模式参数结构体
typedef struct tagNET_DVR_CHANNEL_WORKMODE
{   
    DWORD dwSize;        //结构体大小
    BYTE  byWorkMode;    //工作模式，参见CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //保留
}NET_DVR_CHANNEL_WORKMODE,*LPNET_DVR_CHANNEL_WORKMODE;

//设备通道参数结构体
typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];    //设备IP或域名
    WORD   wDVRPort;                     //端口号
    BYTE   byRes1[2];                   //保留
    BYTE   sUserName[NAME_LEN];            //主机用户名
    BYTE   sPassword[PASSWD_LEN];       //主机密码
    DWORD  dwChannel;                   //通道号
    BYTE   byRes2[32];                  //保留
}NET_DVR_CHANNEL,*LPNET_DVR_CHANNEL;

//从通道信息联合体
typedef union tagNET_DVR_SLAVE_CHANNEL_UNION
{
    BYTE            byRes[152];        //联合体大小
    DWORD           dwLocalChannel;    //本机通道
    NET_DVR_CHANNEL struRemoteChannel; //远程通道
}NET_DVR_SLAVE_CHANNEL_UNION,*LPNET_DVR_SLAVE_CHANNEL_UNION;

//从通道参数结构体
typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //从通道类型，1-本机通道，2-远程通道 
    BYTE   byRes1[3];    //保留
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //从通道联合体，取值依赖于byChanType
    BYTE   byRes2[64];   //保留
}NET_DVR_SLAVE_CHANNEL_PARAM,*LPNET_DVR_SLAVE_CHANNEL_PARAM;


//从通道参数配置结构体
typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{   
    DWORD dwSize;   //结构体大小
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//从通道参数
    BYTE  byRes[64];  //保留
}NET_DVR_SLAVE_CHANNEL_CFG,*LPNET_DVR_SLAVE_CHANNEL_CFG;

//视频质量诊断检测事件
typedef enum tagVQD_EVENT_ENUM
{    
    ENUM_VQD_EVENT_BLUR           = 1,  //图像模糊
        ENUM_VQD_EVENT_LUMA           = 2,  //亮度异常
        ENUM_VQD_EVENT_CHROMA         = 3,  //图像偏色
        ENUM_VQD_EVENT_SNOW           = 4,  //雪花干扰
        ENUM_VQD_EVENT_STREAK         = 5,  //条纹干扰
        ENUM_VQD_EVENT_FREEZE         = 6,  //画面冻结
        ENUM_VQD_EVENT_SIGNAL_LOSS    = 7,  //信号丢失
        ENUM_VQD_EVENT_PTZ            = 8,  //云台失控
        ENUM_VQD_EVENT_SCNENE_CHANGE  = 9,  //场景突变
        ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10, //视频异常
        ENUM_VQD_EVENT_VIDEO_BLOCK    = 11, //视频遮挡
}VQD_EVENT_ENUM;

//视频质量诊断事件条件结构体
typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //通道号
    DWORD dwEventType; //检测事件类型，参见VQD_EVENT_ENUM
    BYTE  byRes[64];   //保留
}NET_DVR_VQD_EVENT_COND,*LPNET_DVR_VQD_EVENT_COND;

//视频质量诊断事件参数
typedef struct tagNET_DVR_VQD_EVENT_PARAM
{ 
    BYTE   byThreshold;    //报警阈值，范围[0,100]
    BYTE   byTriggerMode;  //1-持续触发，2-单次触发
    BYTE   byUploadPic;    //0-不上传图片，1-上传图片，无论是否上传图片，事后都可以从设备获取该事件所对应最新的一张报警图片，参见接口NET_DVR_StartDownload
    BYTE   byRes1;         //保留
    DWORD  dwTimeInterval; //持续触发报警时间间隔，范围[0,3600] 单位：秒
    BYTE   byRes2[64];     //保留
}NET_DVR_VQD_EVENT_PARAM,*LPNET_DVR_VQD_EVENT_PARAM;

//视频质量诊断事件规则
typedef struct tagNET_DVR_VQD_EVENT_RULE
{   
    DWORD  dwSize;       //结构体大小 
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byRes1[3];    //保留
    NET_DVR_VQD_EVENT_PARAM struEventParam; //视频质量诊断事件参数
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//检测时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //处理方式
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //报警触发的录象通道：1表示触发该通道；0表示不触发 
    BYTE   byRes2[128];    //保留
}NET_DVR_VQD_EVENT_RULE,*LPNET_DVR_VQD_EVENT_RULE;

//基准场景参数
typedef struct tagNET_DVR_BASELINE_SCENE
{   
    DWORD dwSize;     //结构体大小
    BYTE  byEnable;   //0-不启用，1-启用
    BYTE  byRes[63];  //保留
}NET_DVR_BASELINE_SCENE,*LPNET_DVR_BASELINE_SCENE;

//基准场景操作参数结构体
typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{   
    DWORD dwSize;     //结构体大小
    DWORD dwChannel;  //通道号
    BYTE  byCommand;  //操作类型，1-此字段保留，暂不使用，2-更新基准场景
    BYTE  byRes[127];  //保留
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM,*LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//视频质量诊断报警结构体
typedef struct tagNET_DVR_VQD_ALARM
{   
    DWORD  dwSize;                //结构体大小
    DWORD  dwRelativeTime;        //相对时标
    DWORD  dwAbsTime;              //绝对时标
    NET_VCA_DEV_INFO struDevInfo; //前端设备信息 
    DWORD  dwEventType;           //事件类型，参考VQD_EVENT_ENUM
    float  fThreshold;            //报警阈值[0.000,1.000]
    DWORD  dwPicDataLen;          //图片长度，为0表示没有图片
    BYTE   *pImage;               //指向图片的指针           
    BYTE   byRes[128];            //保留
}NET_DVR_VQD_ALARM,*LPNET_DVR_VQD_ALARM;

//标定点子结构
typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;     //标定点，主摄像机（枪机）
    NET_DVR_PTZPOS struPtzPos;  //球机输入的PTZ坐标
    BYTE    byRes[8];
}NET_DVR_CB_POINT, LPNET_DVR_CB_POINT;

//标定参数配置结构
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{    
    BYTE byPointNum;            //有效标定点个数
    BYTE byRes[3];                
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //标定点组
}NET_DVR_TRACK_CALIBRATION_PARAM, *LPNET_DVR_TRACK_CALIBRATION_PARAM;

//球机配置结构
typedef struct tagNET_DVR_TRACK_CFG 
{    
    DWORD dwSize;                //结构长度    
    BYTE byEnable;                //标定使能
    BYTE byFollowChan;          // 被控制的从通道
    BYTE byDomeCalibrate;            //设置智能跟踪球机标定，1设置 0不设置 
    BYTE byRes;                    // 保留字节
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam; //标定点组
}NET_DVR_TRACK_CFG, *LPNET_DVR_TRACK_CFG ;

//跟踪模式
typedef enum _TRACK_MODE_
{
    MANUAL_CTRL = 0,  //手动跟踪
        ALARM_TRACK    //报警触发跟踪
}TRACK_MODE;

//手动控制结构
typedef struct tagNET_DVR_MANUAL_CTRL_INFO 
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO, *LPNET_DVR_MANUAL_CTRL_INFO ;

//跟踪模式结构
typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;        //结构长度
    BYTE byTrackMode;   //跟踪模式
    BYTE byRuleConfMode;   //规则配置跟踪模式0-本地配置跟踪，1-远程配置跟踪
    BYTE byRes[2];   //保留，置0
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl;//手动跟踪结构
    }uModeParam;
}NET_DVR_TRACK_MODE,*LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;        /*报警时图片处理方式 0-不处理 1-上传*/
    BYTE    byRes[3];           //保留字节
    NET_DVR_JPEGPARA struPicParam;                 /*图片规格结构*/
}NET_DVR_ALARM_JPEG, *LPNET_DVR_ALARM_JPEG;

/**********************ipc/d5.3.0********************************/
typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;//物理倍率坐标
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//主从跟踪 从摄像机ID编号[1,4]
    BYTE             byRes[63];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE                 byAddressType;   //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    WORD                wPort;            /*端口*/
    BYTE               byLoginStatus; /*从设备的登陆状态 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];//服务器地址，域名 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP地址*/        //IPv4 IPv6地址, 144字节
        } struAddrIP;
    }unionServer;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64    
    BYTE                szUserName[NAME_LEN/*32*/];        /*用户名*/
    BYTE                szPassWord[PASSWD_LEN/*16*/];        /*密码*/
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus ;//连接状态 0- 未连接，1-连接
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];//数组下标0表示从摄像机ID 1,依次类推
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{    
    float fPan;
    float fTilt;
    float fZoom;
    BYTE  byRes[8];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;//标定坐标
    BYTE      byRes[16];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE              byCalibMode;//标定模式: 0-保留,1-自动标定, 2-手动标定
    BYTE             byRes[3]; 
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];//只在手动标定模式下生效
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;        //结构长度
    BYTE byEnable;      //使能 0-false,1-true
    BYTE byMode;        //模式 0-关闭，1-手动，2-自动
    WORD  wTrackingTime;//跟踪时间：[0,60]s
    NET_VCA_POLYGON struRegion;//手动跟踪目标区域范围
    BYTE byRes[64];
}NET_DVR_TRACKING,*LPNET_DVR_TRACKING;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V50
{
    DWORD            dwSize;
    BYTE               byCalibMode;//标定模式: 0-保留,1-自动标定, 2-手动标定
    BYTE             byRes[3]; 
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/]; 
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_V50, *LPNET_DVR_SLAVECAMERA_CALIB_V50;

typedef struct tagNET_DVR_TRACK_INITPOSTION
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//主从跟踪 从摄像机ID编号[1,4]
    BYTE             byRes[127];
}NET_DVR_TRACK_INITPOSTION, *LPNET_DVR_TRACK_INITPOSTION;

typedef struct tagNET_DVR_MANUAL_TRACKRATIO
{
    DWORD            dwSize;
    BYTE             byCoefficient;//倍率系数[1,60]
    BYTE             byRes[127];
}NET_DVR_MANUAL_TRACKRATIO, *LPNET_DVR_MANUAL_TRACKRATIO;

/**********************ipc/d5.3.0********************************/

//分析仪行为分析规则结构
//警戒规则结构
typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;           /* 是否激活规则,0-否, 非0-是 */
    BYTE    byRes1[7];    //保留，设置为0字段
    BYTE   byRuleName[NAME_LEN]; //规则名称
    VCA_EVENT_TYPE dwEventType;   //行为分析事件类型
    NET_VCA_EVENT_UNION uEventParam;//行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    BYTE byRes2[68]; /*保留，设置为0*/
}NET_IVMS_ONE_RULE, *LPNET_IVMS_ONE_RULE;

// 分析仪规则结构
typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];   //规则数组
}NET_IVMS_RULECFG, *LPNET_IVMS_RULECFG;

// IVMS行为分析配置结构
typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;        //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam;                 //图片规格结构
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT];//每个时间段对应规则
} NET_IVMS_BEHAVIORCFG, *LPNET_IVMS_BEHAVIORCFG;

//智能分析仪取流计划子结构
typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME     struTime;       //时间参数
    NET_DVR_PU_STREAM_CFG struPUStream; //前端取流参数
}NET_IVMS_DEVSCHED, *LPNET_IVMS_DEVSCHED;

//智能分析仪参数配置结构
typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED    struDevSched[MAX_DAYS][MAX_TIMESEGMENT];//按时间段配置前端取流以及规则信息
} NET_IVMS_STREAMCFG, *LPNET_IVMS_STREAMCFG;

//屏蔽区域
typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;            //是否激活, 0-否，非0-是
    BYTE byRes[3];         //保留，置0
    NET_VCA_POLYGON  struPolygon; //屏蔽多边形
}NET_VCA_MASK_REGION, * LPNET_VCA_MASK_REGION;

//屏蔽区域链表结构
typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;     //结构长度
    BYTE byRes[4];     //保留，置0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM]; //屏蔽区域数组
}NET_VCA_MASK_REGION_LIST, *LPNET_VCA_MASK_REGION_LIST;


//ATM进入区域参数
typedef struct tagNET_VCA_ENTER_REGION//防止干扰ATM检测
{
    DWORD dwSize;
    BYTE byEnable;            //是否激活，0-否，非0-是
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon; //进入区域
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION, * LPNET_VCA_ENTER_REGION;

//IVMS屏蔽区域链表
typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;    //结构长度
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][ MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST, *LPNET_IVMS_MASK_REGION_LIST;

//IVMS的ATM进入区域参数
typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][ MAX_TIMESEGMENT]; //进入区域
}NET_IVMS_ENTER_REGION, *LPNET_IVMS_ENTER_REGION;

// ivms 报警图片上传结构
typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;               
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;     
}NET_IVMS_ALARM_JPEG, *LPNET_IVMS_ALARM_JPEG;

// IVMS 后检索配置
typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay;// 远程回放
    NET_IVMS_ALARM_JPEG         struAlarmJpeg; // 报警上传图片配置
    NET_IVMS_RULECFG           struRuleCfg;   //IVMS 行为规则配置
}NET_IVMS_SEARCHCFG, *LPNET_IVMS_SEARCHCFG;

//标定参数结构体
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{    
    BYTE byPointNum;    //有效标定点个数
    BYTE byRes[3];        //保留
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //标定点组
    NET_DVR_PTZPOS struHorizonPtzPos;  //球机水平线PTZ坐标
    BYTE byRes2[256];    //保留
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

//跟踪设备配置参数
typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{    
    DWORD  dwSize;         //结构体大小
    BYTE   byEnable;       //启用此跟踪设备, 0-不启用, 1 -启用
    BYTE   byTransMode;    //通讯方式，0-网络SDK，1-485串口
    BYTE   byRes1[2];       //保留    
    NET_DVR_CHANNEL  struTrackDevChan; //联动跟踪设备参数    
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //跟踪设备标定参数    
    BYTE    byRes2[256];    //保留    
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;
/************************************end******************************************/
//NAS认证配置
typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE    sUserName[NAME_LEN];        /* 用户名 32*/
    BYTE    sPassword[PASSWD_LEN];        /* 密码 16*/
    BYTE    byRes1[4];    //保留
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;

typedef union tagNET_DVR_MOUNT_PARAM_UNION
{
    BYTE  uLen[52];                    //联合体结构大小
    NET_DVR_IDENTIFICATION_PARAM struIdentificationParam;//(SMB/CIFS时生效)
} NET_DVR_MOUNT_PARAM_UNION, *LPNET_DVR_MOUNT_PARAM_UNION;

typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0～保留,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;

typedef union tagNET_DVR_MOUNTMETHOD_PARAM_UNION
{
    BYTE  uLen[56]; //联合体结构大小                    
    NET_DVR_NAS_MOUNT_PARAM struNasMountParam;//NAS挂载方式 (byNetDiskType为NFS(NAS)时生效) 
}NET_DVR_MOUNTMETHOD_PARAM_UNION, *LPNET_DVR_MOUNTMETHOD_PARAM_UNION;

//网络硬盘结构配置
typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;                        //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //保留
    NET_DVR_IPADDR struNetDiskAddr;            //网络硬盘地址
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    WORD wPort;                                //iscsi有端口，现在为默认
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];                //保留
}NET_DVR_SINGLE_NET_DISK_INFO, *LPNET_DVR_SINGLE_NET_DISK_INFO;

#define MAX_NET_DISK    16//最大网络硬盘个数

typedef struct tagNET_DVR_NET_DISKCFG 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG, *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;                        //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //保留
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];    /*域名 64*/
    WORD wPort;                                //iscsi有端口，现在为默认
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE    byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40, *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;
//事件类型
//主类型
typedef enum _MAIN_EVENT_TYPE_
{
    EVENT_MOT_DET = 0,        //移动侦测
        EVENT_ALARM_IN = 1,        //报警输入
        EVENT_VCA_BEHAVIOR = 2,    // 行为分析
        EVENT_INQUEST = 3,       //审讯事件
        EVENT_VCA_DETECTION = 4, //智能侦测
        EVENT_POS = 5,
        EVENT_TRIAL_CASE = 6,//庭审案件信息
        EVENT_STREAM_INFO = 100  //流ID信息
}MAIN_EVENT_TYPE;

#define INQUEST_START_INFO        0x1001       /*讯问开始信息*/
#define INQUEST_STOP_INFO         0x1002       /*讯问停止信息*/
#define INQUEST_TAG_INFO          0x1003       /*重点标记信息*/
#define INQUEST_SEGMENT_INFO      0x1004       /*审讯片断状态信息*/
#define INQUEST_CASE_INFO          0x1005        // 案件信息类型

typedef enum _VCA_DETECTION_MINOR_TYPE_
{
    EVENT_VCA_TRAVERSE_PLANE     = 1,           //越警侦测
        EVENT_FIELD_DETECTION,                        //区域入侵侦测
        EVENT_AUDIO_INPUT_ALARM,                    //音频输入异常
        EVENT_SOUND_INTENSITY_ALARM,                //声强突变侦测
        EVENT_FACE_DETECTION,                       //人脸侦测
        EVENT_VIRTUAL_FOCUS_ALARM,                  //虚焦侦测
        EVENT_SCENE_CHANGE_ALARM,                   //场景变更侦测
        EVENT_PIR_ALARM,                            //PIR报警
        EVENT_ENTER_REGION,                           //进入区域
        EVENT_EXIT_REGION,                            //目标离开区域
        EVENT_LOITERING,                               //徘徊
        EVENT_GROUPDETECTION,                       //区域内人员聚集,支持区域规则
        EVENT_RAPIDMOVE,                            //快速移动
        EVENT_PARK,                              //停车
        EVENT_UNATTENDED_BAGGAGE,                   //物品遗留
        EVENT_ATTENDEDBAGGAGE,                      //物品拿取
        EVENT_VEHICLE_DETECTION,                     //车辆检测
        EVENT_ALL = 0xffffffff                        //表示全部
}VCA_DETECTION_MINOR_TYPE;



//行为分析主类型对应的次类型， 0xffff表示全部
typedef enum _BEHAVIOR_MINOR_TYPE_
{
    EVENT_TRAVERSE_PLANE     = 0,    // 穿越警戒面
        EVENT_ENTER_AREA,                //目标进入区域,支持区域规则
        EVENT_EXIT_AREA,                //目标离开区域,支持区域规则
        EVENT_INTRUSION,                 // 周界入侵,支持区域规则
        EVENT_LOITER,                 //徘徊,支持区域规则
        EVENT_LEFT_TAKE,                //物品遗留拿取,支持区域规则
        EVENT_PARKING,                    //停车,支持区域规则
        EVENT_RUN,                    //快速移动,支持区域规则
        EVENT_HIGH_DENSITY,                 //区域内人员聚集,支持区域规则
        EVENT_STICK_UP,                //贴纸条,支持区域规则
        EVENT_INSTALL_SCANNER,                //安装读卡器,支持区域规则
        EVENT_OPERATE_OVER_TIME,        // 操作超时
        EVENT_FACE_DETECT,              // 异常人脸
        EVENT_LEFT,                     // 物品遗留
        EVENT_TAKE,                      // 物品拿取
        EVENT_LEAVE_POSITION,         //离岗事件
        EVENT_TRAIL_INFO = 16,            //尾随
        EVENT_FALL_DOWN_INFO = 19,                 //倒地
        EVENT_OBJECT_PASTE        =20,        // 异物粘贴区域
        EVENT_FACE_CAPTURE_INFO = 21,                //正常人脸
        EVENT_MULTI_FACES_INFO = 22,                  //多张人脸
        EVENT_AUDIO_ABNORMAL_INFO = 23             //声强突变
}BEHAVIOR_MINOR_TYPE;

//主类型6对应的次类型
typedef enum _TRIAL_CASE_MINOR_TYPE_
{
    TRIAL_START_INFO  = 0x1001,    // 庭审开始事件
        TRIAL_STOP_INFO   = 0x1002,        //庭审结束事件
        TRIAL_TAG_INFO    = 0x1003,        //庭审重点标注事件
        TRIAL_SEGMENT_INFO = 0x1004,    // 庭审片段状态信息
        TRIAL_JUDGE_CASE_INFO=0x1005 //庭审案件信息
}TRIAL_CASE_MINOR_TYPE;

// 主类型100，对应的小类型
typedef enum _STREAM_INFO_MINOR_TYPE_
{
    EVENT_STREAM_ID  = 0,                    // 流ID
        EVENT_TIMING = 1,                    // 定时录像
        EVENT_MOTION_DETECT = 2,            // 移动侦测
        EVENT_ALARM = 3,                    // 报警录像
        EVENT_ALARM_OR_MOTION_DETECT = 4,    // 报警或移动侦测
        EVENT_ALARM_AND_MOTION_DETECT = 5,    // 报警和移动侦测
        EVENT_COMMAND_TRIGGER = 6,            // 命令触发
        EVENT_MANNUAL = 7,                    // 手动录像
        EVENT_BACKUP_VOLUME = 8,            // 存档卷录像
        STREAM_EVENT_SEMAPHORE,                //信号量
        STREAM_EVENT_HIDE,                    //遮挡
        STREAM_EVENT_INVERSE,                //逆行
        STREAM_EVENT_VIDEO_LOST,            //视频丢失
        STREAM_EVENT_WIRELESS_ALARM,        //无线报警
        STREAM_EVENT_PIR_ALARM,                //PIR报警
        STREAM_EVENT_CALLHELP_ALARM,        //呼救报警
        
        STREAM_EVENT_FACESNAP,                //人脸抓拍
        STREAM_EVENT_FACE_DETECTION,        //人脸侦测
        STREAM_EVENT_ITS_PLATE,                //车辆检测
        STREAM_EVENT_PDC,                    //客流量统计
        STREAM_EVENT_SCENECHANGE_DETECTION,    //场景变更
        STREAM_EVENT_DEFOCUS_DETECTION,        //虚焦侦测
        STREAM_EVENT_AUDIOEXCEPTION,        //音频异常
        
        //以下为行为分析（COMM_ALARM_RULE）的子类型，具体见VCA_EVENT_TYPE
        VCA_EVENT_TRAVERSE_PLANE,            //穿越警戒面
        VCA_EVENT_INTRUSION,                //周界入侵
        VCA_EVENT_ENTER_AREA,                //进入区域
        VCA_EVENT_EXIT_AREA,                //离开区域
        VCA_EVENT_LOITER,                    //徘徊侦测
        VCA_EVENT_HIGH_DENSITY,                //人员聚集
        VCA_EVENT_RUN,                        //快速移动
        VCA_EVENT_PARKING,                    //非法停车
        VCA_EVENT_LEFT,                        //物品遗留
    VCA_EVENT_TAKE                            //物品拿取
}STREAM_INFO_MINOR_TYPE;

// typedef enum tagITS_MINOR_TYPE
// {
//     ITS_EVENT_CONGESTION    = 0,    // 拥堵
//     ITS_EVENT_PARKING,              // 停车
//     ITS_EVENT_INVERSE,              // 逆行
//     ITS_EVENT_PEDESTRIAN,           // 行人
//     ITS_EVENT_DEBRIS                // 遗留物，抛洒物碎片
// }ITS_MINOR_TYPE;


#define SEARCH_EVENT_INFO_LEN   300    //事件信息长度
#define CASE_NO_LEN                64
#define CASE_NAME_LEN            128
#define LITIGANT_LEN            32
#define CHIEF_JUDGE_LEN         32
#define     SEARCH_CASE_NO_LEN        56
#define  SEARCH_CASE_NAME_LEN    100
#define  SEARCH_LITIGANT_LEN    32
#define  SEARCH_CHIEF_JUDGE_LEN 32
#define     CASE_NO_RET_LEN        52
#define  CASE_NAME_RET_LEN        64
#define     LITIGANT_RET_LEN        24
#define     CHIEF_JUDGE_RET_LEN    24
//事件搜索条件
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;            //0-移动侦测，1-报警输入, 2-智能事件
    WORD wMinorType;            //搜索次类型- 根据主类型变化，0xffff表示全部
    NET_DVR_TIME struStartTime;    //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-全部，0-未锁，1-锁定
    BYTE             byValue;            //0-按位表示，1-按值表示
    BYTE             byRes[130];        // 保留
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];          
        struct//报警输入
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];    //报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30];
        }struAlarmParam;
        
        struct//报警输入--按值
        {
            WORD wAlarmInNo[128];     /*报警输入号，按值表示,采用紧凑型排列*/
            BYTE byRes[44]; //保留
        }struAlarmParamByValue;
        
        struct//移动侦测
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30];//移动侦测通道，byMotDetChanNo[0]若置1则表示查找由通道1发生移动侦测触发的事件
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30];
        }struMotionParam;
        
        struct//移动侦测--按值
        {
            WORD wMotDetChanNo[64];        /* 移动侦测通道，按值表示 ,采用紧凑型排列*/
            BYTE byRes[172];                /*保留*/
        }struMotionParamByValue;
        
        struct//行为分析
        {
            BYTE byChanNo[MAX_CHANNUM_V30];    //触发事件的通道
            BYTE byRuleID;                    //规则ID，0xff表示全部
            BYTE byRes1[43];                //保留
        }struVcaParam;
        
        struct //行为分析--按值方式查找 
        {
            WORD wChanNo[64];     //行为分析对应的通道，按值表示,采用紧凑型排列
            BYTE byRuleID;      //行为分析类型，规则0xff表示全部，从0开始
            BYTE byRes[171];     /*保留*/           
        }struVcaParamByValue;
        
        struct//审讯事件搜索条件
        {            
            BYTE byRoomIndex;    //审讯室编号,按值表示，从1开始
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //保留
        } struInquestParam;
        struct  //智能侦测查找条件
        {
            BYTE byChan [256];//触发智能侦测的通道号，按数组下标表示，byChan[0]若置1则表示查找由通道1发生移动侦测触发的事件 
        }struVCADetectByBit;
        
        struct//智能侦测查找条件 ，通道号按值表示
        {
            DWORD dwChanNo[MAX_CHANNUM_V30-1];// 触发通道号,按值表示，0xffffffff无效，且后续数据也表示无效值
            BYTE byAll;//0-表示不是全部，1-表示全部。
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // 流id信息，72字节长
            DWORD                dwCmdType;  // 外部触发类型，NVR接入云存储使用
            BYTE                byBackupVolumeNum; //存档卷号，CVR使用
            BYTE                byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];  //案件编号
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN]; //案件名称；
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN]; //当事人1；
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN]; //当事人2；
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];//审判长
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM, *LPNET_DVR_SEARCH_EVENT_PARAM;

#define  MAX_POS_KEYWORDS_NUM               3          //支持关键字查找条数
#define  MAX_POS_KEYWORD_LEN                128         //每条关键字长度
#define  SEARCH_EVENT_INFO_LEN_V40             800

//事件搜索条件
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;            //0-移动侦测，1-报警输入, 2-智能事件 5-pos录像
    WORD wMinorType;            //搜索次类型- 根据主类型变化，0xffff表示全部
    NET_DVR_TIME struStartTime;    //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-全部，0-未锁，1-锁定
    BYTE             byRes[131];        // 保留
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];          
        struct//报警输入
        {
            /*报警输入号，按值表示,采用紧凑型排列，0xffff表示后续无效*/
            WORD wAlarmInNo[128];     
            BYTE byRes[544]; //保留
        }struAlarmParam;
        
        struct//移动侦测
        {
            /* 移动侦测通道，按值表示 ,采用紧凑型排列，0xffff表示后续无效*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];        
            BYTE byRes[672];                /*保留*/
        }struMotionParam;
        
        struct //行为分析 
        {
            //行为分析对应的通道，按值表示,采用紧凑型排列，0xffff表示后续无效
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //行为分析类型，规则0xff表示全部，从0开始
            BYTE byRes[671];     /*保留*/           
        }struVcaParam;
        
        struct//审讯事件搜索条件
        {            
            BYTE byRoomIndex;    //审讯室编号,从1开始
            BYTE byRes[799];     //保留
        } struInquestParam;
        
        struct//智能侦测查找条件 ，通道号按值表示
        {
            BYTE byAll;                //查找全部通道，0-否，此时dwChanNo参数有效，
            //1-查找全部通道，此时dwChanNo参数无效。
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// 触发通道号,按值表示，0xffff无效，且后续数据也表示无效值
            BYTE byRes[668];
        }struVCADetect;
        
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // 流id信息，72字节长
            DWORD                dwCmdType;  // 外部触发类型，NVR接入云存储使用
            BYTE                byBackupVolumeNum; //存档卷号，CVR使用
            BYTE                byRes[723];
        }struStreamIDParam;
        
        struct //pos录像
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //通道，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
            BYTE     byAllChan;        //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
            BYTE      byCaseSensitive;      //0-不区分大小写， 1-区分大小写
            BYTE      byCombinateMode;  //关键字组合方式，0-或，1-与
            BYTE      byRes1;              //保留
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN]; 
                                             //关键字查找时的条件
            BYTE    byRes[284];          //保留
        }struPosAlarm;
        
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];       //案件编号
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];   //案件名称
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];   //当事人1
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];   //当事人2
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];   //审判长
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;


//查找返回结果
typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;            //主类型
    WORD wMinorType;            //次类型
    NET_DVR_TIME struStartTime;    //事件开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间，脉冲事件时和开始时间一样
    BYTE byChan[MAX_CHANNUM_V30];    
    BYTE byChanEx[32];   //关联通道，按位表示，使用该字段后byChan可以不使用
    BYTE byRes[4];
    union        
    {
        struct//报警输入结果
        {
            DWORD dwAlarmInNo;     //报警输入号
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//移动侦测结果
        {
            DWORD dwMotDetNo;    //移动侦测通道
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//行为分析结果  
        {
            DWORD dwChanNo;                    //触发事件的通道号
            BYTE byRuleID;                    //规则ID
            BYTE byRes1[3];                    //保留
            BYTE byRuleName[NAME_LEN];        //规则名称
            NET_VCA_EVENT_UNION uEvent;     //行为事件参数
        }struVcaRet;
        struct//审讯事件
        {
            BYTE  byRoomIndex;     //审讯室编号,从1开始
            BYTE  byDriveIndex;    //刻录机编号,从1开始
            BYTE  byRes1[6];       //保留
            DWORD dwSegmentNo;     //本片断在本次审讯中的序号,从1开始 
            WORD  wSegmetSize;     //本片断的大小, 单位M 
            WORD  wSegmentState;   //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            BYTE  byRes2[288];     //保留
        }struInquestRet;
        struct //流id录像查询结果
        {
            DWORD dwRecordType;    //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            DWORD dwRecordLength;    //录像大小
            BYTE  byLockFlag;    // 锁定标志 0：没锁定 1：锁定
            BYTE  byDrawFrameType;    // 0：非抽帧录像 1：抽帧录像
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //文件名
            DWORD dwFileIndex;            // 存档卷上的文件索引
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE    byRoomIndex;     //审讯室编号,从1开始
            BYTE    byDriveIndex;    //刻录机编号,从1开始
            WORD    wSegmetSize;     //本片断的大小, 单位M
            DWORD    dwSegmentNo;    //本片断在本次审讯中的序号,从1开始
            BYTE    bySegmentState;   //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //案件编号
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //案件名称；
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //当事人1；
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //当事人2；
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//审判长
            BYTE    byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET, *LPNET_DVR_SEARCH_EVENT_RET;

//查找返回结果
typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;            //主类型
    WORD wMinorType;            //次类型
    NET_DVR_TIME struStartTime;    //事件开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间，脉冲事件时和开始时间一样
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //触发的通道号，0xffff表示后续无效
    BYTE byRes[36];
    union        
    {
        BYTE  byLen[800];               //联合体长度
        struct//报警输入结果
        {
            DWORD dwAlarmInNo;     //报警输入号
            BYTE byRes[796];
        }struAlarmRet;
        struct//移动侦测结果
        {
            DWORD dwMotDetNo;    //移动侦测通道
            BYTE byRes[796];
        }struMotionRet;
        struct//行为分析结果  
        {
            DWORD dwChanNo;                    //触发事件的通道号
            BYTE byRuleID;                    //规则ID
            BYTE byRes1[3];                    //保留
            BYTE byRuleName[NAME_LEN];        //规则名称
            NET_VCA_EVENT_UNION uEvent;     //行为事件参数
            BYTE byRes[668];                    //保留
        }struVcaRet;
        
        struct//审讯事件
        {
            BYTE  byRoomIndex;     //审讯室编号,从1开始
            BYTE  byDriveIndex;    //刻录机编号,从1开始
            BYTE  byRes1[6];       //保留
            DWORD dwSegmentNo;     //本片断在本次审讯中的序号,从1开始 
            WORD  wSegmetSize;     //本片断的大小, 单位M 
            WORD  wSegmentState;   //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            BYTE  byRes2[784];     //保留
        }struInquestRet;
        
        struct //流id录像查询结果
        {
            DWORD dwRecordType;    //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            DWORD dwRecordLength;    //录像大小
            BYTE  byLockFlag;    // 锁定标志 0：没锁定 1：锁定
            BYTE  byDrawFrameType;    // 0：非抽帧录像 1：抽帧录像
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //文件名
            DWORD dwFileIndex;            // 存档卷上的文件索引
            BYTE  byRes[752];
        }struStreamIDRet;
        
        struct//POS录像查询结果
        {
            DWORD dwChanNo;        //触发产生pos事件的通道
            BYTE  byRes[796];
        }struPosRet;
        
        struct
        {
            BYTE    byRoomIndex;     //审讯室编号,从1开始
            BYTE    byDriveIndex;    //刻录机编号,从1开始
            WORD    wSegmetSize;     //本片断的大小, 单位M
            DWORD    dwSegmentNo;    //本片断在本次审讯中的序号,从1开始
            BYTE    bySegmentState;   //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //案件编号
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //案件名称；
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //当事人1；
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //当事人2；
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//审判长
            BYTE    byRes1[600];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;


//SDK_V35  2009-10-26

// 标定配置类型
typedef enum tagCALIBRATE_TYPE
{
    PDC_CALIBRATE  = 0x01,  // PDC 标定
        BEHAVIOR_OUT_CALIBRATE  = 0x02, //行为室外场景标定  
        BEHAVIOR_IN_CALIBRATE = 0x03,    // 行为室内场景标定 
        ITS_CALBIRETE       = 0x04,      //  交通事件标定
        BV_DIRECT_CALIBRATE      = 0x05,   //双目直接标定
        PDC_LINE_CALIBRATE  = 0x06  //PDC 线 标定
}CALIBRATE_TYPE;

#define MAX_RECT_NUM  6
typedef struct tagNET_DVR_RECT_LIST
{    
    BYTE    byRectNum;    // 矩形框的个数
    BYTE    byRes1[11];  //保留字节 
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM]; // 最大为6个Rect 
}NET_DVR_RECT_LIST, *LPNET_DVR_RECT_LIST;

// PDC 标定参数
typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;       // 标定矩形框列表
    BYTE           byRes[120];       // 保留字节 
}NET_DVR_PDC_CALIBRATION, *LPNET_DVR_PDC_CALIBRATION;


// 标定线的属性类别，用来表示当前标定线在实际表示的是高度线还是长度线。
typedef enum tagLINE_MODE
{
    HEIGHT_LINE,        //高度样本线
        LENGTH_LINE        //长度样本线
}LINE_MODE;
/*
在设置标定信息的时候，如果相应位设置了使能，并设置相关参数，
若没有设置使能，则标定后可以获取相关的摄像机参数
*/
typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;     // 是否使能设置摄像机高度线
    BYTE    byEnableAngle;      // 是否使能设置摄像机俯仰角度
    BYTE    byEnableHorizon;    // 是否使能设置摄像机地平线
    BYTE    byRes[5];   // 保留字节 
    float   fCameraHeight;    // 摄像机高度
    float   fCameraAngle;     // 摄像机俯仰角度
    float   fHorizon;         // 场景中的地平线
}NET_DVR_CAMERA_PARAM, *LPNET_DVR_CAMERA_PARAM;
/*
当fValue表示目标高度的时候，struStartPoint和struEndPoint分别表示目标头部点和脚部点。
当fValue表示线段长度的时候，struStartPoint和struEndPoint分别表示线段起始点和终点，
mode表示当前样本线表示高度线还是长度线。
*/
typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;     // 参照 LINE_MODE
    BYTE            byRes[3];       // 保留字节 
    NET_VCA_POINT   struStartPoint;  
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT, *LPNET_DVR_LINE_SEGMENT;

#define  MAX_LINE_SEG_NUM 8

/*
标定样本线目前需要4-8调样本线，以获取摄像机相关参数
*/
typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;          // 样本线个数
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];    // 样本线最大个数
    NET_DVR_CAMERA_PARAM    struCameraParam;    // 摄像机参数
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION, *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

/*
该结构体表示IAS智能库标定样本，
其中包括一个目标框和一条对应的高度标定线；
目标框为站立的人体外接矩形框；高度线样本标识从人头顶点到脚点的标定线；
用归一化坐标表示；
*/
typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;   // 目标框
    NET_DVR_LINE_SEGMENT struLineSegment;    // 高度标定线
}NET_DVR_IN_CAL_SAMPLE, *LPNET_DVR_IN_CAL_SAMPLE;

#define  MAX_SAMPLE_NUM 5

typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION 
{
    DWORD    dwCalSampleNum;      //  标定样本个数
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM]; // 标定样本最大个数
    NET_DVR_CAMERA_PARAM    struCameraParam;    // 摄像机参数
    BYTE byRes[16];
}NET_DVR_BEHAVIOR_IN_CALIBRATION, *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

#define  CALIB_PT_NUM 4
typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum; //标定点数
    NET_VCA_POINT struPoint[CALIB_PT_NUM]; //图像坐标
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];        // 保留字节
}NET_DVR_ITS_CALIBRATION, *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{   
    DWORD  dwCameraHeight;  //摄像机高度，单位cm
    float  fPitchAngle;     //摄像机俯视角度[0°, 60°],
    float  fInclineAngle;   //摄像机倾斜角度[-20°,20°]
    BYTE   byRes1[228];     //保留
}NET_DVR_BV_DIRECT_CALIBRATION,*LPNET_DVR_BV_DIRECT_CALIBRATION;

// PDC 标定参数
typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[224];// 保留字节 
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;

// 标定参数联合体
// 后续的相关标定参数可以放在该结构里面
typedef union tagNET_DVR_CALIBRATION_PRARM_UNION
{
    BYTE byRes[240];                    //联合体结构大小
    NET_DVR_PDC_CALIBRATION struPDCCalibration;  //PDC 标定参数
    NET_DVR_BEHAVIOR_OUT_CALIBRATION  struBehaviorOutCalibration;  //  行为室外场景标定  主要应用于IVS等
    NET_DVR_BEHAVIOR_IN_CALIBRATION  struBehaviorInCalibration;     // 行为室内场景标定，主要应用IAS等 
    NET_DVR_ITS_CALIBRATION struITSCalibration;
    NET_DVR_BV_DIRECT_CALIBRATION struBvDirectCalibration; //双目直接标定
    NET_DVR_PDC_LINE_CALIBRATION struPDCLineCalibration; //PDC 线标定参数
}NET_DVR_CALIBRATION_PRARM_UNION, *LPNET_DVR_CALIBRATION_PRARM_UNION;


// 标定配置结构
typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;               //标定结构大小
    BYTE    byEnable;           // 是否启用标定
    BYTE    byCalibrationType;    // 标定类型 根据不同类型在联合体类选择不同的标定 参考CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;  // 标定参数联合体
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG, *LPNET_DVR_CALIBRATION_CFG; 

//流量统计方向结构体
typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint; //流量统计方向起始点
    NET_VCA_POINT struEndPoint;    // 流量统计方向结束点 
}NET_DVR_PDC_ENTER_DIRECTION, *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;              //结构大小
    BYTE            byEnable;             // 是否激活规则;
    BYTE            byRes1[23];       // 保留字节 
    NET_VCA_POLYGON          struPolygon;            // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // 流量进入方向
} NET_DVR_PDC_RULE_CFG, *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;              //结构大小
    BYTE            byEnable;             // 是否激活规则;
    BYTE            byRes1[23];       // 保留字节 
    NET_VCA_POLYGON struPolygon;            // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // 流量进入方向
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_TIME_EX struDayStartTime; //白天开始时间，时分秒有效
    NET_DVR_TIME_EX struNightStartTime; //夜晚开始时间，时分秒有效
    BYTE            byRes[100];       // 保留字节
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

/********* IPC5.1.7 人流量统计规则 Begin 2014-03-21***********/
//条件结构
typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize; //结构大小
    DWORD  dwChannel; //通道号
    //DWORD dwID;  兼容球机多场景概念
    BYTE  byRes[64]; 
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

//配置结构
typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize; //结构大小
    BYTE   byEnable; //是否激活规则;
    BYTE   byOSDEnable;//客流统计OSD显示是否启用,  0-否，1-是
    BYTE   byCurDetectType;//当前检测区域类型，0-多边形，1-检测线
    BYTE   byRes1; // 保留字节
    NET_VCA_POINT   struOSDPoint;//客流统计显示OSD显示左上角坐标
    //客流量检测数据上传周期（0-15、1-1、2-5、3-10、4-20、5-30、6-60）单位：分钟
    BYTE   byDataUploadCycle; 
    //每秒上传机制使能（0-关闭，1-开启）
    BYTE   bySECUploadEnable;
    BYTE   byRes2[10];// 保留字节      
    NET_VCA_POLYGON          struPolygon; // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // 流量进入方向
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_TIME_EX struDayStartTime; //白天开始时间，时分秒有效
    NET_DVR_TIME_EX struNightStartTime; //夜晚开始时间，时分秒有效
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*处理方式 仅支持上传中心*/
    BYTE   byDetecteSensitivity;//目标检测灵敏度：范围1-100，默认50
    BYTE   byGenerateSpeedSpace;//目标生成速度（空域）：范围1-100，默认50
    BYTE   byGenerateSpeedTime;// 目标生成速度（时域）：范围1-100，默认50
    BYTE   byCountSpeed;// 计数速度：范围1-100，默认50
    BYTE   byDetecteType;// 目标检测类型：0-自动，1-人头，2-头肩，默认0-自动，自动模式下DSP调整算法的参数配置给算法库
    BYTE   byTargetSizeCorrect;//目标尺寸修正：范围1-100，默认50
    BYTE   byRes3[2];// 保留字节
    NET_VCA_LINE  struLine;//检测线
    BYTE   byRes[236]; //保留字节
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;
/********* IPC5.1.7 人流量统计规则 End 2014-03-21***********/

//试用版信息结构体
typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //试用期剩余时间，0xffff表示无效，单位：天
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byRes[64]; 
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byMode; //生效模式，0-定时，1-手动
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//数据清零时间，时分秒有效
    BYTE  byRes[64]; 
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;     //是否开启智能
    BYTE   byVCAType;       //智能能力类型，VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //码流中是否带智能信息
    BYTE   byMode;            //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE ,TFS 能力时参照 TFS_CHAN_MODE_TYPE，行为分析完整版时参照BEHAVIOR_SCENE_MODE_TYPE
    BYTE   byControlType;   //控制类型，按位表示，0-否，1-是
    //byControlType &1 是否启用抓拍功能
    //byControlType &2 是否启用联动前端设备
    BYTE   byRes[83];         //保留，设置为0
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;

//设置人流量统计参数  复用行为内部关键字参数 
// HUMAN_GENERATE_RATE
// 目标生成速度参数，控制PDC库生成目标的速度。速度越快，目标越容易生成。当输入视频光照条件较差，对比度较低时，或者设置的规则区域较小时，应加快目标生成速度， 避免目标的漏检；当输入视频中对比度较高时，或者规则区域较大时，应该降低目标生成速度，以减少误检。目标生成速度参数共有5级，1级速度最慢，5级最快，默认参数为3。
// 
// DETECT_SENSITIVE
// 目标检测灵敏度控制参数，控制PDC库中一个矩形区域被检测为目标的灵敏度。灵敏度越高，矩形区域越容易被检测为目标，灵敏度越低则越难检测为目标。当输入视频光照条件较差，对比度较低时，应提高检测灵敏度， 避免目标的漏检；当输入视频中对比度较高时，应该降低检测灵敏度，以减少误检。对应参数共有5级，级别1灵敏度最低，5级最高，默认级别为3。
// TRAJECTORY_LEN
// 轨迹生成长度控制参数，表示生成轨迹时要求目标的最大位移像素。对应参数共有5级，级别1，生成长度最长，轨迹生成最慢，5级生成长度最短，轨迹生成最快，默认级别为3。
// TRAJECT_CNT_LEN
// 轨迹计数长度控制参数，表示轨迹计数时要求目标的最大位移像素。对应参数共有5级，级别1，计数要求长度最长，轨迹计数最慢，5级计数要求长度最短，轨迹计数最快，默认级别为3。
// PREPROCESS
// 图像预处理控制参数，0 - 不处理；1 - 处理。默认为0；
// CAMERA_ANGLE
// 摄像机角度输入参数， 0 - 倾斜； 1 - 垂直。默认为0；
typedef enum tagPDC_PARAM_KEY
{
    HUMAN_GENERATE_RATE = 50,              // 目标生成速度 从50开始
        DETECT_SENSITIVE    = 51,               // 检测灵敏度
}PDC_PARAM_KEY;

typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                 // 目标id 
    NET_VCA_RECT struTargetRect;               // 目标框
    BYTE      byRes1[8];        // 保留字节
}NET_DVR_PDC_TARGET_INFO, *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                   //目标个数
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];   //目标信息数组
    BYTE    byRes2[8];                  // 保留字节
}NET_DVR_PDC_TARGET_IN_FRAME, *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;          // PDC人流量报警上传结构体大小
    BYTE                        byMode;          // 0 单帧统计结果 1最小时间段统计结果  
    BYTE                        byChannel;       // 报警上传通道号
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    BYTE                        bySmart;         //专业智能返回0，Smart 返回 1
    BYTE                        byRes1;          // 保留字节    
    /********* IPC5.1.7 新增参数 End 2014-03-21***********/
    NET_VCA_DEV_INFO       struDevInfo;             //前端设备信息
    union        
    {
        struct   // 单帧统计结果时使用
        {
            DWORD   dwRelativeTime;     // 相对时标
            DWORD   dwAbsTime;          // 绝对时标
            BYTE    byRes[92];            
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // 统计起始时间 
            NET_DVR_TIME                      tmEnd;  //  统计结束时间 
            BYTE byRes[92];
        }struStatTime;
    }uStatModeParam;  // 作为一个联合体 单帧的时候才有帧内目标信息 最小时间段统计结果需要统计时间 参数
    DWORD                       dwLeaveNum;        // 离开人数
    DWORD                       dwEnterNum;        // 进入人数
    BYTE                        byRes2[40];           // 保留字节
}NET_DVR_PDC_ALRAM_INFO, *LPNET_DVR_PDC_ALRAM_INFO;


//  人流量信息查询 
typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD       dwLeaveNum;
    DWORD       dwEnterNum; 
    BYTE        byRes1[256];
}NET_DVR_PDC_QUERY, *LPNET_DVR_PDC_QUERY;

typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;             // 结构大小 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // 场景位置信息
    NET_VCA_RULECFG         struVcaRuleCfg;     //行为规则配置
    BYTE                    byRes2[80];         // 保留字节
}NET_DVR_POSITION_RULE_CFG, *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // 结构大小 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // 场景位置信息
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //行为规则配置
    BYTE  byTrackEnable; //是否启用跟踪
    BYTE  byRes1;
    WORD wTrackDuration; //跟踪持续时间，单位s
    BYTE                    byRes2[76];         // 保留字节
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;


typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;    // 是否启用场景限位功能
    BYTE                byRes1[3];
    NET_DVR_PTZPOS      struUp;     // 上限位
    NET_DVR_PTZPOS      struDown;   // 下限位
    NET_DVR_PTZPOS      struLeft;   // 左限位
    NET_DVR_PTZPOS      struRight;  // 右限位
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE, *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    // 场景索引
    BYTE    byRes1;
    WORD    wDwell;    // 停留时间 
    BYTE    byRes2[4];   // 保留字节
}NET_DVR_POSITION_INDEX, *LPNET_DVR_POSITION_INDEX;

#define  MAX_POSITION_NUM 10
typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD dwSize;
    BYTE    byNum; // 场景个数
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG, *LPNET_DVR_POSITION_TRACK_CFG;

//巡航路径场景信息
typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;         // 停留时间 30-300
    BYTE   byPositionID;   // 场景号1-10，默认0表示该巡航点不添加场景
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO, *LPNET_DVR_PATROL_SCENE_INFO;

// 场景巡航跟踪配置信息
typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                 // 结构大小
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];    // 巡航路径
    BYTE   byRes[16];                              // 保留字节
}NET_DVR_PATROL_TRACKCFG, *LPNET_DVR_PATROL_TRACKCFG;

//球机本地规则菜单配置结构体
typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // 结构大小
    WORD    wAlarmDelayTime;    // 报警延时时间，目前球机只支持全局入侵 范围1-120秒
    WORD    wTrackHoldTime;     // 报警跟踪持续时间  范围0-300秒
    BYTE    byTrackMode;        //  参照 IPDOME_TRACK_MODE
    BYTE     byPreDirection;    // 跟踪方向预判 0-不启用 1-启用
    BYTE      byTrackSmooth;        // 跟踪连续  0-不启用 1-启用
    BYTE     byZoomAdjust;    // 倍率系数调整 参见下表
    BYTE    byMaxTrackZoom;    //最大跟踪倍率系数,0-表示默认倍率系数,等级6-标定值*1.0(默认),1-5为缩小标定值，值越小，缩小的比例越大,7-15为放大，值越大，放大的比例越大
    BYTE   byStopTrackWhenFindFace;  //人脸检测到后是否停止跟踪 0-否 1-是
    BYTE   byStopTrackThreshold;   //跟踪终止评分阈值
    BYTE   byRes[9];          //  保留字节                
}NET_DVR_TRACK_PARAMCFG, *LPNET_DVR_TRACK_PARAMCFG;

// 球机机芯参数
typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;   // 球机最大倍率系数
    BYTE    byRes[42];  // 保留字节
}NET_DVR_DOME_MOVEMENT_PARAM, *LPNET_DVR_DOME_MOVEMENT_PARAM;

/********************************智能交通事件 begin****************************************/
#define  MAX_REGION_NUM            8       // 区域列表最大数目
#define  MAX_TPS_RULE            8       // 最大参数规则数目
#define  MAX_AID_RULE            8      // 最大事件规则数目
#define  MAX_LANE_NUM            8        // 最大车道数目

//交通事件类型，
typedef enum tagTRAFFIC_AID_TYPE
{
    CONGESTION          = 0x01,    //拥堵
        PARKING             = 0x02,    //停车  
        INVERSE             = 0x04,    //逆行
        PEDESTRIAN          = 0x08,    //行人                      
        DEBRIS              = 0x10,    //遗留物 抛洒物碎片 
        SMOKE               = 0x20,    //烟雾  
        OVERLINE            = 0x40,     //压线
        VEHICLE_CONTROL_LIST  = 0x80,  //黑名单数据
        SPEED                 = 0x100,  //超速
        LANECHANGE         = 0x200,      //变道
        TURNAROUND         = 0x400,     //掉头
        VEHICLE_OCCUPANCY_NONVEHICLE = 0x800, //机动车占用非机动车位
        GASSER            = 0x1000    //加塞
}TRAFFIC_AID_TYPE;

typedef enum tagTRAFFIC_SCENE_MODE
{
    FREEWAY = 0,    //  高速户外场景
        TUNNEL,         //  高速隧道场景
        BRIDGE          //  高速桥梁场景
}TRAFFIC_SCENE_MODE;

typedef enum tagITS_ABILITY_TYPE
{
    ITS_CONGESTION_ABILITY             = 0x01,      //拥堵
        ITS_PARKING_ABILITY                = 0x02,      //停车  
        ITS_INVERSE_ABILITY                = 0x04,      //逆行
        ITS_PEDESTRIAN_ABILITY             = 0x08,      //行人                      
        ITS_DEBRIS_ABILITY                 = 0x10,      //遗留物 抛洒物碎片
        ITS_SMOKE_ABILITY                  = 0x20,      //烟雾-隧道
        ITS_OVERLINE_ABILITY               = 0x40,      //压线
        ITS_VEHICLE_CONTROL_LIST_ABILITY   = 0x80,        //黑名单数据
        ITS_SPEED_ABILITY                   = 0x100,        //超速        
        ITS_LANECHANGE_ABILITY             = 0x200,     //变道
        ITS_TURNAROUND_ABILITY             = 0x400,      //掉头
        ITS_LANE_VOLUME_ABILITY            = 0x010000,  //车道流量
        ITS_LANE_VELOCITY_ABILITY          = 0x020000,  //车道平均速度
        ITS_TIME_HEADWAY_ABILITY           = 0x040000,  //车头时距
        ITS_SPACE_HEADWAY_ABILITY          = 0x080000,  //车头间距
        ITS_TIME_OCCUPANCY_RATIO_ABILITY   = 0x100000,  //车道占有率，（时间上)
        ITS_SPACE_OCCUPANCY_RATIO_ABILITY  = 0x200000,  //车道占有率，百分比计算（空间上)
        ITS_LANE_QUEUE_ABILITY             = 0x400000,  //排队长度
        ITS_VEHICLE_TYPE_ABILITY           = 0x800000,  //车辆类型
        ITS_TRAFFIC_STATE_ABILITY          = 0x1000000  //交通状态
}ITS_ABILITY_TYPE;

// 交通统计参数
typedef enum tagITS_TPS_TYPE
{
    LANE_VOLUME           = 0x01,    //车道流量
        LANE_VELOCITY         = 0x02,    //车道速度
        TIME_HEADWAY          = 0x04,    //车头时距
        SPACE_HEADWAY         = 0x08,    //车头间距
        TIME_OCCUPANCY_RATIO  = 0x10,    //车道占有率 (时间上)
        SPACE_OCCUPANCY_RATIO = 0x20,    //车道占有率，百分比计算(空间上)
        QUEUE                 = 0x40,    //排队长度
        VEHICLE_TYPE          = 0x80,    //车辆类型
        TRAFFIC_STATE         = 0x100    //交通状态
}ITS_TPS_TYPE; 

typedef struct tagNET_DVR_REGION_LIST 
{
    DWORD    dwSize;    // 结构体大小
    BYTE    byNum;      // 区域个数
    BYTE    byRes1[3];    // 保留字节
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM]; // 区域
    BYTE    byRes2[20];    // 保留字节
}NET_DVR_REGION_LIST,*LPNET_DVR_REGION_LIST;


// 方向结构体
typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // 方向起始点
    NET_VCA_POINT struEndPoint;     // 方向结束点 
}NET_DVR_DIRECTION, *LPNET_DVR_DIRECTION;

// 单个车道
typedef struct tagNET_DVR_ONE_LANE
{
    BYTE    byEnable;                   // 车道是否启用
    BYTE    byRes1[11];                    // 保留字节
    BYTE    byLaneName[NAME_LEN];       // 车道规则名称
    NET_DVR_DIRECTION struFlowDirection;// 车道内车流方向
    NET_VCA_POLYGON struPolygon;        // 车道区域
}NET_DVR_ONE_LANE, *LPNET_DVR_ONE_LANE;

// 车道配置
typedef struct tagNET_DVR_LANE_CFG
{
    DWORD    dwSize;    // 结构体大小
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];    // 车道参数 数组下标作为车道ID，
    BYTE    byRes1[40];     // 保留字节
}NET_DVR_LANE_CFG, *LPNET_DVR_LANE_CFG;

// 交通事件参数
typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;       // 违停检测灵敏度  10-120s
    WORD    wPedestrianDuration;    // 行人持续时间    1-120s
    WORD    wDebrisDuration;        // 抛洒物持续时间  10-120s
    WORD    wCongestionLength;      // 拥堵长度阈值    5-200（米）
    WORD    wCongestionDuration;    // 拥堵持续参数    10-120s
    WORD    wInverseDuration;       // 逆行持续时间    1-10s
    WORD    wInverseDistance;       // 逆行距离阈值 单位m 范围[2-100] 默认 10米
    WORD    wInverseAngleTolerance; // 允许角度偏差 90-180度,车流与逆行允许的夹角
    WORD    wIllegalParkingTime;    // 违停时间[4,60]，单位：分钟 ,TFS(交通违章取证) 城市模式下
    WORD    wIllegalParkingPicNum;  // 违停图片数量[1,6], TFS(交通违章取证) 城市模式下
    BYTE    byMergePic;             // 图片拼接,TFS 城市模式下 0- 不拼接 1- 拼接
    BYTE    byRes1[23];             // 保留字节
}NET_DVR_AID_PARAM, *LPNET_DVR_AID_PARAM;

// 单条交通事件规则结构体
typedef struct tagNET_DVR_ONE_AID_RULE
{   
    BYTE    byEnable;                   // 是否启用事件规则
    BYTE    byRes1[3];                  // 保留字节
    BYTE    byRuleName[NAME_LEN];       // 规则名称 
    DWORD   dwEventType;                // 交通事件检测类型 TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; // 尺寸过滤器
    NET_VCA_POLYGON     struPolygon;    // 规则区域
    NET_DVR_AID_PARAM   struAIDParam;   //  事件参数
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];        //报警触发的录象通道,为1表示触发该通道
    BYTE byRes2[20];
}NET_DVR_ONE_AID_RULE, *LPNET_DVR_ONE_AID_RULE;

// 交通事件规则
typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;                    // 结构体大小 
    BYTE    byPicProType;              //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];                 // 保留字节
    NET_DVR_JPEGPARA struPictureParam; //图片规格结构
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];
    BYTE    byRes2[32];
}NET_DVR_AID_RULECFG, *LPNET_DVR_AID_RULECFG;

// 单条交通事件规则结构体(扩展)
typedef struct tagNET_DVR_ONE_AID_RULE_V41
{   
    BYTE                        byEnable;                 // 是否启用事件规则
    BYTE                        byLaneNo;                 // 关联车道号
    BYTE                        byRes1[2];                // 保留字节
    BYTE                        byRuleName[NAME_LEN];     // 规则名称 
    DWORD                       dwEventType;              // 交通事件检测类型 TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // 尺寸过滤器
    NET_VCA_POLYGON             struPolygon;              // 规则区域
    NET_DVR_AID_PARAM           struAIDParam;             // 事件参数
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// 布防时间段
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;              //处理方式 
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //报警触发的录象通道：1表示触发该通道；0表示不触发 
    BYTE                        byRes2[60];               //保留
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

// 交通事件规则(扩展)
typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // 结构体大小 
    BYTE    byPicProType;               // 报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];                  // 保留字节
    NET_DVR_JPEGPARA struPictureParam;     // 图片规格结构
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //规则数组
    BYTE    byRes2[128];                //保留
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

// 交通统计参数结构体
typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;                   //是否使能车道交通规则参数
    BYTE    byLaneID;                    //车道ID
    BYTE    byRes1[2];
    DWORD   dwCalcType;                 //统计参数类型ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; //尺寸过滤器 
    NET_VCA_POLYGON struVitrualLoop;    //虚拟线圈
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //处理方式,一般为处理是否上传中心，其他功能不需要
    BYTE    byRes2[20];                         //保留字节
}NET_DVR_ONE_TPS_RULE, *LPNET_DVR_ONE_TPS_RULE;

// 交通参数统计规则配置结构体
typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;              // 结构大小
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE]; // 下标对应交通参数ID
    BYTE    byRes2[40];         // 保留字节
}NET_DVR_TPS_RULECFG, *LPNET_DVR_TPS_RULECFG;

// 交通统计参数结构体(扩展)
typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //是否使能车道交通规则参数
    BYTE    byLaneID;                      //车道ID
    BYTE    byRes1[2];                    //保留
    DWORD   dwCalcType;                   // 统计参数类型ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器 
    NET_VCA_POLYGON      struVitrualLoop; //虚拟线圈
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;       //处理方式 
    BYTE    byRes2[60];                   // 保留字节
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;


// 交通参数统计规则配置结构体(扩展)
typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         // 结构大小
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; // 下标对应交通参数ID
    BYTE    byRes[128];     // 保留
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;

// 交通事件信息
typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;   // 规则序号，为规则配置结构下标，0-16
    BYTE            byRes1[3];
    BYTE            byRuleName[NAME_LEN]; //  规则名称
    DWORD           dwAIDType;  // 报警事件类型
    NET_DVR_DIRECTION   struDirect; // 报警指向区域  
    BYTE    bySpeedLimit; //限速值，单位km/h[0,255]
    BYTE    byCurrentSpeed; //当前速度值，单位km/h[0,255]
    BYTE            byRes2[38];  // 保留字节 
}NET_DVR_AID_INFO, *LPNET_DVR_AID_INFO;

// 交通事件报警 
typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;         // 结构长度
    DWORD               dwRelativeTime;    // 相对时标
    DWORD               dwAbsTime;        // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;    // 前端设备信息
    NET_DVR_AID_INFO    struAIDInfo;    // 交通事件信息
    DWORD               dwPicDataLen;   // 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
    BYTE                *pImage;        // 指向图片的指针 
    BYTE                byRes[40];      // 保留字节  
}NET_DVR_AID_ALARM, *LPNET_DVR_AID_ALARM;

// 车道队列结构体 
typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;       //队列头
    NET_VCA_POINT   struTail;       //队列尾
    DWORD           dwLength;      //实际队列长度 单位为米 [0-500]
}NET_DVR_LANE_QUEUE, *LPNET_DVR_LANE_QUEUE; 

typedef enum tagTRAFFIC_DATA_VARY_TYPE
{
    NO_VARY,         //无变化 
        VEHICLE_ENTER,   //车辆进入虚拟线圈
        VEHICLE_LEAVE,   //车辆离开虚拟线圈 
        UEUE_VARY        //队列变化             
}TRAFFIC_DATA_VARY_TYPE; 

typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];  //车道规则名称 
    BYTE    byRuleID;              //规则序号，为规则配置结构下标，0-7 
    BYTE    byVaryType;            //车道交通参数变化类型 参照 TRAFFIC_DATA_VARY_TYPE
    BYTE    byLaneType;               //车道上行或下行
    BYTE    byRes1;
    DWORD    dwLaneVolume;         //车道流量 ，统计有多少车子通过
    DWORD   dwLaneVelocity;        //车道速度，公里计算
    DWORD   dwTimeHeadway;         //车头时距，以秒计算
    DWORD   dwSpaceHeadway;        //车头间距，以米来计算
    float   fSpaceOccupyRation;    //车道占有率，百分比计算（空间上)
    NET_DVR_LANE_QUEUE  struLaneQueue;    //车道队列长度
    NET_VCA_POINT       struRuleLocation; //线圈规则的中心点位置
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM, *LPNET_DVR_LANE_PARAM;


typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;   // 交通参数的车道数目
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO, *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD             dwSize;          //结构体大小
    DWORD             dwRelativeTime;  //相对时标
    DWORD             dwAbsTime;       //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;     //前端设备信息
    NET_DVR_TPS_INFO  struTPSInfo;     //交通事件信息
    BYTE              byRes1[32];      //保留字节
}NET_DVR_TPS_ALARM, *LPNET_DVR_TPS_ALARM;

typedef enum tagTRAFFIC_DATA_VARY_TYPE_EX_ENUM
{    
    ENUM_TRAFFIC_VARY_NO             = 0x00,   //无变化
        ENUM_TRAFFIC_VARY_VEHICLE_ENTER  = 0x01,   //车辆进入虚拟线圈
        ENUM_TRAFFIC_VARY_VEHICLE_LEAVE  = 0x02,   //车辆离开虚拟线圈
        ENUM_TRAFFIC_VARY_QUEUE          = 0x04,   //队列变化
        ENUM_TRAFFIC_VARY_STATISTIC      = 0x08,   //统计数据变化（每分钟变化一次包括平均速度，车道空间/时间占有率，交通状态）        
}TRAFFIC_DATA_VARY_TYPE_EX_ENUM;  

typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; // 车道规则名称
    BYTE               byRuleID;             // 规则序号，为规则配置结构下标，0-7 
    BYTE               byLaneType;             // 车道上行或下行
    BYTE               byTrafficState;       // 车道的交通状态，0-无效，1-畅通，2-拥挤，3-堵塞
    BYTE               byLaneNo;            //车道号
    DWORD              dwVaryType;           // 车道交通参数变化类型参照  TRAFFIC_DATA_VARY_TYPE_EX_ENUM，按位区分
    DWORD              dwTpsType;            // 数据变化类型标志，表示当前上传的统计参数中，哪些数据有效，参照ITS_TPS_TYPE,按位区分
    DWORD              dwLaneVolume;         // 车道流量，统计有多少车子通过
    DWORD              dwLaneVelocity;       // 车道速度，公里计算
    DWORD              dwTimeHeadway ;       // 车头时距，以秒计算
    DWORD              dwSpaceHeadway;       // 车头间距，以米来计算
    float              fSpaceOccupyRation;   // 车道占有率，百分比计算（空间上)
    float              fTimeOccupyRation;    // 时间占有率，百分比计算
    DWORD              dwLightVehicle;       // 小型车数量
    DWORD              dwMidVehicle;         // 中型车数量
    DWORD              dwHeavyVehicle;       // 重型车数量
    NET_DVR_LANE_QUEUE struLaneQueue;        // 车道队列长度
    NET_VCA_POINT      struRuleLocation;     // 规则位置虚拟线圈的中心
    DWORD               dwOversizeVehicle;    // 大型车数量
    BYTE               byRes2[60];           // 保留
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;


typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          // 交通参数的车道数目
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE];
    BYTE                    byRes[32];         //保留
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

// 人脸规则配置 
typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              // 结构体大小
    BYTE           byEnable;            // 是否启用
    BYTE           byEventType;            //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;
    BYTE           byUpLastAlarm;       //2011-04-06 是否先上传最近一次的报警
    BYTE           byUpFacePic; //是否上传人脸子图，0-否，1-是    
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon;    // 人脸检测规则区域
    BYTE           byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE           bySensitivity;   // 规则灵敏度
    WORD            wDuration;      // 触发人脸报警时间阈值
    NET_DVR_JPEGPARA    struPictureParam;         //图片规格结构
    NET_VCA_SIZE_FILTER struSizeFilter;         //尺寸过滤器
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
    BYTE           byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE            byRes2[39];         //保留字节
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{    
    BYTE byEnable; //是否开启画中画
    BYTE byBackChannel; //背景通道号（面板通道）
    BYTE byPosition; //叠加位置，0-左上,1-左下,2-右上,3-右下
    BYTE byPIPDiv; //分屏系数(人脸画面:面板画面)，0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              // 结构体大小
    BYTE  byEnable;            // 是否启用
    BYTE  byEventType;            //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;
    BYTE  byUpLastAlarm;       //2011-04-06 是否先上传最近一次的报警
    BYTE  byUpFacePic; //是否上传人脸子图，0-否，1-是    
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    // 人脸检测规则区域
    BYTE  byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE  bySensitivity;   // 规则灵敏度
    WORD  wDuration;      // 触发人脸报警时间阈值
    NET_DVR_JPEGPARA    struPictureParam;         //图片规格结构
    NET_VCA_SIZE_FILTER struSizeFilter;         //尺寸过滤器
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
    BYTE  byPicRecordEnable;  /*2012-10-22是否启用图片存储, 0-不启用, 1-启用*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7画中画参数
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE  byRes[22];         //保留字节
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD   dwSize;         //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime;        //绝对时标
    BYTE    byRuleName[NAME_LEN];   //规则名称
    NET_VCA_TARGET_INFO  struTargetInfo;//报警目标信息
    NET_VCA_DEV_INFO       struDevInfo;//前端设备信息
    DWORD   dwPicDataLen;    //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    BYTE    byAlarmPicType;    // 0-异常人脸报警图片 1- 人脸图片,2-多张人脸 
    BYTE    byPanelChan;    /*2012-3-1人脸通道关联的面板通道*/
    BYTE    byRelAlarmPicNum; //关联通道报警图片数量
    BYTE    byRes1;
    DWORD   dwFacePicDataLen;//人脸图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    DWORD   dwAlarmID;    //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    BYTE    byRes2[44];   // 保留字节
    BYTE    *pFaceImage; //指向人脸图指针
    BYTE    *pImage;                           //指向图片的指针
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD   uLen[3];            // 联合体大小为12字节
    DWORD  dwHumanIn;      //有无人接近 0 - 无人 1- 有人  
    float       fCrowdDensity;  // 人员聚集值
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

// 目前只有有人无人事件和人员聚集事件实时报警上传
typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;                // Rule ID
    BYTE   byRes[3];                // 保留字节
    BYTE   byRuleName[NAME_LEN];    // 规则名称
    DWORD       dwEventType;            // 参照VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;  // 
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE            byNum;        // 事件实时信息个数
    BYTE            byRes1[3];            // 保留字节
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];    // 事际实时信息
}NET_DVR_EVENT_INFO_LIST,*LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD             dwSize;                // 结构体大小
    DWORD         dwRelativeTime;     // 相对时标
    DWORD        dwAbsTime;            // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;        // 前端设备信息
    NET_DVR_EVENT_INFO_LIST struEventInfoList;    //事件信息列表
    BYTE            byRes2[40];            // 保留字节
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

//单条场景时间段
typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 -无效,1C有效
    BYTE     byRes1[3];                    //保留
    DWORD    dwSceneID;                    //场景ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //场景起效时间
    BYTE     byRes2[16];                   //保留
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME ;

//场景起效时间段配置
typedef struct tagNET_DVR_SCENE_TIME_CFG
{   
    DWORD  dwSize;                                               //结构大小
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //场景时间段数组
    BYTE   byRes[64];                                            //保留
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;


//单条场景配置信息
typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{    
    BYTE   byEnable;                 //是否启用该场景,0-不启用 1- 启用
    BYTE   byDirection;              //监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    BYTE   byRes1[2];                //保留
    DWORD  dwSceneID;                //场景ID(只读), 0 - 表示该场景无效
    BYTE   bySceneName[NAME_LEN];    //场景名称
    NET_DVR_PTZPOS struPtzPos;       //ptz 坐标
    DWORD  dwTrackTime;              //球机跟踪时间[5,300] 秒，TFS(交通取证)模式下有效
    BYTE   byRes2[24];               //保留
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;

//场景配置结构体
typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //结构大小
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //场景配置信息
    BYTE   byRes[40];                                      //保留
}NET_DVR_SCENE_CFG,*LPNET_DVR_SCENE_CFG;

//多场景操作条件
typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //结构大小
    LONG    lChannel;     //通道号
    DWORD   dwSceneID;    //场景ID, 0-表示该场景无效
    BYTE    byRes[48];    //保留
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

//取证方式
typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //结构大小
    BYTE   byMode;      // 0-手动取证 ,1-自动取证，2-半自动跟踪和静态取证
    BYTE   byRes[23];   //保留
}NET_DVR_FORENSICS_MODE,*LPNET_DVR_FORENSICS_MODE;

//报警场景信息
typedef struct tagNET_DVR_SCENE_INFO_
{  
    DWORD           dwSceneID;              //场景ID, 0 - 表示该场景无效
    BYTE            bySceneName[NAME_LEN];  //场景名称
    BYTE            byDirection;            //监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    BYTE            byRes1[3];              //保留
    NET_DVR_PTZPOS  struPtzPos;             //Ptz 坐标
    BYTE            byRes2[64] ;            //保留
}NET_DVR_SCENE_INFO,*LPNET_DVR_SCENE_INFO;

//交通事件报警(扩展)
typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //结构长度
    DWORD              dwRelativeTime;        //相对时标
    DWORD              dwAbsTime;            //绝对时标
    NET_VCA_DEV_INFO   struDevInfo;            //前端设备信息
    NET_DVR_AID_INFO   struAIDInfo;         //交通事件信息
    NET_DVR_SCENE_INFO struSceneInfo;       //场景信息
    DWORD              dwPicDataLen;        //图片长度
    BYTE               *pImage;             //指向图片的指针
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE               byDataType;
    BYTE               byLaneNo;  //关联车道号 
    WORD               wMilliSecond;        //时标毫秒
    //监测点编号（路口编号、内部编号）
    BYTE                  byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE                  byDeviceID[DEVICE_ID_LEN/*48*/];//设备编号
    BYTE               byRes[28]; // 保留字节   
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

//交通统计信息报警(扩展)
typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwRelativeTime;  // 相对时标
    DWORD                 dwAbsTime;       // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;     // 前端设备信息
    NET_DVR_TPS_INFO_V41  struTPSInfo;     // 交通参数统计信息 
    //监测点编号（路口编号、内部编号）
    BYTE           byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE           byDeviceID[DEVICE_ID_LEN/*48*/];//设备编号 
    DWORD                dwStartTime;  // 开始统计时间
    DWORD                dwStopTime;    // 结束统计时间
    BYTE                   byRes[24];      // 保留
} NET_DVR_TPS_ALARM_V41,*LPNET_DVR_TPS_ALARM_V41;

/*******************************智能交通事件 end*****************************************/

#define XXX_MAJOR_VERSION      2

/* 子版本号，性能优化、局部结构调整、模块内集成其他库的主版本提升时递增，最大31 */

#define XXX_SUB_VERSION        3

/* 修正版本号，修正bug后递增，最大31 */

#define XXX_REVISION_VERSION   4

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;        // 主版本号
    WORD    wMinorVersion;        // 次版本号
    WORD    wRevisionNumber;    // 修正号
    WORD    wBuildNumber;        // 编译号
    WORD    wVersionYear;        //    版本日期-年
    BYTE    byVersionMonth;        //    版本日期-月
    BYTE    byVersionDay;        //    版本日期-日
    BYTE    byRes[8];            // 保留字节
}NET_DVR_VCA_VERSION, *LPNET_DVR_VCA_VERSION;


/******************************智能 end***********************************/

/******************************车牌识别 begin******************************************/
typedef struct tagNET_DVR_PLATE_PARAM
{    
    BYTE    byPlateRecoMode;    //车牌识别的模式,默认为1(视频触发模式)
    BYTE    byBelive;            //整牌置信度阈值, 只用于视频识别方式, 根据背景复杂程度设置, 误触发率高就设高, 漏车率高就设低, 建议在80-90范围内
    BYTE    byRes[22];          //保留字节
}NET_DVR_PALTE_PARAM, *LPNET_DVR_PALTE_PARAM;

typedef struct tagNET_DVR_PLATECFG
{    
    DWORD        dwSize;
    DWORD    dwEnable;                           /* 是否启用视频车牌识别 0－否 1－是 */
    BYTE    byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];  // 保留字节
    NET_DVR_JPEGPARA struPictureParam;         //图片规格结构
    NET_DVR_PALTE_PARAM struPlateParam;   // 车牌识别参数配置
    NET_DVR_HANDLEEXCEPTION struHandleType;       /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE    byRelRecordChan[MAX_CHANNUM];        //报警触发的录象通道,为1表示触发该通道
    BYTE   byRes[20];   // 保留字节
}NET_DVR_PLATECFG, *LPNET_DVR_PLATECFG;

// 车牌识别结果子结构
typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;                    //车牌类型
    BYTE  byColor;                        //车牌颜色
    BYTE  byBright;                        //车牌亮度
    BYTE  byLicenseLen;                    //车牌字符个数
    BYTE  byEntireBelieve;                //整个车牌的置信度，-100
    BYTE  byRegion;     // 区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,0xff-所有
    BYTE  byCountry;     // 国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, //ALL  全部"）
    BYTE  byRes[33];                    //保留
    NET_VCA_RECT    struPlateRect;        //车牌位置
    char sLicense[MAX_LICENSE_LEN];        //车牌号码
    BYTE byBelieve[MAX_LICENSE_LEN];    //各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
}NET_DVR_PLATE_INFO, *LPNET_DVR_PLATE_INFO;

typedef struct tagNET_DVR_PLATERECO_RESULE
{
    DWORD dwSize;
    DWORD    dwRelativeTime;                //相对时标
    DWORD    dwAbsTime;                        //绝对时标
    NET_VCA_DEV_INFO struDevInfo;           // 前段设备信息
    NET_DVR_PLATE_INFO struPlateInfo;
    DWORD dwPicDataLen;                        //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    DWORD dwRes[4];                            //保留，设置为0
    BYTE  *pImage;                           //指向图片的指针
}NET_DVR_PLATERECO_RESULE, *LPNET_DVR_PLATERECO_RESULE;

/******************************车牌识别 end******************************************/

/*******************************视频综合平台***********************************/
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //Main type 1-alarm; 2-abnormal; 3-operation; 0xff-all 
    DWORD    dwMinorType;    //Hypo-Type 0-all;
    BYTE    sPanelUser[MAX_NAMELEN]; //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN];//user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr;//remote host IP
    DWORD    dwParaType;//parameter type
    DWORD    dwChannel;//channel number
    DWORD    dwDiskNumber;//HD number
    DWORD    dwAlarmInPort;//alarm input port
    DWORD    dwAlarmOutPort;//alarm output port
    DWORD   dwInfoLen;
    BYTE    byDevSequence;//槽位号
    BYTE    byMacAddr[MACADDR_LEN];//MAC地址,6
    BYTE    sSerialNumber[SERIALNO_LEN];//序列号，48
    char    sInfo[LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1 ];
}NET_DVR_LOG_MATRIX, *LPNET_DVR_LOG_MATRIX;

//2009-11-21 视频综合平台
typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition;//搜索条件，0-按槽位号搜索，1-按序列号搜索，2-按MAC地址进行搜索
    //槽位号，0-79：对应子系统的槽位号；
    //0xff：表示搜索所有的日志，包括78K和所有6467；
    //0xfe：表示搜索78K上的日志；0xfd：子域日志；0xfc：域日志。。
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN];//序列号，48
    BYTE  byMacAddr[MACADDR_LEN];//MAC地址,6
} NET_DVR_VEDIOPLATLOG, *LPNET_DVR_VEDIOPLATLOG;

typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion;//能力集版本号，高16位表示主版本，低16位表示次版本 
    DWORD dwSupportMaxVideoFrameRate;//单位(K)
                                     /*按位:
                                     0:定时录像；
                                     1:定时|事件触发录像 
                                     2:移动侦测录像；
                                     3:网络开关量报警录像；
                                     4:移动侦测|网络开关量报警录像；
                                     5:移动侦测&网络开关量报警录像；
                                     6:周界防范触发录像；
                                     7:人脸检测触发录像；
                                     8:车牌识别触发录像；
    9:手动录像*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode;//按位:第0位:表示主码流，第1位:表示子码流
    BYTE  bySupportStringRow;//支持字符叠加行数
    BYTE  bySupportHideNum;//支持视频遮挡数量
    BYTE  byRes1;
    /*0-DCIF，1-CIF，2-QCIF，3-4CIF，4-2CIF，6-QVGA(320*240), 16-VGA，17-UXGA，18-SVGA，19-HD720p，20-XVGA，21-HD900p，22-SXGAp，27-HD1080i，28-2560*1920，29-1600*304，30-2048*1536，31-2448*2048，32-2448*1200，33-2448*800 ，34-XGA（1024x768），35-SXGA（1280x1024）*/
    BYTE  byMainStreamSupportResolution[8];//主码流支持的分辨率，按位
    BYTE  bySubStreamSupportResolution[8];//子码流支持的分辨率，按位
    BYTE  byEventStreamSupportResolution[8];//事件触发码流支持的分辨率，按位
    BYTE  byNotSupportPreview;//是否支持预览,1-不支持，0-支持
    BYTE  byNotSupportStorage;//是否支持存储,1-不支持，0-支持
    BYTE  byRes2[98];//保留        
}NET_DVR_CODESYSTEMABILITY, *LPNET_DVR_CODESYSTEMABILITY;

/********************************end*******************************************/

/******************************抓拍机*******************************************/
//IO输入配置
typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus;//输入的IO口状态，0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE    byRes[3];//保留字节
}NET_DVR_IO_INCFG, *LPNET_DVR_IO_INCFG;

//IO输出配置
typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus;//IO默认状态：0-低电平，1-高电平 
    BYTE    byIoOutStatus;//IO起效时状态：0-低电平，1-高电平，2-脉冲
    WORD    wAheadTime;//输出IO提前时间，单位us
    DWORD   dwTimePluse;//脉冲间隔时间，单位us
    DWORD   dwTimeDelay;//IO有效持续时间，单位us
    BYTE    byFreqMulti;        //倍频，数值范围[1,15]
    BYTE    byDutyRate;        //占空比，[0,40%]
    BYTE    byRes[2];
}NET_DVR_IO_OUTCFG, *LPNET_DVR_IO_OUTCFG;

//闪光灯配置
typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;//闪光灯闪烁模式，0-不闪，1-闪，2-关联闪，3-轮闪
    BYTE   byRelatedIoIn;//闪光灯关联的输入IO号（关联闪时此参数有效）
    BYTE   byRecognizedLane;  /*关联的IO号，按位表示，bit0表示IO1是否关联，0-不关联，1-关联*/
    BYTE   byDetectBrightness;/*自动检测亮度使能闪光灯0-不检测；1-检测*/
    BYTE   byBrightnessThreld;/*使能闪光灯亮度阈值，范围[0,100],高于阈值闪*/
    BYTE   byStartHour;        //开始时间-小时,取值范围0-23
    BYTE   byStartMinute;        //开始时间-分,取值范围0-59
    BYTE   byEndHour;             //结束时间-小时,取值范围0-23
    BYTE   byEndMinute;        //结束时间-分,取值范围0-59
    BYTE   byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

//红绿灯功能（2个IO输入一组）
typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE    byLightIoIn;//红绿灯的IO 号
    BYTE    byTrigIoIn;//触发的IO号
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE    byTrafficLight; //0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    BYTE     bySnapTimes1; //红灯抓拍次数1，0-不抓拍，非0-连拍次数，最大5次 
    BYTE     bySnapTimes2; //绿灯抓拍次数2，0-不抓拍，非0-连拍次数，最大5次 
    BYTE    byRes1[2];
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//红灯连拍间隔时间，ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//绿灯连拍间隔时间，ms
    BYTE    byRecord;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE    bySessionTimeout;//闯红灯周期录像超时时间（秒）
    BYTE    byPreRecordTime;//闯红灯录像片段预录时间(秒)
    BYTE    byVideoDelay;//闯红灯录像片段延时时间（秒）
    BYTE    byRes2[32];//保留字节
}NET_DVR_LIGHTSNAPCFG, *LPNET_DVR_LIGHTSNAPCFG;

//测速功能(2个IO输入一组）
typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE    byTrigIo1;   //测速第1线圈
    BYTE    byTrigIo2;   //测速第2线圈
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE    byTestSpeedTimeOut;//测速模式超时时间，单位s
    DWORD   dwDistance;//线圈距离,cm
    BYTE    byCapSpeed;//测速模式起拍速度，单位km/h
    BYTE    bySpeedLimit;//限速值，单位km/h
    BYTE     bySnapTimes1; //线圈1抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    BYTE     bySnapTimes2; //线圈2抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//线圈1连拍间隔时间，ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//线圈2连拍间隔时间，ms
    BYTE    byRes[32];//保留字节
}NET_DVR_MEASURESPEEDCFG, *LPNET_DVR_MEASURESPEEDCFG;


//配置条件
typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND,*LPNET_DVR_CLOUDSTORAGE_COND;

//配置结构
typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// 云存储分配节点号
    BYTE    byRes[4];
}NET_DVR_POOLPARAM,*LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//0-不开启，1-开启
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort;//数据端口
    BYTE    byRes1[2];
    char    szUser[CLOUD_NAME_LEN/*48*/]; //用户名
    char    szPassword[CLOUD_PASSWD_LEN/*48*/];     // 密码
    NET_DVR_POOLPARAM  struPoolInfo[16];//数组0表示卡口录像池，数组1表示违章录像池，数组2表示车辆侦测数据池（IPC/D）
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG,*LPNET_DVR_CLOUDSTORAGE_CFG;

typedef  struct  tagNET_DVR_PARKLAMP_COND
{ 
    DWORD  dwSize;
    DWORD  dwChannel;   //通道号
    BYTE   byParkingIndex;   //相对车位号（1～4）
    BYTE   byRes[15];     //保留
}NET_DVR_PARKLAMP_COND, *LPNET_DVR_PARKLAMP_COND;

typedef  struct  tagNET_DVR_PARKLAMP_INFOCFG
{ 
    DWORD dwSize;
    char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    char  sParkingNo[MAX_LICENSE_LEN/*16*/];//车位编号(实际的车位编号)
    BYTE   byLampFlicker;//0~不闪烁 1 ～闪烁 (车位指示灯闪烁)
    BYTE   byLampColor;//0- 灭 1-红 2-绿  3-黄  4-蓝 5-品红 6-青 7-白色  (车位指示灯颜色)
    BYTE   byStatus; //车位状态 0-无车，1-有车
    BYTE   byColorDepth; //车身颜色深浅，0-深色，1-浅色
    BYTE   byColor;//车身颜色，0-其他色，1-白色，2-银色，3-灰色，4-黑色，5-红色，6-深蓝，7-蓝色，8-黄色，9-绿色，10-棕色，11-粉色，12-紫色，0xff-未进行车身颜色识别 
    //车辆品牌类型识别； 参考枚举类型 VLR_VEHICLE_CLASS
    BYTE   byVehicleLogoRecog; 
    BYTE   byRes[250];//保留
}NET_DVR_PARKLAMP_INFOCFG, *LPNET_DVR_PARKLAMP_INFOCFG;

//视频参数配置
typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel; /*0-100*/
    BYTE byContrastLevel; /*0-100*/
    BYTE bySharpnessLevel; /*0-100*/
    BYTE bySaturationLevel; /*0-100*/
    BYTE byHueLevel; /*0-100,（保留）*/
    BYTE byEnableFunc; //使能，按位表示，bit0-SMART IR(防过曝)，bit1-低照度,bit2-强光抑制使能，0-否，1-是
    BYTE byLightInhibitLevel; //强光抑制等级，[1-3]表示等级
    BYTE byGrayLevel; //灰度值域，0-[0-255]，1-[16-235]
}NET_DVR_VIDEOEFFECT, *LPNET_DVR_VIDEOEFFECT;

//增益配置
typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel; /*增益：0-100*/
    BYTE byGainUserSet; /*用户自定义增益；0-100，对于抓拍机，是CCD模式下的抓拍增益*/
    BYTE byRes[2];
    DWORD dwMaxGainValue;/*最大增益值，单位dB*/
}NET_DVR_GAIN, *LPNET_DVR_GAIN;

//白平衡配置
typedef struct tagNET_DVR_WHITEBALANCE
{
BYTE byWhiteBalanceMode; /*0-手动白平衡（MWB）,1-自动白平衡1（AWB1）,2-自动白平衡2 (AWB2),3-自动控制改名为锁定白平衡(Locked WB)，
                         4-室外(Indoor)，5-室内(Outdoor)6-日光灯(Fluorescent Lamp)，7-钠灯(Sodium Lamp)，
                         8-自动跟踪(Auto-Track)9-一次白平衡(One Push)，10-室外自动(Auto-Outdoor)，
                         11-钠灯自动 (Auto-Sodiumlight)，12-水银灯(Mercury Lamp)，13-自动白平衡(Auto)，
14-白炽灯 (IncandescentLamp)，15-暖光灯(Warm Light Lamp)，16-自然光(Natural Light) */
BYTE byWhiteBalanceModeRGain; /*手动白平衡时有效，手动白平衡 R增益*/
BYTE byWhiteBalanceModeBGain; /*手动白平衡时有效，手动白平衡 B增益*/
BYTE byRes[5];
}NET_DVR_WHITEBALANCE, *LPNET_DVR_WHITEBALANCE;

//曝光控制
typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode; /*0 手动曝光 1自动曝光*/
    BYTE  byAutoApertureLevel; /* 自动光圈灵敏度, 0-10 */ 
    BYTE  byRes[2];
    DWORD dwVideoExposureSet; /* 自定义视频曝光时间（单位us）*//*注:自动曝光时该值为曝光最慢值 新增20-1s(1000000us)*/        
    DWORD dwExposureUserSet; /* 自定义曝光时间,在抓拍机上应用时，CCD模式时是抓拍快门速度*/   
    DWORD dwRes;    
} NET_DVR_EXPOSURE, *LPNET_DVR_EXPOSURE;

//宽动态配置
typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled; /*宽动态：0 dsibale  1 enable 2 auto*/
    BYTE byWDRLevel1; /*0-F*/
    BYTE byWDRLevel2; /*0-F*/
    BYTE byWDRContrastLevel; /*0-100*/
    BYTE byRes[16];
} NET_DVR_WDR, *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;   //结构体大小
    NET_DVR_WDR  struWDR; //配置信息
}NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;


//日夜转换功能配置
typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType; /*日夜切换：0-白天，1-夜晚，2-自动，3-定时，4-报警输入触发, 5-自动模式2（无光敏）*/
    BYTE bySwitchScheduleEnabled; /*0 dsibale  1 enable,(保留)*/
    //定时模式参数
    BYTE byBeginTime; /*开始时间（小时），0-23*/
    BYTE byEndTime; /*结束时间（小时），0-23*/
    //模式2
    BYTE byDayToNightFilterLevel; //0-7
    BYTE byNightToDayFilterLevel; //0-7
    BYTE byDayNightFilterTime;//(60秒)
    //定时模式参数
    BYTE byBeginTimeMin; //开始时间（分），0-59
    BYTE byBeginTimeSec; //开始时间（秒），0-59
    BYTE byEndTimeMin; //结束时间（分），0-59
    BYTE byEndTimeSec; //结束时间（秒），0-59
    //报警输入触发模式参数
    BYTE byAlarmTrigState; //报警输入触发状态，0-白天，1-夜晚
} NET_DVR_DAYNIGHT, *LPNET_DVR_DAYNIGHT;

//Gamma校正
typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled; /*0 dsibale  1 enable*/
    BYTE byGammaCorrectionLevel; /*0-100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT, *LPNET_DVR_GAMMACORRECT;

//背光补偿配置
typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode; /*背光补偿:0 off 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE、6自定义，10-开，11-自动，12-多区域背光补偿*/
    BYTE byBacklightLevel; /*0x0-0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1; //（X坐标1）
    DWORD dwPositionY1; //（Y坐标1）
    DWORD dwPositionX2; //（X坐标2）
    DWORD dwPositionY2; //（Y坐标2）
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT, *LPNET_DVR_BACKLIGHT;

//数字降噪功能
typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable; /*0-不启用，1-普通模式数字降噪，2-专家模式数字降噪*/
    BYTE byDigitalNoiseRemoveLevel; /*普通模式数字降噪级别：0x0-0xF*/
    BYTE bySpectralLevel;       /*专家模式下空域强度：0-100*/
    BYTE byTemporalLevel;   /*专家模式下时域强度：0-100*/
    BYTE byDigitalNoiseRemove2DEnable;         /* 抓拍帧2D降噪，0-不启用，1-启用 */    
    BYTE byDigitalNoiseRemove2DLevel;            /* 抓拍帧2D降噪级别，0-100 */
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE, *LPNET_DVR_NOISEREMOVE;

//CMOS模式下前端镜头配置
typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;   //抓拍模式：0-抓拍模式1；1-抓拍模式2
    BYTE byBrightnessGate;//亮度阈值
    BYTE byCaptureGain1;   //抓拍增益1,0-100
    BYTE byCaptureGain2;   //抓拍增益2,0-100
    DWORD dwCaptureShutterSpeed1;//抓拍快门速度1
    DWORD dwCaptureShutterSpeed2;//抓拍快门速度2
    BYTE  byRes[4];
}NET_DVR_CMOSMODECFG, *LPNET_DVR_CMOSMODECFG;

//前端参数配置
typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*亮度、对比度、饱和度、锐度、色调配置*/    
    NET_DVR_GAIN struGain;/*自动增益*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*白平衡*/
    NET_DVR_EXPOSURE struExposure; /*曝光控制*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*Gamma校正*/
    NET_DVR_WDR struWdr;/*宽动态*/
    NET_DVR_DAYNIGHT struDayNight;/*日夜转换*/
    NET_DVR_BACKLIGHT struBackLight;/*背光补偿*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*数字降噪*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
        0-自动光圈, 
        1-手动光圈, 
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-HIK 3.8-16mm F1.5（HV3816P-8MPIR)
        6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        7-HIK 2.7-12mm F1.2（TV2712P-MPIR）
    */
    BYTE byIrisMode;  
    BYTE byMirror ;  /* 镜像：0 off，1- leftright，2- updown，3-center */
    BYTE byDigitalZoom;  /*数字缩放:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*坏点检测,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*黑电平补偿 ,  0-255*/ 
    BYTE byEptzGate;// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    BYTE byLocalOutputGate;//本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60
    BYTE byCoderOutputMode;//编码器fpga输出模式0直通3像素搬家
    BYTE byLineCoding; //是否开启行编码：0-否，1-是
    BYTE byDimmerMode; //调光模式：0-半自动，1-自动
    BYTE byPaletteMode; //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
    BYTE byEnhancedMode; //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    BYTE byDynamicContrastEN;    //动态对比度增强 0-1
    BYTE byDynamicContrast;    //动态对比度 0-100
    BYTE byJPEGQuality;    //JPEG图像质量 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOS模式下前端参数配置，镜头模式从能力集获取
    BYTE byFilterSwitch; //滤波开关：0-不启用，1-启用
    BYTE byFocusSpeed; //镜头调焦速度：0-10
    BYTE byAutoCompensationInterval; //定时自动快门补偿：1-120，单位：分钟
    BYTE bySceneMode;  //场景模式：0-室外，1-室内，2-默认，3-弱光
}NET_DVR_CAMERAPARAMCFG, *LPNET_DVR_CAMERAPARAMCFG;

//透雾
typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //模式，0-不启用，1-自动模式，2-常开模式
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

//电子防抖
typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;//使能 0- 不启用，1- 启用
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

//走廊模式
typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; //是否启用走廊模式 0～不启用， 1～启用
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

// SMART IR(防过曝)配置参数
typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0～手动，1～自动
    BYTE  byIRDistance;//红外距离等级(等级，距离正比例)level:1~100 默认:50（手动模式下增加）
    BYTE  byShortIRDistance;// 近光灯距离等级(1~100)
    BYTE  byLongIRDistance;// 远光灯距离等级(1~100)
}NET_DVR_SMARTIR_PARAM,*LPNET_DVR_SMARTIR_PARAM;

//在byIrisMode 为P-Iris1时生效，配置红外光圈大小等级，配置模式
typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0-自动，1-手动
    BYTE  byPIrisAperture;//红外光圈大小等级(等级,光圈大小正比例)level:1~100 默认:50（手动模式下增加）
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM,*LPNET_DVR_PIRIS_PARAM;


//激光参数配置 2014-02-25
typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE    byControlMode;        //控制模式            0-无效，1-自动，2-手动 默认自动
    BYTE    bySensitivity;        //激光灯灵敏度        0-100 默认50
    BYTE    byTriggerMode;        //激光灯触发模式    0-无效，1-机芯触发，2-光敏触发 默认机芯触发
    BYTE    byBrightness;        //控制模式为手动模式下有效；激光灯亮度        0-255 默认100
    BYTE    byAngle;            //激光灯角度        0-无效，范围1-36  默认12，激光灯照射范围为一个圆圈，调节激光角度是调节这个圆的半径的大小
    BYTE    byLimitBrightness;  //控制模式为自动模式下有效；激光灯亮度限制 0~100 （新增）2014-01-26
    BYTE    byEnabled ;         //手动控制激光灯使能 0-关闭，1-启动
    BYTE    byIllumination;     //激光灯强度配置0~100
    BYTE    byLightAngle;       //补光角度 0~100
    BYTE    byRes[7];           //保留
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off 
    BYTE   byMode;
    //（时间:按能力显示，单位分钟，选项有10,20,30,40,50,60,120,180,240）
    BYTE   byRes1;
    WORD   wCompensateTime; //定时模式下生效
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM,*LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM   //在sensor中完成
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//普通模式等级范围[1,100]，普通模式下生效
    BYTE  byExpertLevel;//专家模式等级范围[1,100]，专家模式下生效
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM,*LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//亮度等级[1,100]；手动模式下生效
    BYTE  byGainLevel; //增益等级[1,100]；手动模式下生效
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM,*LPNET_DVR_AGC_PARAM;

//抓拍机CCD参数 共64字节
typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG 
{
    BYTE byWDRMode;   // 宽动态模式;0~关闭，1~数字宽动态 2~宽动态
    BYTE byWDRType;    // 宽动态切换模式; 0~强制启用，1~按时间启用，2~按亮度启用
    BYTE byWDRLevel;   // 宽动态等级，0~6索引对应1-7，默认索引2（即3级）；
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //开始宽动态时间
    NET_DVR_TIME_EX struEndTime; //结束宽动态时间
    BYTE byDayNightBrightness; //日夜转换亮度阈值，0-100，默认50；
    //记忆色增强
    BYTE byMCEEnabled;//记忆色增强使能，true：开启，false：关闭
    BYTE byMCELevel;//记忆色增强强度，0~100，默认值50
    //自动对比度
    BYTE byAutoContrastEnabled;//自动对比度使能，true：开启，false：关闭
    BYTE byAutoContrastLevel;//自动对比等级（0-100）,默认50
    //细节增强
    BYTE byLSEDetailEnabled;//细节增强使能，true：开启，false：关闭
    BYTE byLSEDetailLevel;//细节增强等级（0-100）,默认50
    // License Plate Definition Enhancement车牌增强
    BYTE byLPDEEnabled;//车牌增强使能，true：开启，false：关闭
    BYTE byLPDELevel;//车牌增强等级（0-100）,默认50
    BYTE byRes[35];
} NET_DVR_SNAP_CAMERAPARAMCFG,*LPNET_DVR_SNAP_CAMERAPARAMCFG;

//光学透雾参数
typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~不启用光学透雾，1~启用光学透雾
    BYTE byRes[7]; 
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

//前端参数配置
typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*亮度、对比度、饱和度、锐度、色调配置*/    
    NET_DVR_GAIN struGain;/*自动增益*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*白平衡*/
    NET_DVR_EXPOSURE struExposure; /*曝光控制*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*Gamma校正*/
    NET_DVR_WDR struWdr;/*宽动态*/
    NET_DVR_DAYNIGHT struDayNight;/*日夜转换*/
    NET_DVR_BACKLIGHT struBackLight;/*背光补偿*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*数字降噪*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    BYTE byIrisMode; /*0-自动光圈 1-手动光圈, 2-P-Iris1, 3-Union 3-9mm F1.6-2.7 (T5280-PQ1), 4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1),5-HIK 3.8-16mm F1.5（HV3816P-8MPIR）*/ 
    BYTE byMirror ;  /* 镜像：0 off，1- leftright，2- updown，3-center 4-Auto*/
    BYTE byDigitalZoom;  /*数字缩放:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*坏点检测,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*黑电平补偿 ,  0-255*/ 
    BYTE byEptzGate;// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    BYTE byLocalOutputGate;//本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    BYTE byCoderOutputMode;//编码器fpga输出模式0直通3像素搬家
    BYTE byLineCoding; //是否开启行编码：0-否，1-是
    BYTE byDimmerMode; //调光模式：0-半自动，1-自动
    BYTE byPaletteMode; //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8, 9-融合1,10-彩虹,11-融合2,12-铁红1,13-铁红2,14-深褐色,15-色彩1,16-色彩2,17-冰火,18-雨,19-红热,20-绿热
    BYTE byEnhancedMode; //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    BYTE byDynamicContrastEN;    //动态对比度增强 0-1
    BYTE byDynamicContrast;    //动态对比度 0-100
    BYTE byJPEGQuality;    //JPEG图像质量 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOS模式下前端参数配置，镜头模式从能力集获取
    BYTE byFilterSwitch; //滤波开关：0-不启用，1-启用
    BYTE byFocusSpeed; //镜头调焦速度：0-10
    BYTE byAutoCompensationInterval; //定时自动快门补偿：1-120，单位：分钟
    BYTE bySceneMode;  //场景模式：0-室外，1-室内，2-默认，3-弱光
    NET_DVR_DEFOGCFG struDefogCfg;//透雾参数
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//电子防抖
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//走廊模式
    BYTE   byExposureSegmentEnable; //0~不启用,1~启用  曝光时间和增益呈阶梯状调整，比如曝光往上调整时，先提高曝光时间到中间值，然后提高增益到中间值，再提高曝光到最大值，最后提高增益到最大值
    BYTE   byBrightCompensate;//亮度增强 [0~100]
    /*
    0-关闭、1-640*480@25fps、2-640*480@30ps、3-704*576@25fps、4-704*480@30fps、5-1280*720@25fps、6-1280*720@30fps、
    7-1280*720@50fps、8-1280*720@60fps、9-1280*960@15fps、10-1280*960@25fps、11-1280*960@30fps、
    12-1280*1024@25fps、13--1280*1024@30fps、14-1600*900@15fps、15-1600*1200@15fps、16-1920*1080@15fps、
    17-1920*1080@25fps、18-1920*1080@30fps、19-1920*1080@50fps、20-1920*1080@60fps、21-2048*1536@15fps、22-2048*1536@20fps、
    23-2048*1536@24fps、24-2048*1536@25fps、25-2048*1536@30fps、26-2560*2048@25fps、27-2560*2048@30fps、
    28-2560*1920@7.5fps、29-3072*2048@25fps、30-3072*2048@30fps、31-2048*1536@12.5、32-2560*1920@6.25、
    33-1600*1200@25、34-1600*1200@30、35-1600*1200@12.5、36-1600*900@12.5、37-1280*960@12.5fps、38-800*600@25fps、39-800*600@30fps40、
    4000*3000@12.5fps、41-4000*3000@15fps、42-4096*2160@20fps、43-3840x2160@20fps 、44-960*576@25fps、45-960*480@30fps、46-752*582@25fps、
    47-768*494@30fps、48-2560*1440@25fps、49-2560*1440@30fps 、50-720P@100fps、51-720P@120fps、52-2048*1536@50fps、53-2048*1536@60fps、
    54-3840*2160@25fps、55-3840*2160@30fps、56-4096*2160@25fps、57-4096*2160@30fps 、58-1280*1024@50fps、59-1280*1024@60fps、
    60-3072*2048@50fps、61-3072*2048@60fps、62-3072*1728@25fps、63-3072*1728@30fps、64-3072*1728@50fps、65-3072*1728@60fps、66-336*256@50fps、67-336*256@60fps、
    68-384*288@50fps、69-384*288@60fps 、70- 640 * 512@50fps 、71- 640 * 512@60fps、72-2592*1944@25fps、73-2592*1944@30fps、74-2688*1536@25fps、75-2688*1536@30fps 
    76-2592*1944@20fps、77-2592*1944@15fps、78-2688*1520@20fps、79-2688*1520@15fps、80-2688*1520@25fps、81-2688*1520@30fps、82- 2720*2048@25fps、 83- 2720*2048@30fps、
    84-336*256@25fps、85- 384*288@25fps、86-640*512@25fps、87-1280*960@50fps、88-1280*960@60fps、89-1280*960@100fps、90-1280*960@120fps、91-4000*3000@20fps、
    92-1920*1200@25fps、93-1920*1200@30fps、94-2560*1920@25fps、95-2560*1920@20fps、96-2560*1920@30fps、97-1280*1920@25fps、98-1280*1920@30fps
    99-4000*3000@24fps、100-4000*3000@25fps、101-4000*3000@10fps、102- 384*288@30fps、103-2560*1920@15fps、104-2400*3840@25fps、105-1200*1920@25fps
    106-4096*1800@30fps、107-3840*1680@30fps、108-2560*1120@30fps、109-704*320@30fps、110-1280*560@30fps、111-4096*1800@25fps、112-3840*1680@25fps
    113-2560*1120@25fps、114-704*320@25fps、115-1280*560@25fps、116-2400*3840@24fps、117-3840*2400@24fps、118-3840*2400@25fps、119-2560*1920@12.5fps
    120-2560*2048@12fps、121-2560*2048@15fps、122-2560*1536@25fps、123-2560*1536@30fps、124-2256*2048@25fps、125-2256*2048@30fps、126-2592*2592@12.5fps、127-2592*2592@15fps、
    128 - 640*512@30fps、129-2048*1520@30fps、130-2048*1520@25fps、131-3840*2160@24fps*/
    BYTE   byCaptureModeN; //视频输入模式（N制）
    BYTE   byCaptureModeP; //视频输入模式（P制）
    NET_DVR_SMARTIR_PARAM struSmartIRParam; //红外放过爆配置信息
    NET_DVR_PIRIS_PARAM struPIrisParam;//PIris配置信息对应byIrisMode字段从2-PIris1开始生效
    //2014-02-25 新增参数
    NET_DVR_LASER_PARAM_CFG struLaserParam;    //激光参数
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//镜头畸变校正 0-关闭,1-开启
    BYTE   byRes1[3]; 
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD ; //抓拍机CCD参数，只用于抓拍机
    NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//光学透雾参数
    BYTE   byRes2[180];
}NET_DVR_CAMERAPARAMCFG_EX, *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD   dwSize;
    BYTE    byState;//聚焦到位状态参数 0-不到位，1-到位
    BYTE    byRes[31];    
}NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;

typedef enum _VCA_PLATE_COLOR_
{
    VCA_BLUE_PLATE  = 0,   //蓝色车牌
        VCA_YELLOW_PLATE,      //黄色车牌
        VCA_WHITE_PLATE,       //白色车牌
        VCA_BLACK_PLATE,       //黑色车牌
        VCA_GREEN_PLATE,       //绿色车牌
        VCA_BKAIR_PLATE,       //民航黑色车牌
        VCA_OTHER = 0xff       //其他
}VCA_PLATE_COLOR;

//车牌类型
typedef enum _VCA_PLATE_TYPE_
{
    VCA_STANDARD92_PLATE = 0,    //标准民用车与军车
        VCA_STANDARD02_PLATE,        //02式民用车牌 
        VCA_WJPOLICE_PLATE,            //武警车 
        VCA_JINGCHE_PLATE,            //警车
        STANDARD92_BACK_PLATE,         //民用车双行尾牌
        VCA_SHIGUAN_PLATE,          //使馆车牌
        VCA_NONGYONG_PLATE,         //农用车
        VCA_MOTO_PLATE              //摩托车
}VCA_PLATE_TYPE;

//车型识别结果
typedef enum _VTR_RESULT
{
    VTR_RESULT_OTHER      =  0,  //未知
    VTR_RESULT_BUS        =  1,  //客车
    VTR_RESULT_TRUCK      =  2,  //货车
    VTR_RESULT_CAR        =  3,  //轿车
    VTR_RESULT_MINIBUS    =  4,  //面包车
    VTR_RESULT_SMALLTRUCK =  5,  //小货车
    VTR_RESULT_HUMAN      =  6,  //行人
    VTR_RESULT_TUMBREL    =  7,  //二轮车
    VTR_RESULT_TRIKE      =  8,  //三轮车
    VTR_RESULT_SUV_MPV    =  9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS =  10,  //中型客车
    VTR_RESULT_MOTOR_VEHICLE = 11, //机动车
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //非机动车
    VTR_RESULT_SMALLCAR   = 13,   //小型轿车
    VTR_RESULT_MICROCAR   = 14,   //微型轿车
    VTR_RESULT_PICKUP     = 15    //皮卡车
}VTR_RESULT;


//车身颜色
typedef enum _VCR_CLR_CLASS
{
    VCR_CLR_UNSUPPORT  = 0,      //不支持
        VCR_CLR_WHITE       = 1,   //白
        VCR_CLR_SILVER        = 2,   //银
        VCR_CLR_GRAY       = 3,      //灰
        VCR_CLR_BLACK      = 4,      //黑
        VCR_CLR_RED           = 5,      //红
        VCR_CLR_DARKBLUE   = 6,      //深蓝
        VCR_CLR_BLUE       = 7,      //蓝
        VCR_CLR_YELLOW     = 8,      //黄
        VCR_CLR_GREEN      = 9,      //绿
        VCR_CLR_BROWN      = 10,  //棕
        VCR_CLR_PINK       = 11,  //粉
        VCR_CLR_PURPLE     = 12,  //紫
        VCR_CLR_DARKGRAY   = 13,  //深灰
        VCR_CLR_CYAN       = 14  //青色
}VCR_CLR_CLASS;

//车辆操作类型 2013-11-04
typedef enum _VCA_OPERATE_TYPE_
{
    VCA_LICENSE_TYPE       = 0x1,  //车牌号码
        VCA_PLATECOLOR_TYPE    = 0x2,  //车牌颜色
        VCA_CARDNO_TYPE        = 0x4,  //卡号
        VCA_PLATETYPE_TYPE     = 0x8,  //车牌类型
        VCA_LISTTYPE_TYPE      = 0x10, //车辆名单类型
        VCA_INDEX_TYPE         = 0x20, //数据流水号 2014-02-25
        VCA_OPERATE_INDEX_TYPE = 0x40  //操作数 2014-03-03
}VCA_OPERATE_TYPE;

typedef enum _VCA_ILLEGAL_TYPE_
{
    VCA_POSTPIC_TYPE          = 0x1, //卡口图片
        VCA_LOWSPEED_TYPE         = 0x2,  //低速
        VCA_HIGHSPEED_TYPE        = 0x4,  //高速
        VCA_RETROGRADE_TYPE       = 0x8,  //逆行
        VCA_RUSH_REDLIGHT_TYPE    = 0x10,   //闯红灯
        VCA_PRESS_LANE_TYPE       = 0x20, //压车道线
        VCA_VIOLATE_GUIDE_TYPE    = 0x40,//不按导向
        VCA_ROAD_STRAND_TYPE      = 0x80,//路口滞留(设备不支持)
        VCA_VEHICLE_ILLEGAL_LANE_TYPE  = 0x100,//机占非
        VCA_ILLEGAL_LANE_CHANGE_TYPE   = 0x200,//违法变道
        VCA_ILLEGAL_LANE_DRIVE_TYPE    = 0x400,//不按车道
        VCA_VIOLATE_BAN_TYPE           = 0x800,//违法禁令
        VCA_CROSS_PARKING_TYPE         = 0x1000,//路口停车
        VCA_GREEN_PARKING_TYPE         = 0x2000//绿灯停车
}VCA_ILLEGAL_TYPE;

typedef enum _VCA_VEHICLE_TYPE_
{
    VCA_OTHER_TYPE          = 0x1,  //其它车型
        VCA_SMALLCAR_TYPE       = 0x2,  //小型车
        VCA_BIGCAR_TYPE         = 0x4,  //大型车
        VCA_BUS_TYPE            = 0x8,  //客车
        VCA_TRUCK_TYPE          = 0x10,  //货车
        VCA_CAR_TYPE            = 0x20,   //轿车
        VCA_MINIBUS_TYPE        = 0x40,   //面包车
        VCA_SMALL_TRUCK_TYPE    = 0x80  //小货车
}VCA_VEHICLE_TYPE;

//车辆品牌主类型
typedef enum _VLR_VEHICLE_CLASS
{
    VLR_OTHER       = 0,    //其它
        VLR_VOLKSWAGEN  = 1,    //大众
        VLR_BUICK       = 2,    //别克
        VLR_BMW         = 3,    //宝马
        VLR_HONDA       = 4,    //本田
        VLR_PEUGEOT     = 5,    //标致
        VLR_TOYOTA      = 6,    //丰田
        VLR_FORD        = 7,    //福特
        VLR_NISSAN      = 8,    //日产
        VLR_AUDI        = 9,    //奥迪
        VLR_MAZDA       = 10,   //马自达
        VLR_CHEVROLET   = 11,   //雪佛兰
        VLR_CITROEN     = 12,   //雪铁龙
        VLR_HYUNDAI     = 13,   //现代
        VLR_CHERY       = 14,   //奇瑞
        VLR_KIA         = 15,   //起亚
        VLR_ROEWE       = 16,   //荣威
        VLR_MITSUBISHI  = 17,   //三菱
        VLR_SKODA       = 18,   //斯柯达
        VLR_GEELY       = 19,   //吉利
        VLR_ZHONGHUA    = 20,   //中华
        VLR_VOLVO       = 21,   //沃尔沃
        VLR_LEXUS       = 22,   //雷克萨斯
        VLR_FIAT        = 23,   //菲亚特
        VLR_EMGRAND     = 24,   //帝豪(吉利)
        VLR_DONGFENG    = 25,   //东风
        VLR_BYD         = 26,   //比亚迪
        VLR_SUZUKI      = 27,   //铃木
        VLR_JINBEI      = 28,   //金杯
        VLR_HAIMA       = 29,   //海马
        VLR_SGMW        = 30,   //五菱
        VLR_JAC         = 31,   //江淮
        VLR_SUBARU      = 32,   //斯巴鲁
        VLR_ENGLON      = 33,   //英伦(吉利)
        VLR_GREATWALL   = 34,   //长城
        VLR_HAFEI       = 35,   //哈飞
        VLR_ISUZU       = 36,   //五十铃(庆铃)
        VLR_SOUEAST     = 37,   //东南
        VLR_CHANA       = 38,   //长安
        VLR_FOTON       = 39,   //福田
        VLR_XIALI       = 40,   //夏利(一汽)
        VLR_BENZ        = 41,   //奔驰
        VLR_FAW         = 42,   //一汽
        VLR_NAVECO      = 43,   //依维柯
        VLR_LIFAN       = 44,   //力帆
        VLR_BESTURN     = 45,   //一汽奔腾(一汽)
        VLR_CROWN       = 46,   //皇冠(丰田)
        VLR_RENAULT     = 47,   //雷诺
        VLR_JMC         = 48,   //JMC(江铃)
        VLR_MG          = 49,   //MG名爵
        VLR_KAMA        = 50,   //凯马
        VLR_ZOTYE       = 51,   //众泰
        VLR_CHANGHE     = 52,   //昌河
        VLR_XMKINGLONG  = 53,   //厦门金龙(金旅)
        VLR_HUIZHONG    = 54,   //上海汇众(上汽集团)
        VLR_SZKINGLONG  = 55,   //苏州金龙
        VLR_HIGER       = 56,   //海格
        VLR_YUTONG      = 57,   //宇通
        VLR_CNHTC       = 58,   //中国重汽
        VLR_BEIBEN      = 59,   //北奔重卡
        VLR_XINGMA      = 60,   //华菱星马
        VLR_YUEJIN      = 61,   //跃进
        VLR_HUANGHAI    = 62,   //黄海
        VLR_OLDWALL     = 63,   //老款长城
        VLR_CHANACOMMERCIAL = 64,   //长安商用
        VLR_PORSCHE                   = 65,               // 保时捷
        VLR_CADILLAC                  = 66,               // 凯迪拉克
        VLR_INFINITI                  = 67,               // 英菲尼迪
        VLR_GLEAGLE                   = 68,               // 吉利全球鹰(吉利)
        VLR_JEEP                      = 69,               // JEEP(吉普)
        VLR_LANDROVER                 = 70,               // 路虎
        VLR_CHANGFENG                 = 71,               // 长丰
        VLR_BENNI                     = 72,               // 长安奔奔(长安)
        VLR_ERA                       = 73,               // 福田时代(时代)
        VLR_TAURUS                    = 74,               // 长安金牛星(长安商用)
        VLR_EADO                      = 75,               // 长安逸动
        VLR_SHANQI                    = 76,               // 陕汽
        VLR_HONGYAN                   = 77,               // 红岩汽车(上汽依维柯红岩)
        VLR_DRAGON                    = 78,               // 霸龙汽车(东风柳汽)
        VLR_JACTEXT                   = 79,               // 江淮JAC (江淮)
        VLR_JACBUS                    = 80,               // 江淮现代客车 (江淮)
        VLR_ANKAI                     = 81,               // 安凯客车
        VLR_SHENLONG                  = 82,               // 申龙客车
        VLR_DAEWOO                    = 83,               // 大宇客车
        VLR_WUZHENG                   = 84,               // 五征汽车
        VLR_MAN                       = 85,               // MAN汽车
        VLR_ZHONGTONG                 = 86,               // 中通客车
        VLR_BAOJUN                    = 87,               // 宝骏
        VLR_BQWEIWANG                 = 88,               // 北汽威旺
        VLR_TRUMPCHE                  = 89,               // 传祺
        VLR_LUFENG                    = 90,               // 陆风
        VLR_HMZHENGZHOU               = 91,               // 海马郑州
        VLR_BEIJING                   = 92,               // 北京汽车
        VLR_ZHONGSHUN                 = 93,               // 中顺
        VLR_WEILIN                    = 94,               // 威麟汽车
        VLR_OPEL                      = 95,               // 欧宝
        VLR_KARRY                     = 96,               // 开瑞
        VLR_SMA                       = 97,               // 华普汽车
        VLR_SMATEXT                   = 98,               // 华普汽车文字SMA
        VLR_YUWIN                     = 99,               // 江铃驭胜
        VLR_MINI                      = 100,               // 宝马MINI
        VLR_MARK                      = 101,               // 丰田MARKX 
        VLR_HAVAL                     = 102,               // 哈弗HAVAL
        VLR_OGA                       = 103,               // 讴歌
        VLR_VENUCIA                   = 104,               // 启辰
        VLR_BYD2                      = 105,               // 比亚迪样式2 (比亚迪)
        VLR_SMART                     = 106,               // 奔驰SMART
        VLR_BAW                       = 107,               // 北京汽车制造厂BAW
        VLR_LUXGEN                    = 108,               // 纳智捷
        VLR_YEMA                      = 109,               // 野马
        VLR_ZTE                       = 110,               // 中兴
        VLR_EVERUS                    = 111,               // 理念
        VLR_CHRYSLER                  = 112,               // 克莱斯勒
        VLR_GONOW                     = 113,               // 吉奥汽车
        VLR_SHJIANG                   = 114,               // 松花江
        VLR_RUILIN                    = 115,               // 瑞麟
        VLR_FORTA                     = 116,               // 福达
        VLR_GAGUAR                    = 117,               // 捷豹
        VLR_HEIBAO                    = 118,               // 黑豹
        VLR_TKING                     = 119,               // 唐骏
        VLR_TKINGTEXT                 = 120,               // 唐骏文字
        VLR_FODAY                     = 121,               // 福迪
        VLR_LOTUS                     = 122,               // 莲花汽车
        VLR_NANJUN                    = 123,               // 南骏
        VLR_SHUANGHUAN                = 124,               // 双环汽车
        VLR_SAIBAO                    = 125,               // 哈飞赛豹
        VLR_HAWTAI                    = 126,               // 华泰
        VLR_LIFO                      = 127,               // 永源飞碟
        VLR_JONWAY                    = 128,               // 永源汽车
        VLR_FULONGMA                  = 129,               // 福龙马
        VLR_WEILI                     = 130,               // 潍力
        VLR_ANCHI                     = 131,               // 江淮安驰
        VLR_PAIXI                     = 132,               // 派喜
        VLR_HIGERTEXT                 = 133,               // 海格HIGER文字
        VLR_RIYECAR                   = 134,               // 广汽日野轻卡
        VLR_RIYETRUCK                 = 135,               // 广汽日野重卡
        VLR_JIANGNAN                  = 136,               // 江南
        VLR_OLDZOTYE                  = 137,               // 老款众泰
        VLR_OLDXIALI                  = 138,               // 老款夏利
        VLR_NEWAOCHI                  = 139,               // 新奥驰
        VLR_CDW                       = 140,               // 王牌重汽
        VLR_CDWTEXT                   = 141,               // 王牌重汽文字
        VLR_CIIMO                     = 142,               // 本田思铭
        VLR_CHANADS                   = 143,               // 长安谛艾仕
        VLR_DS                        = 144,               // 道奇
        VLR_ROHENS                    = 145,               // 现代劳恩斯酷派
        VLR_YANTAI                    = 146,               // 燕台
        VLR_SHUANGLONG                = 147,               // 双龙
        VLR_FENGLING                  = 148,               // 时代风菱
        VLR_XINKAI                    = 149,               // 新凯
        VLR_GMC                       = 150,               // GMC
        VLR_DATONG                    = 151,               // 上汽大通
        VLR_BQYINXIANG                = 152,               // 北汽银翔
        VLR_NEWCHERY                  = 153,               // 新奇瑞
        VLR_MUDAN                     = 154,               // 牡丹
        VLR_DAYUN                     = 155,               // 大运汽车
        VLR_DONGWO                    = 156,               // 东沃汽车
        VLR_UNION                     = 157,               // 联合汽车
        VLR_CHUNZHOU                  = 158,               // 春洲客车
        VLR_SANY                      = 159,               // 三一重工
        VLR_YAXING                    = 160,               // 亚星客车
        VLR_HENGTONG                  = 161,               // 恒通客车
        VLR_SHAOLIN                   = 162,               // 少林客车
        VLR_YOUNG                     = 163,               // 青年客车
        VLR_STOM                      = 164,               // 十通
        VLR_SANHUAN                   = 165,               // 三环
        VLR_XUGONG                    = 166,               // 徐工
        VLR_BEIFANG                   = 167,               // 北方汽车
        VLR_JIANGHUAN                 = 168,               // 江环货车
        VLR_BJFARM                    = 169,               // 北京农用
        VLR_NEWDADI                   = 170,               // 新大地汽车
        VLR_SUNWIN                    = 171,               // 申沃客车
        VLR_YINGTIAN                  = 172,               // 英田
        VLR_QINGQI                    = 173,               // 轻骑
        VLR_CHUFENG                   = 174,               // 楚风汽车
        VLR_SCANIA                    = 175,               // 斯堪尼亚
        VLR_JIULONG                   = 176,               // 九龙客车
        VLR_YOUYI                     = 177,               // 友谊客车
        VLR_SHANGRAO                  = 178,               // 上饶客车
        VLR_JIJIANG                   = 179,               // 吉江
        VLR_YANGZI                    = 180,               // 扬子客车
        VLR_XIWO                      = 181,               // 西沃客车
        VLR_CHANGJIANG                = 182,               // 长江客车
        VLR_WUYI                      = 183,               // 武夷
        VLR_CHENGDU                   = 184,               // 成都客车
        VLR_TIANMA                    = 185,               // 天马
        VLR_BAOLONG                   = 186,               // 宝龙
        VLR_NEWYATU                   = 187,               // 新雅途
        VLR_BARUI                     = 188,               // 起亚霸锐
        VLR_GUANZHI                   = 189,               // 观致
        VLR_XIYATE                    = 190,               // 西雅特
        VLR_BINLI                     = 191,               // 宾利
        VLR_DADI                      = 192,               // 大迪
        VLR_FUQI                      = 193,               // 富奇
        VLR_HANGTIAN                  = 194,               // 航天汽车
        VLR_HENGTIAN                  = 195,               // 恒天汽车
        VLR_JMCCAR                    = 196,               // 江铃轻汽
        VLR_KAERSEN                   = 197,               // 卡尔森汽车
        VLR_KAWEI                     = 198,               // 卡威汽车
        VLR_LANBOJINI                 = 199,               // 兰博基尼
        VLR_MASHALADI                 = 200,               // 玛莎拉蒂
        VLR_SHUCHI                    = 201,               // 舒驰客车
        VLR_SHILI                     = 202,               // 实力客车
        VLR_HUABEI                    = 203,               // 中客华北
        VLR_YIZHENG                   = 204,               // 上汽仪征
        VLR_CHUNLAN                   = 205,               // 春兰汽车
        VLR_DAFA                      = 206,               // 大发汽车
        VLR_SHENYE                    = 207,               // 神野汽车
        VLR_FALALI                    = 208,               // 法拉利汽车
        VLR_FUXING                    = 209,               // 福星汽车
        VLR_ANYUAN                    = 210,               // 安源客车
        VLR_JINGHUA                   = 211,               // 京华客车
        VLR_TAIHU                     = 212,               // 太湖客车
        VLR_WUZHOULONG                = 213,               // 五洲龙
        VLR_CHANGLONG                 = 214,               // 常隆客车
        VLR_YUEXI                     = 215,               // 悦西客车
        VLR_SHENMA                    = 216,               // 神马客车
        VLR_LUSHAN                    = 217,               // 庐山牌
        VLR_WANFENG                   = 218,               // 万丰牌
        VLR_GZYUNBAO                  = 219,               // 广州云豹
        VLR_ZHONGDA                   = 220,               // 中大汽车
        VLR_THREEWHEEL                = 221,               // 三轮车
        VLR_TWOWHEEL                  = 222,               // 二轮车
        VLR_JBC                       = 223,              // 金杯JBC
        VLR_YZJIANG                   = 224,               // 扬子江客车
        VLR_CNJ                       = 225,               // 南骏CNJ
        VLR_FORLAND                   = 226,               // 福田时代文字
        VLR_FARMCAR                   = 227,               // 农用车
        VLR_DONGFANGHONG              = 228,               // 东方红
        VLR_STEYR                     = 229,               // 斯太尔汽车
        VLR_HONGQI                    = 230,               // 红旗
        VLR_USER1       = 231,   //用户1
        VLR_USER2       = 232,   //用户2
        VLR_USER3       = 233,   //用户3
        VLR_USER4       = 234,   //用户4
        VLR_USER5       = 235,   //用户5
        VLR_USER6       = 236,   //用户6
        VLR_USER7       = 237,   //用户7
        VLR_USER8       = 238    //用户8
}VLR_VEHICLE_CLASS;

/********************车辆品牌子类型Begin*************************/
//大众子品牌类型
typedef enum _VSB_VOLKSWAGEN_CLASS
{
    VSB_VOLKSWAGEN_OTHER          = 0,   // 其他（保留）
        VSB_VOLKSWAGEN_LAVIDA         = 1,   // 朗逸
        VSB_VOLKSWAGEN_CROSSLAVIDA    = 2,   // 朗境
        VSB_VOLKSWAGEN_TIGUAN         = 3,   // 途观
        VSB_VOLKSWAGEN_TOURAN         = 4,   // 途安
        VSB_VOLKSWAGEN_SANTANA        = 5,   // 桑塔纳
        VSB_VOLKSWAGEN_SANTANA2000    = 6,   // 桑塔纳2000
        VSB_VOLKSWAGEN_SANTANA3000    = 7,   // 桑塔纳3000
        VSB_VOLKSWAGEN_VISTA          = 8,   // 桑塔纳-志俊
        VSB_VOLKSWAGEN_PASSAT         = 9,   // 帕萨特
        VSB_VOLKSWAGEN_PASSATLINGYU   = 10,  // 帕萨特-领驭
        VSB_VOLKSWAGEN_POLO           = 11,  // 波罗
        VSB_VOLKSWAGEN_POLOCROSS      = 12,  // 波罗-运动版
        VSB_VOLKSWAGEN_POLOGTI        = 13,  // 波罗-GTI
        VSB_VOLKSWAGEN_SAGITAR        = 14,  // 速腾
        VSB_VOLKSWAGEN_MAGOTAN        = 15,  // 迈腾
        VSB_VOLKSWAGEN_JETTA          = 16,  // 捷达
        VSB_VOLKSWAGEN_BORA           = 17,  // 宝来
        VSB_VOLKSWAGEN_NEWGOLF        = 18,  // 新高尔夫
        VSB_VOLKSWAGEN_GOLFGTI        = 19,  // 高尔夫-GTI
        VSB_VOLKSWAGEN_GOL            = 20,  // 高尔
        VSB_VOLKSWAGEN_CADDY          = 21,  // 开迪
        VSB_VOLKSWAGEN_PHAETON        = 22,  // 辉腾
        VSB_VOLKSWAGEN_TOUREG         = 23,  // 途锐
        VSB_VOLKSWAGEN_SCIROCCO       = 24,  // 尚酷
        VSB_VOLKSWAGEN_BEETLE         = 25,  // 甲壳虫
        VSB_VOLKSWAGEN_SHARAN         = 26,  // 夏朗
        VSB_VOLKSWAGEN_MULTIVAN       = 27,  // 迈特威
        VSB_VOLKSWAGEN_CARBONCOPY     = 28,  // 一汽大众-CC
        VSB_VOLKSWAGEN_VISTACHANGDA   = 29,  // 桑塔纳志俊-畅达
        VSB_VOLKSWAGEN_BORASPORTLINE  = 30,   // 宝来-SPORTLINE
        VSR_VOLKSWAGEN_CC_1             =31,   //大众-CC-2012,2011,2010
        VSR_VOLKSWAGEN_Cross_POLO_1     = 32,   //大众-Cross-POLO-2010,2007
        VSR_VOLKSWAGEN_Cross_POLO_2     = 33,   //大众-Cross-POLO-2014,2012
        VSR_VOLKSWAGEN_MULTIVAN_1       = 34,   //大众-Multivan-2014,2012,2011
        VSR_VOLKSWAGEN_POLO_1           = 35,   //大众-POLO-2006,2005,2004,2003,2002
        VSR_VOLKSWAGEN_POLO_2           = 36,   //大众-POLO-2013,2012,2011
        VSR_VOLKSWAGEN_POLO_JINQU_1     = 37,   //大众-POLO劲取-2009,2008,2007,2006
        VSR_VOLKSWAGEN_POLO_JINQU_2     = 38,   //大众-POLO劲取-2011
        VSR_VOLKSWAGEN_Tiguan_1         = 39,   //大众-Tiguan-2011,2009
        VSR_VOLKSWAGEN_Tiguan_2         = 40,   //大众-Tiguan-2014,2013,2012
        VSR_VOLKSWAGEN_XIALANG_1        = 41,   //大众-夏朗-2013,2012
        VSR_VOLKSWAGEN_BAOLAI_1         = 42,   //大众-宝来-2005,2004
        VSR_VOLKSWAGEN_BAOLAI_2         = 43,   //大众-宝来-2006
        VSR_VOLKSWAGEN_BAOLAI_3         = 44,   //大众-宝来-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_BAOLAI_4         = 45,   //大众-宝来-2014,2013
        VSR_VOLKSWAGEN_SHANGKU_1        = 46,   //大众-尚酷-2014,2013
        VSR_VOLKSWAGEN_PASATE_1         = 47,   //大众-帕萨特-2003进口,2001领驭
        VSR_VOLKSWAGEN_PASATE_2         = 48,   //大众-帕萨特-2007,2006,2005领驭
        VSR_VOLKSWAGEN_PASATE_3         = 49,   //大众-帕萨特-2009,2008,2007,2005,2004,2003,2001,2000
        VSR_VOLKSWAGEN_PASATE_4         = 50,   //大众-帕萨特-2011,2009领驭
        VSR_VOLKSWAGEN_PASATE_5         = 51,   //大众-帕萨特-2014,2013,2012,2011
        VSR_VOLKSWAGEN_JIEDA_1          = 52,   //大众-捷达-2005CIF伙伴,2002
        VSR_VOLKSWAGEN_JIEDA_2          = 53,   //大众-捷达-2009,2008,2006,2005,2004
        VSR_VOLKSWAGEN_JIEDA_3          = 54,   //大众-捷达-2012,2010
        VSR_VOLKSWAGEN_JIEDA_4          = 55,   //大众-捷达-2013
        VSR_VOLKSWAGEN_LANGYI_1         = 56,   //大众-朗逸-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_LANGYI_2         = 57,   //大众-朗逸-2013
        VSR_VOLKSWAGEN_SANGTANA_1       = 58,   //大众-桑塔纳-2007,2002,2000,1999,1995
        VSR_VOLKSWAGEN_SANGTANA_2       = 59,   //大众-桑塔纳-2014,2013
        VSR_VOLKSWAGEN_SANGTANA_3       = 60,   //大众-桑塔纳2000-2003,2001,2000,1999,1998,1996
        VSR_VOLKSWAGEN_SANGTANA_4       = 61,   //大众-桑塔纳3000-2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,   //大众-桑塔纳志俊(vista)-2011,2010,2009,2008
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,   //大众-桑塔纳志俊(vista)-2006
        VSR_VOLKSWAGEN_JIAKECHONG_1     = 64,   //大众-甲壳虫-2010,2009,2008,2007,2006,2005
        VSR_VOLKSWAGEN_JIAKECHONG_2     = 65,   //大众-甲壳虫-2014,2013
        VSR_VOLKSWAGEN_HUITENG_2        = 66,   //大众-辉腾-2010,2009,2007,2006
        VSR_VOLKSWAGEN_MAITENG_1        = 67,   //大众-迈腾-2011,2010,2009,2008,2007
        VSR_VOLKSWAGEN_MAITENG_2        = 68,   //大众-迈腾-2013,2012
        VSR_VOLKSWAGEN_TUAN_3           = 69,   //大众-途安-2006,2005,2004
        VSR_VOLKSWAGEN_TUAN_1           = 70,   //大众-途安-2010,2009,2008
        VSR_VOLKSWAGEN_TUAN_2           = 71,   //大众-途安-2013,2012,2011
        VSR_VOLKSWAGEN_TUGUAN_1         = 72,   //大众-途观-2012,2011,2010
        VSR_VOLKSWAGEN_TURUI_1          = 73,   //大众-途锐-2006,2005,2003
        VSR_VOLKSWAGEN_TURUI_2          = 74,   //大众-途锐-2014,2013,2012,2011
        VSR_VOLKSWAGEN_SUTENG_1         = 75,   //大众-速腾-2010,2009,2007,2006
        VSR_VOLKSWAGEN_SUTENG_2         = 76,   //大众-速腾-2011
        VSR_VOLKSWAGEN_SUTENG_3         = 77,   //大众-速腾-2014,2013,2012
        VSR_VOLKSWAGEN_GAOERFU_1        = 78,   //大众-高尔夫-2008,2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_GAOERFU_2        = 79,   //大众-高尔夫-2012,2011进口,2012,2011,2010
        VSR_VOLKSWAGEN_GAOERFU_3        = 80,   //大众-高尔夫GTI-2013,2012,2011,2010
        VSR_VOLKSWAGEN_LANGYI_3         = 81,   //大众-朗逸-2014
        VSR_VOLKSWAGEN_HUITENG_1        = 82   //大众-辉腾-2004
} VSB_VOLKSWAGEN_CLASS;

//别克子品牌类型
typedef enum _VBR_BUICK_CLASS
{
    VBR_BUICK_OTHER        = 0,   // 其他（保留）
        VBR_BUICK_ENCORE       = 1,   // 昂科拉
        VBR_BUICK_GL8          = 2,   // GL8
        VBR_BUICK_LEGAL        = 3,   // 君威
        VBR_BUICK_LACROSS      = 4,   // 君越
        VBR_BUICK_EXCELLE      = 5,   // 凯越
        VBR_BUICK_EXCELLEGT    = 6,   // 英朗GT
        VBR_BUICK_WXCELLEXT    = 7,   // 英朗XT
        VBR_BUICK_ENCLAVE      = 8,   // 昂科雷
        VBR_BUICK_ROYAUM       = 9,   // 荣御
        VBR_BUICK_SAIL         = 10,  // 别克赛欧
        VBR_BUICK_EXCELLEHRV   = 11,  // 凯越HRV
        VBR_BUICK_PARKAVENUE   = 12,  // 林荫大道
        VBR_BUICK_CENTURY      = 13,   // 新世纪
        VBR_BUICK_GL8_1          = 14,   // 别克-GL8-2004,2003
        VBR_BUICK_GL8_2          = 15,   // 别克-GL8-2007,2006,2005
        VBR_BUICK_GL8_3          = 16,   // 别克-GL8-2010_2008_2006_2005陆尊
        VBR_BUICK_GL8_4          = 17,   // 别克-GL8-2014,2013,2012,2011
        VBR_BUICK_GL8_5          = 18,   // 别克-GL8-2014_2013_2011豪华版
        VBR_BUICK_ENCORE_1       = 19,   // 别克-昂科拉-2014,2013
        VBR_BUICK_ENCLAVE_1      = 20,   // 别克-昂科雷-2013,2010,2009
        VBR_BUICK_LEGAL_1        = 21,   // 别克-君威-2001,2000,1999
        VBR_BUICK_LEGAL_2        = 22,   // 别克-君威-2008,2006,2005,2004,2002
        VBR_BUICK_LEGAL_3        = 23,   // 别克-君威-2013,2012,2011,2010,2009
        VBR_BUICK_LEGAL_4        = 24,   // 别克-君威-2013_2012_2011运动版
        VBR_BUICK_LEGAL_5        = 25,   // 别克-君威-2014
        VBR_BUICK_LEGAL_6        = 26,   // 别克-君威-2014运动版
        VBR_BUICK_LACROSS_1      = 27,   // 别克-君越-2008,2007,2006
        VBR_BUICK_LACROSS_2      = 28,   // 别克-君越-2012,2011,2010,2009
        VBR_BUICK_LACROSS_3      = 29,   // 别克-君越-2013
        VBR_BUICK_EXCELLE_1      = 30,   // 别克-凯越-2006,2005,2004
        VBR_BUICK_EXCELLE_2      = 31,   // 别克-凯越-2008_2006_2005_2004HRV
        VBR_BUICK_EXCELLE_3      = 32,   // 别克-凯越-2011,2009,2008
        VBR_BUICK_EXCELLE_4      = 33,   // 别克-凯越-2013
        VBR_BUICK_PARKAVENUE_1   = 34,   // 别克-林荫大道-2011,2010,2009,2008,2007
        VBR_BUICK_SAIL_1         = 35,   // 别克-赛欧-2004,2003
        VBR_BUICK_EXCELLEGT_1    = 36,   // 别克-英朗GT-2013,2012,2011,2010
        VBR_BUICK_WXCELLEXT_1    = 37,   // 别克-英朗XT-2014,2013,2012,2010
        VBR_BUICK_CENTURY_1      = 38,   // 别克-新世纪-2000
        VBR_BUICK_RONGYU_1       = 39   // 别克-荣御-2005,2004
}VBR_BUICK_CLASS;

//宝马子品牌类型
typedef enum _VSB_BMW_CLASS
{
    VSB_BMW_OTHER       = 0,   // 其他（保留）
        VSB_BMW_3SERIES     = 1,   // 宝马3系
        VSB_BMW_5SERIES     = 2,   // 宝马5系
        VSB_BMW_X1          = 3,   // 宝马X1
        VSB_BMW_1SERIES     = 4,   // 宝马1系
        VSB_BMW_7SERIES     = 5,   // 宝马7系
        VSB_BMW_X3          = 6,   // 宝马X3
        VSB_BMW_X5          = 7,   // 宝马X5
        VSB_BMW_X6          = 8,   // 宝马X6
        VSB_BMW_Z4          = 9,   // 宝马Z4
        VSB_BMW_MINI        = 10,  // 迷你
        VSB_BMW_6SERIES     = 11,   //宝马6系
        VSB_BMW_YIXI_1      = 12,     // 宝马-1系-2011,2010,2008,2007
        VSB_BMW_YIXI_2      = 13,     // 宝马-1系-2013,2012
        VSB_BMW_SANXI_1     = 14,     // 宝马-3系-2004
        VSB_BMW_SANXI_2     = 15,     // 宝马-3系-2007,2005
        VSB_BMW_SANXI_3     = 16,     // 宝马-3系-2012,2011,2010,2009
        VSB_BMW_SANXI_4     = 17,     // 宝马-3系-2014,2013
        VSB_BMW_WUXI_1      = 18,     // 宝马-5系-2010,2009,2008
        VSB_BMW_WUXI_2      = 19,     // 宝马-5系-2013,2012,2011
        VSB_BMW_LIUXI_1     = 20,     // 宝马-6系-未知
        VSB_BMW_QIXI_1      = 21,     // 宝马-7系-2011,2010,2009
        VSB_BMW_QIXI_2      = 22,     // 宝马-7系-2013
        VSB_BMW_X1_1        = 23,     // 宝马-X1-2012,2010
        VSB_BMW_X1_2        = 24,     // 宝马-X1-2014,2013
        VSB_BMW_X3_1        = 25,     // 宝马-X3-2009,2008,2006
        VSB_BMW_X3_2        = 26,     // 宝马-X3-2013,2012,2011
        VSB_BMW_X5_1        = 27,     // 宝马-X5-2010,2009,2008
        VSB_BMW_X5_2        = 28,     // 宝马-X5-2013,2012,2011
        VSB_BMW_X5_3        = 29,     // 宝马-X5-2013运动型
        VSB_BMW_X6_1        = 30,     // 宝马-X6-2013,2012,2011,2009,2008
        VSB_BMW_Z4_1        = 31     // 宝马-Z4-2004
}VSB_BMW_CLASS;

//本田子品牌类型
typedef enum _VSB_HONDA_CLASS
{
    VSB_HONDA_OTHER       = 0,   // 其他（保留）
        VSB_HONDA_CRV         = 1,   // 本田CR-V(思威)
        VSB_HONDA_JADE        = 2,   // 杰德
        VSB_HONDA_CIVIC       = 3,   // 思域
        VSB_HONDA_SPIRIOR     = 4,   // 思铂睿
        VSB_HONDA_CIIMO       = 5,   // 思铭
        VSB_HONDA_ELYSION     = 6,   // 艾力绅
        VSB_HONDA_OBYSSEY     = 7,   // 奥赛德
        VSB_HONDA_FIT         = 8,   // 飞度
        VSB_HONDA_NEWCITY     = 9,   // 锋范
        VSB_HONDA_CROSSTOUR   = 10,  // 歌诗图
        VSB_HONDA_CRIDER      = 11,  // 凌派
        VSB_HONDA_ACCORD      = 12,  // 雅阁
        VSB_HONDA_CITY        = 13,  // 思迪
        VSB_HONDA_ANTILOCK    = 14,  // 阿柯德
        VSB_HONDA_CRZ         = 15,   // 本田CR-Z
        VSB_HONDA_CRV_1       = 16,   // 本田-CR-V-2004
        VSB_HONDA_CRV_2       = 17,   // 本田-CR-V-2005
        VSB_HONDA_CRV_3       = 18,   // 本田-CR-V-2008,2007
        VSB_HONDA_CRV_4       = 19,   // 本田-CR-V-2010
        VSB_HONDA_CRV_5       = 20,   // 本田-CR-V-2013,2012
        VSB_HONDA_CRIDER_1    = 21,   // 本田-凌派-2014,2013
        VSB_HONDA_OBYSSEY_1   = 22,   // 本田-奥德赛-2002
        VSB_HONDA_OBYSSEY_2   = 23,   // 本田-奥德赛-2006,2005,2004
        VSB_HONDA_OBYSSEY_3   = 24,   // 本田-奥德赛-2008,2007
        VSB_HONDA_OBYSSEY_4   = 25,   // 本田-奥德赛-2011豪华版
        VSB_HONDA_CIVIC_1     = 26,   // 本田-思域-2007
        VSB_HONDA_CIVIC_5     = 27,   // 本田-思域-1996
        VSB_HONDA_CIVIC_2     = 28,   // 本田-思域-2008,2006
        VSB_HONDA_CIVIC_3     = 29,   // 本田-思域-2009
        VSB_HONDA_CIVIC_4     = 30,   // 本田-思域-2013,2012,2011
        VSB_HONDA_CITY_1      = 31,   // 本田-思迪-2008,2007,2006
        VSB_HONDA_SPIRIOR_1   = 32,   // 本田-思铂睿-2009
        VSB_HONDA_SIMING_1    = 33,   // 本田-思铭-2012
        VSB_HONDA_JIEDE_1     = 34,   // 本田-杰德-2013
        VSB_HONDA_CROSSTOUR_1 = 35,   // 本田-歌诗图-2013,2012,2010
        VSB_HONDA_AILISHEN_1  = 36,   // 本田-艾力绅-2012
        VSB_HONDA_NEWCITY_1   = 37,   // 本田-锋范-2009
        VSB_HONDA_NEWCITY_2   = 38,   // 本田-锋范-2011
        VSB_HONDA_NEWCITY_3   = 39,   // 本田-锋范-2014,2012
        VSB_HONDA_ACCORD_1    = 40,   // 本田-雅阁-1996
        VSB_HONDA_ACCORD_2    = 41,   // 本田-雅阁-1999
        VSB_HONDA_ACCORD_3    = 42,   // 本田-雅阁-2001
        VSB_HONDA_ACCORD_4    = 43,   // 本田-雅阁-2003
        VSB_HONDA_ACCORD_5    = 44,   // 本田-雅阁-2008
        VSB_HONDA_ACCORD_6    = 45,   // 本田-雅阁-2010
        VSB_HONDA_ACCORD_7    = 46,   // 本田-雅阁-2011
        VSB_HONDA_ACCORD_8    = 47,   // 本田-雅阁-2012
        VSB_HONDA_ACCORD_9    = 48,   // 本田-雅阁-2013
        VSB_HONDA_ACCORD_10   = 49,   // 本田-雅阁-2014
        VSB_HONDA_FIT_1       = 50,   // 本田-飞度-2004
        VSB_HONDA_FIT_2       = 51,   // 本田-飞度-2004三厢
        VSB_HONDA_FIT_3       = 52,   // 本田-飞度-2005
        VSB_HONDA_FIT_4       = 53,   // 本田-飞度-2007
        VSB_HONDA_FIT_5       = 54,   // 本田-飞度-2008
        VSB_HONDA_FIT_6       = 55   // 本田-飞度-2013,2011
}VSB_HONDA_CLASS;

//标致子品牌类型
typedef enum _VSB_PEUGEOT_CLASS
{
    VSB_PEUGEOT_OTHER      = 0,   // 其他（保留）
        VSB_PEUGEOT_2008       = 1,   // 标致2008
        VSB_PEUGEOT_207        = 2,   // 标致207
        VSB_PEUGEOT_SENNA      = 3,   // 赛纳
        VSB_PEUGEOT_3008       = 4,   // 标致3008
        VSB_PEUGEOT_301        = 5,   // 标致301
        VSB_PEUGEOT_307        = 6,   // 标致307
        VSB_PEUGEOT_308        = 7,   // 标致308
        VSB_PEUGEOT_408        = 8,   // 标致408
        VSB_PEUGEOT_508        = 9,   // 标致508
        VSB_PEUGEOT_206        = 10,  // 标致206
        VSB_PEUGEOT_407        = 11,   // 标致407
        VSB_PEUGEOT_206_1      = 12, // 标致-206-未知
        VSB_PEUGEOT_207_1      = 13, // 标致-207两厢-2011,2010,2009
        VSB_PEUGEOT_207_2      = 14, // 标致-207两厢-2013
        VSB_PEUGEOT_3008_1     = 15, // 标致-3008-2014,2013
        VSB_PEUGEOT_301_1      = 16, // 标致-301-未知
        VSB_PEUGEOT_307_1      = 17, // 标致-307三厢-2007,2006,2005,2004
        VSB_PEUGEOT_307_2      = 18, // 标致-307三厢-2010,2009,2008
        VSB_PEUGEOT_307_3      = 19, // 标致-307两厢-2013_2012_2011CROSS
        VSB_PEUGEOT_308_1      = 20, // 标致-308-2014,2013,2012
        VSB_PEUGEOT_407_1      = 21, // 标致-407-未知
        VSB_PEUGEOT_408_1      = 22, // 标致-408-2012,2011,2010
        VSB_PEUGEOT_408_2      = 23, // 标致-408-2013
        VSB_PEUGEOT_508_1      = 24, // 标致-508-2014,2013,2012,2011
        VSB_PEUGEOT_207_3      = 25, // 标致-207三厢-2011,2010,2009
        VSB_PEUGEOT_307_4      = 26 // 标致-307两厢-2013,2012,2010,2009,2008
        
}VSB_PEUGEOT_CLASS;

//丰田子品牌类型
typedef enum _VSB_TOYOTA_CLASS
{
    VSB_TOYOTA_OTHER            = 0,   // 其他（保留）
        VSB_TOYOTA_HIGHLANDER       = 1,   // 汉兰达
        VSB_TOYOTA_CAMRY            = 2,   // 凯美瑞
        VSB_TOYOTA_YARIS            = 3,   // 雅力士
        VSB_TOYOTA_YARISL           = 4,   // YARIS L致炫
        VSB_TOYOTA_VERSO            = 5,   // 逸致
        VSB_TOYOTA_HUAGUAN          = 6,   // 花冠
        VSB_TOYOTA_CROWN            = 7,   // 皇冠
        VSB_TOYOTA_COROLLA          = 8,   // 卡罗拉
        VSB_TOYOTA_COSTER           = 9,   // 柯斯达
        VSB_TOYOTA_PRADO            = 10,  // 普拉多
        VSB_TOYOTA_PRIUS            = 11,  // 普锐斯
        VSB_TOYOTA_RAV4             = 12,  // 丰田RAV4
        VSB_TOYOTA_REZI             = 13,  // 锐志
        VSB_TOYOTA_VIOS             = 14,  // 威驰
        VSB_TOYOTA_PREVIA           = 15,  // 普瑞维亚
        VSB_TOYOTA_HIACE            = 16,  // 海狮
        VSB_TOYOTA_86               = 17,  // 丰田86
        VSB_TOYOTA_SPEQUOIA         = 18,  // 红杉
        VSB_TOYOTA_LANDCRUISER      = 19,  // 陆地巡洋舰(兰德酷路泽)
        VSB_TOYOTA_SIENNA           = 20,  // 赛纳
        VSB_TOYOTA_CAMRYHYBRID      = 21,  // 凯美瑞-HYBRID
        VSB_TOYOTA_GRACE            = 22,  // 阁瑞斯
        VSB_TOYOTA_ALPHARD          = 23,   // 埃尔法
        VSB_TOYOTA_RAV4_1           = 24,   // 丰田-RAV4-2012手动经典版,2011,2010,2009
        VSB_TOYOTA_RAV4_2           = 25,   // 丰田-RAV4-2013
        VSB_TOYOTA_86_1             = 26,   // 丰田-丰田86-未知
        VSB_TOYOTA_JIAMEI_2         = 27,   // 丰田-佳美-2001,2000,1999,1998
        VSB_TOYOTA_JIAMEI_3         = 28,   // 丰田-佳美-2004,2003,2002
        VSB_TOYOTA_LANDEKLZ_1       = 29,   // 丰田-兰德酷路泽-2011中东版,2010,2007
        VSB_TOYOTA_KAIMEIRUI_1      = 30,   // 丰田-凯美瑞-2008,2007,2006
        VSB_TOYOTA_KAIMEIRUI_2      = 31,   // 丰田-凯美瑞-2012尊瑞
        VSB_TOYOTA_KAIMEIRUI_3      = 32,   // 丰田-凯美瑞-2012经典版,2011,2010,2009
        VSB_TOYOTA_KAIMEIRUI_4      = 33,   // 丰田-凯美瑞-2013,2012
        VSB_TOYOTA_KAIMEIRUI_5      = 34,   // 丰田-凯美瑞-2013经典版
        VSB_TOYOTA_KAIMEIRUI_6      = 35,   // 丰田-凯美瑞-2014,2012骏瑞
        VSB_TOYOTA_KALUOLA_1        = 36,   // 丰田-卡罗拉-2010,2009,2008,2007,2006
        VSB_TOYOTA_KALUOLA_2        = 37,   // 丰田-卡罗拉-2013,2012,2011
        VSB_TOYOTA_AIERFA_1         = 38,   // 丰田-埃尔法-2011,2010
        VSB_TOYOTA_AIERFA_2         = 39,   // 丰田-埃尔法-2013,2012
        VSB_TOYOTA_WEICHI_1         = 40,   // 丰田-威驰-2004,2003
        VSB_TOYOTA_WEICHI_2         = 41,   // 丰田-威驰-2007,2006,2005
        VSB_TOYOTA_WEICHI_3         = 42,   // 丰田-威驰-2009,2008
        VSB_TOYOTA_WEICHI_4         = 43,   // 丰田-威驰-2013,2012,2011,2010
        VSB_TOYOTA_WEICHI_5         = 44,   // 丰田-威驰-2014
        VSB_TOYOTA_PULADUO_1        = 45,   // 丰田-普拉多-2007,2006,2005,2004
        VSB_TOYOTA_PULADUO_2        = 46,   // 丰田-普拉多-2010
        VSB_TOYOTA_PULADUO_3        = 47,   // 丰田-普拉多-2014
        VSB_TOYOTA_PURUIWEIYA_1     = 48,   // 丰田-普瑞维亚-2004
        VSB_TOYOTA_PURUIWEIYA_4     = 49,   // 丰田-普瑞维亚-2005
        VSB_TOYOTA_PURUIWEIYA_2     = 50,   // 丰田-普瑞维亚-2006
        VSB_TOYOTA_PURUIWEIYA_3     = 51,   // 丰田-普瑞维亚-2012,2010,2008,2007
        VSB_TOYOTA_KESIDA_1         = 52,   // 丰田-柯斯达-2007
        VSB_TOYOTA_KESIDA_2         = 53,   // 丰田-柯斯达-2011
        VSB_TOYOTA_HANLANDA_1       = 54,   // 丰田-汉兰达-2011,2009
        VSB_TOYOTA_HANLANDA_2       = 55,   // 丰田-汉兰达-2012
        VSB_TOYOTA_HANLANDA_3       = 56,   // 丰田-汉兰达-2013
        VSB_TOYOTA_HAISHI_1         = 57,   // 丰田-海狮-2001
        VSB_TOYOTA_HUANGGUAN_1      = 58,   // 丰田-皇冠-1999
        VSB_TOYOTA_HUANGGUAN_2      = 59,   // 丰田-皇冠-2009,2008,2007,2006,2005
        VSB_TOYOTA_HUANGGUAN_3      = 60,   // 丰田-皇冠-2010
        VSB_TOYOTA_HUANGGUAN_4      = 61,   // 丰田-皇冠-2012,2011
        VSB_TOYOTA_HONGSHAN_1       = 62,   // 丰田-红杉-未知
        VSB_TOYOTA_HUAGUAN_1        = 63,   // 丰田-花冠-2006,2005,2004
        VSB_TOYOTA_HUAGUAN_2        = 64,   // 丰田-花冠-2009,2008,2007
        VSB_TOYOTA_HUAGUAN_3        = 65,   // 丰田-花冠-2011,2010
        VSB_TOYOTA_YIZHI_1          = 66,   // 丰田-逸致-2014,2012,2011
        VSB_TOYOTA_RUIZHI_1         = 67,   // 丰田-锐志-2006,2005
        VSB_TOYOTA_RUIZHI_2         = 68,   // 丰田-锐志-2009,2008,2007
        VSB_TOYOTA_RUIZHI_3         = 69,   // 丰田-锐志-2010风度版
        VSB_TOYOTA_RUIZHI_4         = 70,   // 丰田-锐志-2012,2010
        VSB_TOYOTA_LUDIXUNYANG_1    = 71,   // 丰田-陆地巡洋舰-未知
        VSB_TOYOTA_YALISHI_1        = 72,   // 丰田-雅力士-2009,2008,2007
        VSB_TOYOTA_YALISHI_2        = 73,   // 丰田-雅力士-2012,2011,2010
        VSB_TOYOTA_RAV4_3           = 74,   // 丰田-RAV4-2013经典,精英,尊崇,2012
        VSB_TOYOTA_YARiSL_1         = 75,   // 丰田-YARiS-L
        VSB_TOYOTA_JIAMEI_1         = 76,   // 丰田-佳美-1996
        VSB_TOYOTA_PLATZ_1          = 77,   // 丰田-PLATZ-1999
        VSB_TOYOTA_LANDEKLZ_2       = 78   // 丰田-兰德酷路泽-2014,2012中东版,2012
}VSB_TOYOTA_CLASS;

//福特子品牌类型
typedef enum _VSB_FORD_CLASS
{
    VSB_FORD_OTHER       = 0,   // 其他（保留）
        VSB_FORD_FOCUS       = 1,   // 福克斯
        VSB_FORD_FIESTA      = 2,   // 嘉年华
        VSB_FORD_SMAX        = 3,   // 麦柯斯
        VSB_FORD_MONDEO      = 4,   // 蒙迪欧
        VSB_FORD_ECOSPORT    = 5,   // 翼博
        VSB_FORD_ESCAPE      = 6,   // 翼虎
        VSB_FORD_ZHISHENG    = 7,   // 致胜
        VSB_FORD_ESCORT      = 8,   // 福睿斯
        VSB_FORD_EXPLORER    = 9,   // 福特探险者
        VSB_FORD_EDGE        = 10,  // 锐界
        VSB_FORD_TRANSIT     = 11,   // 全顺
        VSB_FORD_QUANSHUN_1      = 12,    // 福特-全顺-未知
        VSB_FORD_JIANIANHUA_1    = 13,    // 福特-嘉年华三厢-2006,2005,2004
        VSB_FORD_JIANIANHUA_2    = 14,    // 福特-嘉年华三厢-2011,2010,2009
        VSB_FORD_JIANIANHUA_3    = 15,    // 福特-嘉年华三厢-2013
        VSB_FORD_JIANIANHUA_4    = 16,    // 福特-嘉年华两厢-2012
        VSB_FORD_TANXIANZHE_1    = 17,    // 福特-探险者-2013,2011
        VSB_FORD_FOCUS_1         = 18,    // 福特-福克斯三厢-2005
        VSB_FORD_FOCUS_2         = 19,    // 福特-福克斯三厢-2005经典型
        VSB_FORD_FOCUS_3         = 20,    // 福特-福克斯三厢-2008,2007,2006
        VSB_FORD_FOCUS_4         = 21,    // 福特-福克斯三厢-2013,2012经典,2011,2009
        VSB_FORD_FOCUS_5         = 22,    // 福特-福克斯两厢-2012
        VSB_FORD_FOCUS_6         = 23,    // 福特-福克斯两厢-2012基本,时尚,2011,2010,2009,2008
        VSB_FORD_YIBO_1          = 24,    // 福特-翼博-2013
        VSB_FORD_YIHU_1          = 25,    // 福特-翼虎-2013
        VSB_FORD_MENGDIOU_1      = 26,    // 福特-蒙迪欧-2003
        VSB_FORD_MENGDIOU_2      = 27,    // 福特-蒙迪欧-2005,2004
        VSB_FORD_MENGDIOU_3      = 28,    // 福特-蒙迪欧-2006
        VSB_FORD_MENGDIOU_4      = 29,    // 福特-蒙迪欧-2013
        VSB_FORD_MENGDIOU_5      = 30,    // 福特-蒙迪欧-致胜-2010,2008,2007
        VSB_FORD_MENGDIOU_6      = 31,    // 福特-蒙迪欧-致胜-2011
        VSB_FORD_RUIJIE_1        = 32,    // 福特-锐界-2012,2011
        VSB_FORD_MAIKESI_1       = 33    // 福特-麦柯斯-2008,2007
}VSB_FORD_CLASS;

//日产子品牌类型
typedef enum _VSB_NISSAN_CLASS
{
    VSB_NISSAN_OTHER              = 0,   // 其他（保留）
        VSB_NISSAN_XTRAIL             = 1,   // 奇骏
        VSB_NISSAN_MURANO             = 2,   // 楼兰
        VSB_NISSAN_LIVINA             = 3,   // 骊威
        VSB_NISSAN_MARCH              = 4,   // 玛驰
        VSB_NISSAN_TIIDA              = 5,   // 骐达
        VSB_NISSAN_TEANA              = 6,   // 天籁
        VSB_NISSAN_QASHQAI            = 7,   // 逍客
        VSB_NISSAN_SYLPHY             = 8,   // 轩逸
        VSB_NISSAN_SUNNY              = 9,   // 阳光
        VSB_NISSAN_D22PICKUP          = 10,  // D22皮卡
        VSB_NISSAN_D22VAN             = 11,  // D22厢式车
        VSB_NISSAN_CABSTAR            = 12,  // 凯普斯达
        VSB_NISSAN_HV200              = 13,  // NV200
        VSB_NISSAN_PALADIN            = 14,  // 帕拉丁
        VSB_NISSAN_YIDA               = 15,  // 颐达
        VSB_NISSAN_DUCK               = 16,  // 公爵
        VSB_NISSAN_CEFIRO             = 17,  // 风度
        VSB_NISSAN_FENGSHENBLUEBIRD   = 18,  // 风神蓝鸟
        VSB_NISSAN_FENGSHENSUNNY      = 19,  // 风神阳光
        VSB_NISSAN_SUCCE              = 20,  // 帅客
        VSB_NISSAN_FUGA               = 21,  // 风雅
        VSB_NISSAN_BLUEBIRD4          = 22,  // 蓝鸟4代
        VSB_NISSAN_VENUCIA            = 23,  // 启辰
        VSB_NISSAN_QUEST              = 24,  // 贵士
        VSB_NISSAN_GENISS             = 25,   // 俊逸
        VSB_NISSAN_NV200_1            = 26,  // 日产-NV200-2013,2012,2011,2010
        VSB_NISSAN_TIANLAI_1          = 27,  // 日产-天籁-2005,2004
        VSB_NISSAN_TIANLAI_2          = 28,  // 日产-天籁-2007,2006
        VSB_NISSAN_TIANLAI_3          = 29,  // 日产-天籁-2010,2008
        VSB_NISSAN_TIANLAI_4          = 30,  // 日产-天籁-2012,2011
        VSB_NISSAN_TIANLAI_5          = 31,  // 日产-天籁-2012云安全版,2011公爵
        VSB_NISSAN_TIANLAI_6          = 32,  // 日产-天籁-2014,2013
        VSB_NISSAN_QIJUN_1            = 33,  // 日产-奇骏-2010,2008
        VSB_NISSAN_QIJUN_2            = 34,  // 日产-奇骏-2012,2011进口
        VSB_NISSAN_PALADING_1         = 35,  // 日产-帕拉丁-2013,2011,2006,2004
        VSB_NISSAN_LOULAN_1           = 36,  // 日产-楼兰-2013,2011
        VSB_NISSAN_LOULAN_2           = 37,  // 日产-玛驰-2010
        VSB_NISSAN_LANNIAO_1          = 38,  // 日产-蓝鸟-2002
        VSB_NISSAN_LANNIAO_2          = 39,  // 日产-蓝鸟-2003
        VSB_NISSAN_LANNIAO_3          = 40,  // 日产-蓝鸟-2004
        VSB_NISSAN_GUISHI_1           = 41,  // 日产-贵士-2005
        VSB_NISSAN_XUANYI_1           = 42,  // 日产-轩逸-2006
        VSB_NISSAN_XUANYI_2           = 43,  // 日产-轩逸-2012经典,2009,2007
        VSB_NISSAN_XUANYI_3           = 44,  // 日产-轩逸-2014,2012
        VSB_NISSAN_XIAOKE_1           = 45,  // 日产-逍客-2009,2008
        VSB_NISSAN_XIAOKE_2           = 46,  // 日产-逍客-2013,2012,2011
        VSB_NISSAN_SUNNY_3            = 47,  // 日产-阳光-2004
        VSB_NISSAN_SUNNY_1            = 48,  // 日产-阳光-2006,2005
        VSB_NISSAN_SUNNY_2            = 49,  // 日产-阳光-2012,2011
        VSB_NISSAN_YIDA_1             = 50,  // 日产-颐达-2008,2006,2005
        VSB_NISSAN_YIDA_2             = 51,  // 日产-颐达-未知
        VSB_NISSAN_FENGDU_1           = 52,  // 日产-风度-未知
        VSB_NISSAN_FENGYA_1           = 53,  // 日产-风雅-未知
        VSB_NISSAN_LIWEI_1            = 54,  // 日产-骊威-2008,2007
        VSB_NISSAN_LIWEI_2            = 55,  // 日产-骊威-2009
        VSB_NISSAN_LIWEI_3            = 56,  // 日产-骊威-2010
        VSB_NISSAN_LIWEI_4            = 57,  // 日产-骊威-2011,2010劲锐,2008炫能型
        VSB_NISSAN_JUNYI_1            = 58,  // 日产-骏逸-2006
        VSB_NISSAN_QIDA_1             = 59,  // 日产-骐达-2006,2005
        VSB_NISSAN_QIDA_2             = 60,  // 日产-骐达-2009,2008
        VSB_NISSAN_QIDA_3             = 61,  // 日产-骐达-2013,2012,2011
        VSB_NISSAN_RUIQI_1            = 62   // 日产-锐骐皮卡-2009豪华型
}VSB_NISSAN_CLASS;

//奥迪子品牌类型
typedef enum _VSB_AUDI_CLASS
{
    VSB_AUDI_OTHER        = 0,   // 其他（保留）
        VSB_AUDI_A3           = 1,   // 奥迪A3
        VSB_AUDI_A4L          = 2,   // 奥迪A4L
        VSB_AUDI_A6L          = 3,   // 奥迪A6L
        VSB_AUDI_Q3           = 4,   // 奥迪Q3
        VSB_AUDI_Q5           = 5,   // 奥迪Q5
        VSB_AUDI_A1           = 6,   // 奥迪A1
        VSB_AUDI_A4           = 7,   // 奥迪A4
        VSB_AUDI_A5           = 8,   // 奥迪A5
        VSB_AUDI_A6           = 9,   // 奥迪A6
        VSB_AUDI_A7           = 10,  // 奥迪A7
        VSB_AUDI_A8L          = 11,  // 奥迪A8L
        VSB_AUDI_Q7           = 12,  // 奥迪Q7
        VSB_AUDI_S5           = 13,  // 奥迪S5
        VSB_AUDI_TT           = 14,  // 奥迪TT
        VSB_AUDI_100          = 15,  // 奥迪100
        VSB_AUDI_200          = 16,  // 奥迪200
        VSB_AUDI_S7           = 17,  // 奥迪S7
        VSB_AUDI_S8           = 18,  // 奥迪S8
        VSB_AUDI_100_1        = 19,   // 奥迪-100-未知
        VSB_AUDI_200_1        = 20,   // 奥迪-200-未知
        VSB_AUDI_A1_1         = 21,   // 奥迪-A1-2014,2013,2012
        VSB_AUDI_A3_1         = 22,   // 奥迪-A3-2013,2010舒适版
        VSB_AUDI_A3_2         = 23,   // 奥迪-A3-2013技术型,2011,2010
        VSB_AUDI_A4_1         = 24,   // 奥迪-A4-2005国产,2000进口版
        VSB_AUDI_A4_2         = 25,   // 奥迪-A4-2007,2006国产,2004进口
        VSB_AUDI_A4L_1        = 26,   // 奥迪-A4L-2013
        VSB_AUDI_A5_1         = 27,   // 奥迪-A5-2011,2010
        VSB_AUDI_A6_1         = 28,   // 奥迪-A6-1996,1995,1991
        VSB_AUDI_A6L_1        = 29,   // 奥迪-A6L-2008,2007,2006,2005
        VSB_AUDI_A6L_2        = 30,   // 奥迪-A6L-2011,2010,2009
        VSB_AUDI_A6L_3        = 31,   // 奥迪-A6L-2014,2013,2012
        VSB_AUDI_A7_1         = 32,   // 奥迪-A7-2014,2013进取型,2012,2011
        VSB_AUDI_A8L_1        = 33,   // 奥迪-A8L-2006
        VSB_AUDI_A8L_2        = 34,   // 奥迪-A8L-2009,2008
        VSB_AUDI_A8L_3        = 35,   // 奥迪-A8L-2011
        VSB_AUDI_A8L_4        = 36,   // 奥迪-A8L-2013,2012
        VSB_AUDI_Q3_1         = 37,   // 奥迪-Q3-2014,2013,2012
        VSB_AUDI_Q5_1         = 38,   // 奥迪-Q5-2012,2010运动 
        VSB_AUDI_Q5_2         = 39,   // 奥迪-Q5-2012豪华型,2010越野版
        VSB_AUDI_Q5_3         = 40,   // 奥迪-Q5-2012进取型,2011,2010,2009
        VSB_AUDI_Q5_4         = 41,   // 奥迪-Q5-2013
        VSB_AUDI_Q7_1         = 42,   // 奥迪-Q7-2007
        VSB_AUDI_Q7_2         = 43,   // 奥迪-Q7-2014,2013
        VSB_AUDI_S7_1         = 44,   // 奥迪-S7-2013
        VSB_AUDI_S8_1         = 45,   // 奥迪-S8-2013
        VSB_AUDI_TT_2         = 46,   // 奥迪-TT-2010,2008,2007
        VSB_AUDI_TT_3         = 47,   // 奥迪-TT-2012,2011
        VSB_AUDI_TT_4         = 48,   // 奥迪-TT-2013,2013,2011TTS
        VSB_AUDI_TT_1         = 49   // 奥迪-TT-2008TTS
}VSB_AUDI_CLASS;

//马自达子品牌类型
typedef enum _VSB_MAZDA_CLASS
{
    VSB_MAZDA_OTHER         = 0,   // 其他（保留）
        VSB_MAZDA_CX5           = 1,   // 马自达CX5
        VSB_MAZDA_2             = 2,   // 马自达2
        VSB_MAZDA_3             = 3,   // 马自达3
        VSB_MAZDA_6             = 4,   // 马自达6
        VSB_MAZDA_8             = 5,   // 马自达8
        VSB_MAZDA_COREWING      = 6,   // 睿翼
        VSB_MAZDA_CX7           = 7,   // 马自达CX7
        VSB_MAZDA_X5            = 8,   // 马自达X5
        VSB_MAZDA_5             = 9,   // 马自达5
        VSB_MAZDA_PREMACY       = 10,  // 老款普力马
        VSB_MAZDA_MPV           = 11,   // 马自达MPV
        VSB_MAZDA_CX5_1         = 12,   // 马自达-CX-5-2014,2013,2012进口
        VSB_MAZDA_CX7_1         = 13,   // 马自达-CX-7-2014,2013,2011,2010
        VSB_MAZDA_2_1           = 14,   // 马自达-Mazda2两厢-2011,2009,2008,2007A
        VSB_MAZDA_3_1           = 15,   // 马自达-Mazda3三厢-2004,2002
        VSB_MAZDA_3_2           = 16,   // 马自达-Mazda3三厢-2009,2007
        VSB_MAZDA_3_3           = 17,   // 马自达-Mazda3三厢-2012,2010
        VSB_MAZDA_3_4           = 18,   // 马自达-Mazda3星骋两厢-2013,2012
        VSB_MAZDA_5_1           = 19,   // 马自达-Mazda5-2010,2008,2007
        VSB_MAZDA_5_2           = 20,   // 马自达-Mazda5-2013,2012,2011
        VSB_MAZDA_6_2           = 21,   // 马自达-Mazda6-2006
        VSB_MAZDA_6_3           = 22,   // 马自达-Mazda6-2007
        VSB_MAZDA_8_1           = 23,   // 马自达-Mazda8-2013,2011,2010
        VSB_MAZDA_PREMACY_1     = 24,   // 马自达-普力马-2003
        VSB_MAZDA_PREMACY_2     = 25,   // 马自达-普力马-2006,2005,2004
        VSB_MAZDA_COREWING_1    = 26,   // 马自达-睿翼-2012,2011,2010,2009
        VSB_MAZDA_COREWING_2    = 27,   // 马自达-睿翼轿跑-2011,2010
        VSB_MAZDA_COREWING_3    = 28,   // 马自达-睿翼轿跑-2012
        VSB_MAZDA_2_2           = 29,   // 马自达-Mazda2劲翔(三厢)-2011,2010,2008
        VSB_MAZDA_6_1           = 30,   // 马自达-Mazda6-2004
        VSB_MAZDA_6_4           = 31   // 马自达-Mazda6-2014,2013,2012,2011,2010
}VSB_MAZDA_CLASS;

//雪佛兰子品牌类型
typedef enum _VSB_CHEVROLET_CLASS
{
    VSB_CHEVROLET_OTHER          = 0,   // 其他（保留）
        VSB_CHEVROLET_NEWAVEO        = 1,   // 爱唯欧
        VSB_CHEVROLET_EPICA          = 2,   // 景程
        VSB_CHEVROLET_CRUZE          = 3,   // 科鲁兹
        VSB_CHEVROLET_CAPTIVA        = 4,   // 科帕奇
        VSB_CHEVROLET_MALIBU         = 5,   // 迈锐宝
        VSB_CHEVROLET_SAIL           = 6,   // 赛欧
        VSB_CHEVROLET_CAMARO         = 7,   // 科迈罗
        VSB_CHEVROLET_LECHENG        = 8,   // 乐成
        VSB_CHEVROLET_LOVA           = 9,   // 乐风
        VSB_CHEVROLET_OLDAVEO        = 10,  // 乐骋-老款爱唯欧
        VSB_CHEVROLET_SPARK          = 11,  // 乐驰
        VSB_CHEVROLET_SAILSRV        = 12,   // 赛欧SRV
        VSB_CHEVROLET_LOVA_1         = 13,   // 雪佛兰-乐风-2009,2008,2007,2006
        VSB_CHEVROLET_LOVA_2         = 14,   // 雪佛兰-乐风-2010
        VSB_CHEVROLET_SPARK_1        = 15,   // 雪佛兰-乐驰-2010,2009,2006,2005,2004
        VSB_CHEVROLET_SPARK_2        = 16,   // 雪佛兰-乐驰-2010运动款
        VSB_CHEVROLET_OLDAVEO_1      = 17,   // 雪佛兰-乐骋-2005
        VSB_CHEVROLET_OLDAVEO_2      = 18,   // 雪佛兰-乐骋-2010,2009,2008
        VSB_CHEVROLET_EPICA_1        = 19,   // 雪佛兰-景程-2005
        VSB_CHEVROLET_EPICA_3        = 20,   // 雪佛兰-景程-2012,2011,2010
        VSB_CHEVROLET_EPICA_4        = 21,   // 雪佛兰-景程-2012,2011,2010致真版
        VSB_CHEVROLET_EPICA_5        = 22,   // 雪佛兰-景程-2013
        VSB_CHEVROLET_NEWAVEO_1      = 23,   // 雪佛兰-爱唯欧三厢-2013,2012,2011
        VSB_CHEVROLET_CAPTIVA_1      = 24,   // 雪佛兰-科帕奇-2010,2008
        VSB_CHEVROLET_CAPTIVA_2      = 25,   // 雪佛兰-科帕奇-2014,2013,2012,2011
        VSB_CHEVROLET_KEMAILUO_1     = 26,   // 雪佛兰-科迈罗-2012,2011
        VSB_CHEVROLET_CRUZE_1        = 27,   // 雪佛兰-科鲁兹-2014,2013,2012,2011,2010,2009
        VSB_CHEVROLET_SAIL_1         = 28,   // 雪佛兰-赛欧三厢-2005
        VSB_CHEVROLET_SAIL_2         = 29,   // 雪佛兰-赛欧三厢-2013,2011,2010
        VSB_CHEVROLET_MALIBU_1       = 30,   // 雪佛兰-迈锐宝-2014,2013,2012
        VSB_CHEVROLET_EPICA_2        = 31   // 雪佛兰-景程-2009,2008,2007
}VSB_CHEVROLET_CLASS;

//雪铁龙子品牌类型
typedef enum _VSB_CITROEN_CLASS
{
    VSB_CITROEN_OTHER                 = 0,   // 其他（保留）
        VSB_CITROEN_C2                    = 1,   // 雪铁龙C2
        VSB_CITROEN_C4L                   = 2,   // 雪铁龙C4L
        VSB_CITROEN_C5                    = 3,   // 雪铁龙C5
        VSB_CITROEN_ELYSEE                = 4,   // 爱丽舍三厢
        VSB_CITROEN_CQUATRELIANGXIANG     = 5,   // 世嘉两厢
        VSB_CITROEN_CQUATRESANXIANG       = 6,   // 世嘉三厢
        VSB_CITROEN_SAEAPICASSO           = 7,   // 萨拉-毕加索
        VSB_CITROEN_PICASSO               = 8,   // 毕加索
        VSB_CITROEN_CTRIOMPHE             = 9,   // 凯旋
        VSB_CITROEN_XSARA                 = 10,  // 塞纳  
        VSB_CITROEN_SHENLONGFUKANG        = 11,  // 神龙富康
        VSB_CITROEN_CHANGANDS             = 12,   // 长安DS
        VSB_CITROEN_C2_1                  = 13,   // 雪铁龙-C2-2012,2010,2008,2007,2006
        VSB_CITROEN_C4L_1                 = 14,   // 雪铁龙-C4L-2014,2013
        VSB_CITROEN_C4PICASSO_1           = 15,   // 雪铁龙-C4毕加索-2009舒适版
        VSB_CITROEN_C5_1                  = 16,   // 雪铁龙-C5-2012,2011,2010
        VSB_CITROEN_CQUATRESANXIANG_1     = 17,   // 雪铁龙-世嘉三厢-2013,2012
        VSB_CITROEN_CQUATRELIANGXIANG_1   = 18,   // 雪铁龙-世嘉两厢-2011,2010,2009,2008
        VSB_CITROEN_CTRIOMPHE_1           = 19,   // 雪铁龙-凯旋-2010,2009,2008,2006
        VSB_CITROEN_FUKANG_1              = 20,   // 雪铁龙-富康-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_1              = 21,   // 雪铁龙-爱丽舍三厢-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_2              = 22,   // 雪铁龙-爱丽舍三厢-2013,2012,2011,2010,2009,2008,2007
        VSB_CITROEN_SAEAPICASSO_1         = 23    // 雪铁龙-萨拉-毕加索-2014 
}VSB_CITROEN_CLASS;

//现代子品牌类型
typedef enum _VSB_HYUNDAI_CLASS
{
    VSB_HYUNDAI_OTHER            = 0,   // 其他（保留）
        VSB_HYUNDAI_IX35             = 1,   // 现代IX35
        VSB_HYUNDAI_LANGDONG         = 2,   // 朗动
        VSB_HYUNDAI_MOINCA           = 3,   // 名驭
        VSB_HYUNDAI_SHENGDA          = 4,   // 胜达
        VSB_HYUNDAI_VERNA            = 5,   // 瑞纳
        VSB_HYUNDAI_RUIYI            = 6,   // 瑞奕
        VSB_HYUNDAI_SONATAEIGHT      = 7,   // 索纳塔八
        VSB_HYUNDAI_TUCSON           = 8,   // 途胜
        VSB_HYUNDAI_YUEDONG          = 9,   // 悦动
        VSB_HYUNDAI_ELANTRA          = 10,  // 伊兰特
        VSB_HYUNDAI_GRANDSANTAFE     = 11,  // 格锐
        VSB_HYUNDAI_COUPE            = 12,  // 酷派
        VSB_HYUNDAI_MATRIX           = 13,  // 美佳
        VSB_HYUNDAI_ACCENT           = 14,  // 雅绅特
        VSB_HYUNDAI_IX30             = 15,  // 现代IX30
        VSB_HYUNDAI_SONATA           = 16,  // 索纳塔
        VSB_HYUNDAI_REFINE           = 17,  // 现代瑞风商务车
        VSB_HYUNDAI_MISTRA           = 18,  // 名图
        VSB_HYUNDAI_SONATAYUFENG     = 19,  // 索纳塔-御翔
        VSB_HYUNDAI_SANTAFE          = 20,  // 现代圣达菲
        VSB_HYUNDAI_HUIYI            = 21,   // 进口辉翼
        VSB_HYUNDAI_I30_1            = 22,   // 现代-i30-2010,2009
        VSB_HYUNDAI_IX35_1           = 23,   // 现代-ix35-2012,2011,2010
        VSB_HYUNDAI_YILANTE_1        = 24,   // 现代-伊兰特-2006,2005,2004
        VSB_HYUNDAI_YILANTE_2        = 25,   // 现代-伊兰特-2007三厢
        VSB_HYUNDAI_YILANTE_3        = 26,   // 现代-伊兰特-2011
        VSB_HYUNDAI_SHENGDA_1        = 27,   // 现代-全新胜达-2013,2012
        VSB_HYUNDAI_MINGTU_1         = 28,   // 现代-名图-2014,2013
        VSB_HYUNDAI_MINGYU_1         = 29,   // 现代-名驭-2013,2011,2009
        VSB_HYUNDAI_SHENGDAFEI_1     = 30,   // 现代-圣达菲-未知
        VSB_HYUNDAI_YUXIANG_1        = 31,   // 现代-御翔-2005舒适版
        VSB_HYUNDAI_YUXIANG_2        = 32,   // 现代-御翔-2006,2005
        VSB_HYUNDAI_YUEDONG_1        = 33,   // 现代-悦动-2010,2009,2008
        VSB_HYUNDAI_YUEDONG_2        = 34,   // 现代-悦动-2012,2011
        VSB_HYUNDAI_SHENGDA_2        = 35,   // 现代-新胜达-2009,2006
        VSB_HYUNDAI_SHENGDA_3        = 36,   // 现代-新胜达-2012,2011,2010
        VSB_HYUNDAI_LANGDONG_1       = 37,   // 现代-朗动-2013,2012
        VSB_HYUNDAI_GERUI_1          = 38,   // 现代-格锐-未知
        VSB_HYUNDAI_RUIYI_1          = 39,   // 现代-瑞奕-2014
        VSB_HYUNDAI_RUINA_1          = 40,   // 现代-瑞纳三厢-2013,2010
        VSB_HYUNDAI_RUINA_2          = 41,   // 现代-瑞纳两厢-2014,2013,2011
        VSB_HYUNDAI_RUIFENG_1        = 42,   // 现代-瑞风-未知
        VSB_HYUNDAI_SUONATA_1        = 43,   // 现代-索纳塔-2008,2007,2006,2004,2003标准型
        VSB_HYUNDAI_SUONATA_2        = 44,   // 现代-索纳塔-2010,2009,2008,2006,2004
        VSB_HYUNDAI_SOUNATA_3        = 45,   // 现代-索纳塔八-2011,2010
        VSB_HYUNDAI_WEILAKESI_1      = 46,   // 现代-维拉克斯-2012,2010,2008,2007
        VSB_HYUNDAI_MEIJIA_1         = 47,   // 现代-美佳-未知
        VSB_HYUNDAI_JINKOUHUIYI_1    = 48,   // 现代-进口辉翼-未知
        VSB_HYUNDAI_TUSHENG_1        = 49,   // 现代-途胜-2005
        VSB_HYUNDAI_TUSHENG_2        = 50,   // 现代-途胜-2011,2009,2008,2006
        VSB_HYUNDAI_TUSHENG_3        = 51,   // 现代-途胜-2013
        VSB_HYUNDAI_KUPAI_1          = 52,   // 现代-酷派-未知
        VSB_HYUNDAI_YASHENTE_1       = 53,   // 现代-雅绅特-2008,2006
        VSB_HYUNDAI_YASHENTE_2       = 54,   // 现代-雅绅特-2011
        VSB_HYUNDAI_LINGXIANG_1      = 55,   // 现代-领翔-2009,2008
        VSB_HYUNDAI_FEISI_1          = 56    // 现代-飞思-2011
}VSB_HYUNDAI_CLASS;

//奇瑞子品牌类型
typedef enum _VSB_CHERY_CLASS
{
    VSB_CHERY_OTHER        = 0,   // 其他（保留）
        VSB_CHERY_A1           = 1,   // 奇瑞A1
        VSB_CHERY_A3           = 2,   // 奇瑞A3
        VSB_CHERY_EASTAR       = 3,   // 东方之子
        VSB_CHERY_FULWIN       = 4,   // 风云
        VSB_CHERY_QQ           = 5,   // 奇瑞QQ
        VSB_CHERY_E5           = 6,   // 奇瑞E5
        VSB_CHERY_COWIN        = 7,   // 旗云
        VSB_CHERY_TIGGO        = 8,   // 瑞虎
        VSB_CHERY_A5           = 9,   // 奇瑞A5
        VSB_CHERY_S16          = 10,  // 奇瑞S16
        VSB_CHERY_YOUYA        = 11,  // 优雅
        VSB_CHERY_V5           = 12,  // 奇瑞V5
        VSB_CHERY_E3           = 13,   // 奇瑞E3
        VSB_CHERY_A1_1                = 14,     // 奇瑞-A1-2011,2008,2007
        VSB_CHERY_A3LIANGXIANG_1      = 15,     // 奇瑞-A3两厢-2012,2010,2009
        VSB_CHERY_A5_1                = 16,     // 奇瑞-A5-2009,2007,2006
        VSB_CHERY_QQ_1                = 17,     // 奇瑞-QQ-2006,2005,2004
        VSB_CHERY_QQ_2                = 18,     // 奇瑞-QQ-2010,2007,2006
        VSB_CHERY_QQ_3                = 19,     // 奇瑞-QQ-2012,2011,2010,2009,2007
        VSB_CHERY_QQ_4                = 20,     // 奇瑞-QQ-2012运动版
        VSB_CHERY_QQ_5                = 21,     // 奇瑞-QQ-2013
        VSB_CHERY_DONGFANGZHIZI_1     = 22,     // 奇瑞-东方之子-2005,2004,2003
        VSB_CHERY_DONGFANGZHIZI_2     = 23,     // 奇瑞-东方之子-2007,2006
        VSB_CHERY_DONGFANGZHIZI_3     = 24,     // 奇瑞-东方之子CROSS-2009,2008,2007
        VSB_CHERY_YOUYA_1             = 25,     // 奇瑞-优雅-未知
        VSB_CHERY_E3_1                = 26,     // 奇瑞-奇瑞E3-2013
        VSB_CHERY_E5_1                = 27,     // 奇瑞-奇瑞E5-2014,2012,2011
        VSB_CHERY_QIYUN1_1            = 28,     // 奇瑞-旗云1-2010
        VSB_CHERY_QIYUN1_2            = 29,     // 奇瑞-旗云1-2012
        VSB_CHERY_QIYUN_1             = 30,     // 奇瑞-旗云-2004
        VSB_CHERY_QIYUN_2             = 31,     // 奇瑞-旗云-2009,2008,2007,2006
        VSB_CHERY_QIYUN2_1            = 32,     // 奇瑞-旗云2-2012
        VSB_CHERY_QIYUN2_2            = 33,     // 奇瑞-旗云2-2012豪华型,2010
        VSB_CHERY_QIYUN3_1            = 34,     // 奇瑞-旗云3-2010
        VSB_CHERY_RUIHU_1             = 35,     // 奇瑞-瑞虎-2007,2006,2005
        VSB_CHERY_RUIHU_2             = 36,     // 奇瑞-瑞虎-2009,2007
        VSB_CHERY_RUIHU_3             = 37,     // 奇瑞-瑞虎-2012,2011
        VSB_CHERY_RUIHU_4             = 38,     // 奇瑞-瑞虎-2013,2012自动DVVT豪华型
        VSB_CHERY_RUIHU_5             = 39,     // 奇瑞-瑞虎-2013精英版豪华型,2012精英版舒适型
        VSB_CHERY_FENGYUN2SANXIANG_1  = 40,     // 奇瑞-风云2三厢-2010
        VSB_CHERY_AIRUIZE7_1          = 41     // 奇瑞-艾瑞泽7-2014,2013
}VSB_CHERY_CLASS;

//起亚子品牌类型
typedef enum _VSB_KIA_CLASS
{
    VSB_KIA_OTHER        = 0,   // 其他（保留）
        VSB_KIA_K2           = 1,   // 起亚K2
        VSB_KIA_K3           = 2,   // 起亚K3
        VSB_KIA_K5           = 3,   // 起亚K5
        VSB_KIA_RIO          = 4,   // 锐欧
        VSB_KIA_CERATO       = 5,   // 赛拉图
        VSB_KIA_SPORTAGER    = 6,   // 狮跑
        VSB_KIA_SOUL         = 7,   // 秀尔
        VSB_KIA_ZHIPAO       = 8,   // 智跑
        VSB_KIA_CARENS       = 9,   // 佳乐
        VSB_KIA_CARNIVAL     = 10,  // 嘉华
        VSB_KIA_OPTIMA       = 11,  // 远舰
        VSB_KIA_OPIRUS       = 12,  // 欧菲莱斯
        VSB_KIA_MAXIMA       = 13,  // 千里马
        VSB_KIA_FORTE        = 14,  // 福瑞迪
        VSB_KIA_SORENTO      = 15,  // 索兰托
        VSB_KIA_K2_1         = 16,   // 起亚-K2-2013,2012,2011
        VSB_KIA_K3_1         = 17,   // 起亚-K3-2012
        VSB_KIA_K5_1         = 18,   // 起亚-K5-2012,2011
        VSB_KIA_RUIOU_1      = 19,   // 起亚-RIO锐欧-2009,2007
        VSB_KIA_QIANLIMA_1   = 20,   // 起亚-千里马-2004
        VSB_KIA_QIANLIMA_2   = 21,   // 起亚-千里马-2006,2005
        VSB_KIA_JIAHUA_1     = 22,   // 起亚-嘉华-未知
        VSB_KIA_XINJIALE_1   = 23,   // 起亚-新佳乐-2011
        VSB_KIA_ZHIPAO_1     = 24,   // 起亚-智跑-2014,2012,2011,2010
        VSB_KIA_SHIPAO_1     = 25,  // 起亚-狮跑-2008,2007,2005
        VSB_KIA_SHIPAO_2     = 26,  // 起亚-狮跑-2011,2009
        VSB_KIA_SHIPAO_3     = 27,  // 起亚-狮跑-2012
        VSB_KIA_SHIPAO_4     = 28,  // 起亚-狮跑-2013
        VSB_KIA_FURUIDI_1    = 29,  // 起亚-福瑞迪-2012,2011,2009
        VSB_KIA_FURUIDI_2    = 30,  // 起亚-福瑞迪-2014
        VSB_KIA_XIUER_1      = 31,  // 起亚-秀尔-2012,2010
        VSB_KIA_SUOLANTUO_1  = 32,  // 起亚-索兰托-2006
        VSB_KIA_SUOLANTUO_2  = 33,  // 起亚-索兰托-2012,2010,2009
        VSB_KIA_SAILATU_1    = 34,  // 起亚-赛拉图-2006,2005
        VSB_KIA_SAILATU_2    = 35,  // 起亚-赛拉图-2007
        VSB_KIA_SAILATU_3    = 36,  // 起亚-赛拉图-2012,2010GLS
        VSB_KIA_YUANJIAN_1   = 37   // 起亚-远舰-未知
}VSB_KIA_CLASS;

//奔驰子品牌类型
typedef enum _VSB_BENZ_CLASS
{
    VSB_BENZ_OTHER         = 0,   // 其他（保留）
        VSB_BENZ_C             = 1,   // 奔驰C级
        VSB_BENZ_E             = 2,   // 奔驰E级
        VSB_BENZ_GLK           = 3,   // 奔驰GLK级
        VSB_BENZ_WEITING       = 4,   // 威霆-PINYIN
        VSB_BENZ_SPRINTER      = 5,   // 凌特
        VSB_BENZ_VIANO         = 6,   // 唯雅诺
        VSB_BENZ_M             = 7,   // 奔驰M系
        VSB_BENZ_CLK           = 8,   // 奔驰CLK系
        VSB_BENZ_G             = 9,   // 奔驰G系
        VSB_BENZ_GL            = 10,  // 奔驰GL系
        VSB_BENZ_R             = 11,  // 奔驰R系
        VSB_BENZ_S             = 12,  // 奔驰S系
        VSB_BENZ_A             = 13,  // 奔驰A系
        VSB_BENZ_SMART         = 14,  // 斯玛特(精灵)
        VSB_BENZ_B             = 15,  // 奔驰B系
        VSB_BENZ_SLK           = 16,  // 奔驰SLK系
        VSB_BENZ_MB100         = 17,  // 奔驰MB100
        VSB_BENZ_VITO          = 18,  // 威特
        VSB_BENZ_CLS           = 19,  // 奔驰CLS系
        VSB_BENZ_SL            = 20,   // 奔驰SL系
        VSB_BENZ_AJI_1         = 21,   // 奔驰-A级-2011,2009
        VSB_BENZ_AJI_2         = 22,   // 奔驰-A级-2013
        VSB_BENZ_BJI_1         = 23,   // 奔驰-B级-2010,2009
        VSB_BENZ_CJI_1         = 24,   // 奔驰-C级-2010,2008,2007时尚型
        VSB_BENZ_CJI_2         = 25,   // 奔驰-C级-2013,2011,CGI
        VSB_BENZ_CJI_3         = 26,   // 奔驰-C级-2013,2011时尚型
        VSB_BENZ_EJI_1         = 27,   // 奔驰-E级-2002
        VSB_BENZ_EJI_2         = 28,   // 奔驰-E级-2007,2006
        VSB_BENZ_EJI_3         = 29,   // 奔驰-E级-2013,2012,2011,2010,2009
        VSB_BENZ_EJI_4         = 30,   // 奔驰-E级-2013,2012,2011,2010,2009时尚型
        VSB_BENZ_GLKJI_1       = 31,   // 奔驰-GLK级-2012,2011
        VSB_BENZ_GLKJI_2       = 32,   // 奔驰-GLK级-2012,2011豪华型,2008
        VSB_BENZ_GLKJI_3       = 33,   // 奔驰-GLK级-2014,2013
        VSB_BENZ_GLJI_1        = 34,   // 奔驰-GL级-2011
        VSB_BENZ_GLJI_2        = 35,   // 奔驰-GL级-2011尊贵型,2010
        VSB_BENZ_GLJI_3        = 36,   // 奔驰-GL级-2012,2010北美版
        VSB_BENZ_GJI_1         = 37,   // 奔驰-G级-2013,2010,2009
        VSB_BENZ_MB100_1       = 38,   // 奔驰-MB100-2000
        VSB_BENZ_MLJI_1        = 39,   // 奔驰-ML级-2006,2005
        VSB_BENZ_MLJI_2        = 40,   // 奔驰-ML级-2010,2008
        VSB_BENZ_MLJI_3        = 41,   // 奔驰-ML级-2014,2012
        VSB_BENZ_RJI_1         = 42,   // 奔驰-R级-2006
        VSB_BENZ_RJI_2         = 43,   // 奔驰-R级-2007
        VSB_BENZ_RJI_3         = 44,   // 奔驰-R级-2014,2011,2010,2009
        VSB_BENZ_SLKJI_2       = 45,   // 奔驰-SLK级-2006,2004
        VSB_BENZ_SLKJI_3       = 46,   // 奔驰-SLK级-2010,2009
        VSB_BENZ_SLKJI_1       = 47,   // 奔驰-SLK级-2011
        VSB_BENZ_SJI_1         = 48,   // 奔驰-S级-2004
        VSB_BENZ_SJI_2         = 49,   // 奔驰-S级-2009_Hybrid,2008,2006
        VSB_BENZ_SJI_3         = 50,   // 奔驰-S级-2009,2008商务型
        VSB_BENZ_SJI_4         = 51,   // 奔驰-S级-2012,2011,2010
        VSB_BENZ_LINGTE_1      = 52,   // 奔驰-凌特-2013,2012,2011
        VSB_BENZ_WEIYANUO_1    = 53,   // 奔驰-唯雅诺-2010,2006,2004
        VSB_BENZ_WEIYANUO_2    = 54,   // 奔驰-唯雅诺-2014,2013,2012,2011
        VSB_BENZ_WEITING_1     = 55,   // 奔驰-威霆-2013,2011,2010
        VSB_BENZ_KECHE_1       = 56    // 奔驰-客车车型1-A款
}VSB_BENZ_CLASS;

//斯柯达子品牌类型
typedef enum _VSB_SKODA_CLASS
{
    VSB_SKODA_OTHER            = 0,   // 其他（保留）
        VSB_SKODA_HAORUI           = 1,   // 昊锐
        VSB_SKODA_FABIA            = 2,   // 晶锐
        VSB_SKODA_OCTAVIA          = 3,   // 明锐
        VSB_SKODA_SUPERB           = 4,   // 速派
        VSB_SKODA_SPACEBACK        = 5,   // 昕动
        VSB_SKODA_RAPID            = 6,   // 昕锐
        VSB_SKODA_YETI             = 7,    // 野帝
        VSB_SKODA_HAORUI_1         = 8,      // 斯柯达-昊锐-2013,2012,2010,2009
        VSB_SKODA_MINGRUI_1        = 9,      // 斯柯达-明锐-2009,2008,2007
        VSB_SKODA_MINGRUI_2        = 10,      // 斯柯达-明锐-2014,2013,2012,2011,2010
        VSB_SKODA_MINGRUI_3        = 11,      // 斯柯达-明锐RS-2010
        VSB_SKODA_XINRUI_1         = 12,      // 斯柯达-昕锐-2013乐选型
        VSB_SKODA_JINGRUI_1        = 13,      // 斯柯达-晶锐-2011,2009,2008
        VSB_SKODA_JINGRUI_2        = 14,      // 斯柯达-晶锐-2014,2013,2012
        VSB_SKODA_JINGRUI_3        = 15,      // 斯柯达-晶锐-2014,2013,2012Sport版
        VSB_SKODA_SUPAI_1          = 16,      // 斯柯达-速派-2013
        VSB_SKODA_YEDI_1           = 17      // 斯柯达-野帝-2014,2013
}VSB_SKODA_CLASS;

//东风子品牌类型
typedef enum _VSB_DONGFENG_CLASS
{
    VSB_DONGFENG_OTHER                 = 0,   // 其他（保留）
        VSB_DONGFENG_JOYEARX5              = 1,   // 景逸X5
        VSB_DONGFENG_LINGZHI               = 2,   // 菱智
        VSB_DONGFENG_JOYEARX3              = 3,   // 景逸X3
        VSB_DONGFENG_JOYEAR                = 4,   // 景逸
        VSB_DONGFENG_FENGXINGCM7           = 5,   // 风行CM7
        VSB_DONGFENG_YUFENG                = 6,   // 御风
        VSB_DONGFENG_FENGSHENA60           = 7,   // 风神A60
        VSB_DONGFENG_FENGSHENS30           = 8,   // 风神S30
        VSB_DONGFENG_FENGSHENH30CROSS      = 9,   // 风神H30-CROSS
        VSB_DONGFENG_PICKUP                = 10,  // 东风皮卡
        VSB_DONGFENG_ZHONGXINGMIANBAOCHE   = 11,  // 东风中型面包车
        VSB_DONGFENG_XIAOXINGMIANBAOCHE    = 12,  // 东风小型面包车
        VSB_DONGFENG_ZHONGXINGVAN          = 13,  // 东风重型货车
        VSB_DONGFENG_QINGXINGXIANGSHIVAN   = 14,  // 东风轻型厢式货车
        VSB_DONGFENG_QINGZHONGXINGVAN      = 15,  // 东风轻中型普通货车
        VSB_DONGFENG_FENGSHENMERCURY       = 16,  // 风神水星
        VSB_DONGFENG_SUCCE                 = 17,  // 帅客
        VSB_DONGFENG_ODIN                  = 18,  // 奥丁
        VSB_DONGFENG_YUMSUN                = 19,  // 御轩
        VSB_DONGFENG_RUIQI                 = 20,  // 锐骐
        VSB_DONGFENG_FENGGUANG             = 21,  // 风光
        VBR_DONGFENG_C35_1                 = 22,   // 东风-C35-2013
        VBR_DONGFENG_K07_1                 = 23,   // 东风-K07-2008
        VBR_DONGFENG_K07_2                 = 24,   // 东风-K07-2010,2006
        VBR_DONGFENG_V21_1                 = 25,   // 东风-V21-2011
        VBR_DONGFENG_JIALONG_1             = 26,   // 东风-东风嘉龙-载货车
        VBR_DONGFENG_XKFG_1                = 27,   // 东风-东风小康风光-2013
        VBR_DONGFENG_CV03_1                = 28,   // 东风-俊风CV03-2012
        VBR_DONGFENG_KAIPUTE_1             = 29,   // 东风-凯普特-C390
        VBR_DONGFENG_DUOLIKA_1             = 30,   // 东风-多利卡-S2800
        VBR_DONGFENG_DUOLIKA_2             = 31,   // 东风-多利卡-XL中卡
        VBR_DONGFENG_DUOLIKA_3             = 32,   // 东风-多利卡-中卡
        VBR_DONGFENG_TIANJIN_1             = 33,   // 东风-天锦-4X2载货车
        VBR_DONGFENG_TIANJIN_2             = 34,   // 东风-天锦-A款
        VBR_DONGFENG_XBW_1                 = 35,   // 东风-小霸王-轻卡1
        VBR_DONGFENG_XBW_2                 = 36,   // 东风-小霸王-轻卡2
        VBR_DONGFENG_MENGKA_1              = 37,   // 东风-梦卡-轻卡
        VBR_DONGFENG_FURUIKA_1             = 38,   // 东风-福瑞卡-轻卡1
        VBR_DONGFENG_RUIQI_1               = 39,   // 东风-锐骐皮卡-2013,2010,2009
        VBR_DONGFENG_A60_1                 = 40,   // 东风风神-A60-2014,2012
        VBR_DONGFENG_H30_1                 = 41,   // 东风风神-H30-Cross-2012,2011
        VBR_DONGFENG_H30_2                 = 42,   // 东风风神-H30-Cross-2014,2013
        VBR_DONGFENG_H30_3                 = 43,   // 东风风神-H30-2012
        VBR_DONGFENG_JINGYI_1              = 44,   // 东风风行-景逸-2014_2012LV,2011豪华型
        VBR_DONGFENG_JINGYI_2              = 45,   // 东风风行-景逸-2014_2012XL,2011,2010,2009,2008,2007
        VBR_DONGFENG_JINGYI_3              = 46,   // 东风风行-景逸X5-2014,2013
        VBR_DONGFENG_LINGZHI_1             = 47,   // 东风风行-菱智-2004
        VBR_DONGFENG_LINGZHI_2             = 48,   // 东风风行-菱智-2011,2008,2007
        VBR_DONGFENG_LINGZHI_3             = 49,   // 东风风行-菱智-2011Q3标准型,2010Q7
        VBR_DONGFENG_LINGZHI_4             = 50,   // 东风风行-菱智-2014_2013M3
        VBR_DONGFENG_LINGZHI_5             = 51   // 东风风行-菱智-2014_2013V3,2011M3_商用版_舒适型
}VSB_DONGFENG_CLASS;

//比亚迪子品牌类型
typedef enum _VSB_BYD_CLASS
{
    VSB_BYD_OTHER         = 0,   // 其他（保留）
        VSB_BYD_F0            = 1,   // 比亚迪F0
        VSB_BYD_F3            = 2,   // 比亚迪F3
        VSB_BYD_F3R           = 3,   // 比亚迪F3R
        VSB_BYD_F6            = 4,   // 比亚迪F6
        VSB_BYD_G3            = 5,   // 比亚迪G3
        VSB_BYD_G3R           = 6,   // 比亚迪G3R
        VSB_BYD_G6            = 7,   // 比亚迪G6
        VSB_BYD_L3            = 8,   // 比亚迪L3
        VSB_BYD_M6            = 9,   // 比亚迪M6
        VSB_BYD_S6            = 10,  // 比亚迪S6
        VSB_BYD_SURUI         = 11,  // 速锐
        VSB_BYD_FOLEL         = 12,  // 秦川福莱尔
        VSB_BYD_SIRUI         = 13,  // 思锐
        VSB_BYD_MT5           = 14,  // 比亚迪MT5(精灵)
        VSB_BYD_F0_1          = 15,        // 比亚迪-F0-2013,2012,2011,2010,2009,2008
        VSB_BYD_F3R_1         = 16,        // 比亚迪-F3R-2011,2009,2008,2007
        VSB_BYD_F6_1          = 17,        // 比亚迪-F6-2011,2009,2008
        VSB_BYD_G3R_1         = 18,        // 比亚迪-G3R-2011
        VSB_BYD_G6_1          = 19,        // 比亚迪-G6-2013,2012,2011
        VSB_BYD_L3_1          = 20,        // 比亚迪-L3-2013,2012,2011,2010
        VSB_BYD_M6_1          = 21,        // 比亚迪-M6-2013,2011,2010
        VSB_BYD_S6_1          = 22,        // 比亚迪-S6-2014,2013,2012,2011
        VSB_BYD_FULAIER_1     = 23,        // 比亚迪-福莱尔-2005豪华型
        VSB_BYD_SURUI_1       = 24        // 比亚迪-速锐-2014,2013,2012
}VSB_BYD_CLASS;

//铃木子品牌类型
typedef enum _VSB_SUZUKI_CLASS
{
    VSB_SUZUKI_OTHER           = 0,   // 其他（保留）
        VSB_SUZUKI_ALTO            = 1,   // 长安奥拓
        VSB_SUZUKI_SCROSS          = 2,   // 锋驭
        VSB_SUZUKI_SWIFT           = 3,   // 雨燕
        VSB_SUZUKI_SX4             = 4,   // 天语
        VSB_SUZUKI_LINGYANG        = 5,   // 羚羊
        VSB_SUZUKI_BEIDOUXING      = 6,   // 北斗星
        VSB_SUZUKI_LIANAA6         = 7,   // 利亚纳-A6
        VSB_SUZUKI_LANDY           = 8,   // 浪迪
        VSB_SUZUKI_SPLASH          = 9,   // 派喜
        VSB_SUZUKI_GRANDVITARA     = 10,  // 超级维特拉
        VSB_SUZUKI_JIMNY           = 11,  // 吉姆尼
        VSB_SUZUKI_KAZASHI         = 12,  // 凯泽西
        VSB_SUZUKI_LIANA           = 13,   // 利亚纳
        VSB_SUZUKI_LIANA_1           = 14,     // 铃木-利亚纳三厢-2012,2011,2010,2008,2007,2005
        VSB_SUZUKI_LIANA_2           = 15,     // 铃木-利亚纳两厢-2013,2012,2011
        VSB_SUZUKI_BEIDOUXING_1      = 16,     // 铃木-北斗星-2012,2011,2010,2009,2008,2007,2005,2004标准型
        VSB_SUZUKI_BEIDOUXING_2      = 17,     // 铃木-北斗星-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003
        VSB_SUZUKI_BEIDOUXING_3      = 18,     // 铃木-北斗星-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003适用型
        VSB_SUZUKI_BEIDOUXING_4      = 19,     // 铃木-北斗星-2013X5
        VSB_SUZUKI_JIMUNI_1          = 20,     // 铃木-吉姆尼-2011,2010,2009,2007
        VSB_SUZUKI_JIMUNI_2          = 21,     // 铃木-吉姆尼-2012
        VSB_SUZUKI_SX4_1             = 22,     // 铃木-天语SX4三厢-2008,2006
        VSB_SUZUKI_SX4_2             = 23,     // 铃木-天语SX4三厢-2010,2009
        VSB_SUZUKI_SX4_3             = 24,     // 铃木-天语SX4两厢-2011A,2009,2008,2007
        VSB_SUZUKI_SX4_4             = 25,     // 铃木-天语SX4两厢-2011B
        VSB_SUZUKI_SX4_5             = 26,     // 铃木-天语SX4尚悦-2013,2012,2011
        VSB_SUZUKI_ALTO_1            = 27,     // 铃木-奥拓-2006,2001,2000,1999,1993标准型
        VSB_SUZUKI_ALTO_2            = 28,     // 铃木-奥拓-2006,2004,2001,2000,1999,1993
        VSB_SUZUKI_ALTO_3            = 29,     // 铃木-奥拓-2013
        VSB_SUZUKI_ALTO_4            = 30,     // 铃木-奥拓-2014,2012,2011,2010,2009
        VSB_SUZUKI_SPLASH_1          = 31,     // 铃木-派喜-2013,2012,2011
        VSB_SUZUKI_LANDY_1           = 32,     // 铃木-浪迪-2011,2010,2007
        VSB_SUZUKI_LINGYANG_2        = 33,     // 铃木-羚羊-2006,2004,2003
        VSB_SUZUKI_LINGYANG_3        = 34,     // 铃木-羚羊-2009,2008,2007
        VSB_SUZUKI_LINGYANG_4        = 35,     // 铃木-羚羊-2011
        VSB_SUZUKI_LINGYANG_5        = 36,     // 铃木-羚羊-2012
        VSB_SUZUKI_GRANDVITARA_1     = 37,     // 铃木-超级维特拉-2011,2008,2007,2006
        VSB_SUZUKI_FENGYU_1          = 38,     // 铃木-锋驭-2014
        VSB_SUZUKI_SWIFT_1           = 39,     // 铃木-雨燕-2011_1.3L,2009,2008,2007,2005
        VSB_SUZUKI_SWIFT_2           = 40,     // 铃木-雨燕-2012,2011
        VSB_SUZUKI_KINGCHANG_1       = 41,     // 铃木-昌铃王-2004
        VSB_SUZUKI_LINGYANG_1        = 42     // 铃木-羚羊-2002
}VSB_SUZUKI_CLASS;

//五菱子品牌类型
typedef enum _VSB_SGMW_CLASS
{
    VSB_SGMW_OTHER               = 0,   // 其他（保留）
        VSB_SGMW_HONGGUANG           = 1,   // 五菱宏光
        VSB_SGMW_HONGGUANGS          = 2,   // 五菱宏光S
        VSB_SGMW_ZHIGUANG            = 3,   // 五菱之光
        VSB_SGMW_RONGGUANGS          = 4,   // 五菱荣光S
        VSB_SGMW_RONGGUANG           = 5,   // 五菱荣光
        VSB_SGMW_HONGTU              = 6,   // 五菱鸿途
        VSB_SGMW_XINGWANG            = 7,   // 五菱兴旺
        VSB_SGMW_YANGGUANG           = 8,   // 五菱扬光
        VSB_SGMW_XIAOXUANFENG        = 9,   // 五菱小旋风
        VSB_SGMW_WULINGZHIGUANG_1    = 10,       // 五菱-五菱之光-2010,2009立业
        VSB_SGMW_WULINGZHIGUANG_2    = 11,       // 五菱-五菱之光-2010短车身,基本型
        VSB_SGMW_WULINGZHIGUANG_3    = 12,       // 五菱-五菱之光-2010长车身,2008厢式,2007
        VSB_SGMW_XINGWANG_1          = 13,       // 五菱-兴旺面包车-2003
        VSB_SGMW_XINGWANG_2          = 14,       // 五菱-兴旺面包车-2009标准
        VSB_SGMW_XINGWANG_3          = 15,       // 五菱-兴旺面包车-2010,2009,2007,2006,2005,2004
        VSB_SGMW_HONNGUANG_1         = 16,       // 五菱-宏光-2013,2010
        VSB_SGMW_HONNGUANG_2         = 17,       // 五菱-宏光-2014,2013S
        VSB_SGMW_XIAOXUANFENG_1      = 18,       // 五菱-小旋风-2006
        VSB_SGMW_YANGGUANG_1         = 19,       // 五菱-扬光-2006,2005,2004
        VSB_SGMW_YANGGUANG_2         = 20,       // 五菱-扬光-2008,2007
        VSB_SGMW_YANGGUANG_3         = 21,       // 五菱-扬光-2009,2006,2005手动标准型
        VSB_SGMW_RONGGUANG_1         = 22,       // 五菱-荣光面包车-2012,2011,2008基本
        VSB_SGMW_RONGGUANG_2         = 23,       // 五菱-荣光面包车-2012,2011,2008标准
        VSB_SGMW_HONGTU_1            = 24        // 五菱-鸿途-2010,2009,2008,2007
}VSB_SGMW_CLASS;

//长安子品牌类型
typedef enum _VSB_CHANA_CLASS
{
    VSB_CHANA_OTHER                = 0,   // 其他（保留）
        VSB_CHANA_HONOR                = 1,   // 欧诺
        VSB_CHANA_XINGKA               = 2,   // 长安星卡
        VSB_CHANA_ZHIXING              = 3,   // 长安之星
        VSB_CHANA_PICKUP               = 4,   // 长安神骐小卡(长安皮卡)
        VSB_CHANA_ZHIXING2             = 5,   // 长安之星2代
        VSB_CHANA_TAURUS               = 6,   // 金牛星
        VSB_CHANA_XINGGUANG            = 7,   // 长安星光
        VSB_CHANA_BENNI                = 8,   // 奔奔
        VSB_CHANA_ALSVIN               = 9,   // 悦翔
        VSB_CHANA_CX20                 = 10,  // 长安CX20
        VSB_CHANA_CX30                 = 11,  // 长安CX30
        VSB_CHANA_EADO                 = 12,  // 逸动
        VSB_CHANA_ZHIXINGS460          = 13,  // 长安之星S460
        VSB_CHANA_CM8                  = 14,  // 长安CM8
        VSB_CHANA_XINBAO               = 15,  // 新豹
        VSB_CHANA_XUNLONG              = 16,  // 勋龙
        VSB_CHANA_YUNTONG              = 17,  // 运通
        VSB_CHANA_LEIMENG              = 18,  // 镭蒙
        VSB_CHANA_XINGYUN              = 19,  // 长安星韵
        VSB_CHANA_OULIWEI              = 20,  // 欧力威
        VSB_CHANA_EADOXT               = 21,   // 致尚XT
        VSB_CHANA_XINGYUN_1            = 22,      // 长安商用-星韵-2004,2003,2000
        VSB_CHANA_OULIWEI_1            = 23,      // 长安商用-欧力威-2013
        VSB_CHANA_YUNTONG_1            = 24,      // 长安商用-运通-2004
        VSB_CHANA_TAURUS_1             = 25,      // 长安商用-金牛星-2013,2012,2011,2010
        VSB_CHANA_LEIMENG_1            = 26,      // 长安商用-镭蒙-2005,2003
        VSB_CHANA_ZHIXING_1            = 27,      // 长安商用-长安之星-2010,2009
        VSB_CHANA_ZHIXING_2            = 28,      // 长安商用-长安之星-2013
        VSB_CHANA_ZHIXING_3            = 29,      // 长安商用-长安之星2-2009,2008
        VSB_CHANA_ZHIXING_4            = 30,      // 长安商用-长安之星2-2012
        VSB_CHANA_ZHIXING_5            = 31,      // 长安商用-长安之星S460-2010,2009
        VSB_CHANA_ZHIXING_6            = 32,      // 长安商用-长安之星SC6350-2003
        VSB_CHANA_PICKUP_1             = 33,      // 长安商用-长安微货神骐-2013,2012
        VSB_CHANA_XINGGUANG_1          = 34,      // 长安商用-长安星光4500-2009,2007
        VSB_CHANA_XINGGUANG_2          = 35,      // 长安商用-长安星光4500-2012
        VSB_CHANA_HONOR_1              = 36      // 长安商用-长安欧诺-2014,2012
}VSB_CHANA_CLASS;

//长安轿车子品牌类型
typedef enum _VSB_EADO_CLASS
{
    VSB_EADO_OTHER                = 0,       // 其他（保留）
        VSB_EADO_CS_1                 = 1,       // 长安轿车-CS35-2014,2013,2012
        VSB_EADO_CX_1                 = 2,       // 长安轿车-CX20-2011
        VSB_EADO_CX_2                 = 3,       // 长安轿车-CX30两厢-2010
        VSB_EADO_BENBEN_1             = 4,       // 长安轿车-奔奔-2008,2007,2006
        VSB_EADO_BENBEN_2             = 5,       // 长安轿车-奔奔-2008经典型,2007运动型
        VSB_EADO_BENBEN_3             = 6,       // 长安轿车-奔奔-2010
        VSB_EADO_BENBEN_4             = 7,       // 长安轿车-奔奔MINI-2011,2010
        VSB_EADO_BENBEN_5             = 8,       // 长安轿车-奔奔MINI-2012
        VSB_EADO_YUEXIANG_1           = 9,       // 长安轿车-悦翔-2011,2010,2009
        VSB_EADO_YUEXIANG_2           = 10,       // 长安轿车-悦翔-2012
        VSB_EADO_YUEXIANG_3           = 11,       // 长安轿车-悦翔V3-2013,2012
        VSB_EADO_YUEXIANG_4           = 12,       // 长安轿车-悦翔V5-2012
        VSB_EADO_YIDONG_1             = 13        // 长安轿车-逸动-2014,2013,2012
}VSB_EADO_CLASS;

//金杯子品牌类型
typedef enum _VSB_JINBEI_CLASS
{
    VSB_JINBEI_OTHER           = 0,   // 其他（保留）
        VSB_JINBEI_GRACE           = 1,   // 金杯阁瑞斯
        VSB_JINBEI_HIACE           = 2,   // 金杯海狮
        VSB_JINBEI_HAIXING         = 3,   // 海星
        VSB_JINBEI_BADAO           = 4,   // 金杯霸道
        VSB_JINBEI_LINGQI          = 5,   // 领骐
        VSB_JINBEI_JINQI           = 6,   // 金骐
        VSB_JINBEI_LINGCHI         = 7,   // 领驰
        VSB_JINBEI_QIYUN           = 8,   // 骐运
        VSB_JINBEI_ZHISHANG_1      = 9,       // 金杯-智尚S30-2014,2013,2012
        VSB_JINBEI_HAIXING_1       = 10,       // 金杯-海星-2012
        VSB_JINBEI_HAIXING_2       = 11,       // 金杯-海星-2012A7特惠型,2011
        VSB_JINBEI_HIACE_1         = 12,       // 金杯-海狮-2008
        VSB_JINBEI_HIACE_2         = 13,       // 金杯-海狮-2013,2011,2010
        VSB_JINBEI_HIACE_3         = 14,       // 金杯-海狮-2013豪华型,2011汽油,2008标准型
        VSB_JINBEI_JINDIAN_1       = 15,       // 金杯-金典-2009
        VSB_JINBEI_GRACE_1         = 16,       // 金杯-阁瑞斯MPV-2011,2008,2007
        VSB_JINBEI_GRACE_2         = 17,       // 金杯-阁瑞斯MPV-2011御领豪华型,2010,2009,2007标准9座
        VSB_JINBEI_BADAO_1         = 18       // 金杯-霸道SUV-2011,2008 
        
}VSB_JINBEI_CLASS;

//吉利子品牌类型
typedef enum _VSB_GEELY_CLASS
{
    VSB_GEELY_OTHER              = 0,   // 其他（保留）
        VSB_GEELY_EC7                = 1,   // 吉利帝豪EC7
        VSB_GEELY_EC8                = 2,   // 吉利帝豪EC8                                                          
        VSB_GEELY_SC3                = 3,   // 吉利SC3
        VSB_GEELY_SC5RV              = 4,   // 吉利SC5-RV
        VSB_GEELY_SC6                = 5,   // 吉利SC6
        VSB_GEELY_JINGYING           = 6,   // 金鹰
        VSB_GEELY_JINGGANG           = 7,   // 金刚
        VSB_GEELY_SX7                = 8,   // 吉利SX7
        VSB_GEELY_HAOQING            = 9,   // 豪情
        VSB_GEELY_MEIRI              = 10,  // 美日
        VSB_GEELY_YINGLUNSC7         = 11,  // 英伦SC7
        VSB_GEELY_PANDA              = 12,  // 熊猫
        VSB_GEELY_YUANJING           = 13,  // 远景
        VSB_GEELY_ZIYOUJIAN          = 14   // 自由舰
}VSB_GEELY_CLASS;

//三菱子品牌类型
typedef enum _VSB_MITSUBISHI_CLASS
{
    VSB_MITSUBISHI_OTHER                 = 0,   // 其他（保留）
        VSB_MITSUBISHI_GALANT                = 1,   // 戈蓝
        VSB_MITSUBISHI_ZINGER                = 2,   // 君阁
        VSB_MITSUBISHI_LANCER                = 3,   // 蓝瑟
        VSB_MITSUBISHI_LANCEREX              = 4,   // 翼神
        VSB_MITSUBISHI_PAJERO                = 5,   // 帕杰罗
        VSB_MITSUBISHI_PAJEROSPORT           = 6,   // 帕杰罗-劲畅
        VSB_MITSUBISHI_JINGXUANASX           = 7,   // 劲炫ASX
        VSB_MITSUBISHI_GRANDIS               = 8,   // 三菱格蓝迪
        VSB_MITSUBISHI_OUTLANDER             = 9,   // 欧蓝德
        VSB_MITSUBISHI_QINXINGYUEYE          = 10,  // 三菱轻型越野
        VSB_MITSUBISHI_GTO                   = 11,  // 三菱GTO
        VSB_MITSUBISHI_SOVERAN               = 12,  // 三菱菱绅
        VSB_MITSUBISHI_LIONVEL               = 13,  // 三菱菱悦
        VSB_MITSUBISHI_HAFEISIMBO            = 14,   // 哈飞赛马
        VSB_MITSUBISHI_LANCEREX_1            = 15,   // 三菱-三菱翼神-2012,2011,2010
        VSB_MITSUBISHI_JINGXUAN_1            = 16,   // 三菱-劲炫-2012,2011
        VSB_MITSUBISHI_ZINGER_1              = 17,   // 三菱-君阁-2011,2009
        VSB_MITSUBISHI_PAJERO_1              = 18,   // 三菱-帕杰罗-2004国产
        VSB_MITSUBISHI_PAJERO_2              = 19,   // 三菱-帕杰罗-2004进口
        VSB_MITSUBISHI_PAJERO_3              = 20,   // 三菱-帕杰罗-2010进口
        VSB_MITSUBISHI_PAJEROSPORT_1         = 21,   // 三菱-帕杰罗劲畅-2011
        VSB_MITSUBISHI_GALANT_1              = 22,   // 三菱-戈蓝-2009
        VSB_MITSUBISHI_GALANDI_1             = 23,   // 三菱-格蓝迪-2007
        VSB_MITSUBISHI_GALANDI_2             = 24,   // 三菱-格蓝迪-2010
        VSB_MITSUBISHI_OUTLANDER_1           = 25,   // 三菱-欧蓝德-2012,2011,2010
        VSB_MITSUBISHI_OUTLANDER_2           = 26,   // 三菱-欧蓝德-2013
        VSB_MITSUBISHI_LINGYUE_1             = 27,   // 三菱-菱悦-未知
        VSB_MITSUBISHI_LANCER_1              = 28   // 三菱-蓝瑟-2010
}VSB_MITSUBISHI_CLASS;

//雷克萨斯子品牌类型
typedef enum _VSB_LEXUS_CLASS
{
    VSB_LEXUS_OTHER             = 0,   // 其他（保留）
        VSB_LEXUS_ES                = 1,   // 雷克萨斯ES
        VSB_LEXUS_CT                = 2,   // 雷克萨斯CT                                                          
        VSB_LEXUS_RX                = 3,   // 雷克萨斯RX
        VSB_LEXUS_IS                = 4,   // 雷克萨斯IS
        VSB_LEXUS_LX                = 5,   // 雷克萨斯LX
        VSB_LEXUS_GS                = 6,   // 雷克萨斯GS
        VSB_LEXUS_GX                = 7,   // 雷克萨斯GX
        VSB_LEXUS_LS                = 8,    // 雷克萨斯LS
        VSB_LEXUS_CT_1              = 9,   // 雷克萨斯-CT-2013,2012,2011
        VSB_LEXUS_ES_1              = 10,   // 雷克萨斯-ES-1994
        VSB_LEXUS_ES_2              = 11,   // 雷克萨斯-ES-2010,2009,2006
        VSB_LEXUS_ES_3              = 12,   // 雷克萨斯-ES-2013,2012
        VSB_LEXUS_GS_1              = 13,   // 雷克萨斯-GS-2011,2010,2009,2008,2005
        VSB_LEXUS_GX_1              = 14,   // 雷克萨斯-GX-2012,2010
        VSB_LEXUS_IS_1              = 15,   // 雷克萨斯-IS-2011
        VSB_LEXUS_LS_1              = 16,   // 雷克萨斯-LS-1994
        VSB_LEXUS_LS_2              = 17,   // 雷克萨斯-LS-2005,2004
        VSB_LEXUS_LS_3              = 18,   // 雷克萨斯-LS-2009,2007,2006
        VSB_LEXUS_LX_1              = 19,   // 雷克萨斯-LX-2013,2012
        VSB_LEXUS_RX_1              = 20,   // 雷克萨斯-RX-2011,2010,2009
        VSB_LEXUS_RX_2              = 21,   // 雷克萨斯-RX-2013,2012
        VSB_LEXUS_RX_3              = 22   // 雷克萨斯-RX-2007
}VSB_LEXUS_CLASS;

//荣威子品牌类型
typedef enum _VSB_ROEWE_CLASS
{
    VSB_ROEWE_OTHER              = 0,   // 其他（保留）
        VSB_ROEWE_350                = 1,   // 荣威350
        VSB_ROEWE_550                = 2,   // 荣威550                                                          
        VSB_ROEWE_W5                 = 3,   // 荣威W5
        VSB_ROEWE_950                = 4,   // 荣威950
        VSB_ROEWE_750                = 5,   // 荣威750
        VSB_ROEWE_350_1              = 6,   // 荣威-350-2011迅智版,2010
        VSB_ROEWE_350_2              = 7,   // 荣威-350-2014,2013,2012,2011
        VSB_ROEWE_550_1              = 8,   // 荣威-550-2012,2010,2009,2008
        VSB_ROEWE_750_1              = 9,   // 荣威-750-2009,2008,2007,2006
        VSB_ROEWE_750_2              = 10,  // 荣威-750-2012,2011
        VSB_ROEWE_950_1              = 11   // 荣威-950-2012
}VSB_ROEWE_CLASS;


//海马子品牌类型
typedef enum _VSB_HAIMA_CLASS
{
    VSB_HAIMA_OTHER               = 0,   // 其他（保留）
        VSB_HAIMA_PREMARIN            = 1,   // 普力马
        VSB_HAIMA_S7                  = 2,   // 海马S7
        VSB_HAIMA_PRINCE              = 3,   // 海马王子
        VSB_HAIMA_CUPID               = 4,   // 海马2-丘比特
        VSB_HAIMA_HATCHBACK           = 5,   // 海马3-欢动
        VSB_HAIMA_KNIGHT              = 6,   // 骑士
        VSB_HAIMA_HAPPIN              = 7,   // 海福星
        VSB_HAIMA_FAMILY              = 8,   // 福美来
        VSB_HAIMA_M3                  = 9,    // 海马M3
        VSB_HAIMA_CUPID_1             = 10,   // 海马-丘比特-2012,2011,2010
        VSB_HAIMA_PREMARIN_1          = 11,   // 海马-普力马-2007
        VSB_HAIMA_PREMARIN_2          = 12,   // 海马-普力马-2012,2010
        VSB_HAIMA_HATCHBACK_1         = 13,   // 海马-欢动-2010,2009
        VSB_HAIMA_HAPPIN_1            = 14,   // 海马-海福星-2010,2009,2008,2007,2004
        VSB_HAIMA_HAPPIN_2            = 15,   // 海马-海福星-2012,2011
        VSB_HAIMA_M3_1                = 16,   // 海马-海马3-2010,2008,2007
        VSB_HAIMA_FAMILY_1            = 17,   // 海马-福美来-2007,2006
        VSB_HAIMA_FAMILY_2            = 18,   // 海马-福美来-2010,2009,2008
        VSB_HAIMA_FAMILY_3            = 19,   // 海马-福美来-2011
        VSB_HAIMA_FAMILY_4            = 20,   // 海马-福美来-2014,2013,2012
        VSB_HAIMA_KNIGHT_1            = 21,   // 海马-骑士-2013_2012A,2011,2010
        VSB_HAIMA_KNIGHT_2            = 22,   // 海马-骑士-2013_2012B
        VSB_HAIMA_NEWHONGDA_1         = 23,   // 海马商用车-新鸿达-2009
        VSB_HAIMA_NEWHONDGA_2         = 24,   // 海马商用车-新鸿达-2012
        VSB_HAIMA_PRINCE_1            = 25,   // 海马商用车-海马王子-2010
        VSB_HAIMA_RONGDA_1            = 26   // 海马商用车-荣达-2012
        
}VSB_HAIMA_CLASS;

//长城子品牌类型
typedef enum _VSB_GREATWALL_CLASS
{
    VSB_GREATWALL_OTHER               = 0,   // 其他（保留）
        VSB_GREATWALL_SING                = 1,   // 赛影
        VSB_GREATWALL_SAIJUN              = 2,   // 赛骏
        VSB_GREATWALL_HAVAL               = 3,   // 哈弗
        VSB_GREATWALL_SAFE                = 4,   // 赛弗
        VSB_GREATWALL_SAIKU               = 5,   // 赛酷
        VSB_GREATWALL_SAILING             = 6,   // 赛铃
        VSB_GREATWALL_KINGDEER            = 7,   // 金迪尔
        VSB_GREATWALL_DEER                = 8,   // 迪尔
        VSB_GREATWALL_WINGLE              = 9,   // 风骏
        VSB_GREATWALL_COOLBEAR            = 10,  // 酷熊
        VSB_GREATWALL_LINGAO              = 11,  // 凌傲
        VSB_GREATWALL_CROSS               = 12,  // 炫丽
        VSB_GREATWALL_GWPERI              = 13,  // 精灵
        VSB_GREATWALL_COWRY               = 14,  // 腾翼
        VSB_GREATWALL_M4                  = 15,   // 长城M4
        VSB_GREATWALL_LINGAO_1            = 16,   // 长城-凌傲-2010
        VSB_GREATWALL_HAVAL_1             = 17,   // 长城-哈弗H3-2010,2009
        VSB_GREATWALL_HAVAL_2             = 18,   // 长城-哈弗H3-2012,2010,2009锐意版
        VSB_GREATWALL_HAVAL_3             = 19,   // 长城-哈弗H5-2012,2011,2010
        VSB_GREATWALL_HAVAL_4             = 20,   // 长城-哈弗H5-2012,2011,2010绿静豪华型
        VSB_GREATWALL_HAVAL_5             = 21,   // 长城-哈弗H5-2012舒适型
        VSB_GREATWALL_HAVAL_6             = 22,   // 长城-哈弗H5-2014,2013
        VSB_GREATWALL_HAVAL_8             = 23,   // 长城-哈弗H6-2014,2013升级版
        VSB_GREATWALL_HAVAL_9             = 24,   // 长城-哈弗M2-2010
        VSB_GREATWALL_HAVAL_10            = 25,   // 长城-哈弗M2-2013,2012
        VSB_GREATWALL_HAVAL_11            = 26,   // 长城-哈弗M4-2012
        VSB_GREATWALL_HAVAL_12            = 27,   // 长城-哈弗派-2011
        VSB_GREATWALL_CROSS_1             = 28,   // 长城-炫丽-2009,2008
        VSB_GREATWALL_CROSS_2             = 29,   // 长城-炫丽CROSS-2011,2009
        VSB_GREATWALL_JINGLING_1          = 30,   // 长城-精灵-未知
        VSB_GREATWALL_SING_1              = 31,   // 长城-赛影-2003
        VSB_GREATWALL_SAIKU_1             = 32,   // 长城-赛酷-2004
        VSB_GREATWALL_SAILING_1           = 33,   // 长城-赛铃-未知
        VSB_GREATWALL_DIER_1              = 34,   // 长城-迪尔-未知
        VSB_GREATWALL_COOLBEAR_1          = 35,   // 长城-酷熊-2010,2009
        VSB_GREATWALL_KINGDEER_1          = 36,   // 长城-金迪尔-2008,2007,2004,2003
        VSB_GREATWALL_GREATWALL_1         = 37,   // 长城-长城C20R-2013,2011
        VSB_GREATWALL_GREATWALL_2         = 38,   // 长城-长城C30-2010
        VSB_GREATWALL_GREATWALL_3         = 39,   // 长城-长城C30-2012
        VSB_GREATWALL_GREATWALL_4         = 40,   // 长城-长城C30-2013
        VSB_GREATWALL_GREATWALL_5         = 41,   // 长城-长城C50-2013,2012
        VSB_GREATWALL_GREATWALL_6         = 42,   // 长城-长城V80-2013,2012,2010,2009,2008
        VSB_GREATWALL_WINGLE_1            = 43,   // 长城-风骏3-2011,2010,2007,2006
        VSB_GREATWALL_WINGLE_2            = 44,   // 长城-风骏5-2014,2012,2011,2009 
        VSB_GREATWALL_HAVAL_7             = 45   // 长城-哈弗H6-2013,2012,2011
}VSB_GREATWALL_CLASS;

//道奇子品牌类型
typedef enum _VSB_DS_CLASS
{
    VSB_DS_OTHER                      = 0,          // 其他（保留）
        VSB_DS_KUBO_1                     = 1,          // 道奇-酷搏-2011,2010,2009,2008
        VSB_DS_KUWEI_1                    = 2,          // 道奇-酷威-2011,2010,2009
        VSB_DS_KUWEI_2                    = 3           // 道奇-酷威-2013
}VSB_DS_CLASS;

//路虎子品牌类型
typedef enum _VSB_LANDROVER_CLASS
{
    VSB_LANDROVER_OTHER              = 0,   // 其他（保留）
        VSB_LANDROVER_FAXIAN_1           = 1,   // 路虎-发现-2005,2004
        VSB_LANDROVER_FAXIAN_2           = 2,   // 路虎-发现-2013,2011,2010
        VSB_LANDROVER_LANSHENG_1         = 3,   // 路虎-揽胜-2012,2011,2010
        VSB_LANDROVER_LANSHENG_2         = 4,   // 路虎-揽胜极光-2014,2013,2012,2011
        VSB_LANDROVER_LANSHENG_3         = 5,   // 路虎-揽胜运动版-2013,2012,2011,2010
        VSB_LANDROVER_LANSHENG_4         = 6,   // 路虎-揽胜运动版-2013驭红限量版
        VSB_LANDROVER_SXZ_1              = 7   // 路虎-神行者2代-2014,2013,2011
}VSB_LANDROVER_CLASS;

//名爵子品牌类型
typedef enum _VSB_MG_CLASS
{
    VSB_MG_OTHER             = 0,  // 其他（保留）
        VSB_MG_3SW_1             = 1,  // MG-MG-3SW-2009,2008
        VSB_MG_MG3_1             = 2,  // MG-MG3-2013,2012,2011
        VSB_MG_MG5_1             = 3,  // MG-MG5-2014,2013,2012
        VSB_MG_MG6_1             = 4,  // MG-MG6三厢-2012,2011
        VSB_MG_MG7_1             = 5,  // MG-MG7-2010,2009,2008,2007
}VSB_MG_CLASS;

//一汽子品牌类型
typedef enum _VSB_FAW_CLASS
{
    VSB_FAW_OTHER                                       = 0,    // 其他（保留）
        VSB_FAW_501_1                                        = 1,    //一汽-501-轻卡
        VSB_FAW_N3_1                                        = 2,    //一汽-N3+两厢-2006
        VSB_FAW_N3_2                                        = 3,    //一汽-N3+两厢-2008
        VSB_FAW_JIABAO_1                                    = 4,    //一汽-佳宝货车-2011T50,T57
        VSB_FAW_JIABAO_2                                    = 5,    //一汽-佳宝面包车-2000
        VSB_FAW_JIABAO_3                                    = 6,    //一汽-佳宝面包车-2006
        VSB_FAW_JIABAO_4                                    = 7,    //一汽-佳宝面包车-2012,2011V50舒适版
        VSB_FAW_JIABAO_5                                    = 8,    //一汽-佳宝面包车-2012,2011V70
        VSB_FAW_JIABAO_6                                    = 9,    //一汽-佳宝面包车-2013,2012,2011V52实用型
        VSB_FAW_JIABAO_7                                    = 10,    //一汽-佳宝面包车-2014,2013V80
        VSB_FAW_XIALI_1                                        = 11,    //一汽-夏利-1999,1997
        VSB_FAW_XIALI_2                                        = 12,    //一汽-夏利2000-2003,2002
        VSB_FAW_XIALI_3                                        = 13,    //一汽-夏利A+-2011,2010,2006,2005
        VSB_FAW_XIALI_4                                        = 14,    //一汽-夏利N3-2012
        VSB_FAW_XIALI_5                                        = 15,    //一汽-夏利N5-2014,2013,2011,2010,2009
        VSB_FAW_XIALI_6                                        = 16,    //一汽-夏利N7-2013
        VSB_FAW_AOWEI_1                                        = 17,    //一汽-奥威J5P-2005,2004,2003
        VSB_FAW_AOWEI_2                                        = 18,    //一汽-奥威J5P-4X2复合型牵引车,自卸车
        VSB_FAW_AOWEI_3                                        = 19,    //一汽-奥威J5P-4X2牵引车,卸货车
        VSB_FAW_AOWEI_4                                        = 20,    //一汽-奥威J5P-6X6越野自卸车
        VSB_FAW_AOXING_1                                    = 21,    //一汽-奥星-2004
        VSB_FAW_WEILE_1                                        = 22,    //一汽-威乐-2004
        VSB_FAW_WEILE_2                                        = 23,    //一汽-威乐-2008,2007
        VSB_FAW_WEIZI_1                                        = 24,    //一汽-威姿-2004
        VSB_FAW_WEIZHI_1                                    = 25,    //一汽-威志V2-2012手动CROSS
        VSB_FAW_WEIZHI_2                                    = 26,    //一汽-威志V2-2012自动CROSS,2010
        VSB_FAW_WEIZHI_3                                    = 27,    //一汽-威志V5-2013,2012
        VSB_FAW_WEIZHI_4                                    = 28,    //一汽-威志三厢-2009,2008,2007
        VSB_FAW_WEIZHI_5                                    = 29,    //一汽-威志三厢-2011
        VSB_FAW_XIAOJIEFANG_1                                = 30,    //一汽-小解放-90,109马力轻卡
        VSB_FAW_HANWEI_1                                    = 31,    //一汽-悍威J5M-4X4载货车
        VSB_FAW_HANWEI_2                                    = 32,    //一汽-悍威J5M-6X6牵引车,6X4自卸车
        VSB_FAW_HANWEI_3                                    = 33,    //一汽-悍威J5M-8X8自卸车
        VSB_FAW_XINDAWEI_1                                    = 34,    //一汽-新大威-2010
        VSB_FAW_XINHANWEI_1                                    = 35,    //一汽-新悍威-2011
        VSB_FAW_SENYA_1                                        = 36,    //一汽-森雅M80-2012,2011,2009
        VSB_FAW_TENGWEI_1                                    = 37,    //一汽-腾威L5M-重卡
        VSB_FAW_JIEFANG_1                                    = 38,    //一汽-解放J4R-A款
        VSB_FAW_JIEFANG_2                                    = 39,    //一汽-解放J4R-自卸车,牵引车
        VSB_FAW_JIEFANG_3                                    = 40,    //一汽-解放J6-2004
        VSB_FAW_JIEFANG_4                                    = 41,    //一汽-解放J6-重卡
        VSB_FAW_JIEFANG_5                                    = 42,    //一汽-解放J6L-中卡
        VSB_FAW_JIEFANG_6                                    = 43,    //一汽-解放L5-A款
        VSB_FAW_SAILONG_1                                    = 44,    //一汽-赛龙-中卡
        VSB_FAW_JUNWEI_1                                    = 45,    //一汽-骏威J5K-中卡
        VSB_FAW_B50_1                                        = 46,    //一汽-奔腾B50-2012,2011,2009
        VSB_FAW_B50_2                                        = 47    //一汽-奔腾B50-2013
}VSB_FAW_CLASS;


//上汽子品牌类型
typedef enum _VSB_SAICMOTOR_CLASS
{
    VSB_SAICMOTOR_OTHER               = 0,    // 其他（保留）
        VSB_HONGYAN_JIESHI_1              = 1,    // 上汽依维柯红岩-杰狮-2012
        VSB_DATONG_V80_1                  = 2     // 上汽大通-V80-2014,2013,2012,2011
}VSB_SAICMOTOR_CLASS;

//东南汽车子品牌类型
typedef enum _VSB_SOUEAST_CLASS
{
    VSB_SOUEAST_OTHER                 = 0,    // 其他（保留）
        VSB_SOUEAST_V3_1                  = 1,    // 东南-V3菱悦-2011超值幸福版,2010,2009,2008
        VSB_SOUEAST_V3_2                  = 2,    // 东南-V3菱悦-2012
        VSB_SOUEAST_V3_3                  = 3,    // 东南-V3菱悦-2012旗舰版,2011,2010新风采版
        VSB_SOUEAST_V3_4                  = 4,    // 东南-V3菱悦-2012风采版
        VSB_SOUEAST_V5_1                  = 5,    // 东南-V5菱致-2014,2013,2012
        VSB_SOUEAST_XIWANG_1              = 6,    // 东南-希旺-2011,2010
        VSB_SOUEAST_DELIKA_1              = 7,    // 东南-得利卡-2003,2002
        VSB_SOUEAST_DELIKA_2              = 8,    // 东南-得利卡-2005
        VSB_SOUEAST_DELIKA_3              = 9,    // 东南-得利卡-2008
        VSB_SOUEAST_DELIKA_4              = 10,    // 东南-得利卡-2009
        VSB_SOUEAST_LINGSHUAI_1           = 11,    // 东南-菱帅-2005,2004GLXi
        VSB_SOUEAST_FULIKA_1              = 12,    // 东南-富利卡-2005
        VSB_SOUEAST_FULIKA_2              = 13    // 东南-富利卡-2007
}VSB_SOUEAST_CLASS;


//中兴汽车子品牌类型
typedef enum _VSB_ZTE_CLASS
{
    VSB_ZTE_OTHER                     = 0,        // 其他（保留）
        VSB_ZTE_WEIHU_1                   = 1,        // 中兴-威虎-2012,2010
        VSB_ZTE_WEIHU_2                   = 2,        // 中兴-威虎TUV-2010,2006
        VSB_ZTE_WUXIAN_1                  = 3,        // 中兴-无限-2008
        VSB_ZTE_WUXIAN_2                  = 4         // 中兴-无限-2012,2011,2010,2009
}VSB_ZTE_CLASS;


//中华汽车子品牌类型
typedef enum _VSB_ZHONGHUA_CLASS
{
    VSB_ZHONGHUA_OTHER                = 0,    // 其他（保留）
        VSB_ZHONGHUA_H230_1               = 1,   // 中华-H230-2012
        VSB_ZHONGHUA_H320_1               = 2,   // 中华-H320-2012
        VSB_ZHONGHUA_H330_1               = 3,   // 中华-H330-2013
        VSB_ZHONGHUA_H530_1               = 4,   // 中华-H530-2012,2011
        VSB_ZHONGHUA_V5_1                 = 5,   // 中华-V5-2012,2011
        VSB_ZHONGHUA_ZUNCHI_1             = 6,   // 中华-尊驰-2004
        VSB_ZHONGHUA_ZUNCHI_2             = 7,   // 中华-尊驰-2005,2003
        VSB_ZHONGHUA_KUBAO_1              = 8,   // 中华-酷宝-2007
        VSB_ZHONGHUA_JUNJIE_1             = 9,   // 中华-骏捷-2010,2009,2008,2007,2006
        VSB_ZHONGHUA_JUNJIE_2             = 10,   // 中华-骏捷-2012,2011
        VSB_ZHONGHUA_JUNJIECROSS_1        = 11,   // 中华-骏捷cross-2010,2009
        VSB_ZHONGHUA_JUNJIEFRV_1          = 12,   // 中华-骏捷FRV-2009,2008
        VSB_ZHONGHUA_JUNJIEFRV_2          = 13,   // 中华-骏捷FRV-2010
        VSB_ZHONGHUA_JUNJIEFSV_1          = 14,   // 中华-骏捷FSV-2009
        VSB_ZHONGHUA_JUNJIEFSV_2          = 15,   // 中华-骏捷FSV-2010
        VSB_ZHONGHUA_JUNJIEFSV_3          = 16   // 中华-骏捷FSV-2011
}VSB_ZHONGHUA_CLASS;


//中国重汽子品牌类型
typedef enum _VSB_CNHTC_CLASS
{
    VSB_CNHTC_OTHER                   = 0,    // 其他（保留）
        VSB_CNHTC_HOKA_2                  = 1,      // 中国重汽-HOKA-牵引车,自卸车
        VSB_CNHTC_HOWO_1                  = 2,      // 中国重汽-HOWO-A7
        VSB_CNHTC_HOWO_2                  = 3,      // 中国重汽-HOWO-T7H
        VSB_CNHTC_HOWO_3                  = 4,      // 中国重汽-HOWO-轻卡
        VSB_CNHTC_HOWO_4                  = 5,      // 中国重汽-HOWO重卡-牵引车
        VSB_CNHTC_HOWO_5                  = 6,      // 中国重汽-HOWO重卡-自卸车A
        VSB_CNHTC_HOWO_6                  = 7,      // 中国重汽-HOWO重卡-自卸车B
        VSB_CNHTC_HOWO_7                  = 8,      // 中国重汽-HOWO重卡-载货车A
        VSB_CNHTC_HOWO_8                  = 9,      // 中国重汽-HOWO重卡-载货车C
        VSB_CNHTC_SITAIERWANG_1           = 10,      // 中国重汽-斯太尔王-牵引车A,载货车,搅拌车
        VSB_CNHTC_HAOHAN_1                = 11,      // 中国重汽-豪瀚-A款
        VSB_CNHTC_HAOYUN_1                = 12,      // 中国重汽-豪运-牵引车B,载货车,自卸车
        VSB_CNHTC_JINWANGZI_1             = 13,      // 中国重汽-金王子重卡-牵引车B
        VSB_CNHTC_HOKA_1                  = 14      // 中国重汽-HOKA-H7
}VSB_CNHTC_CLASS;

//中通子品牌类型
typedef enum _VSB_ZHONGTONG_CLASS
{
    VSB_ZHONGTONG_OTHER               = 0,  // 其他（保留）
        VSB_ZHONGTONG_KAICHI_1            = 1,  // 中通客车-凯驰A-A款
        VSB_ZHONGTONG_LINGYU_1            = 2,  // 中通客车-领御-A款
        VSB_ZHONGTONG_LINGXIU_1           = 3,  // 中通客车-领秀-A款
        VSB_ZHONGTONG_LINGHANG_1          = 4,  // 中通客车-领航-A款
        VSB_ZHONGTONG_SHIJI_1             = 5,  // 中通客车-世纪-A款
        VSB_ZHONGTONG_KAIXUAN_1           = 6,  // 中通客车-凯旋-A款
        VSB_ZHONGTONG_LINGYUN_1           = 7,  // 中通客车-领韵A-A款
        VSB_ZHONGTONG_YANGGUANG_1         = 8  // 中通客车-阳光-A款
}VSB_ZHONGTONG_CLASS;


//九龙子品牌类型
typedef enum _VSB_JIULONG_CLASS
{
    VSB_JIULONG_OTHER                 = 0,    // 其他（保留）
        VSB_JIULONG_JIULONGA5_1           = 1,    // 九龙-九龙A5-2011
}VSB_JIULONG_CLASS;

//众泰子品牌类型
typedef enum _VSB_ZOTYE_CLASS
{
    VSB_ZOTYE_OTHER                  = 0,       // 其他（保留）
        VSB_ZOTYE_2008_2                  = 1,      // 众泰-2008-2011,2010,2008
        VSB_ZOTYE_5008_1                  = 2,      // 众泰-5008-2013,2011,2010,2008
        VSB_ZOTYE_Z300_1                  = 3,      // 众泰-Z300-2013,2012
        VSB_ZOTYE_2008_1                  = 4      // 众泰-2008-2007
}VSB_ZOTYE_CLASS;

//依维柯子品牌类型
typedef enum _VSB_NAVECO_CLASS
{
    VSB_NAVECO_OTHER                  = 0,       // 其他（保留）
        VSB_NAVECO_Daily_1                = 1,     // 依维柯-Daily-2006,2004,2003
        VSB_NAVECO_Power_1                = 2,     // 依维柯-Power-Daily
        VSB_NAVECO_Turbo_1                = 3,     // 依维柯-Turbo-Daily-2014,2012,2011
        VSB_NAVECO_Venice_1               = 4,     // 依维柯-Venice-2011,2008
        VSB_NAVECO_BAODI_1                = 5,     // 依维柯-宝迪-2012,2009
        VSB_NAVECO_DEYIHUOCHE_1           = 6,     // 依维柯-得意货车-2011
        VSB_NAVECO_DULING_1               = 7     // 依维柯-都灵-2010,2009,2007
}VSB_NAVECO_CLASS;

//保时捷子品牌类型
typedef enum _VSB_PORSCHE_CLASS
{
    VSB_PORSCHE_OTHER                 = 0,    // 其他（保留）
        VBR_PORSCHE_PANAMERA_1            = 1,    // 保时捷-panamera-2013,2012,2010
        VBR_PORSCHE_CAYENNE_1             = 2,    // 保时捷-卡宴Cayenne-2014,2013,2011,2010
}VSB_PORSCHE_CLASS;


//克莱斯勒子品牌类型
typedef enum _VSB_CHRYSLER_CLASS
{
    VSB_CHRYSLER_OTHER                = 0,    // 其他（保留）
        VSB_CHRYSLER_300C_1               = 1,   // 克莱斯勒-300C-2007,2006,2004
        VSB_CHRYSLER_PTMANBUZHE_1         = 2,   // 克莱斯勒-PT漫步者-2007
}VSB_CHRYSLER_CLASS;

//凯迪拉克子品牌类型
typedef enum _VSB_CADILLAC_CLASS
{
    VSB_CADILLAC_OTHER                = 0,    // 其他（保留）
        VSB_CADILLAC_ATS_1                = 1,   // 凯迪拉克-ATS-2014
        VSB_CADILLAC_CTS_1                = 2,   // 凯迪拉克-CTS-2012
        VSB_CADILLAC_CTS_3                = 3,   // 凯迪拉克-CTS-2012精英运动型,2011,2010,2009,2008
        VSB_CADILLAC_SLS_1                = 4,   // 凯迪拉克-SLS赛威-2007,2006
        VSB_CADILLAC_SLS_2                = 5,   // 凯迪拉克-SLS赛威-2012,2011,2010
        VSB_CADILLAC_SRX_1                = 6,   // 凯迪拉克-SRX-2012,2011,2010,2009
        VSB_CADILLAC_CTS_2                = 7,   // 凯迪拉克-CTS-2012,2009CTS
        VSB_CADILLAC_KAILEIDE_1           = 8   // 凯迪拉克-凯雷德-2011,2010,2008,2007,2006
}VSB_CADILLAC_CLASS;


//凯马KAMA子品牌类型
typedef enum _VSB_KAMA_CLASS
{
    VSB_KAMA_OTHER                    = 0,       // 其他（保留）
        VSB_KAMA_QINGKA_2                 = 1,       // 凯马KAMA-凯马-轻卡D
        VSB_KAMA_FULAIKA_1                = 2,       // 凯马KAMA-福来卡-轻卡A
        VSB_KAMA_JINYUNKA_1               = 3,       // 凯马KAMA-金运卡-轻卡
        VSB_KAMA_JUNWEIKA_1               = 4,       // 凯马KAMA-骏威卡车-2014,2011
        VSB_KAMA_QINGKA_1                 = 5       // 凯马KAMA-凯马-轻卡C
}VSB_KAMA_CLASS;

//力帆子品牌类型
typedef enum _VSB_LIFAN_CLASS
{
    VSB_LIFAN_OTHER                   = 0,      // 其他（保留）
        VSB_LIFAN_320_1                   = 1,      // 力帆-320-2012,2011,2009
        VSB_LIFAN_520_1                   = 2,      // 力帆-520-2007,2006
        VSB_LIFAN_520_2                   = 3,      // 力帆-520-2013,2011,2010,2008
        VSB_LIFAN_620_1                   = 4,      // 力帆-620-2012,2010,2009,2008
        VSB_LIFAN_X60_1                   = 5,      // 力帆-X60-2013,2012,2011
        VSB_LIFAN_FENGSHUN_1              = 6      // 力帆-丰顺-2011
}VSB_LIFAN_CLASS;


//北京子品牌类型
typedef enum _VSB_BEIJING_CLASS
{
    VSB_BEIJING_OTHER                 = 0,      // 其他（保留）
        VSB_BEIJING_E_1                   = 1,    // 北京汽车-E系列两厢-2014,2013,2012
}VSB_BEIJING_CLASS;

//北奔重汽子品牌类型
typedef enum _VSB_BEIBEN_CLASS
{
    VSB_BEIBEN_OTHER                  = 0,      // 其他（保留）
        VSB_BEIBEN_NG80_1                 = 1,     // 北奔重汽-NG80-重卡A
        VSB_BEIBEN_NG80_2                 = 2,     // 北奔重汽-NG80-重卡B
        VSB_BEIBEN_NG80_3                 = 3,     // 北奔重汽-NG80-重卡C
        VSB_BEIBEN_V3_1                   = 4,     // 北奔重汽-北奔V3-V3H1
        VSB_BEIBEN_V3_2                   = 5     // 北奔重汽-北奔V3-重卡A
}VSB_BEIBEN_CLASS;

//北方客车子品牌类型
typedef enum _VSB_BEIFANG_CLASS
{
    VSB_BEIFANG_OTHER                 = 0,      // 其他（保留）
        VSB_BEIFANG_A_1                   = 1       // 北方客车-客车车型1-A款
}VSB_BEIFANG_CLASS;


//北汽制造子品牌类型
typedef enum _VSB_BAW_CLASS
{
    VSB_BAW_OTHER                     = 0,        // 其他（保留）
        VSB_BAW_YUSHENG007_1              = 1,        // 北汽制造-域胜007-2013,2011
        VSB_BAW_QILING_1                  = 2,        // 北汽制造-旗铃-A款
        VSB_BAW_LUBA_1                    = 3,        // 北汽制造-陆霸-2004
        VSB_BAW_QISHI_1                   = 4         // 北汽制造-骑士-2009,2007
}VSB_BAW_CLASS;

//北汽威旺子品牌类型
typedef enum _VSB_BQWEIWANG_CLASS
{
    VSB_BQWEIWANG_OTHER               = 0,  // 其他（保留）
        VSB_BQWEIWANG_205_1               = 1,  // 北汽威旺-205-2013
        VSB_BQWEIWANG_306_1               = 2   // 北汽威旺-306-2014,2013,2011
}VSB_BQWEIWANG_CLASS;


//华普子品牌类型
typedef enum _VSB_SMA_CLASS
{
    VSB_SMA_OTHER                     = 0,        // 其他（保留）
        VSB_SMA_HAIYU_1                   = 1,        // 华普-海域-2007,2005,2004
        VSB_SMA_HAIYU_2                   = 2,        // 华普-海域-2007海域MB
        VSB_SMA_HAISHANG_1                = 3,        // 华普-海尚-2008,2005
        VSB_SMA_HAIJING_1                 = 5,        // 华普-海景-2010,2009
        VSB_SMA_HAIXUN_1                  = 4,        // 华普-海迅-2005,2004飙风
        VSB_SMA_HAIXUN_2                  = 6,        // 华普-海迅-2007,2006
}VSB_SMA_CLASS;

//华菱星马子品牌类型
typedef enum _VSB_XINGMA_CLASS
{
    VSB_XINGMA_OTHER                  = 0,        // 其他（保留）
        VSB_XINGMA_XINGKAIMA_1            = 1         // 华菱星马-星凯马-牵引车型1,载货车型1
}VSB_XINGMA_CLASS;

//双环子品牌类型
typedef enum _VSB_SHUANGHUAN_CLASS
{
    VSB_SHUANGHUAN_OTHER              = 0,        // 其他（保留）
        VSB_SHUANGHUAN_SCEO_1             = 1,        // 双环-SCEO-2011,2009,2006,2005
}VSB_SHUANGHUAN_CLASS;

//吉普子品牌类型
typedef enum _VSB_JEEP_CLASS
{
    VSB_JEEP_OTHER                    = 0,       // 其他（保留）
        VSB_JEEP_DAQIENUOJI_1             = 1,       // 吉普-大切诺基(进口)-2014,2013,2012,2011
        VSB_JEEP_DAQIENUOJI_2             = 2,       // 吉普-大切诺基(进口)-2014舒享导航版
        VSB_JEEP_ZHINANZHE_1              = 3,       // 吉普-指南者-2010,2007
        VSB_JEEP_ZHINANZHE_2              = 4,       // 吉普-指南者-2014,2013,2012,2011
        VSB_JEEP_MUMAREN_1                = 5,       // 吉普-牧马人-2012使命召唤限量版,2011
        VSB_JEEP_MUMAREN_2                = 6,       // 吉普-牧马人-2014,2013,2012,2011,2010,2009,2008
        VSB_JEEP_ZIYOUKE                  = 7,       // 吉普-自由客-2014,2013,2012,2011
}VSB_JEEP_CLASS;

//启辰子品牌类型
typedef enum _VSB_VENUCIA_CLASS
{
    VSB_VENUCIA_OTHER                 = 0,       // 其他（保留）
        VSB_VENUCIA_D50_1                 = 1        // 启辰-D50-2014,2013,2012
}VSB_VENUCIA_CLASS;

//哈飞子品牌类型
typedef enum _VSB_HAFEI_CLASS
{
    VSB_HAFEI_OTHER                   = 0,      // 其他（保留）
        VSB_HAFEI_XINMINYI_1              = 1,      // 哈飞-新民意货车-2010
        VSB_HAFEI_XINMINYI_2              = 2,      // 哈飞-新民意面包车-2012
        VSB_HAFEI_MINYI_1                 = 3,      // 哈飞-民意货车-2006
        VSB_HAFEI_MINYI_2                 = 4,      // 哈飞-民意面包车-2008
        VSB_HAFEI_SAIBAO_1                = 5,      // 哈飞-赛豹Ⅲ-2012
        VSB_HAFEI_SAIMA_1                 = 6,      // 哈飞-赛马-2002
        VSB_HAFEI_SAIMA_2                 = 7,      // 哈飞-赛马-2004,2003
        VSB_HAFEI_SAIMA_3                 = 8,      // 哈飞-赛马-2009
        VSB_HAFEI_LUBAO_1                 = 9,      // 哈飞-路宝-2004
        VSB_HAFEI_LUBAO_2                 = 10,      // 哈飞-路宝-2008,2007
        VSB_HAFEI_LUBAO_3                 = 11,      // 哈飞-路宝-2012
        VSB_HAFEI_LUZUNXIAOBAWANG_1       = 12,      // 哈飞-路尊小霸王-2011,2010
        VSB_HAFEI_RUIYI_1                 = 13,      // 哈飞-锐意-2009
        VSB_HAFEI_JUNYI_1                 = 14       // 哈飞-骏意-2012,2010
}VSB_HAFEI_CLASS;

//唐骏欧铃子品牌类型
typedef enum _VSB_TKING_CLASS
{
    VSB_TKING_OTHER                   = 0,      // 其他（保留）
        VSB_TKING_OUGUAN_1                = 1,      // 唐骏欧铃-欧冠-2011
        VSB_TKING_OUGUAN_2                = 2,      // 唐骏欧铃-欧冠-轻卡B
        VSB_TKING_OUTENG_1                = 3,      // 唐骏欧铃-欧腾-轻卡A
        VSB_TKING_FUXING_1                = 4,      // 唐骏欧铃-福星-2006
        VSB_TKING_QINGKAWANG_1            = 5,      // 唐骏欧铃-轻卡王-轻卡
        VSB_TKING_AFANDA_1                = 6,      // 唐骏欧铃-阿凡达-中重卡
        VSB_TKING_JUNQI_1                 = 7       // 唐骏欧铃-骏麒-中重卡A
}VSB_TKING_CLASS;

//大宇子品牌类型
typedef enum _VSB_DAEWOO_CLASS
{
    VSB_DAEWOO_OTHER                  = 0,    // 其他（保留）
        VBR_DAEWOO_6960H3_1               = 1     // 大宇-6960H3-A款
}VSB_DAEWOO_CLASS;

//大运汽车子品牌类型
typedef enum _VSB_DAYUN_CLASS
{
    VSB_DAYUN_OTHER                   = 0,     // 其他（保留）
        VBR_DAYUN_ZHONGKA_1               = 1      // 大运汽车-重卡-A款
}VSB_DAYUN_CLASS;

//奔腾子品牌类型
typedef enum _VSB_BESTURN_CLASS
{
    VSB_BESTURN_OTHER                 = 0,   // 其他（保留）
        VSB_BESTURN_B70_1                 = 1,    // 奔腾-B70-2009,2007,2006
        VSB_BESTURN_B70_2                 = 2,    // 奔腾-B70-2011
        VSB_BESTURN_B70_3                 = 3,    // 奔腾-B70-2011精英型,2010
        VSB_BESTURN_B70_4                 = 4,    // 奔腾-B70-2012
        VSB_BESTURN_B90_1                 = 5,    // 奔腾-B90-2012
        VSB_BESTURN_AOXING_1              = 6       // 一汽-奥星-2004
}VSB_BESTURN_CLASS;

//威麟子品牌类型
typedef enum _VSB_WEILIN_CLASS
{
    VSB_WEILIN_OTHER                 = 0,      // 其他（保留）
        VSB_WEILIN_H3_1                   = 1,     // 威麟-H3-2011
        VSB_WEILIN_V5_1                   = 2,     // 威麟-V5-2012,2009
        VSB_WEILIN_X5_1                   = 3      // 威麟-X5-2012,2011,2010
}VSB_WEILIN_CLASS;

//宇通子品牌类型
typedef enum _VSB_YUTONG_CLASS
{
    VSB_YUTONG_OTHER                  = 0,     // 其他（保留）
        VSB_YUTONG_8XI_1                  = 1,     // 宇通-8系-2012,2005
        VSB_YUTONG_KECHE_1                = 2,     // 宇通-客车车型10-2013,2010
        VSB_YUTONG_KECHE_3                = 3,     // 宇通-客车车型2-A款
        VSB_YUTONG_KECHE_4                = 4,     // 宇通-客车车型8-2004
        VSB_YUTONG_KECHE_5                = 5,     // 宇通-客车车型9-2014
        VSB_YUTONG_KECHE_2                = 6      // 宇通-客车车型12-A款
}VSB_YUTONG_CLASS;

//安凯子品牌类型
typedef enum _VSB_ANKAI_CLASS
{
    VSB_ANKAI_OTHER                   = 0,      // 其他（保留）
        VSB_ANKAI_KECHE_1                 = 1,      // 安凯-客车车型1-A款
        VSB_ANKAI_KECHE_2                 = 2       // 安凯-客车车型3-A款
}VSB_ANKAI_CLASS;

//宝骏子品牌类型
typedef enum _VSB_BAOJUN_CLASS
{
    VSB_BAOJUN_OTHER            = 0,   // 其他（保留）
        VSB_BAOJUN_630_1                  = 1      // 宝骏-宝骏630-2014,2013,2012,2011
}VSB_BAOJUN_CLASS;

//宾利子品牌类型
typedef enum _VSB_BINLI_CLASS
{
    VSB_BINLI_OTHER                   = 0,     // 其他（保留）
        VSB_BINLI_OULU_1                  = 1      // 宾利-欧陆-2009,2008
}VSB_BINLI_CLASS;

//广汽传祺子品牌类型
typedef enum _VSB_TRUMPCHE_CLASS
{
    VSB_TRUMPCHE_OTHER                = 0,   // 其他（保留）
        VSB_TRUMPCHE_GA5_1                = 1,   // 广汽传祺-GA5-2012,2011
        VSB_TRUMPCHE_GA5_2                = 3,   // 广汽传祺-GA5-2013,2012自动精英版
        VSB_TRUMPCHE_GS5_1                = 2    // 广汽传祺-GS5-2014,2013,2012
}VSB_TRUMPCHE_CLASS;

//广汽吉奥 子品牌类型
typedef enum _VSB_GONOW_CLASS
{
    VSB_GONOW_OTHER                   = 0,   // 其他（保留）
        VSB_GONOW_G3_1                    = 1,      // 广汽吉奥-G3-2011
        VSB_GONOW_G5_1                    = 2,      // 广汽吉奥-G5-2012,2011
        VSB_GONOW_SHUAIJIAN_1             = 4,      // 广汽吉奥-帅舰-2012,2009
        VSB_GONOW_XINGWANGM1_1            = 3,      // 广汽吉奥-星旺M1-2012
        VSB_GONOW_CAIYUN500_1             = 5      // 广汽吉奥-财运500-2010
}VSB_GONOW_CLASS;

//庆铃子品牌类型
typedef enum _VSB_ISUZU_CLASS
{
    VSB_ISUZU_OTHER                   = 0,   // 其他（保留）
        VSB_ISUZU_ZHONGXINGSHANGYONG_1    = 1,      // 庆铃-中型商用车-2011
        VSB_ISUZU_WUSHILINGPIKA_1         = 2,      // 庆铃-五十铃皮卡-2009
        VSB_ISUZU_WUSHILINGPIKA_2         = 3,      // 庆铃-五十铃皮卡-2014,2009
        VSB_ISUZU_JINGJIZHE_1             = 4      // 庆铃-竞技者-2004,2002
}VSB_ISUZU_CLASS;


//开瑞子品牌类型
typedef enum _VSB_KARRY_CLASS
{
    VSB_KARRY_OTHER                   = 0,   // 其他（保留）
        VSB_KARRY_YOU_2                   = 1,      // 开瑞-优优-2013,2012
        VSB_KARRY_YOUJIN_1                = 2,      // 开瑞-优劲-2012,2011基本型,2010
        VSB_KARRY_YOUSHENG_1              = 3,      // 开瑞-优胜-2010
        VSB_KARRY_YOUSHENG_2              = 4,      // 开瑞-优胜-2012,2011
        VSB_KARRY_YOUYA                   = 5,      // 开瑞-优雅-2012,2011,2007
        VSB_KARRY_YOU_1                   = 6      // 开瑞-优优-2011,2010,2009
}VSB_KARRY_CLASS;

//捷豹子品牌类型
typedef enum _VSB_GAGUAR_CLASS
{
    VSB_GAGUAR_OTHER                  = 0,   // 其他（保留）
        VSB_GAGUAR_XF_1                   = 1,     // 捷豹-XF-2014,2013
        VSB_GAGUAR_XJ_1                   = 2     // 捷豹-XJ-2014,2013,2012,2011,2010
}VSB_GAGUAR_CLASS;

//斯巴鲁子品牌类型
typedef enum _VSB_SUBARU_CLASS
{
    VSB_SUBARU_OTHER                  = 0,   // 其他（保留）
        VSB_SUBARU_AOHU_1                 = 1,     // 斯巴鲁-傲虎-2012,2011,2010
        VSB_SUBARU_LISHI_1                = 2,     // 斯巴鲁-力狮轿车-2008,2006
        VSB_SUBARU_LISHI_2                = 3,     // 斯巴鲁-力狮轿车-2011,2010
        VSB_SUBARU_XV_1                   = 4,     // 斯巴鲁-斯巴鲁XV-2014,2012
        VSB_SUBARU_SENLINREN_1            = 5,     // 斯巴鲁-森林人-2007,2006
        VSB_SUBARU_SENLINREN_2            = 6     // 斯巴鲁-森林人-2012,2011,2010,2009,2008
}VSB_SUBARU_CLASS;

//时代汽车子品牌类型
typedef enum _VSB_ERA_CLASS
{
    VSB_ERA_OTHER                     = 0,   // 其他（保留）
        VSB_ERA_XIAOKA_1                  = 1,        // 时代汽车-小卡之星-小卡之星1,2,Q2
        VSB_ERA_XIAOKA_3                  = 2,        // 时代汽车-小卡之星-小卡之星5
        VSB_ERA_XIAOKA_4                  = 3,        // 时代汽车-小卡之星-福锐
        VSB_ERA_KANGRUI_1                 = 4,        // 时代汽车-康瑞-康瑞H1
        VSB_ERA_KANGRUI_2                 = 5,        // 时代汽车-康瑞-康瑞H3
        VSB_ERA_KANGRUI_3                 = 6,        // 时代汽车-康瑞-康瑞K1,KQ1
        VSB_ERA_RUIWO_1                   = 7,        // 时代汽车-瑞沃-RC1
        VSB_ERA_RUIWO_2                   = 8,        // 时代汽车-瑞沃-RC2
        VSB_ERA_RUIWO_3                   = 9,        // 时代汽车-瑞沃-瑞沃II轻卡A
        VSB_ERA_JINGANG                   = 10,        // 时代汽车-金刚-金刚568
        VSB_ERA_LINGHANG_1                = 11,        // 时代汽车-领航-领航2
        VSB_ERA_LINGHANG_2                = 12,        // 时代汽车-领航-领航3
        VSB_ERA_YULING_1                  = 13,        // 时代汽车-驭菱-驭菱V1
        VSB_ERA_YULING_2                  = 14,        // 时代汽车-驭菱-驭菱V5,VQ5
        VSB_ERA_YULING_3                  = 15,        // 时代汽车-驭菱-驭菱VQ1,VQ2
        VSB_ERA_YULING_4                  = 17,        // 时代汽车-驭菱-鸿运
        VSB_ERA_XIAOKA_2                  = 17,        // 时代汽车-小卡之星-小卡之星3
}VSB_ERA_CLASS;

//昌河子品牌类型
typedef enum _VSB_CHANGHE_CLASS
{
    VSB_CHANGHE_OTHER           = 0,  // 其他（保留）
        VSB_CHANGHE_CH6321_1        = 1,  // 昌河-CH6321-2000
        VSB_CHANGHE_DANSHUANGPAI_1  = 2,  // 昌河-昌河新单双排-1999
        VSB_CHANGHE_AIDIER_1        = 3,  // 昌河-爱迪尔-2004
        VSB_CHANGHE_AIDIER_2        = 4,  // 昌河-爱迪尔Ⅱ-2007,2006
        VSB_CHANGHE_FURUIDA_1       = 5   // 昌河-福瑞达面包车-2014,2013,2011,2009
}VSB_CHANGHE_CLASS;

//欧宝子品牌类型
typedef enum _VSB_OPEL_CLASS
{
    VSB_OPEL_OTHER              = 0,    // 其他（保留）
        VSB_OPEL_YATE_1             = 1     // 欧宝-雅特-2010GTC全景风挡版,2007,2006
}VSB_OPEL_CLASS;

//永源子品牌类型
typedef enum _VSB_JONWAY_CLASS
{
    VSB_JONWAY_OTHER            = 0,   // 其他（保留）
        VSB_JONWAY_A380_1           = 1    // 永源-A380-2010,2009,2008
}VSB_JONWAY_CLASS;

//江南子品牌类型
typedef enum _VSB_JIANGNAN_CLASS
{
    VSB_JIANGNAN_OTHER          = 0,   // 其他（保留）
        VSB_JIANGNAN_TT_1           = 1    // 江南-江南TT-2011,2010,2004
}VSB_JIANGNAN_CLASS;

//吉利全球鹰子品牌类型
typedef enum _VSB_GLEAGLE_CLASS
{
    VSB_GLEAGLE_OTHER                      = 0,   // 其他（保留）
        VSB_GLEAGLE_EAGLE_GC7_1                = 1,   // 吉利全球鹰-GC7-2013,2012
        VSB_GLEAGLE_EAGLE_GX2_1                = 2,   // 吉利全球鹰-GX2-2012,2011
        VSB_GLEAGLE_EAGLE_GX7_1                = 3,   // 吉利全球鹰-GX7-2013,2012
        VSB_GLEAGLE_EAGLE_PANDA_1              = 4,   // 吉利全球鹰-熊猫-2013,2011,2010,2009
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1          = 5,   // 吉利全球鹰-自由舰-2009精致标准型,2007
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2          = 6,   // 吉利全球鹰-自由舰-2010,2009,2008,2006,2005
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3          = 7,   // 吉利全球鹰-自由舰-2012,2011
        VSB_GLEAGLE_EAGLE_YUANJING_1           = 8,   // 吉利全球鹰-远景-2011,2010,2009,2008,2006
        VSB_GLEAGLE_EAGLE_YUANJING_2           = 9,   // 吉利全球鹰-远景-2013,2012
}VSB_GLEAGLE_CLASS;

//吉利帝豪子品牌类型
typedef enum _VSB_EMGRAND_CLASS
{
    VSB_EMGRAND_OTHER                      = 0,   // 其他（保留）
        VSB_EMGRAND_EC7_2                      = 1,   // 吉利帝豪-EC7-2013
        VSB_EMGRAND_EC7_3                      = 2,   // 吉利帝豪-EC7-RV
        VSB_EMGRAND_EC8_1                      = 3,   // 吉利帝豪-EC8-2013,2011,2010
        VSB_EMGRAND_EC7_1                      = 4    // 吉利帝豪-EC7-2012,2010,2009
}VSB_EMGRAND_CLASS;


//吉利英伦子品牌类型
typedef enum _VSB_ENGLON_CLASS
{
    VSB_ENGLON_OTHER                       = 0,    // 其他（保留）
        VSB_ENGLON_SC3_1                       = 1,    // 吉利英伦-SC3-2012
        VSB_ENGLON_SC5_1                       = 2,    // 吉利英伦-SC5-RV-2012
        VSB_ENGLON_SC6_1                       = 3,    // 吉利英伦-SC6-2012
        VSB_ENGLON_SC7_1                       = 4,    // 吉利英伦-SC7-2013,2012,2011,2010
        VSB_ENGLON_SX7_1                       = 5,    // 吉利英伦-SX7-2014,2013
        VSB_ENGLON_JINGANG_1                   = 6,    // 吉利英伦-金刚-2010,2007,2006
        VSB_ENGLON_JINYING_1                   = 7     // 吉利英伦-金鹰-2011,2010,2008
}VSB_ENGLON_CLASS;


//江淮-子品牌类型
typedef enum _VSB_JAC_CLASS
{
    VSB_JAC_OTHER               = 0,      // 其他（保留）
        VSB_JAC_TONGYUE_1           = 1,      // 江淮-同悦-2012,2010,2008
        VSB_JAC_HEYUE_1             = 2,      // 江淮-和悦-2012,2011,2010
        VSB_JAC_HEYUEA30_2          = 3,      // 江淮-和悦A30-2013
        VSB_JAC_HEYUERS_3           = 4,      // 江淮-和悦RS-2012,2011
        VSB_JAC_HAOYUN_1            = 5,      // 江淮-好运-轻卡1
        VSB_JAC_WEILING_2           = 6,      // 江淮-威铃-排半轻卡
        VSB_JAC_WEILING_3           = 7,      // 江淮-威铃-栏板载货车
        VSB_JAC_WEILING_4           = 8,      // 江淮-威铃-轻卡
        VSB_JAC_KECHE_1             = 9,      // 江淮-客车-A款
        VSB_JAC_BINYUE_1            = 10,      // 江淮-宾悦-2010,2008
        VSB_JAC_SHUAILING_2         = 11,      // 江淮-帅铃-轻卡
        VSB_JAC_KANGLING_1          = 12,      // 江淮-康铃-轻卡1
        VSB_JAC_KANGLING_2          = 13,      // 江淮-康铃-轻卡2
        VSB_JAC_YUEYUE_1            = 14,      // 江淮-悦悦-2013,2012,2011,2010
        VSB_JAC_XINGRUI_1           = 15,      // 江淮-星锐-2012,2011
        VSB_JAC_GEERFA_H_1          = 16,      // 江淮-格尔发H-栏板载货车
        VSB_JAC_GEERFA_K_2          = 17,      // 江淮-格尔发K-重卡1
        VSB_JAC_GEERFA_K_3          = 18,      // 江淮-格尔发K-重卡2
        VSB_JAC_GEERFA_M_4          = 19,      // 江淮-格尔发M-栏板载货车
        VSB_JAC_RUIFENG_1           = 20,      // 江淮-瑞风-2011,2009,2007手动
        VSB_JAC_RUIFENG_2           = 21,      // 江淮-瑞风-2013,2012,2011,2010,2007,2005
        VSB_JAC_RUIFENG_3           = 22,      // 江淮-瑞风M5-2012,2011
        VSB_JAC_RUIFENG_4           = 23,      // 江淮-瑞风S5-2013
        VSB_JAC_RUIYING_1           = 24,      // 江淮-瑞鹰-2009,2007
        VSB_JAC_RUIYING_2           = 25,      // 江淮-瑞鹰-2013,2012,2011
        VSB_JAC_JUNLING_2           = 26,      // 江淮-骏铃-窄体版,中体版
        VSB_JAC_WEILING_1           = 27,      // 江淮-威铃-厢式轻卡
        VSB_JAC_SHUAILING_1         = 28,      // 江淮-帅铃-五十铃
        VSB_JAC_RUILING_1           = 29,      // 江淮-瑞铃-2012
        VSB_JAC_JUNLING_1           = 30      // 江淮-骏铃-旗舰版
}VSB_JAC_CLASS;


//江铃子品牌类型
typedef enum _VSB_JMC_CLASS
{
    VSB_JMC_OTHER               = 0,      // 其他（保留）
        VSB_JMC_KAIYUN_1            = 1,      // 江铃-凯运-102,109马力轻卡
        VSB_JMC_KAIYUN_2            = 2,      // 江铃-凯运-95马力轻卡
        VSB_JMC_YUHU_1              = 3,      // 江铃-域虎-2012
        VSB_JMC_BAODIAN_1           = 4,      // 江铃-宝典-2007
        VSB_JMC_BAODIAN_2           = 5,      // 江铃-宝典-2009标准型,2008
        VSB_JMC_BAODIAN_3           = 6,      // 江铃-宝典-2014,2012,2009豪华型
        VSB_JMC_BAOWEI_1            = 7,      // 江铃-宝威-2005
        VSB_JMC_BAOWEI_2            = 8,      // 江铃-宝威-2009
        VSB_JMC_QUANSHUN_1          = 9,      // 江铃-福特新世代全顺-2010,2008
        VSB_JMC_QUANSHUN_2          = 10,      // 江铃-经典全顺-2006
        VSB_JMC_QUANSHUN_3          = 11,      // 江铃-经典全顺-2013,2011,2010
        VSB_JMC_SHUNDA_1            = 12,      // 江铃-顺达-2004,2003
        VSB_JMC_SHUNDA_2            = 13,      // 江铃-顺达-2011,2010,2008
        VSB_JMC_YUSHENG_1           = 14,      // 江铃-驭胜-2013
        VSB_JMC_YUSHENG_2           = 15       // 江铃-驭胜-2013手动特装版,2012,2011
}VSB_JMC_CLASS;

// 沃尔沃子品牌类型
typedef enum _VSB_VOLVO_CLASS
{
    VSB_VOLVO_OTHER             = 0,   // 其他（保留）
        VSB_VOLVO_C30_1             = 1,    // 沃尔沃-C30-2013,2012,2011,2010
        VSB_VOLVO_S40_1             = 2,    // 沃尔沃-S40-2012,2011,2010,2009,2008,2007
        VSB_VOLVO_S60_1             = 3,    // 沃尔沃-S60-2003
        VSB_VOLVO_S60_2             = 4,    // 沃尔沃-S60-2013,2012,2011
        VSB_VOLVO_S80L_1            = 5,    // 沃尔沃-S80L-2012,2011,2010,2009
        VSB_VOLVO_XC60_1            = 6,    // 沃尔沃-XC60-2013,2012,2011,2010,2009
        VSB_VOLVO_XC90_1            = 7     // 沃尔沃-XC90-2013,2012,2011,2008
}VSB_VOLVO_CLASS;

// 海格子品牌类型
typedef enum _VSB_HIGER_CLASS
{
    VSB_HIGER_OTHER             = 0,   // 其他（保留）
        VSB_HIGER_H8_1              = 1,    // 海格-H8-A款
        VSB_HIGER_H92_1             = 2,    // 海格-H92-A款
        VSB_HIGER_V7_1              = 3,    // 海格-V7,V8-2006
        VSB_HIGER_KECHE_1           = 4,    // 海格-客车车型5-A款
        VSB_HIGER_LONGWEI_1         = 5,    // 海格-龙威-2012,2011
        VSB_HIGER_H7V_1             = 6     // 海格-海格H7V-2010
}VSB_HIGER_CLASS;

// 瑞麒子品牌类型
typedef enum _VSB_RUILIN_CLASS
{
    VSB_RUILIN_OTHER            = 0,   // 其他（保留）
        VSB_RUILIN_G3_1             = 1,   // 瑞麒-G3-2012,2010
        VSB_RUILIN_G5_1             = 2,   // 瑞麒-G5-2012,2011,2010
        VSB_RUILIN_M1_1             = 3,   // 瑞麒-M1-2013,2011,2010,2009
        VSB_RUILIN_X1_1             = 4,   // 瑞麒-X1-2012A,2011,2010
        VSB_RUILIN_X1_2             = 5    // 瑞麒-X1-2012B
}VSB_RUILIN_CLASS;

// 申龙子品牌类型
typedef enum _VSB_SHENLONG_CLASS
{
    VSB_SHENLON_OTHER                  = 0,         // 其他（保留）
        VSB_SHENLONG_KECHE_1               = 1          //申龙客车-客车车型4-A款
}VSB_SHENLONG_CLASS;

// 福田子品牌类型
typedef enum _VSB_FOTON_CLASS
{
    VSB_FOTON_OTHER                    = 0,            // 其他（保留）
        VSB_FOTON_AOLING_1                 = 1,            // 福田-奥铃-中卡
        VSB_FOTON_AOLING_2                 = 2,            // 福田-奥铃-厢式货车
        VSB_FOTON_AOLING_3                 = 3,            // 福田-奥铃-奥铃TX,CTX
        VSB_FOTON_OUMAN_1                  = 4,            // 福田-欧曼-GTL6系B
        VSB_FOTON_OUMAN_2                  = 5,            // 福田-欧曼-TX6系,9系
        VSB_FOTON_OUMAN_3                  = 6,            // 福田-欧曼-欧曼重卡1
        VSB_FOTON_OUMAN_4                  = 7,            // 福田-欧曼-雄狮6系,9系
        VSB_FOTON_OUHUI_1                  = 8,            // 福田-欧辉客车-D款
        VSB_FOTON_OUMAKE_1                 = 9,            // 福田-欧马可-3系
        VSB_FOTON_OUMAKE_2                 = 10,            // 福田-欧马可-5系
        VSB_FOTON_SAPU_1                   = 11,            // 福田-萨普-2011
        VSB_FOTON_SAPU_3                   = 12,            // 福田-萨普-2011柴油共轨
        VSB_FOTON_MENGPAIKE_1              = 13,            // 福田-蒙派克-2013
        VSB_FOTON_MIDI_1                   = 14,            // 福田-迷迪-2011,2009
        VSB_FOTON_FENGJING_1               = 15,            // 福田-风景系列-2012,2011,2009
        VSB_FOTON_SAPU_2                  = 16            // 福田-萨普-2011四驱征服者Z7
}VSB_FOTON_CLASS;

//福迪子品牌类型
typedef enum _VSB_FODAY_CLASS
{
    VSB_FODAY_OTHER                    = 0,            // 其他（保留）
        VSB_FODAY_CHAOREN_1                = 1,            // 福迪-小超人皮卡-2009,2006
        VSB_FODAY_CHAOREN_2                = 2,            // 福迪-小超人皮卡-2011
        VSB_FODAY_TANSUOZHE_1              = 3,            // 福迪-探索者6-2013,2011,2010
        VSB_FODAY_TANSUOZHE_2              = 4,            // 福迪-探索者Ⅱ-2011,2010,2009
        VSB_FODAY_TANSUOZHE_3              = 5,            // 福迪-探索者Ⅲ-2011,2004
        VSB_FODAY_XIONGSHI_1               = 6             // 福迪-雄狮F16皮卡-2012
}VSB_FODAY_CLASS;

// 红旗子品牌类型
typedef enum _VSB_HONGQI_CLASS
{
    VSB_HONGQI_OTHER                   = 0,         // 其他（保留）
        VSB_HONGQI_MINGSHI_1               = 1           // 红旗-明仕-2007,2003,2001,2000,1999
}VSB_HONGQI_CLASS;


// 纳智捷 子品牌类型
typedef enum _VSB_LUXGEN_CLASS
{
    VSB_LUXGEN_OTHER                   = 0,         // 其他（保留）
        VSB_LUXGEN_DASEVEN_1               = 1          // 纳智捷-大7-SUV
}VSB_LUXGEN_CLASS;

// 夏利子品牌类型
typedef enum _VSB_XIALI_CLASS
{
    VSB_XIALI_OTHER                    = 0,         // 其他（保留）
        VSB_XIALI_QIBING_1                 = 1,         // 美亚(夏利)-奇兵-2010
}VSB_XIALI_CLASS;

// 舒驰客车子品牌类型
typedef enum _VSB_SHUCHI_CLASS
{
    VSB_SHUCHI_OTHER                   = 0,         // 其他（保留）
        VSB_SHUCHI_A_1                     = 1          // 舒驰客车-客车-A款
}VSB_SHUCHI_CLASS;

//英菲尼迪子品牌类型
typedef enum _VSB_INFINITI_CLASS
{
    VSB_INFINITI_OTHER                 = 0,         // 其他（保留）
        VSB_INFINITI_EX_1                  = 1,         // 英菲尼迪-EX-2013,2011,2010,2009,2008
        VSB_INFINITI_FX_1                  = 2,         // 英菲尼迪-FX-2007
        VSB_INFINITI_FX_2                  = 3,         // 英菲尼迪-FX-2011,2010,2009
        VSB_INFINITI_FX_3                  = 4,         // 英菲尼迪-FX-2013,2012FX35
        VSB_INFINITI_G_1                   = 5,         // 英菲尼迪-G-2013,2010
        VSB_INFINITI_JX_1                  = 6          // 英菲尼迪-JX-2013,2011
}VSB_INFINITI_CLASS;


// 莲花子品牌类型
typedef enum _VSB_LOTUS_CLASS
{
    VSB_LOTUS_OTHER                    = 0,            // 其他（保留）
        VSB_LOTUS_L3_1                     = 1,            // 莲花-L3三厢-2010豪华型,2009
        VSB_LOTUS_L3_2                     = 2             // 莲花-L5三厢-2012,2011
}VSB_LOTUS_CLASS;

//菲亚特子品牌类型
typedef enum _VSB_FIAT_CLASS
{
    VSB_FIAT_OTHER                     = 0,            // 其他（保留）
        VSB_FIAT_FEIYUE_1                  = 1             // 菲亚特-菲跃-2014,2013,2012
}VSB_FIAT_CLASS;

//讴歌子品牌类型
typedef enum _VSB_OGA_CLASS
{
    VSB_OGA_OTHER                      = 0,              // 其他（保留）
        VSB_OGA_MDX_1                      = 1,              // 讴歌-MDX-2010
        VSB_OGA_MDX_2                      = 2               // 讴歌-MDX-2011
}VSB_OGA_CLASS;



// 跃进子品牌类型
typedef enum _VSB_YUEJIN_CLASS
{
    VSB_YUEJIN_OTHER                   = 0,           // 其他（保留）
        VSB_YUEJIN_SHUAIHU_1               = 1,           // 跃进-帅虎-H100,H300
        VSB_YUEJIN_CAISHEN_1               = 2,           // 跃进-财神-S100
        VSB_YUEJIN_CAISHEN_2               = 3,           // 跃进-财神-S300
        VSB_YUEJIN_CAISHEN_3               = 4            // 跃进-财神-S500
}VSB_YUEJIN_CLASS;

//野马子品牌类型
typedef enum _VSB_YEMA_CLASS
{
    VSB_YEMA_OTHER                     = 0,        // 其他（保留）
        VSB_YEMA_F99_1                     = 1            // 野马-F99-2012,2011,2010,2009 
}VSB_YEMA_CLASS;

//金龙子品牌类型
typedef enum _VSB_SZKINGLONG_CLASS
{
    VSB_SZKINGLONG_OTHER               = 0,        // 其他（保留）
        VSB_SZKINGLONG_BUS11_1             = 1,       // 金龙-客车车型11-A款
        VSB_SZKINGLONG_BUS12_1             = 2,       // 金龙-客车车型12-A款
        VSB_SZKINGLONG_BUS13_1             = 3,       // 金龙-客车车型13-A款
        VSB_SZKINGLONG_BUS14_1             = 4,       // 金龙-客车车型14-A款
        VSB_SZKINGLONG_BUS16_1             = 5,       // 金龙-客车车型16-A款
        VSB_SZKINGLONG_BUS18_1             = 6,       // 金龙-客车车型18-A款
        VSB_SZKINGLONG_BUS1_1              = 7,       // 金龙-客车车型1-A款
        VSB_SZKINGLONG_BUS20_1             = 8,       // 金龙-客车车型20-A款
        VSB_SZKINGLONG_BUS2_1              = 9,       // 金龙-客车车型2-A款
        VSB_SZKINGLONG_BUS5_1              = 10,       // 金龙-客车车型5-A款
        VSB_SZKINGLONG_BUS6_1              = 11,       // 金龙-客车车型6-A款
        VSB_SZKINGLONG_BUS9_1              = 12,       // 金龙-客车车型9-A款
        VSB_SZKINGLONG_BUS10_1             = 13,       // 金龙-客车车型10-A款
        VSB_SZKINGLONG_BUS15_1             = 14        // 金龙-客车车型15-A款
}VSB_SZKINGLONG_CLASS;

//长丰猎豹子品牌类型
typedef enum _VSB_CHANGFENG_CLASS
{
    VSB_CHANGFENG_OTHER                = 0,        // 其他（保留）
        VSB_CHANGFENG_CS7_1                = 1,        // 长丰猎豹-CS7-2009
        VSB_CHANGFENG_QIBING_1             = 2,        // 长丰猎豹-奇兵-2010,2009
        VSB_CHANGFENG_LIEBAO_1             = 3,        // 长丰猎豹-猎豹CS6-2010,2008
        VSB_CHANGFENG_FULING_1             = 4,        // 长丰猎豹-福铃皮卡-A款
        VSB_CHANGFENG_FEIYANG_1            = 5,        // 长丰猎豹-飞扬皮卡-2010,2009,2005
        VSB_CHANGFENG_FEITENG_1            = 6,        // 长丰猎豹-飞腾-2010,2009,2006
        VSB_CHANGFENG_BLACKJINGANG_1       = 7,        // 长丰猎豹-黑金刚-2013,2010,2009,2008,2006
}VSB_CHANGFENG_CLASS;

//陆风子品牌类型
typedef enum _VSB_LUFENG_CLASS
{
    VSB_LUFENG_OTHER                   = 0,           // 其他（保留）
        VSB_LUFENG_X6_1                    = 1,           // 陆风-X6-2005
        VSB_LUFENG_X6_2                    = 2,           // 陆风-X6-2006
        VSB_LUFENG_X6_3                    = 3,           // 陆风-X6-2011,2010,2008,2007
        VSB_LUFENG_LUFENGX5_1              = 4,           // 陆风-陆风X5-2013
        VSB_LUFENG_LUFENGX8_1              = 5,           // 陆风-陆风X8-2013,2012,2011,2009
        VSB_LUFENG_LUFENGX8_2              = 6,           // 陆风-陆风X8-2014,2012探索版
        VSB_LUFENG_FENGHUA_1               = 7,           // 陆风-风华-2008,2007
        VSB_LUFENG_X6_4                    = 8,           // 陆风-X6-2011两驱
        VSB_LUFENG_FENGSHANG_1             = 9            // 陆风-风尚-2011,2006 
}VSB_LUFENG_CLASS;

//陕汽重卡子品牌类型
typedef enum _VSB_SHANQI_CLASS
{
    VSB_SHANQI_OTHER                   = 0,           // 其他（保留）
        VSB_SHANQI_AOLONG_1                = 1,           // 陕汽重卡-奥龙-重卡A
        VSB_SHANQI_AOLONG_2                = 2,           // 陕汽重卡-奥龙-重卡B
        VSB_SHANQI_DELONG_1                = 3,           // 陕汽重卡-德龙F2000-4X2牵引车
        VSB_SHANQI_DELONG_2                = 4,           // 陕汽重卡-德龙F3000-B款
        VSB_SHANQI_DELONG_3                = 5,           // 陕汽重卡-德龙M3000-重卡 
}VSB_SHANQI_CLASS;


//野马子品牌类型
typedef enum _VSB_RENAULT_CLASS
{
    VSB_RENAULT_OTHER                  = 0,          // 其他（保留）
        VSB_RENAULT_MEIGANNA_1             = 1,          // 雷诺-梅甘娜-2006
        VSB_RENAULT_KELEIAO_1              = 2,          // 雷诺-科雷傲-2010,2009
        VSB_RENAULT_KELEIAO_2              = 3,          // 雷诺-科雷傲-2013,2012
        VSB_RENAULT_SCENE_1                = 4,          // 雷诺-风景-2007
        VSB_RENAULT_FENGLANG_1             = 5,          // 雷诺-风朗-2011
        VSB_RENAULT_TAFEIKE_1              = 6           // 雷诺-塔菲克-2004    
}VSB_RENAULT_CLASS;

//黄海子品牌类型
typedef enum _VSB_HUANGHAI_CLASS
{
    VSB_HUANGHAI_OTHER                 = 0,         // 其他（保留）
        VSB_HUANGHAI_DACAISHEN_1           = 1,         // 黄海-大柴神-2013,2012
        VSB_HUANGHAI_DACAISHEN_2           = 2,         // 黄海-大柴神-2013,2012,2011,2010,2009柴油版
        VSB_HUANGHAI_BUS4_1                = 3,         // 黄海-客车车型4-2012,2011
        VSB_HUANGHAI_CHALLENGER_1          = 4,         // 黄海-挑战者-2011,2010,2009,2008
        VSB_HUANGHAI_AOLONGCUV_1           = 5,         // 黄海-翱龙CUV-2010,2009
        VSB_HUANGHAI_AOJUN_1               = 6,         // 黄海-傲骏-2009
        VSB_HUANGHAI_AOJUN_2               = 7,         // 黄海-傲骏-2010,2009
        VSB_HUANGHAI_QISHENGV3_1           = 8,         // 黄海-旗胜V3-2011
        VSB_HUANGHAI_LINGHANGZHE_1         = 9,         // 黄海-领航者-2007,2005
        VSB_HUANGHAI_FENGCHI_1             = 10         // 黄海-风驰-A款
}VSB_HUANGHAI_CLASS;

/********************车辆品牌子类型End*************************/

//车辆信息
typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;          //车辆序号
    BYTE  byVehicleType;    //车辆类型 0 表示其它车型，1 表示小型车，2 表示大型车 ,3表示行人触发 ,4表示二轮车触发 5表示三轮车触发(3.5Ver)
    BYTE  byColorDepth;        //车身颜色深浅
    BYTE  byColor;          //车身颜色,参考VCR_CLR_CLASS
    /*雷达异常状态：
    0~雷达正常，
    1~雷达故障
    2~雷达一直发送某一个相同速度值
    3~雷达送出数据为0
    4~雷达送出数据过大或者过小
    */
    BYTE  byRadarState;
    WORD  wSpeed;           //单位km/h
    WORD  wLength;          //前一辆车的车身长度  
                            /*违规类型，0-正常，1-低速，2-超速，3-逆行，4-闯红灯,5-压车道线,6-不按导向，7-路口滞留，
                            8-机占非，9-违法变道，10-不按车道 11-违反禁令，12-路口停车，13-绿灯停车, 14-未礼让行人(违法代码1357), 
    15-违章停车，16-违章掉头,17-占用应急车道,18-禁右,19-禁左,20-压黄线,21-未系安全带,22-行人闯红灯,23-加塞*/
    BYTE  byIllegalType;
    BYTE  byVehicleLogoRecog; //参考枚举类型 VLR_VEHICLE_CLASS
    BYTE  byVehicleSubLogoRecog; //车辆品牌子类型识别；参考VSB_VOLKSWAGEN_CLASS等子类型枚举。
    BYTE  byVehicleModel; //车辆子品牌年款，0-未知，参考"车辆子品牌年款.xlsx"
    BYTE  byCustomInfo[16];  //自定义信息
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" (该字段兼容byVehicleLogoRecog);
    BYTE  byRes3[14];    
}NET_DVR_VEHICLE_INFO, *LPNET_DVR_VEHICLE_INFO;

//车牌检测结果
typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;            //结构长度
    BYTE    byResultType;    //0-视频识别结果，1图像识别结果 2 大于10M时走下载路线
    BYTE    byChanIndex;    //通道号
    WORD    wAlarmRecordID;    //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    DWORD   dwRelativeTime;    //相对时间点  
    BYTE    byAbsTime[32];    //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999（毫秒）
    DWORD   dwPicLen;        //图片长度(近景图)
    DWORD    dwPicPlateLen;  //车牌小图片长度
    DWORD   dwVideoLen;        //录像内容长度
    BYTE    byTrafficLight;    //0-非红绿灯抓拍，1-绿灯时抓拍；2-红灯时抓拍
    BYTE    byPicNum;       //连拍的图片序号
    BYTE    byDriveChan;    //触发车道号
    BYTE     byVehicleType; //车辆类型，参考VTR_RESULT
    DWORD   dwBinPicLen;    //车牌二值图长度
    DWORD   dwCarPicLen;    //车辆原图长度
    DWORD   dwFarCarPicLen; //远景图长度
    BYTE    *pBuffer3;      //车牌二值图
    BYTE    *pBuffer4;      //车辆原图
    BYTE    *pBuffer5;      //远景图
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）
    BYTE    byRes3[6];   
    NET_DVR_PLATE_INFO  struPlateInfo;    //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    *pBuffer1;                   // 当上传的是图片(近景图)，指针指向图片信息，当上传的是视频，指针指向视频信息，如果不想获得图片或视频信息，传NULL(DVS车辆近景图)
    BYTE    *pBuffer2;                  // 当上传的是图片(车牌图)时，指向车牌图片的指针（DVS车牌彩图）
}NET_DVR_PLATE_RESULT, *LPNET_DVR_PLATE_RESULT;
//后面紧跟图片数据和录像数据，只传一种，图片数据为场景图片+车牌小图片

//图像叠加信息配置        
typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD        dwSize;
    BYTE        byOverlayInfo;//叠加使能开关，0-不叠加，1-叠加
    BYTE        byOverlayMonitorInfo;//是否叠加监测点信息，0-不叠加，1-叠加
    BYTE        byOverlayTime;//是否叠加时间，0-不叠加，1-叠加
    BYTE        byOverlaySpeed;//是否叠加速度，0-不叠加，1-叠加
    BYTE        byOverlaySpeeding;//是否叠加超速比例，0-不叠加，1-叠加
    BYTE        byOverlayLimitFlag;//是否叠加限速标志，0-不叠加，1-叠加
    BYTE        byOverlayPlate;//是否叠加车牌号，0-不叠加，1-叠加
    BYTE        byOverlayColor;//是否叠加车身颜色，0-不叠加，1-叠加
    BYTE        byOverlayLength;//是否叠加车长，0-不叠加，1-叠加
    BYTE        byOverlayType;//是否叠加车型，0-不叠加，1-叠加
    BYTE        byOverlayColorDepth;//是否叠加车身颜色深浅，0-不叠加，1-叠加
    BYTE        byOverlayDriveChan;//是否叠加车道，0-不叠加，1-叠加
    BYTE        byOverlayMilliSec; //叠加毫秒信息 0-不叠加，1-叠加
    BYTE        byOverlayIllegalInfo; //叠加违章信息 0-不叠加，1-叠加
    BYTE        byOverlayRedOnTime;  //叠加红灯已亮时间 0-不叠加，1-叠加
    BYTE        byFarAddPlateJpeg;      //远景图是否叠加车牌截图,0-不叠加,1-叠加
    BYTE        byNearAddPlateJpeg;      //近景图是否叠加车牌截图,0-不叠加,1-叠加
    BYTE        byRes1[3];    //保留
    BYTE        byMonitorInfo1[32];    //监测点信息1
    BYTE        byMonitorInfo2[44]; //检测点信息2
    BYTE        byRes2[52];    //保留
}NET_DVR_IMAGEOVERLAYCFG, *LPNET_DVR_IMAGEOVERLAYCFG;

//单IO触发抓拍功能配置
typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE     bySnapTimes; //线圈抓拍次数，0-不抓拍，非0-连拍次数，目前最大5次  
    WORD    wSnapWaitTime;  //抓拍等待时间，单位ms，取值范围[0,60000]
    WORD    wIntervalTime[MAX_INTERVAL_NUM];//连拍间隔时间，ms
    DWORD   dwSnapVehicleNum; //抓拍车辆序号。
    NET_DVR_JPEGPARA  struJpegPara;//抓拍图片参数
    BYTE    byRes2[16];//保留字节
}NET_DVR_SNAPCFG, *LPNET_DVR_SNAPCFG;

typedef enum _ITC_MAINMODE_ABILITY_
{
    ITC_MODE_UNKNOW    = 0x0,   //无
        ITC_POST_MODE  = 0x1,  //卡口模式
        ITC_EPOLICE_MODE      = 0x2,  //电警模式
        ITC_POSTEPOLICE_MODE  = 0x4  //卡式电警模式
}ITC_MAINMODE_ABILITY;

typedef enum _ITC_RECOG_REGION_TYPE_
{
    ITC_REGION_RECT    = 0x0,   //矩形
        ITC_REGION_POLYGON  = 0x1,  //多边形
}ITC_RECOG_REGION_TYPE;

typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum;//IO输入口数
    BYTE  byIoOutNum;//IO输出口数
    BYTE  bySingleSnapNum;//单IO触发组数
    BYTE  byLightModeArrayNum;//红绿灯模式组数
    BYTE  byMeasureModeArrayNum;//测速模式组数
    BYTE  byPlateEnable; //车牌识别能力
    BYTE  byLensMode;//镜头模式0-CCD,1-CMOS
    BYTE  byPreTriggerSupport; //是否支持原触发模式，0-支持，1-不支持
    DWORD dwAbilityType; //支持的触发模式能力，按位表示，定义见ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //支持的IO测速组数
    BYTE  byIoLightGroup; //支持的IO红绿灯组数
    BYTE  byRecogRegionType; //牌识区域支持的类型，详见定义ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //设备能力，按位表示，0-不支持，1-支持
    // bySupport&0x1，表示是否支持扩展的字符叠加配置
    // bySupport&0x2，表示是否支持扩展的校时配置结构
    // bySupport&0x4, 表示是否支持多网卡(多网隔离)
    // bySupport&0x8, 表示是否支持网卡的bonding功能(网络容错)
    // bySupport&0x10, 表示是否支持语音对讲
    //2013-07-09 能力集返回
    WORD wSupportMultiRadar;// 设备能力，按位表示，0-不支持，1-支持
    // wSupportMultiRadar&0x1，表示 卡口RS485雷达 支持车道关联雷达处理
    // wSupportMultiRadar&0x2，表示 卡口虚拟线圈 支持车道关联雷达处理
    // wSupportMultiRadar&0x4，表示 混行卡口 支持车道关联雷达处理
    // wSupportMultiRadar&0x8，表示 视频检测 支持车道关联雷达处理
    BYTE  byICRPresetNum;
    // 表示支持的ICR预置点（滤光片偏移点）数
    BYTE  byICRTimeSlot;//表示支持的ICR的时间段数（1～8）
    BYTE  bySupportRS485Num;//表示支持的RS485口的数量
    BYTE  byExpandRs485SupportSensor;// 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSensor &0x1，表示电警车检器支持车检器
    // byExpandRs485SupportSensor &0x2，表示卡式电警车检器支持车检器
    BYTE  byExpandRs485SupportSignalLampDet;// 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSignalLampDet &0x1，表示电警车检器支持外接信号灯检测器
    // byExpandRs485SupportSignalLampDet &0x2，表示卡式电警车检器支持外接信号灯检测器
    BYTE  byRelayNum;// 表示支持继电器的个数 2013-11-04
    BYTE  bySupport1; //设备能力，按位表示，0-不支持，1-支持
    // bySupport1&0x1，表示是否支持自定义校时信息配置
    // bySupport1&0x2,  表示是否支持视频触发优化方案
    // bySupport1&0x4,  表示是否支持DDNS配置方案
    // bySupport1&0x8,  表示是否支持获取设备当前触发模式接口命令
    // bySupport1&0x10, 表示是否支持出入口配置 2014-03-03
    // bySupport1&0x20,  表示是否支持GPS模块参数配置
    // bySupport1&0x40,  表示是否支持NTP校时间隔支持分钟设置
    // bySupport1&0x80,  表示是否支持tps报警数据上传
    BYTE  bySupport2; //设备能力，按位表示，0-不支持，1-支持
    // bySupport2&0x01,  表示是否支持码流附加信息配置
    // bySupport2&0x02,  表示通道图像参数（INTER_PICCFG_V30）中是否支持视频叠加时间毫秒启用参数（byOSDMilliSecondEnable）
    BYTE  bySupportWhiteBalance; //白平衡能力，默认都是支持手动白平衡、自动白平衡、自动白平衡2这3种模式。
    // bySupportWhiteBalance &0x01,  表示是否支持日光灯模式
    // bySupportWhiteBalance &0x02,  表示是否支持自然光模式
    // bySupportWhiteBalance &0x04,  表示是否支持暖光灯模式
    // bySupportWhiteBalance &0x08,  表示是否支持白炽灯模式
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY, *LPNET_DVR_SNAP_ABILITY;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//预置点号1～8 , 0代表无
    BYTE   bySubSwitchMode;//1~白天，2~晚上 (当预置点等于0 的时候生效)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM  //156
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//自动切换时间段 (自动切换下 时空下生效 现在支持4组，预留4组)
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{    
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100]
    BYTE  bySubSwitchMode;//1~白天，2~晚上
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    BYTE  byICRAutoSwitch; // ICR自动切换加阈值选项, 取值范围[0 100]
    BYTE  byRes[147];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

//算法自动
typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//检测阈值,范围[0,100],默认 58
    BYTE  byAbBrightnessThreshold; //异常亮度阈值，范围[0,100]，默认12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;

typedef union tagNET_ITC_ICR_PARAM_UNION
{
    BYTE uLen[156];
    NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
    NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
    NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
    NET_ITC_ICR_ALGAOTOSWITCH_PARAM strICRAlgorithmAutoSwitch;
}NET_ITC_ICR_PARAM_UNION,*LPNET_ITC_ICR_PARAM_UNION;

typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~自动切换，2~手动切换 ,3~定时切换,4~算法自动 
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;

//2013-07-09 异常处理
typedef struct
{    
    DWORD   dwHandleType; //异常处理,异常处理方式的"或"结果
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出（继电器输出）*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/  
    BYTE     byEnable; //0～不启用，1～启用
    BYTE    byRes;
    WORD    wDuration;//持续时间(单位/s)
    BYTE    byAlarmOutTriggered[MAX_ITC_EXCEPTIONOUT];//触发输出通道
    BYTE    byRes1[8];
} NET_ITC_HANDLEEXCEPTION, *LPNET_ITC_HANDLEEXCEPTION;

typedef struct
{
    DWORD dwSize;
    NET_ITC_HANDLEEXCEPTION struSnapExceptionType[MAX_EXCEPTIONNUM_V30]; //数组的每个元素都表示一种异常，数组0- 硬盘出错,1-网线断,2-IP 地址冲突, 3-车检器异常, 4-信号灯检测器异常
}NET_ITC_EXCEPTION,*LPNET_ITC_EXCEPTION;

typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX; /*线圈左上角横坐标（2个字节）*/
    WORD wTopLeftY; /*线圈左上角纵坐标（2个字节）*/
    WORD wWdith; /*线圈宽度（2个字节）*/
    WORD wHeight; /*线圈高度（2个字节）*/
} NET_DVR_TRIGCOORDINATE, *LPNET_DVR_TRIGCOORDINATE;

typedef enum _PROVINCE_CITY_IDX_
{
    ANHUI_PROVINCE             = 0,              //安徽
        AOMEN_PROVINCE             = 1,              //澳门
        BEIJING_PROVINCE           = 2,              //北京
        CHONGQING_PROVINCE         = 3,              //重庆
        FUJIAN_PROVINCE            = 4,              //福建
        GANSU_PROVINCE             = 5,              //甘肃
        GUANGDONG_PROVINCE         = 6,              //广东
        GUANGXI_PROVINCE           = 7,              //广西
        GUIZHOU_PROVINCE           = 8,              //贵州
        HAINAN_PROVINCE            = 9,              //海南
        HEBEI_PROVINCE             = 10,             //河北
        HENAN_PROVINCE             = 11,             //河南
        HEILONGJIANG_PROVINCE      = 12,             //黑龙江
        HUBEI_PROVINCE             = 13,             //湖北
        HUNAN_PROVINCE             = 14,             //湖南
        JILIN_PROVINCE             = 15,             //吉林
        JIANGSU_PROVINCE           = 16,             //江苏
        JIANGXI_PROVINCE           = 17,             //江西
        LIAONING_PROVINCE          = 18,             //辽宁
        NEIMENGGU_PROVINCE         = 19,             //内蒙古
        NINGXIA_PROVINCE           = 20,             //宁夏
        QINGHAI_PROVINCE           = 21,             //青海
        SHANDONG_PROVINCE          = 22,             //山东
        SHANXI_JIN_PROVINCE        = 23,             //山西
        SHANXI_SHAN_PROVINCE       = 24,             //陕西
        SHANGHAI_PROVINCE          = 25,             //上海
        SICHUAN_PROVINCE           = 26,             //四川
        TAIWAN_PROVINCE            = 27,             //台湾
        TIANJIN_PROVINCE           = 28,             //天津
        XIZANG_PROVINCE            = 29,             //西藏
        XIANGGANG_PROVINCE         = 30,             //香港
        XINJIANG_PROVINCE          = 31,             //新疆
        YUNNAN_PROVINCE            = 32,             //云南
        ZHEJIANG_PROVINCE          = 33              //浙江
}PROVINCE_CITY_IDX;

typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2]; /*保留*/
    DWORD dwCity; /*城市，详见PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;

//场景模式
typedef enum _SCENE_MODE_
{
    UNKOWN_SCENE_MODE   = 0,            //未知场景模式
        HIGHWAY_SCENE_MODE  = 1,            //高速场景模式
        SUBURBAN_SCENE_MODE = 2,            //郊区场景模式(保留)
        URBAN_SCENE_MODE    = 3,            //市区场景模式
        TUNNEL_SCENE_MODE   = 4             //隧道场景模式(保留)
}SCENE_MODE;

typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;  /* 是否使能虚拟线圈，0-不使用，1-使用*/
    BYTE    byIsDisplay; /* 是否显示虚拟线圈，0-不显示，1-显示*/
    BYTE    byLoopPos; //晚间触发线圈的偏向：0-向上，1-向下
    BYTE    bySnapGain; /*抓拍增益*/
    DWORD   dwSnapShutter; /*抓拍快门速度*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate; //保留
    NET_DVR_TRIGCOORDINATE struRes[MAX_VL_NUM];
    BYTE    byTotalLaneNum;/*视频触发的车道数1*/
    BYTE    byPolarLenType; /*偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。*/
    BYTE    byDayAuxLightMode; /*白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明*/
    BYTE    byLoopToCalRoadBright; /*用以计算路面亮度的车道(虚拟线圈)*/
    BYTE    byRoadGrayLowTh; /*路面亮度低阈值初始化值1*/
    BYTE    byRoadGrayHighTh; /*路面亮度高阈值初始化值140*/
    WORD    wLoopPosBias; /*晚间触发线圈位移30*/
    DWORD   dwHfrShtterInitValue; /*连续图像曝光时间的初始值2000*/
    DWORD   dwSnapShtterInitValue; /*抓拍图像曝光时间的初始值500*/
    DWORD   dwHfrShtterMaxValue; /*连续图像曝光时间的最大值20000*/
    DWORD   dwSnapShtterMaxValue; /*抓拍图像曝光时间的最大值1500*/
    DWORD   dwHfrShtterNightValue; /*晚间连续图像曝光时间的设置值3000*/
    DWORD   dwSnapShtterNightMinValue; /*晚间抓拍图像曝光时间的最小值3000*/
    DWORD   dwSnapShtterNightMaxValue; /*晚间抓拍图像曝光时间的最大值5000*/
    DWORD   dwInitAfe; /*增益的初始值200*/
    DWORD   dwMaxAfe; /*增益的最大值400*/
    WORD    wResolutionX;/* 设备当前分辨率宽*/
    WORD    wResolutionY;/* 设备当前分辨率高*/
    DWORD   dwGainNightValue; /*晚间增益，默认值70*/
    DWORD   dwSceneMode; /*场景模式， 详见SCENE_MODE */
    DWORD   dwRecordMode; /*录像标志：0-不录像，1-录像*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*地址位置*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*触发灵敏度，1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM, *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD dwSize;
    BYTE  byPlateEnable;//是否支持车牌识别，0-不支持，1-支持
    BYTE  byRes1[2];   //保留
    BYTE  byFrameFlip;   //图像是否翻转 0-不翻转，1-翻转
    WORD  wFlipAngle;    //图像翻转角度 0,90,180,270
    WORD  wLightPhase;   //相位，取值范围[0, 360]
    BYTE  byLightSyncPower;  //是否信号灯电源同步，0-不同步；1-同步
    BYTE  byFrequency;        //信号频率
    BYTE  byUploadSDEnable;  //是否自动上传SD图片，0-否；1-是
    BYTE  byPlateMode; //识别模式参数:0-视频触发,1-外部触发
    BYTE  byUploadInfoFTP; //是否上传抓拍附加信息到FTP，0-否，1-是
    BYTE  byAutoFormatSD; //是否自动格式化SD卡，0-否，1-是
    WORD  wJpegPicSize; //Jpeg图片大小[64-8196]
    BYTE  bySnapPicResolution;  //抓拍图片分辨率(与NET_DVR_COMPRESSION_INFO_V30中分辨率保持一致)
    BYTE  byRes[55]; //保留
}NET_DVR_SNAPENABLECFG, *LPNET_DVR_SNAPENABLECFG;

/*ftp上传参数*/
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwEnableFTP;            /*是否启动ftp上传功能*/
    char    sFTPIP[16];                /*ftp 服务器*/
    DWORD    dwFTPPort;                /*ftp端口*/
    BYTE    sUserName[NAME_LEN];    /*用户名*/
    BYTE    sPassword[PASSWD_LEN];    /*密码*/
    DWORD    dwDirLevel;    /*0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录*/
    WORD     wTopDirMode;    /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，0x4=使用监测点,0x5=使用时间(年月),0x=6自定义,0x7=违规类型,0x8=方向,0x9=地点*/
    WORD     wSubDirMode;    /* 二级目录，0x1 = 使用通道名,0x2 = 使用通道号，,0x3=使用时间(年月日),0x4=使用车道号,0x=5自定义,0x6=违规类型,0x7=方向,0x8=地点*/
    BYTE    byEnableAnony; //启用匿名，0-否，1-是
    BYTE    byPicArchivingInterval;//图片归档间隔[1~30],0表示关闭
    BYTE    byRes[22];
}NET_DVR_FTPCFG, *LPNET_DVR_FTPCFG;

/*可用来命名图片的相关元素 */
#define PICNAME_ITEM_DEV_NAME         1        /*设备名*/
#define PICNAME_ITEM_DEV_NO         2        /*设备号*/
#define PICNAME_ITEM_DEV_IP         3        /*设备IP*/
#define PICNAME_ITEM_CHAN_NAME         4        /*通道名*/
#define PICNAME_ITEM_CHAN_NO         5        /*通道号*/
#define PICNAME_ITEM_TIME             6        /*时间*/
#define PICNAME_ITEM_CARDNO            7        /*卡号*/
#define PICNAME_ITEM_PLATE_NO       8   /*车牌号码*/
#define PICNAME_ITEM_PLATE_COLOR    9   /*车牌颜色*/
#define PICNAME_ITEM_CAR_CHAN       10  /*车道号*/
#define PICNAME_ITEM_CAR_SPEED      11  /*车辆速度*/
#define PICNAME_ITEM_CARCHAN        12  /*监测点*/
#define PICNAME_ITEM_PIC_NUMBER     13  //图片序号
#define PICNAME_ITEM_CAR_NUMBER     14  //车辆序号
#define PICNAME_MAXITEM             15

#define PICNAME_ITEM_SPEED_LIMIT_VALUES    15 //限速值
#define PICNAME_ITEM_ILLEGAL_CODE          16 //国标违法代码
#define PICNAME_ITEM_CROSS_NUMBER          17 //路口编号
#define PICNAME_ITEM_DIRECTION_NUMBER      18 //方向编号

//(3.7Ver)
#define PICNAME_ITEM_CAR_COLOR             19 //车身颜色
#define PICNAME_ITEM_PLATE_COORDINATE      20 //车牌坐标
#define PICNAME_ITEM_CAR_TYPE              21 //车辆类型
#define PICNAME_ITEM_VIOLATION_TYPE        22 //违规类型
#define PICNAME_ITEM_CUSTOM                255//自定义



//图片命名
typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    桉数组定义文件命名的规则 */
    BYTE     byDelimiter;        /*分隔符，一般为'_'*/
}NET_DVR_PICTURE_NAME, *LPNET_DVR_PICTURE_NAME;

//命名规则：2013-09-27
#define PICNAME_ITEM_PARK_DEV_IP             1        /*设备IP*/
#define PICNAME_ITEM_PARK_PLATE_NO          2       /*车牌号码*/
#define PICNAME_ITEM_PARK_TIME                 3        /*时间*/
#define PICNAME_ITEM_PARK_INDEX             4       /*车位编号*/
#define PICNAME_ITEM_PARK_STATUS            5       /*车位状态*/
#define PICNAME_ITEM_BUILDING_NUMBER        6       /*栋号单元号*/
#define PICNAME_ITEM_OUTDOOR_UNIT_ID        7       /*门口机编号*/
#define PICNAME_ITEM_UNLOCK_TYPE            8       /*开锁方式*/
#define PICNAME_ITEM_DEVICE_NAME            9       //设备名称
#define PICNAME_ITEM_PERIOD_NO              10      /*期号*/
#define PICNAME_ITEM_DEV_INDEX              11      /*设备编号*/
#define PICNAME_PREFIX                      32      /*图片名自定义前缀长度*/
//图片命名扩展 2013-09-27
typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    桉数组定义文件命名的规则 */
    BYTE     byDelimiter;                    /*分隔符，一般为'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //图片名自定义前缀
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

/* 串口抓图设置*/
typedef struct 
{
    BYTE    byStrFlag;    /*串口数据开始符*/
    BYTE     byEndFlag;    /*结束符*/
    WORD    wCardIdx;    /*卡号相对起始位*/
    DWORD     dwCardLen;    /*卡号长度*/
    DWORD   dwTriggerPicChans;    /*所触发的通道号，按位，从第1位开始计，即0x2表示第一通道*/
}NET_DVR_SERIAL_CATCHPIC_PARA, *LPNET_DVR_SERIAL_CATCHPIC_PARA;

//DVR抓图参数配置（基线）
typedef struct 
{
    DWORD    dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];    /*每个通道的图像参数*/
    WORD    wBurstMode;                            /*抓图方式,按位设置.0x1=报警输入触发，0x2=移动侦测触发 0x4=232触发，0x8=485触发，0x10=网络触发*/
    WORD    wUploadInterval;                    /*图片上传间隔(秒)[0,65535]*/
    NET_DVR_PICTURE_NAME     struPicNameRule;    /* 图片命名规则 */
    BYTE    bySaveToHD;        /*是否保存到硬盘*/
    BYTE    byRes1;
    WORD    wCatchInterval;        /*抓图间隔(毫秒)[0,65535]*/
    BYTE    byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];    /* 每个通道一次触发拍照次数 */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30]; /*报警触发抓拍通道,按位设置，从第1位开始*/
}NET_DVR_JPEGCFG_V30, *LPNET_DVR_JPEGCFG_V30;

//抓拍触发请求结构(保留)
typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-不关闭(默认)，1-关闭
    BYTE   byLaneNo;//车道号, 范围为1-6，默认为1(抓拍机内部测试使用)
    BYTE   byRes[22]; //保留
}NET_DVR_MANUALSNAP, *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG    
{
    DWORD dwSize; 
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写*/
    BYTE byPlateOSD;    /*0:不发送车牌彩色图,1:发送车牌彩色图*/
    BYTE bySendJPEG1;   /*0-不传送近景JPEG图,1-传送近景JPEG图*/
    BYTE bySendJPEG2;   /*0-不传送远景JPEG图,1-传送远景JPEG图*/
    WORD wDesignedPlateWidth;   /*车牌设计宽度*/
    BYTE byTotalLaneNum;  /*识别的车道数*/
    BYTE byRes1;      /*保留*/
    WORD wRecognizedLane;  /*识别的车道号，按位表示，bit0表示车道1是否识别，0-不识别，1-识别*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];  /*车道识别区域*/
                                                  DWORD dwRecogMode;  /*识别的类型，
                                                                      bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ； 
                                                                      bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
                                                                      bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
                                                                      bit3-农用车识别：0-不采用农用车识别，1-农用车识别； 
                                                                      bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
                                                                      bit5-帧定位或场定位：0-帧定位，1-场定位；
                                                                      bit6-帧识别或场识别：0-帧识别，1-场识别； 
                                                  bit7-晚上或白天：0-白天，1-晚上 */
                                                  BYTE  bySendPRRaw;           //是否发送原图：0-不发送，1-发送 
                                                  BYTE  bySendBinImage;      //是否发送车牌二值图：0-不发送，1-发送 
                                                  BYTE  byDelayCapture;  //延时抓拍控制,单位：帧
                                                  BYTE  byUseLED;    //使用LED控制，0-否，1-是
                                                  BYTE  byRes2[68];    //保留
}NET_DVR_SPRCFG, *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;    //是否启用车牌亮度补偿（默认启用）：0-关闭，1-启用 
    BYTE byPlateExpectedBright;    //车牌的预期亮度（默认值50）, 范围[0, 100]
    BYTE byRes1[2];    //保留 
    BYTE byTradeoffFlash;     //是否考虑闪光灯的影响: 0 - 否;  1 - 是(默认); 
    //使用闪光灯补光时, 如果考虑减弱闪光灯的亮度增强效应, 则需要设为1;否则为0
    BYTE byCorrectFactor;     //纠正系数, 范围[0, 100], 默认值50 (在tradeoff_flash切换时,恢复默认值）
    WORD wLoopStatsEn;  //是否该线圈的亮度，按位表示，0-不统计，1-统计
    BYTE byPlcBrightOffset;// 车牌亮度补偿灵敏度(虚拟线圈模式起效)，取值范围1~100
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //预览连接个数
    WORD wFortifyLinkNum; //布防连接个数
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //预览的用户IP地址
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //布防连接的用户IP地址
    DWORD dwVideoFrameRate;    //帧率：0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;      //抓拍分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //传输类型：0-主码流；1-子码流
    BYTE byTriggerType; //触发模式：0-视频触发；1-普通触发
    DWORD dwSDVolume;  //SD卡容量
    DWORD dwSDFreeSpace; //SD卡剩余空间
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //车检器状态：0-未使用；1-正常；2-异常
    BYTE byDetectorLinkState; //车检器连接状态：0-未连接；1-连接
    BYTE bySDStatus;    //SD卡状态 0－活动；1－休眠；2－异常，3-无sd卡
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //布防等级，0-无，1-一等级（高），2-二等级（中），3-三等级（低）
    BYTE byRes2[116]; //保留
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//线圈距离,单位cm，取值范围[0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];    //信号灯通道号
    BYTE  byCapSpeed;//标志限速，单位km/h，取值范围[0,255]
    BYTE  bySpeedLimit;//限速值，单位km/h，取值范围[0,255]
    BYTE  byTrafficDirection;//车流方向，0-由东向西，1-由西向东，2-由南向北，3-由北向南
    BYTE  byRes1; //保留
    WORD  wLoopPreDist;        /*触发延迟距离 ，单位：分米*/
    WORD  wTrigDelay;             /*触发硬延时时间 ，单位：毫秒*/
    BYTE  byRes[124];//保留字节
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;


//信号灯异常检测
typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;        //结构长度
    //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    BYTE    byAbsTime[32];    
    NET_DVR_IPADDR    struAlarmCamIP;//报警摄像机IP
    DWORD   dwPic1Len;     //异常图片1长度
    DWORD   dwPic2Len;     //异常图片2长度
    char    *pPic1Buffer;    //数据指针  叠加车道线图片
    char    *pPic2Buffer;    //数据指针  叠加信号灯状态图片
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize; // 结构体大小
    DWORD         dwChannel;                //通道号    
    BYTE          byExternalDevType;// 0-无效值（保留）1-信号灯,2-闪光灯
    BYTE          byRes[63];             // 保留字节
}NET_DVR_EXDEVDET_COND,*LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize; // 结构体大小
    BYTE          byExternalDevStatus;// 0-正常1-异常
    BYTE          byRes[63];// 保留字节
} NET_DVR_EXDEVDET_CFG,*LPNET_DVR_EXDEVDET_CFG;

/***************************** end *********************************************/

#define IPC_PROTOCOL_NUM      50   //ipc 协议最大个数

//协议类型
typedef struct tagNET_DVR_PROTO_TYPE
{ 
    DWORD dwType;               /*ipc协议值*/    
    BYTE  byDescribe[DESC_LEN]; /*协议描述字段*/    
}NET_DVR_PROTO_TYPE, *LPNET_DVR_PROTO_TYPE;

//协议列表
typedef struct tagNET_DVR_IPC_PROTO_LIST
{    
    DWORD   dwSize; 
    DWORD   dwProtoNum;           /*有效的ipc协议数目*/   
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM];   /*有效的ipc协议*/    
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST, *LPNET_DVR_IPC_PROTO_LIST;

//协议列表V41
typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;  
    DWORD   dwProtoNum;  //有效的ipc协议数目
    BYTE    *pBuffer;    //协议列表缓冲区, dwProtoNum 个NET_DVR_PROTO_TYPE结构  
    DWORD   dwBufferLen; //缓冲区长度
    BYTE    byRes[32];   
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P参数（水平参数）
    DWORD    dwTiltPos;    // T参数（垂直参数）
    DWORD    dwZoomPos;  // Z参数（变倍参数）
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;

//人体特征识别结果结构体
typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;    //年龄段,参见 HUMAN_AGE_GROUP_ENUM
    BYTE bySex;         //性别, 1 - 男 , 2 - 女
    BYTE byEyeGlass;    //是否戴眼镜 1 - 不戴, 2 - 戴
    BYTE byRes [13];    //保留
}NET_VCA_HUMAN_FEATURE ,*LPNET_VCA_HUMAN_FEATURE;

//物体颜色属性
typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;            //颜色在移动物体中的占比阈值
    BYTE  byRed;                        // RGB颜色三分量中的红色
    BYTE  byGreen;                    // RGB颜色三分量中的绿色
    BYTE  byBlue;                   // RGB颜色三分量中的兰色
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE ,*LPNET_DVR_OBJECT_FEATURE;

//组合搜索条件
typedef union tagNET_DVR_ADVANCE_COND_UNION
{  
    BYTE                  byLen[36];  //联合体长度
    NET_VCA_HUMAN_FEATURE      struHumanFeature; //人体属性
    NET_DVR_OBJECT_FEATURE     struObjectFeature; //物体属性
}NET_DVR_ADVANCE_COND_UNION,*LPNET_DVR_ADVANCE_COND_UNION;


#define MAX_ALERTLINE_NUM    8 //最大警戒线条数    


typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{    
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];  //穿越境界面参数
    DWORD dwPreTime;   /*智能报警提前时间 单位:秒*/
    DWORD dwDelayTime; /*智能报警延迟时间 单位:秒*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ坐标信息
    BYTE  byAdvanceType;   //组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    BYTE  byRes1[3];  //保留
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //组合属性
    BYTE  byRes[5604]; //保留
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND; //越界侦测查询条件

#define MAX_INTRUSIONREGION_NUM    8 //最大区域数数
typedef struct tagNET_DVR_INTRUSION_SEARCHCOND  
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/]; //入侵区域
    DWORD dwPreTime;   /*智能报警提前时间 单位:秒*/
    DWORD dwDelayTime; /*智能报警延迟时间 单位:秒*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ坐标信息
    BYTE  byAdvanceType;//组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    BYTE  byRes1[3];  //保留
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //组合属性
    BYTE byRes[5348]; //保留
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND; //区域入侵


typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //识别区域
    DWORD           dwPreTime;   /*智能录像提前时间 单位:秒*/
    DWORD           dwDelayTime; /*智能录像延迟时间 单位:秒*/
    BYTE byRes[5972]; //保留
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND; //人脸检测


typedef union tagNET_DVR_AREA_SMARTSEARCH_COND_UNION
{  
    BYTE    byLen[6144];  //结构体长度
    BYTE    byMotionScope[64][96]; //侦测区域 0-96位表示64行，共有96*64个小宏块，1-是移动侦测区域，0-非移动侦测区域 
    NET_DVR_TRAVERSE_PLANE_SEARCHCOND struTraversPlaneCond; //越界侦测
    NET_DVR_INTRUSION_SEARCHCOND struIntrusionCond; //区域入侵
    NET_DVR_FACEDETECTION_SEARCHCOND struFaceSnapCond; //人脸侦测条件
}NET_DVR_AREA_SMARTSEARCH_COND_UNION,
*LPNET_DVR_AREA_SMARTSEARCH_COND_UNION;


//智能搜索参数
typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE      byChan;                    //通道号
    BYTE      bySearchCondType; //智能查找联合体NET_DVR_AREA_SMARTSEARCH_COND_UNION的索引     
    /*0-移动侦测区域 ，1-越界侦测， 2-区域入侵, 3-人脸侦测 */
    WORD      wChan;                //通道号， 该字段是对byChan的扩展，使用该字段后byChan可以不再使用
    NET_DVR_TIME struStartTime;        //录像开始的时间
    NET_DVR_TIME struEndTime;        //录像停止的时间
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //智能查找条件
    BYTE  bySensitivity;               //移动侦测搜索灵敏度,1    >80%  2 40%~80%  3 1%~40%    
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM, *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{  
    DWORD                   dwSize;                 //结构体大小
    NET_DVR_STREAM_INFO   struIDInfo;           //通道信息
    BYTE                   bySearchCondType;     //智能查找联合体索引 0-侦测区域, 1-越界侦测, 2-区域入侵,3-人脸侦测, 4-车牌检测
    BYTE                  bySensitivity; //侦测区域动态分析灵敏度,1-100
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;  
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //智能查找条件
    BYTE                  byRes2[256];
}NET_DVR_SMART_SEARCH_PARAM_V40,*LPNET_DVR_SMART_SEARCH_PARAM_V40;



typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;    //移动侦测报警开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间
    BYTE byRes[64];
}NET_DVR_SMART_SEARCH_RET, *LPNET_DVR_SMART_SEARCH_RET;

// IPSAN 文件目录查找
typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IP地址
    WORD            wPort;      // IPSAN  端口
    BYTE            byRes[10];  // 保留字节
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // 返回的文件目录
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;

//DVR设备参数
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR名称
    DWORD dwDVRID;                //DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;        //是否循环录像,0:不是; 1:是
    //以下不可更改
    BYTE sSerialNumber[SERIALNO_LEN];  //序列号
    DWORD dwSoftwareVersion;            //软件版本号,高16位是主版本,低16位是次版本
    DWORD dwSoftwareBuildDate;            //软件生成日期,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;            //DSP软件版本,高16位是主版本,低16位是次版本
    DWORD dwDSPSoftwareBuildDate;        // DSP软件生成日期,0xYYYYMMDD
    DWORD dwPanelVersion;                // 前面板版本,高16位是主版本,低16位是次版本
    DWORD dwHardwareVersion;    // 硬件版本,高16位是主版本,低16位是次版本
    BYTE byAlarmInPortNum;        //DVR报警输入个数
    BYTE byAlarmOutPortNum;        //DVR报警输出个数
    BYTE byRS232Num;            //DVR 232串口个数
    BYTE byRS485Num;            //DVR 485串口个数 
    BYTE byNetworkPortNum;        //网络口个数
    BYTE byDiskCtrlNum;            //DVR 硬盘控制器个数
    BYTE byDiskNum;                //DVR 硬盘个数
    BYTE byDVRType;                //DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                //DVR 通道个数
    BYTE byStartChan;            //起始通道号,例如DVS-1,DVR - 1
    BYTE byDecordChans;            //DVR 解码路数
    BYTE byVGANum;                //VGA口的个数 
    BYTE byUSBNum;                //USB口的个数
    BYTE byAuxoutNum;            //辅口的个数
    BYTE byAudioNum;            //语音口的个数
    BYTE byIPChanNum;            //最大数字通道数 低8位，高8位见byHighIPChanNum 
    BYTE byZeroChanNum;            //零通道编码个数
    BYTE bySupport;        //能力，位与结果为0表示不支持，1表示支持，
    //bySupport & 0x1, 表示是否支持智能搜索
    //bySupport & 0x2, 表示是否支持备份
    //bySupport & 0x4, 表示是否支持压缩参数能力获取
    //bySupport & 0x8, 表示是否支持多网卡
    //bySupport & 0x10, 表示支持远程SADP
    //bySupport & 0x20, 表示支持Raid卡功能
    //bySupport & 0x40, 表示支持IPSAN搜索
    //bySupport & 0x80, 表示支持rtp over rtsp
    BYTE byEsataUseage;        //Esata的默认用途，0-默认备份，1-默认录像
    BYTE byIPCPlug;            //0-关闭即插即用，1-打开即插即用
    BYTE byStorageMode;        //0-盘组模式,1-磁盘配额, 2抽帧模式
    BYTE bySupport1;        //能力，位与结果为0表示不支持，1表示支持
    //bySupport1 & 0x1, 表示是否支持snmp v30
    //bySupport1 & 0x2, 支持区分回放和下载
    //bySupport1 & 0x4, 是否支持布防优先级    
    //bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
    //bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
    //bySupport1 & 0x20, 表示是否支持rtsp over http    
    WORD wDevType;//设备型号
    BYTE  byDevTypeName[DEV_TYPE_NAME_LEN];//设备型号名称 
    BYTE bySupport2; //能力集扩展，位与结果为0表示不支持，1表示支持
    //bySupport2 & 0x1, 表示是否支持扩展的OSD字符叠加(终端和抓拍机扩展区分)
    BYTE byAnalogAlarmInPortNum; //模拟报警输入个数
    BYTE byStartAlarmInNo;    //模拟报警输入起始号
    BYTE byStartAlarmOutNo;  //模拟报警输出起始号
    BYTE  byStartIPAlarmInNo;  //IP报警输入起始号
    BYTE  byStartIPAlarmOutNo; //IP报警输出起始号
    BYTE byHighIPChanNum;      //数字通道个数，高8位 
    BYTE byEnableRemotePowerOn;//是否启用在设备休眠的状态下远程开机功能，0-不启用，1-启用
    WORD wDevClass; //设备大类，判断设备是属于哪个产品线，0 保留，1-50 DVR，51-100 DVS，101-150 NVR，151-200 IPC，65534 其他，具体分类方法见《设备类型对应序列号和类型值.docx》
    BYTE byRes2[6];            //保留
}NET_DVR_DEVICECFG_V40, *LPNET_DVR_DEVICECFG_V40;

#define MAX_ZEROCHAN_NUM    16
//零通道压缩配置参数
typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;            //结构长度
    BYTE  byEnable;            //0-停止零通道编码，1-表示启用零通道编码
    BYTE  byRes1[3];            //保留
    DWORD dwVideoBitrate;     //视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    BYTE  byRes2[32];        //保留
}NET_DVR_ZEROCHANCFG, *LPNET_DVR_ZEROCHANCFG;

//零通道缩放参数
typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;                //结构长度
    NET_VCA_POINT  struPoint;    //画面中的坐标点
    BYTE byState;                //现在的状态，0-缩小，1-放大  
    BYTE byPreviewNumber;       //预览数目,0-1画面,1-4画面,2-9画面,3-16画面 该参数只读
    BYTE byPreviewSeq[MAX_WINDOW_V30];//画面通道信息 该参数只读
    BYTE byRes[30];                //保留 
}NET_DVR_ZERO_ZOOMCFG, *LPNET_DVR_ZERO_ZOOMCFG;

#define DESC_LEN_64 64
typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;            //结构长度
    BYTE    byEnable;            //0-禁用SNMP，1-表示启用SNMP
    BYTE    byRes1[3];            //保留
    WORD    wVersion;        //snmp 版本  v1 = 1, v2 =2, v3 =3，设备目前不支持 v3
    WORD    wServerPort; //snmp消息接收端口，默认 161
    BYTE    byReadCommunity[NAME_LEN]; //读共同体，最多31,默认"public"
    BYTE    byWriteCommunity[NAME_LEN];//写共同体,最多31 字节,默认 "private"
    BYTE     byTrapHostIP [DESC_LEN_64];    //自陷主机ip地址描述，支持IPV4 IPV6和域名描述    
    WORD    wTrapHostPort;   // trap主机端口
    BYTE    byTrapName[NAME_LEN];    
    BYTE    byRes2[70];    //保留
}NET_DVR_SNMPCFG, *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE    byUserName[NAME_LEN];            // 用户名                
    BYTE    bySecLevel;                        // 安全级别 1-无校验 2-无授权校验 3-授权校验
    BYTE    byAuthtype;                        // 认证类型 0-MD5认证 1-SHA认证 2: none
    BYTE    byPrivtype;                        // 0: DES; 1: AES; 2: none;
    BYTE    byRes[5];
    BYTE    byAuthpass[PASSWD_LEN];            // 认证密码
    BYTE    byPrivpass[PASSWD_LEN];            // 加密密码
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

// snmpv30
typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD                dwSize;            //结构长度
    BYTE                byEnableV1;        //0-禁用SNMP V1，1-表示启用SNMP V1
    BYTE                byEnableV2;        //0-禁用SNMP V2，1-表示启用SNMP V2
    BYTE                byEnableV3;        //0-禁用SNMP V3，1-表示启用SNMP V3
    BYTE                byRes1[3];
    WORD                wServerPort;                    //snmp消息接收端口，默认 161
    BYTE                byReadCommunity[NAME_LEN];        //读共同体，最多31,默认"public"
    BYTE                byWriteCommunity[NAME_LEN];        //写共同体,最多31 字节,默认 "private"
    BYTE                 byTrapHostIP [DESC_LEN_64];        //自陷主机ip地址描述，支持IPV4 IPV6和域名描述    
    WORD                wTrapHostPort;                    // trap主机端口
    BYTE                byRes2[2];       
    NET_DVR_SNMPv3_USER    struRWUser;    // 读写用户
    NET_DVR_SNMPv3_USER    struROUser;    // 只读用户
    BYTE                byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

#define  PROCESSING          0     //正在处理
#define  PROCESS_SUCCESS     100   //过程完成
#define  PROCESS_EXCEPTION   400   //过程异常
#define  PROCESS_FAILED      500   //过程失败
#define  PROCESS_QUICK_SETUP_PD_COUNT 501 //一键配置至少3块硬盘

#define  SOFTWARE_VERSION_LEN 48
typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;     // 设备IP地址
    WORD            wPort;      // 设备端口号
    WORD            wFactoryType;   // 设备厂家类型
    char            chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char            chSerialNo[16]; // 序列号
    WORD            wEncCnt;       // 编码通道个数
    BYTE            byMACAddr[MACADDR_LEN];        // MAC 地址
    NET_DVR_IPADDR  struSubDVRIPMask;   // DVR IP地址掩码
    NET_DVR_IPADDR  struGatewayIpAddr;  // 网关
    NET_DVR_IPADDR    struDnsServer1IpAddr;            /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR    struDnsServer2IpAddr;            /* 域名服务器2的IP地址 */
    BYTE            byDns;
    BYTE            byDhcp;
    BYTE            szGB28181DevID[DEV_ID_LEN];  //GB28181协议接入时的设备ID，用于IPC以GB28181协议接入
    BYTE            byActivated;//0-无效，1-已激活，2-未激活
    BYTE            byRes[125];     // 保留字节
}NET_DVR_SADPINFO, *LPNET_DVR_SADPINFO;

#define  MAX_SADP_NUM   256   // 搜索到设备最大数目
typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD            dwSize;   //  结构大小
    WORD             wSadpNum;   // 搜索到设备数目
    BYTE             byRes[6];   // 保留字节
    NET_DVR_SADPINFO struSadpInfo[MAX_SADP_NUM]; // 搜索
}NET_DVR_SADPINFO_LIST, *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY, *LPNET_DVR_SADP_VERIFY;

/*******************************备份接口 begin********************************/
//获取备份设备信息接口定义
#define DESC_LEN_32          32   //描述字长度
#define MAX_NODE_NUM         256  //节点个数

typedef struct tagNET_DVR_DESC_NODE
{ 
    int   iValue;           
    BYTE  byDescribe[DESC_LEN_32]; //描述字段 
    DWORD dwFreeSpace;           //获取磁盘列表专用,单位为M
    BYTE  byRes[12];              //保留  
}NET_DVR_DESC_NODE, *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{ 
    DWORD     dwSize;            //结构长度
    DWORD     dwNodeNum;         //能力结点个数
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //描述参数  
}NET_DVR_DISKABILITY_LIST, *LPNET_DVR_DISKABILITY_LIST;

//备份进度列表
#define BACKUP_SUCCESS                100  //备份完成
#define BACKUP_CHANGE_DEVICE          101  //备份设备已满，更换设备继续备份

#define BACKUP_SEARCH_DEVICE          300  //正在搜索备份设备
#define BACKUP_SEARCH_FILE            301  //正在搜索录像文件
#define BACKUP_SEARCH_LOG_FILE        302  //正在搜索日志文件

#define BACKUP_EXCEPTION              400  //备份异常
#define BACKUP_FAIL                      500  //备份失败

#define BACKUP_TIME_SEG_NO_FILE       501  //时间段内无录像文件
#define BACKUP_NO_RESOURCE            502  //申请不到资源
#define BACKUP_DEVICE_LOW_SPACE       503  //备份设备容量不足
#define BACKUP_DISK_FINALIZED         504  //刻录光盘封盘
#define BACKUP_DISK_EXCEPTION         505  //刻录光盘异常
#define BACKUP_DEVICE_NOT_EXIST       506  //备份设备不存在
#define BACKUP_OTHER_BACKUP_WORK      507  //有其他备份操作在进行
#define BACKUP_USER_NO_RIGHT          508  //用户没有操作权限
#define BACKUP_OPERATE_FAIL           509  //操作失败
#define BACKUP_NO_LOG_FILE            510  //硬盘中无日志

//备份过程接口定义
typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;   //文件个数
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM]; //文件列表
    BYTE byDiskDes[DESC_LEN_32];   //备份磁盘描述
    BYTE byWithPlayer;      //是否备份播放器
    BYTE byContinue;    /*是否继续备份 0不继续 1继续*/
    BYTE byRes[34];         //保留
}NET_DVR_BACKUP_NAME_PARAM, *LPNET_DVR_BACKUP_NAME_PARAM;

typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;        //按时间备份的通道
    NET_DVR_TIME    struStartTime;   //备份的起始时间
    NET_DVR_TIME    struStopTime;    //备份的终止时间
    BYTE            byDiskDes[DESC_LEN_32];     //备份磁盘描述
    BYTE            byWithPlayer;               //是否备份播放器
    BYTE            byContinue;                 //是否继续备份 0不继续 1继续
    BYTE            byDrawFrame;                 //0 不抽帧  1 抽帧
    BYTE            byUseBackCfgParam;          //使用备份配置中的参数，0-无效，1-启用(启用后，通道号无效)，2-不启用
    DWORD           dwStreamType;                //备份码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    BYTE            byRes[28];                     // 保留字节 
}NET_DVR_BACKUP_TIME_PARAM, *LPNET_DVR_BACKUP_TIME_PARAM;
/********************************* end *******************************************/

typedef enum _COMPRESSION_ABILITY_TYPE_
{
    COMPRESSION_STREAM_ABILITY = 0, //码流压缩类型
        MAIN_RESOLUTION_ABILITY = 1,    //主码流压缩分辨率
        SUB_RESOLUTION_ABILITY  = 2,    //子码流压缩分辨率
        EVENT_RESOLUTION_ABILITY =  3,  //事件压缩参数分辨率
        FRAME_ABILITY = 4,                //帧率能力
        BITRATE_TYPE_ABILITY = 5,        //位率类型能力
        BITRATE_ABILITY = 6,            //位率上限
        THIRD_RESOLUTION_ABILITY = 7,   //三码流压缩分辨率
        STREAM_TYPE_ABILITY = 8,        //码流类型
        PIC_QUALITY_ABILITY = 9,         //图像质量
        INTERVAL_BPFRAME_ABILITY = 10,  //BP帧间隔
        VIDEO_ENC_ABILITY = 11,           //视频编码能力
        AUDIO_ENC_ABILITY = 12,           //音频编码能力
        VIDEO_ENC_COMPLEXITY_ABILITY = 13, //视频编码复杂度能力
        FORMAT_ABILITY = 14, //封装格式能力
}COMPRESSION_ABILITY_TYPE;

//能力列表
typedef struct tagNET_DVR_ABILITY_LIST
{ 
    DWORD     dwAbilityType;    //能力类型 COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];        //保留字节
    DWORD     dwNodeNum;        //能力结点个数
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //描述参数  
}NET_DVR_ABILITY_LIST, *LPNET_DVR_ABILITY_LIST;

#define MAX_ABILITYTYPE_NUM  12   //最大能力项
// 压缩参数能力列表
typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{ 
    DWORD     dwSize;            //结构长度
    DWORD     dwAbilityNum;        //能力类型个数
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM]; //描述参数  
}NET_DVR_COMPRESSIONCFG_ABILITY, *LPNET_DVR_COMPRESSIONCFG_ABILITY;
/********************************9000RH begin****************************************/
#define SUPPORT_PD_NUM            16
#define SUPPORT_ARRAY_NUM        8
#define SUPPORT_VD_NUM            128
#define SUPPORT_PD_NUM_            16
#define SUPPORT_PD_NUM_PARTTWO    8

typedef enum tagRAID_MODE
{
    RAID0 = 1,
        RAID1,
        RAID10,
        RAID1E,
        RAID5,
        RAID6,
        RAID50,
        JBOD, 
        RAID60
}RAID_MODE;

typedef enum tagHD_SUPPORT_TYPE
{
    HD_TYPE_SATA    = 0x01,
        HD_TYPE_PATA    = 0x02,
        HD_TYPE_SAS     = 0x04,
        HD_TYPE_ATAPI   = 0x08,
        HD_TYPE_TAPE    = 0x10,
        HD_TYPE_SES     = 0x20
}HD_SUPPORT_TYPE;

// 按位表示 位为0表示不支持  1表示支持
typedef enum tagSUPPORT_RAID_TYPE
{
    RAID0_ABILITY   = 0x0001,
        RAID1_ABILITY   = 0x0002,
        RAID10_ABILITY  = 0x0004,
        RAID1E_ABILITY  = 0x0008,
        RAID5_ABILITY   = 0x0010,
        RAID6_ABILITY   = 0x0020,
        RAID50_ABILITY  = 0x0040,
        JBOD_ABILITY    = 0x0080,
        RAID60_ABILITY  = 0x0100
}SUPPORT_RAID_TYPE;

// 物理磁盘 
typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;         // 硬盘槽位 
    BYTE    byType;         // 硬盘信息；0 普通，1全局热备，2-阵列热备 3-阵列盘
    BYTE    byStatus;       // 硬盘状态；  0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 9-休眠0xff-不存在
    BYTE    byMode[40];   // 硬盘类型 字符串
    DWORD   dwHCapacity;    //  磁盘总量高32位 单位kb
    DWORD   dwLCapacity;    //  磁盘总量低32位
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;          // 所属阵列ID
    BYTE    byRes[102];         // 保留字节  
}NET_DVR_PHY_DISK_INFO, *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST, *LPNET_DVR_PHY_DISK_LIST;

typedef enum tagBGA_TYPE
{
    BGA_REBUILD = 0x01,            // 重建
        BGA_CONSISTENCY_FIX = 0x02,    // 一致性检查并修复
        BGA_CONSISTENCY_CHECK = 0x04,  // 一致性检查
        BGA_INIT_QUICK = 0x08,         // 初始化(快)
        BGA_INIT_BACK = 0x10,          // 初始化(完全)
        BGA_MIGRATION = 0x20,       // 迁移
        BGA_INIT_FORE = 0x40,           // 初始化
        BGA_COPYBACK = 0x80             // 回迁
}BGA_TYPE;

typedef enum tagBGA_STATE
{
    BGA_STATE_NONE = 0,     //  无后台任务
        BGA_STATE_RUNNING,       //  后台任务正在运行
        BGA_STATE_ABORTED,       //  后台任务取消
        BGA_STATE_PAUSED         //  后台任务暂停     
}BGA_STATE;
typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;  // 后台任务及类型 
    BYTE    byBgaState;           /*函数返回值--后台任务状态*/
    WORD    wBgaPercentage;     /*函数返回值--后台任务执行百分比*/
    BYTE    byRes[4];  // 保留字节
}NET_DVR_BGA_INFO, *LPNET_DVR_BGA_INFO;

// 阵列信息
typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID; // 阵列ID
    BYTE    byRaidMode; // raid模式  参照RAID_MODE
    BYTE    byStatus;  // 0-在线 1-磁盘丢失 2-下线 3-降级 4-异常 5-次正常 6-外来盘  7-已删除 8-SMART状态异常 0xff-不存在
    DWORD   dwHCapacity; // 阵列容量高32位
    DWORD   dwLCapacity; // 阵列容量低32位
    DWORD   dwHFreeSpace;   // 阵列剩余空间高32位
    DWORD   dwLFreeSpace;   // 阵列剩余空间高32位
    BYTE    byArrayName[MAX_NAMELEN]; // 阵列名称
    BYTE    byPDCount;  // 物理磁盘数目
    BYTE    bySpareCount;   // 热备数目
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];    // 物理磁盘索引
    WORD    wSparePDSlots[SUPPORT_PD_NUM];    // 热备磁盘索引
    NET_DVR_BGA_INFO    struBgaInfo;    // 后台任务运行状态
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //物理磁盘索引扩展，0表示无效
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];    // 热备磁盘索引扩展，0表示无效
    BYTE    byRes2[48]; // 保留字节
}NET_DVR_ARRAY_INFO, *LPNET_DVR_ARRAY_INFO;


typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;     // 结构体大小
    DWORD   dwCount;    // 阵列个数
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST, *LPNET_DVR_ARRAY_LIST;

//虚拟磁盘信息
typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;    //虚拟磁盘槽位  
    BYTE    byStatus; // 状态0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 0xff-不存在 
    BYTE    byRaidMode; // Raid 模式 参照 RAID_MODE
    WORD    wArrayID;      // 所属阵列ID
    BYTE    byRepair;   // 是否需要修复 0 不需要 1需要
    BYTE    byUsage;          //LUN卷的使用方式  0-IPSAN 1-FCSAN 2-DVR网盘 3-NAS 4-录像卷
    BYTE    byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];    // 虚拟磁盘名名称
    DWORD   dwHCapacity;    // 虚拟磁盘容量高32位
    DWORD   dwLCapacity;    // 虚拟磁盘容量低32位
    DWORD   dwHFreeSpace;   // 虚拟磁盘剩余空间高32位
    DWORD   dwLFreeSpace;   // 虚拟磁盘剩余空间低32位
    NET_DVR_BGA_INFO    struBgaInfo;    // 后台运行状态
    DWORD                dwBlockSize;    //最小存储单元块大小
    NET_DVR_IPADDR        struWarrantIP;    // 授权的DVR网盘IP
    char                szArrayGroup[NAME_LEN];     //使用的阵列名称组，以逗号隔开，为空则使用默认阵列
    BYTE                byRes[20];
}NET_DVR_VD_INFO, *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;     // 结构体大小
    DWORD   dwCount;    // 虚拟磁盘个数
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];  //虚拟磁盘数组
}NET_DVR_VD_LIST, *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION, *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD  wVDSlot;
    BYTE  byAlloc;  // 是否已经分配
    BYTE  byRes[5];
    DWORD dwHVDSlotSize;    // 虚拟磁盘空间大小高32位
    DWORD dwLVDSlotSize;    // 虚拟磁盘空间大小低32位
}NET_DVR_VD_SLOT, *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;                        /*current number of slots in DG*/ 
    BYTE    byRes1[3];              // 保留字节
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO, *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;    // 结构体大小
    NET_DVR_ADAPTER_VERSION struVersion;    // 适配器版本号
    BYTE    bySlotCount;    //适配器槽位数
    BYTE    bySupportMigrate;  // 迁移(1-支持  0-不支持)
    BYTE    bySupportExpand;   // 扩容  (1-支持  0-不支持)
    BYTE    bySupportRebuild;  // 是否支持重建阵列 (1、支持 0-不支持)
    WORD    wSlotSupportType; //  按位表示 HD_SUPPORT_TYPE
    WORD    wSupportRaidType;      // 支持Raid 类型 按位表示  
    BYTE    byAutoRebuild;      // 0 不自动重建 1自动重建 可设
    BYTE    byRes[27];      // 保留字节
}NET_DVR_RAID_ADAPTER_INFO, *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    //是否一键创建  如果为一键创建，则创建时时候的之需要array名称，而不需要其他参数
    // 其他参数有设备自行创建
    BYTE    byRaidMode;     // 创建/迁移时Raid的类型
    BYTE    byPDCount;  // 物理磁盘数目
    WORD    wArrayID;   // 迁移或者重建时需要指出阵列ID      
    WORD    wPDSlots[SUPPORT_PD_NUM];// 物理磁盘 
    BYTE    byName[MAX_NAMELEN];  // array 名称
    BYTE    byInitMode;              //初始化方式
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];       //物理磁盘信息
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM, *LPNET_DVR_OPERATE_ARRAY_PARAM;


#define INIT_QUICK                                      0    /*快速初始化*/
#define INIT_FULLFOREGROUND                             1    /*完全初始化(前台)*/
#define INIT_FULLBACKGROUND                             2    /*完全初始化(后台)*/

typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;        // 阵列ID
    BYTE    bySlot;            // 创建虚拟磁盘指定槽位
    BYTE    byInitType;     // 创建虚拟磁盘时初始化类型 0 - 快速初始化 1 - 前台完全初始化 2 - 后台完全初始化
    DWORD    dwHCapacity;    // 虚拟磁盘大小高32位
    DWORD    dwLCapacity;    // 虚拟磁盘大小低32位
    BYTE    byName[MAX_NAMELEN]; // 虚拟磁盘名称
    BYTE    byRes2[16];          // 保留字节 
}NET_DVR_OPERATE_VD_PARAM, *LPNET_DVR_OPERATE_VD_PARAM;


typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;        // 物理磁盘槽位
    WORD    wArrayID;       // 所属的阵列
    BYTE    bySpareType;    // 热备类型 1-全局热备  2 指定阵列  当为指定阵列的时候需要指出所属阵列的ID
    BYTE    byRes[7];       // 保留字节
}NET_DVR_SPARE_DISK_PARAM, *LPNET_DVR_SPARE_DISK_PARAM;

/********************************9000RH End****************************************/


#define MATRIX_MAXDECSUBSYSTEMCHAN    4//视频综合平台解码子系统通道号

//获取解码子系统关联信息
typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE    byJoinStatus;//关联状态，0-没有关联，1-已经关联
    BYTE    byJoinSubSystem;//所关联子系统槽位号
    BYTE    byJoinDispNum;//所关联显示通道号
    BYTE    byJoinSubWindowNum;//所关联子窗口号
    BYTE    byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS,LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE    bySubSystemType;//子系统类型，0-无，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统,5-码分子系统，6-报警子系统
    BYTE    byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE    byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE    bySubSystemNum;//级联子系统槽位号，0~79，子系统类型是3或4时可用    
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE    byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE    byRes[7];
}NET_DVR_SINGLESUBSYSTEMJOININFO,LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM];//80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

//2010-04-13 增加NAT功能相关配置
typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD                  dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2];//NAT IP地址 
    BYTE                byNATEnable;//是否启用NAT功能，0-不启用，非0-启用
    BYTE                  byRes[63];
}NET_DVR_NATASSOCIATECFG, *LPNET_DVR_NATASSOCIATECFG;

//2010-06-01 视频综合平台报警配置
typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE     byEnableTemperatureAlarm;//使能温度超限报警，0-报警，1-不报警
    BYTE     byRes1[3];
    int      iTemperatureUpLimited;    //精确到小数点后两位，如1234表示温度12.34度
    int      iTemperatureDownLimited;    
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE     byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG, *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm;//热插拔报警使能，1-报警，0-不报警
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG, *LPNET_DVR_BOARDALARMCFG;


typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD                          dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;    
    NET_DVR_BOARDALARMCFG          struBoardAlarmCfg;    
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM];//0-风扇异常，1-子系统异常，2-IP地址冲突，3-网线断，4-非法访问，5-光纤异常，6-前面板异常
    BYTE                         byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG,*LPNET_DVR_VIDEOPLATFORMALARMCFG;
//2010-05-17
typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD        dwSize;
    NET_DVR_IPADDR   struIP;  /*编码器IP地址*/
    WORD        wPort;        //编码器端口号
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名（32） */
    BYTE        sPassword[PASSWD_LEN];    /*密码 （16）*/
    BYTE        byChan;//编码器通道号
    BYTE        byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE, *LPNET_DVR_CODESPLITTERASSOCIATE;

//2010-06-01 视频综合平台报警上传结构
typedef struct tagNET_DVR_MATRIXSUBSYSTEMINFO
{
    BYTE   byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE   byRes [14];
} NET_DVR_MATRIXSUBSYSTEMINFO, *LPNET_DVR_MATRIXSUBSYSTEMINFO;

typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;      //结构体大小
    BYTE   byAlarmType;    // 0-拔出子板，1-插入子板,2-温度超上限报警，3-温度超下限报警，4-风扇状态异常，5-子系统异常,6-非法访问，7-光纤异常报警,8-前面板异常报警
    BYTE   byBoardNum;     //子板号，从1起，B10不支持该字段，无效，置为0xff
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8]; //子板槽位号,一个子板中有8个子系统，其分别对应的槽位号，子系统异常时，bySubSystemChan[0]表示对应子系统序号        
    int    iTemperature;  //温度超限报警时有用，温度值
    BYTE   byMainboardSeq;//温度超限报警时有用，0-非主板，1-主板
    BYTE   byRes2[3];
    BYTE   byFanSequence[32];//异常风扇，byFanSequence[i] = 1表示风扇i+1异常，byFanSequence[i] = 0表示风扇i+1正常    
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;// 光纤异常报警时使用，输入结点
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;//光纤异常报警时使用，输出结点
    BYTE   byRes3[68];    
}NET_DVR_VIDEOPLATFORM_ALRAMINFO,*LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

/***************************审讯DVR begin *****************************/
#define MAX_INQUEST_PIP_NUM        3     //单通道显示的画中画数目
#define MAX_INQUEST_CDRW_NUM    4     //最大刻录机数目
#define MAX_INQUEST_PIP_NUM_EX    16        //审讯机画中画最大个数

typedef struct 
{
    DWORD      dwSize;
    DWORD      dwNum;                       //刻录机的数量
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30];// 是否选中该光驱
    DWORD      dwModeSelect;                //0表示循环刻录模式  1表示并行刻录模式(默认模式)
    BYTE       byRes[24];                   //保留
    DWORD       dwStartCDRW;                 //DVR 本地已经开始刻录
    DWORD      dwHdExcp;                    //硬盘有异 常
    DWORD       dwInterval;                  //时间间隔，10分钟(0)、20分钟(1)、30分钟(2)
    char        sLable[64];                  //光盘名称
}NET_DVR_INQUEST_CDRW_CFG, *LPNET_DVR_INQUEST_CDRW_CFG;

typedef struct
{
    char      sFileName[36];             //文件名
    DWORD     dwFileLen;                 //文件长度
}NET_DVR_INQUEST_FILEINFO, *LPNET_DVR_INQUEST_FILEINFO;

typedef struct 
{
    DWORD     dwFileNum;                     // 需要刻录或者删除的文件数，最多一次20个
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //下面两个参数在表示刻录的文件时使用
    DWORD     dwCDIndex;                    //刻录机的索引：1:选择1号刻录机；2:选择2号刻录机； 3:3号刻录机,4:4号刻录机,5:所有刻录机
    DWORD      bFinalizeDisc;                 // 0=刻录完之后不封盘；1=刻录完之后封盘
}NET_DVR_INQUEST_FILES, *LPNET_DVR_INQUEST_FILES;

typedef struct 
{    
    DWORD     dwEnable;            //刻录机状态是否有效,0-无效,1-有效    
                                DWORD     dwStatus;            /* 当dwType=0时，
                                                            0-光盘正常，1-无光盘或光盘异常,
                                                            当dwType=1或2时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足，
                                                            4-异常导致审讯终止(81不支持)
                                                            当dwType=3时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=4时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=5时,
                                                            0-光盘正常， 1-无光盘或光盘异常,
                                                            2-光盘已封盘(81不支持)
                                                            当dwType=6或7时,
                                                            0-刻录正常, 1-无光盘或光盘异常,
                                2-光盘已封盘(81不支持), 3-光盘空间不足*/        
                                DWORD    dwVolumn;      //光盘容量,单位M
                                DWORD    dwFreeSpace;   //光盘剩余容量,单位M    
                                DWORD    dwTimeLeft;     // 光盘剩余时间，单位秒
                                BYTE          byCDType;         // 光盘类型
                                BYTE       byRes[3];      //保留字节
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct 
{    
/*运行状态：0-审讯开始，
1-审讯过程中刻录，2-审讯停止，
3-刻录审讯文件, 
4-备份(事后备份和本地备份)
5-空闲
6-初始化硬盘
    7-恢复审讯*/
    DWORD    dwType;            
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];   //数组0表示刻录机1    
    NET_DVR_TIME_EX            struInquestStartTime;        //审讯开始的时间点
    BYTE                    byRes[16];             //保留
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;

typedef struct
{
    BYTE     byPipChan;              //画中画显示的通道 0xFF关闭
    BYTE     byRes[3];              //保留字节
    WORD     wTopLeftX;              //画中画的x坐标
    WORD     wTopLeftY;              //画中画的Y坐标
}NET_DVR_INQUEST_PIP_PARAM, *LPNET_DVR_INQUEST_PIP_PARAM;

typedef struct 
{
    BYTE     byBaseChan;          //显示画中画所在的通道
    BYTE     byBackChan;          //显示画中画背景通道
                                  BYTE     byPIPMode;           /*是否开启, 
                                                                0 当前窗口无小画面
                                                                1 当前窗口有1个小画面
                                                                2 当前窗口有2个小画面
                                                                3 当前窗口有3个小画面
                                  */
                                  BYTE     byRes;               //保留字节
                                  NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];  //画面位置的参数    
}NET_DVR_INQUEST_PIP_STATUS, *LPNET_DVR_INQUEST_PIP_STATUS;

//V40扩展，将画中画个数扩展为32个
typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*画中画显示的通道 0xFF关闭*/ 
    BYTE     byRes1[3];
    WORD     wTopLeftX;         /*画中画的x坐标*/
    WORD     wTopLeftY;         /*画中画的Y坐标*/
    WORD     wHeight;            /*画中画的高 */
    WORD     wWidth;            /*画中画的宽 */
    BYTE     byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD    struStructHead;
    BYTE             byBaseChan;     /*显示画中画所在的通道*/
    BYTE             byBackChan;     /*显示画中画背景通道*/
                                    BYTE             byPIPMode;      /*是否开启, 0 当前窗口无小画面
                                                                    1 当前窗口有1个小画面
                                                                    2 当前窗口有2个小画面
                                                                    3 当前窗口有3个小画面
                                                                    4 当前窗口有4个小画面
                                                                    5 当前窗口有5个小画面
                                                                    6 当前画面有6个小画面
                                                                    7 当前窗口有7个小画面
                                                                    8 当前窗口有8个小画面
                                                                    9 当前窗口有9个小画面
                                    255  当前窗口关闭预览画面*/
                                    BYTE                         byPipCount;          /*小画面的个数*/
                                    BYTE                        byPicShowMode; /*画面显示模式，0-画中画，1-画面均分2-画面拼接*/
                                    BYTE                        byRes[31];        /*保留*/
                                    NET_DVR_INQUEST_PIP_PARAM_V40     strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*画面位置的参数*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct 
{
    BYTE    sSecretKey[16];        /*码流加密密钥*/
    BYTE    byRes[64];             /*保留字节*/
}NET_DVR_INQUEST_SECRET_INFO, *LPNET_DVR_INQUEST_SECRET_INFO;


/***************************审讯DVR end *****************************/


/********************************接口参数结构(end)*********************************/
#define        MAX_BIGSCREENNUM    100//最多大屏拼接数

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE    byScreenSeq;//屏幕序号，0xff表示不用此屏,64-T解码器第一个表示主屏
    BYTE    bySubSystemNum;//解码子系统槽位号,解码器此值没有用
    BYTE    byDispNum;//解码子系统上对应显示通道号，64-T解码器中该值表示解码器的显示通道号
    BYTE    byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE    byEnable;//大屏拼接使能，0-不使能，1-使能
    BYTE    byModeX;/*大屏拼接模式*/
    BYTE    byModeY;
    BYTE    byMainDecodeSystem;//综合平台的解码板中该值表示主屏槽位号，64-T解码器中该值表示解码通道号
    BYTE    byMainDecoderDispChan;//主屏所用显示通道号，1.1netra版本新增，netra解码器有两个显示通道，都能够作为主屏。64-T中该值无效
    BYTE    byVideoStandard;      //大屏每个子屏制式相同 1:NTSC,2:PAL
    BYTE    byRes1[2];
    DWORD  dwResolution;         //大屏每个子屏分辨率相同
    //大屏拼接从屏幕信息
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM]; 
    //起始坐标必须为基准坐标的整数倍
    WORD    wBigScreenX; //大屏在电视墙中起始X坐标
    WORD    wBigScreenY; //大屏在电视墙中起始Y坐标
    BYTE    byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;


#define    DECODEPIC_LEFTADJUST            1        /*图像左移*/
#define    DECODEPIC_RIGHTADJUST            2        /*图像右移*/
#define    DECODEPIC_UPADJUST                3        /*图像上移*/
#define    DECODEPIC_DOWNADJUST            4        /*图像下移*/
#define    DECODEPIC_REDUCEADJUST            5        /*图像缩小*/  
#define    DECODEPIC_FULL_SCREEN_ADJUST    6        /*图像全屏*/
#define    DECODEPIC_CANCEL_FULL_SCREEN_ADJUST    7        /*图像取消全屏显示*/   
#define DECODEPIC_AUTOADJUST           8        /*  图像自动调整 */
#define DECODEPIC_HEIGHTADJUST         9       /* 图像高度调整 */
#define DECODEPIC_WIDTHADJUST             10       /* 图像宽度调整 */

#define     MAX_UNITEDMATRIX_NUM        8//级联中最多视频综合平台数量
#define     MAX_SUBDOMAIN_NUM            4//级联中最多子域数量
typedef struct tagNET_DVR_SUBSERVERINFO
{
    BYTE        bySequence;//序号，对于子域，是子域号，对于视频综合平台，是平台号，0表示无此平台\子域
    BYTE        byBelongSubDomain;//对于平台有效，表示属于哪个子域
    BYTE        byRes1[6];
    DWORD       dwMaxIpcNums;//连接的最多IPC数量
    NET_DVR_IPADDR struSubMatrixIP;        /*IP地址*/
    WORD        wSubMatrixPort;        /*子系统端口号*/
    BYTE        byRes2[6];
}NET_DVR_SUBSERVERINFO, *LPNET_DVR_SUBSERVERINFO;

typedef struct tagNET_DVR_UNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBSERVERINFO struDomainInfo;
    NET_DVR_SUBSERVERINFO struSubDomainInfo[MAX_SUBDOMAIN_NUM];//子域信息
    NET_DVR_SUBSERVERINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];//视频综合平台信息
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXINFO, *LPNET_DVR_UNITEDMATRIXINFO;        

typedef struct tagNET_DVR_REGCALLBACKPARAM
{
    char sDeviceID[NAME_LEN];//设备ID串
    char sPassword[PASSWD_LEN];
    BYTE sSerialNumber[SERIALNO_LEN]; /* 设备序列号 */
    DWORD dwDeviceType;//设备类型
    BYTE nStatus;// 上下线状态（0下线，1上线）
    /* net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks */
    BYTE byNetType;    
    BYTE byRes[14];
}NET_DVR_REGCALLBACKPARAM, *LPNET_DVR_REGCALLBACKPARAM;

typedef struct tagNET_DVR_LOGONREPONSEPARAM
{
    //心跳时间间隔，单位：秒, 5的倍数，180秒以内。默认是15秒。
    WORD wHeartbeatTime;
    BYTE byOvertimes;// 设备心跳超时次数，默认是3次
    BYTE byRes[13];    
}NET_DVR_LOGONREPONSEPARAM, *LPNET_DVR_LOGONREPONSEPARAM;


typedef struct tagNET_DVR_PREVIEWPARAM
{
    BYTE byTransProtol;        //传输协议，0-TCP, 1-UDP
    BYTE byTransMode;        ///* 传输码流模式 0－主码流 1－子码流*/ 
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD wPort;/*CU端口*/
    WORD wUdpPort;
    BYTE bySupportQos;//是否启用QOS,1-启用，0-不启用
    //是否是NAT预览请求，0-否，1-是(只需byTransMode字段)
    BYTE  byNatRequest;
    BYTE  byPreviewType;// 0-普通预览 1-延时预览
    BYTE  byRes[7];
}NET_DVR_PREVIEWPARAM, *LPNET_DVR_PREVIEWPARAM;
typedef struct tagNET_DVR_DEVICENATINFO
{
    NET_DVR_IPADDR struPuIp; //PU端外网IP地址
    WORD    wOuterPort;/*PU外网端口*/
    WORD    wInterPort;//PU发送视频的本地端口
    DWORD   nSessionID;//CMS分配的sessionID
    BYTE    byRes[4];
}NET_DVR_DEVICENATINFO, *LPNET_DVR_DEVICENATINFO;


typedef struct tagNET_DVR_PREVIEWCALLBACKPARAM
{
    LONG lChannel;
    BYTE nLinkProtocol;
    BYTE nTransMode;
    BYTE byPreviewType; //0-普通预览 1-延时预览
    BYTE byRes[5];
    DWORD nSessionID;//CMS分配的sessionID
}NET_DVR_PREVIEWCALLBACKPARAM, *LPNET_DVR_PREVIEWCALLBACKPARAM;

//回放
typedef struct tagNET_DVR_PLAYBACKREQUESTPARAM
{
    BYTE byPlayBackMode;        /* 回放下载模式 1－按名字 2－按时间 */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* 回放的文件名 */
        struct 
        {
            LONG    lChannel;                /*回放的通道号*/
            NET_DVR_TIME struStartTime;            /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;            /* 按时间回放的结束时间 */
            BYTE    byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD    wPort;/*CU端口*/
    BYTE    byRes2[2];
    DWORD   dwSessionID;//CMS分配的sessionID,输出参数
    BYTE    byRes3[16];
}NET_DVR_PLAYBACKREQUESTPARAM, *LPNET_DVR_PLAYBACKREQUESTPARAM;    

//2010-10-06
typedef struct tagNET_DVR_PLAYBACKCALLBACKPARAM
{
    BYTE byPlayBackMode;        /* 回放下载模式 1－按名字 2－按时间 */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* 回放的文件名 */
        struct 
        {
            LONG        lChannel;                /*回放的通道号*/
            NET_DVR_TIME struStartTime;            /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;            /* 按时间回放的结束时间 */
            BYTE       byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    DWORD nSessionID;//CMS分配的sessionID
    BYTE byRes2[44];
}NET_DVR_PLAYBACKCALLBACKPARAM, *LPNET_DVR_PLAYBACKCALLBACKPARAM;  

typedef struct tagNET_DVR_VOICEREQUESETPARAM
{
    BYTE    nVoiceChannel;        //对讲通道号
    BYTE    byRes1[3];
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD     wPort;/*CU端口*/
    BYTE    byRes2[10];
}NET_DVR_VOICEREQUESTPARAM, *LPNET_DVR_VOICEREQUESTPARAM;             

typedef struct tagNET_DVR_ALARMSETUPREQUESETPARAM
{
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD     wPort;/*CU端口*/
    BYTE    byRes[2];
}NET_DVR_ALARMSETUPREQUESTPARAM, *LPNET_DVR_ALARMSETUPREQUESTPARAM;        

typedef struct tagNET_DVR_GPSALARMINFO
{
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    NET_DVR_TIME_EX struGpsTime;    /*GPS上传的时间*/
    DWORD    dwLongitude;    /* 经度*/
    DWORD    dwLatitude;  /* 纬度*/
    int     iTimeZone; /*时区，用分钟数表示，+60代表东1区，+480代表东8区，-60代表西区，-480代表西8区，该字段和GPSTime构成一个完整的时间描述*/ 
    DWORD dwDirection; /*车辆方向=实际方向（以度为单位，正北方向为，顺时针方向计算）*100*/
    WORD  wSatellites; /*卫星数量*/
    WORD  wPrecision; /*精度*/
    DWORD dwHeight; /*高度:厘米，预留*/
    DWORD dwGPSSeq; /*GPS序号，GPS补传时要用到*/
    WORD  wSpeed;//速度，单位，km/h
    /* direction[0]:'E'or'W'(东经/西经), direction[1]:'N'or'S'(北纬/南纬)*/
    char sDirection[2]; 
    BYTE byLocateMode;/*定位模式(初值0)，1,自主定位,2,差分3,估算,4,数据无效*/  
    BYTE byRes[3];
}NET_DVR_GPSALARMINFO, *LPNET_DVR_GPSALARMINFO;

//图片信息上传
typedef struct tagNET_DVR_PICINFO
{
    DWORD   dwSize;                //结构长度
    BYTE    byChanIndex;            //通道号
    BYTE    byRes1[3];                //保留
    BYTE     byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE    byAbsTime[32];        //绝对时间点, yyyymmddhhmmssxxx,
    DWORD   dwPicLen;                    //图片长度
    BYTE    byRes2[32];
    BYTE    *pPicBuffer;
}NET_DVR_PICTUREINFO, *LPNET_DVR_PICTUREINFO;

//平台参数
typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;//CMS用于UDP外网查询的端口
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;

///拨号功能
#define DIALPASSWD_LEN  32 //拨号密码长度

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;    /* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;    /* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;    /* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;


typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];        /* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];    /* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];    /* password, eg. "card" */
    BYTE byApn[NAME_LEN];        /* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;        /* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;    /* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];    
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

#define MAX_PHONE_NUM                32//最长号码长度

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;        /* 0: disable; 1: enable 3g */
    BYTE byDialMethod;        /* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;    /* switch methold: 0: auto switch;1：3G优先，2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* 使能报警输入触发拨号; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;        /* auto off line when no connection exist,单位：分钟，范围：5~65535分钟 */    
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;        /*网卡序号*/
    BYTE byNetType;        /* 指定获得某个网络的默认拨号参数，设置时此参数没用。0：自动；1：CDMA；2：EVDO；3：WCDMA；4：TD-SCDMA */
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;


/* UIM card information */
typedef enum
{
    UIM_UNKNOWN = 0,
        UIM_VALID = 1,
        UIM_NOVALID = 4,
        UIM_ROAM = 11,
        UIM_NOEXIST = 255
}UIM_INFO;

/* real 3g mode */
typedef enum
{
    /* evdo */
    RMODE_CDMA1X = 12,
        RMODE_EVDO = 14,
        RMODE_CDMAHYBRID = 18,
        /* wcdma */
        RMODE_GSM = 21,
        RMODE_GPRS = 22,
        RMODE_EDGE = 23,
        RMODE_WCDMA = 24,
        RMODE_HSDPA = 25,
        RMODE_HSUPA = 26,
        RMODE_HSPA = 27,
        /* tdscdma */
        RMODE_TGSM = 31,
        RMODE_TGPRS = 32,
        RMODE_TEDGE = 33,
        RMODE_TDSCDMA = 34,
        RMODE_TDHSDPA = 35,
        RMODE_TDHSUPA = 36,
        RMODE_TDHSPA = 37
}REAL_MODE;

typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;        /* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;        /* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;            /* signal RSSI */
    DWORD dwDialStatus;        /* dial status */
    NET_DVR_IPADDR struLocalIp;    /* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;    /* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;    /* wireless networks netmask */
    NET_DVR_IPADDR struDns;        /* wireless networks DNS */     
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

//短信功能
#define MAX_WHITELIST_NUM            8 //最大白名单数

#define HARDDISKFULL_EXCEPTION      0x0     /*硬盘满*/
#define HARDDISKERROR_EXCEPTION     0x1     /*硬盘错*/
#define ETHERNETBROKEN_EXCEPTION    0x2     /*网线断*/
#define IPADDRCONFLICT_EXCEPTION    0x3     /*IP地址冲突*/
#define ILLEGALACCESS_EXCEPTION     0x4     /*非法访问*/
#define VI_EXCEPTION                0x5     /*视频信号异常*/
#define VS_MISMATCH_EXCEPTION       0x6     /*输入/输出视频制式不匹配 */
#define VIDEOCABLELOSE_EXCEPTION    0x7     /*视频无信号*/
#define AUDIOCABLELOSE_EXCEPTION    0x8     /*音频无信号*/
#define ALARMIN_EXCEPTION           0x9     /*报警输入*/
#define MASKALARM_EXCEPTION         0xa     /*遮挡报警*/
#define MOTDET_EXCEPTION            0xb     /*移动侦测*/
#define RECORDING_EXCEPTION         0xc     /*录像异常*/
#define WIRELESS_EXCEPTION          0xd     /*PIR报警*/
#define PIR_EXCEPTION                0xe     /*无线报警*/
#define CALLHELP_EXCEPTION          0xf     /*呼救报警*/

#define AUDIO_DETECTION_EXCEPTION              0x10    /*音频异常侦测报警*/
#define SCENECHANGE_DETECTION_EXCEPTION        0x11    /*场景侦测报警*/
#define DEFOCUS_DETECTION_EXCEPTION            0x12    /*虚焦侦测报警*/
#define FACE_DETECTION_ENTRANCE_EXCEPTION      0x13    /*人脸侦测报警*/
#define LINE_DETECTION_ENTRANCE_EXCEPTION      0x14    /*越界侦测报警*/
#define FIELD_DETECTION_ENTRANCE_EXCEPTION     0x15    /*区域入侵侦测报警*/
#define REGION_EXITING_EXCEPTION               0x16    /*离开区域侦测报警*/
#define REGION_ENTRANCE_EXCEPTION              0x17    /*进入区域报警*/
#define LOITERING_EXCEPTION                    0x18    /*人员徘徊侦测报警*/
#define GROUP_EXCEPTION                        0x19    /*人员聚集侦测报警*/
#define RAPIDMOVE_EXCEPTION                    0x1a    /*快速移动侦测报警*/
#define PARKING_EXCEPTION                      0x1b    /*停车侦测报警*/
#define UNATTENDEDBAGGAGE_EXCEPTION            0x1c    /*物品遗留侦测报警*/
#define ATTENDEDBAGGAGE_EXCEPTION              0x1d    /*物品拿取侦测报警*/


#define PHONECFG_RECEIVE_SMS        0x0    /* 支持接收报警短信 */
#define PHONECFG_SMS_CONTROL        0x1    /* 支持短信控制上下线 */
#define PHONECFG_CALL_CONTROL       0x2    /* 支持呼叫控制上线 */
#define PHONECFG_SMS_REBOOT         0x3    /*支持短信重启*/
#define PHONECFG_DOOR_CONTROL       0x4    /* 支持门操作控制*/

typedef struct tagNET_DVR_PHONECFG
{
    BYTE byWhiteList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*按字节表示是否使能该号码的某功能，具体位代表的含义
    见PHONECFG_RECEIVE_SMS等定义 */
    BYTE byAlarmHandler[32];   /*按字节表示是否使能对某个报警类型的短信发送*/
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struWhiteList[MAX_WHITELIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;


typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;//短信条数
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;//所分配指针长度，输入参数
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;            /* the index of sms */
    BYTE byStatus;            /* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;        /* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

#define    MAX_SMSCONTENT_LEN        140//短信内容长度
typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;     

//pin码配置
typedef enum
{
    CPIN_READY = 1,
        CPIN_PIN = 2,
        CPIN_PUK = 3,
        CPIN_PIN2 = 4,
        CPIN_PUK2 = 5
}PIN_READY;

typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;        /* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;    /* remain input PIN times */
    BYTE byPukTimes;    /* remain input PUK times */    
    BYTE bEnableLock;    /* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;

typedef enum
{
    PIN_ENABLE = 1,
        PIN_DISABLE = 2,
        PIN_VERIFY = 3,
        PUK_VERIFY = 4,
        PIN_CHANGE = 5
}PIN_CMD;
#define MAX_PIN_LEN        12  //PIN码最大长度
typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;        /* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];        /* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];    /* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;


//图片质量
typedef struct 
{
    /* 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA*/
    WORD    wPicSize;
    WORD    wPicQuality; /* 图片质量系数 0-最好 1-较好 2-一般 */
    //抓图图片处理方式，1-上传中心，2-设备本地保存，3-上传中心同时设备本地保存
    BYTE    byPicTackleMode; 
    BYTE   byRes[11];
}NET_DVR_PUSHJPEGPARA, *LPNET_DVR_PUSHJPEGPARA;


#define    COM_PUSHALARM        0x1200    //设备基本报警信息上传，推模式设备使用
#define    COM_PUSHALARM_V30    0x1201    //设备基本报警信息上传v30，推模式设备使用
typedef struct tagNET_DVR_PUSHALARMINFO
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*触发的输出端口，哪一位为1表示对应哪一个输出*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘*/
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[4];
}NET_DVR_PUSHALARMINFO, *LPNET_DVR_PUSHALARMINFO;

typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 */
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*触发的输出端口，为1表示对应输出*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmType为2或3,6，9，10时，表示哪个通道，dwChannel[0]对应第1个通道*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘*/
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[7];
}NET_DVR_PUSHALARMINFO_V30, *LPNET_DVR_PUSHALARMINFO_V30;

//2011-04-20
//启动控制
typedef struct tagNET_DVR_MB_AUTOWORKPARA
{
    /*当前启动控制方式 0:  预留,  1:  延时关机,  2:  自动开关机*/
    BYTE    byCurPowerCtrlType;   
    BYTE    byRes[3];
    NET_DVR_SCHEDTIME    struWorkTime[MAX_DAYS][2];    
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD     dwHaltDelay; /* 关机延迟时间,单位min */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*启动控制相关参数设置*/
    BYTE       byEnableUnderVoltProtect;   /*是否开启欠压保护*/
    BYTE       byUnderVoltPercent;   /*欠压保护百分比，有85、90、95三个有效值*/
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;
/*注：1）、关机延迟时间, 可选时间为 0，5分钟，10分钟 ，20分钟 25分钟 30分钟 35分钟 40分钟 ，45 分钟 50分钟 ，60分钟 ，60*2分钟 ，60*3  60 *4   60*5  60*6 */

//自动备份
typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* 是否开启自动备份 0 关闭 ，1 开启 */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30];     /*需要备份的通道*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*备份天数*/
                                        /* 备份文件类型 
                                        {0,ALL_RECORD_TYPE,全部},
                                        {1,TIMING_REC,定时},
                                        {2,MOTION_DETECT_REC,移动侦测 },
                                        {3,ALARM_REC,报警 },
    {4,MANUAL_REC,手动录像}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];    /* 自动备份时间段*/                
    BYTE  byRes2[36];                        /* 保留字节*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;


typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;    /*是否启用GPS */
    BYTE  byGpsInterface;/*gps接收接口0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*速度单位，0：公里/小时，1 ：英里/小时*/
    BYTE  byEnableRetrieve; /* 盲区补发(1启用，0不启用) */
    int      iAdjustTime;/*时区*/
    BYTE  byEnableAdjustTime;/*是否启用GPS校时， 1-启用, 0-不启动*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;    /* GPS上传间隔, 秒*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD 显示，每字节代表一路 */
    DWORD dwSpeedLimit;    /* 限速报警*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm; 
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;
/*注：1）、当单位为公里/小时 时范围为（0 ,965）；当采用英里/小时做单位的时候 ，最大速度范围为：0-600*/

#define         SENSOR_IN_NUMBER          8
typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*行车状态相关触发的联动，只用后4个，分别代表刹车、左转、右转、倒车，0-高电平，1-低电平*/
    BYTE  byTriggerChannel [SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay [MAX_CHANNUM_V30];/*OSD显示,每位代表一路*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;


typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD    dwMaxXAcc;    /* X轴加速度报警值 ，该取值为实际数值乘以10,最小为0*/
    DWORD    dwMaxYAcc;    /* Y轴加速度报警值 ，该取值为实际数值乘以10.最小为0*/
    DWORD    dwMaxZAcc;    /* Z轴加速度报警值， 该取值为实际数值乘以10,最小为0*/
    BYTE    byRes[4];
}NET_DVR_ACCELERATIONCFG,*LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*模块选择：0内置/1外置*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];    /*保留扩展字节*/
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR    struDownloadSvrIp;        /* 自动下载服务器地址 */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA,*LPNET_DVR_MB_DOWNLOADSVRPARA;

/* 车牌识别的相关参数*/
typedef struct tagNET_DVR_PLATERECOG_PARA
{
    DWORD dwSize;
    BYTE byPrMode; /* 车牌识别的模式, 静态图像0/动态视频1 */
    BYTE byPrScene; /* 车牌识别的场景, 低速场景0/高速场景1 */
    BYTE byPrDetRect; /* 0:全屏幕;1:中心区域 */
    BYTE byPrPicQuality; /* 车牌识别返回的图片质量, 0:最低/3:最高 */    
    BYTE byPrPicMode;/*车牌识别返回的图片分辨率: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF */
    BYTE byPlateOsdDisplay; /* 车牌OSD是否显示 0:不显示/1:显示 */
    BYTE byPrProvCharIndex;    /* 车牌识别省份首汉字对应的索引 */
    BYTE byPrProvCharIndex1;    /* 车牌识别常见首汉字1对应的索引 */
    BYTE byPrProvCharIndex2;    /* 车牌识别常见首汉字2对应的索引 */
    BYTE byRes[7];
}NET_DVR_PLATERECOG_PARA, *LPNET_DVR_PLATERECOG_PARA;


/* 动态取证系统,限速设置参数的结构*/
typedef struct tagNET_DVR_SPEEDLMT_PARA
{
    BYTE    bStartMaxSpeedLimit;        /* 开启高速限制 */
    BYTE    bStartMinSpeedLimit;        /* 开启低速限制 */
    BYTE    byRes[6];
    DWORD    dwMaxSpeedLimit;                /* 最高限速 */
    DWORD    dwMinSpeedLimit;                /* 最低限速 */
}NET_DVR_SPEEDLMT_PARA, *LPNET_DVR_SPEEDLMT_PARA;

/* 动态取证系统,车牌比对参数的结构*/
typedef struct tagNET_DVR_PLATECHECK_PARA
{
    BYTE    bAlarmWhenChecked;            /* 稽查成功是否报警 */
    BYTE    bInformWhenChecked;            /* 稽查成功是否对话框提示 */
    BYTE    byRes[6];
    NET_DVR_IPADDR struBlackFtpServer;            /* 黑名单FTP服务器地址 */
}NET_DVR_PLATECHECK_PARA, *LPNET_DVR_PLATECHECK_PARA;

typedef struct tagNET_DVR_ENFORCESYS_PARA
{
    DWORD dwSize;
    NET_DVR_SPEEDLMT_PARA    struSpeedLmtPara;    /*限速设置*/
    NET_DVR_PLATECHECK_PARA struPlateCheckPara;    /*车牌比对*/
    BYTE    bySelPeccType;    /*是否选择违章类型*/
    BYTE    byEnfOptHabit; /*取证操作习惯, 0:长按取证;1:短按两次取证*/
                           /*预览帧率调节模式分三种：
                           A 关闭 adjPrevFpsMode=0
                           以固定高帧率(25FPS)预览
                           B 标准 adjPrevFpsMode=1
                           以固定低帧率(6FPS)预览
                           C 自适应 adjPrevFpsMode=2
                           根据GPS速度信息动态调整预览帧率，
    3秒无有效GPS的情况下，以固定高帧率预览*/
    BYTE    byAdjPrevFpsMode;        
    BYTE    byRes1;
    NET_DVR_IPADDR  struUploadServerIp; //上传服务器地址
    WORD    wUploadServerPort;
    BYTE    byRes2[18];
}NET_DVR_ENFORCESYS_PARA, *LPNET_DVR_ENFORCESYS_PARA;

typedef struct tagNET_DVR_PUSHMODEPARAM
{
    //直连模式下UDP预览模式，1-同端口多路流，2-一端口一路流
    BYTE byUdpPreviewMode; 
    //语音对讲工作模式，0-语音对讲，1-语音转发（SDK不进行语音的采集和播放）
    BYTE byVoiceWorkMode; 
    BYTE byRes[18];    
}NET_DVR_PUSHMODEPARAM, *LPNET_DVR_PUSHMODEPARAM;

#define MAX_ALARMHOST_ALARMIN_NUM            512//网络报警主机最大报警输入口数
#define MAX_ALARMHOST_ALARMOUT_NUM            512//网络报警主机最大报警输出口数

#define ALARMHOST_MAX_AUDIOOUT_NUM            32//网络报警主机最大语音输出数
#define ALARMHOST_MAX_ELECTROLOCK_NUM        32//网络报警主机最大电锁数
#define ALARMHOST_MAX_MOBILEGATE_NUM        32//网络报警主机最大移动门数
#define ALARMHOST_MAX_SIREN_NUM             8 // 最大警号数目
#define MAX_ALARMHOST_SUBSYSTEM             32//报警主机最大子系统数

//传感器类型
typedef enum tagSENSOR_TYPE
{
    SENSOR_TYPE_NONE = 0,                   // 无
        SENSOR_TYPE_TEMPERATURE = 1,            // 温度
        SENSOR_TYPE_HUMIDITY ,                  // 湿度
        SENSOR_TYPE_WINDSPEED,                  // 风速
        SENSOR_TYPE_GAS,                        // 气体
        SENSOR_AC_VOLTAGE,                      // 交流电压
        SENSOR_AC_CURRENT,                      // 交流电流
        SENSOR_DC_VOLTAGE,                      // 直流电压
        SENSOR_DC_CURRENT,                      // 直流电流
        SENSOR_WATER_PRESSURE,                  // 水压
        SENSOR_PRESSURE_TRANSMITTER,            // 压力变送器
        SENSOR_FLOW_TRANSMITTER,                // 流量变送器
        SENSOR_WATER_LEAKAGE,                   // 漏水传感器
        SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,//一体化温变
        SENSOR_ISOLATION_TEMPERATURE_DETECTOR,  //隔离式温变
        SENSOR_RESIDUAL_CHLORINE,               //在线余氯仪
        SENSOR_TYPE_AC_TERMINAL = 16,           //AC端子              
        SENSOR_TYPE_AC_SOCKET = 17,             //AC插座
        SENSOR_TYPE_UNKNOW = 255                // 未定义
}SENSOR_TYPE;

typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD  dwSize;                 // 结构体大小
    BYTE    byName[NAME_LEN];    // 传感器名称
    BYTE    byEnable;               // 是否启用 
    BYTE    byValid;                // 是否有效 传感器正常不正常(该参数只能获取不能个配置)
    BYTE    byType;                 // 模拟量类型 参照SENSOR_TYPE
    BYTE    byAlarmMode;//报警模式，五种，15-HHHH、14-HHHL、12-HHLL、8HLLL、0-LLLL，即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    float   fMeasureHigh;           // 量程上限
    float   fMeasureLow;            // 量程下限
    float    fAlarm1;           //报警限1,报警限1-4 依次增大
    float    fAlarm2;           //报警限2
    float    fAlarm3;           //报警限3
    float    fAlarm4;           //报警限4
    DWORD   dwOsdCfg;          //模拟量字符叠加，按位表示0-15对应视频通道1-16
    float    fSensitive;            // 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化大于0.1，需要上传。如果为1，则表示变化超过1时上报。
    BYTE    bySensorStandard;    //传感器规格，0- 0~20mA，1, 0~5V
    BYTE    byChan;            //模拟量通道号
    BYTE    byRes3[114];            // 保留字节
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;                    // 结构大小
    BYTE    byName[NAME_LEN];        // 名称
    WORD    wDelay;                    // 输出延迟 单位为秒, 范围 0~5599s 0表示一直有输出
    BYTE    byRes1[2];
    DWORD   dwOverallEventJointSirenOn;        //全局事件联动警号输出开启，事件类型按位表示，bit0-主机防拆, bit1-全局键盘紧急报警,bit2-交流电断电，bit3-电池电压低,bit4-电话线掉线,bit5-有线网络异常,bit6-无线网络异常,  bit7-键盘485断线
    DWORD    dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//子系统事件联动警号输出开启。数组下标表示子系统号，每一个元素按位表示事件类型，bit0-紧急报警
    BYTE    byRes2[448];  // 保留字节　　
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byEnable;    // 0--关机 1--开机
    BYTE    byMode;        // 空调模式
    BYTE    byTemperature;    // 温度，具体值表示 通常为16-30度
    BYTE    byRes[9];        // 保留字节
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;

typedef enum tagDETECTOR_TYPE
{
    PANIC_BUTTON = 0,               // 紧急开关
        MAGNETIC_CONTACT,               // 门磁开关
        SMOKE_DETECTOR,                 // 烟感探测器
        ACTIVE_INFRARED_DETECTOR,       // 主动红外探测器
        PASSIVE_INFRARED_DETECTOR,      // 被动红外探测器
        GLASS_BREAK_DETECTOR,           // 玻璃破碎探测器
        VIBRATION_DETECTOR,             // 震动探测器
        DUAL_TECHNOLOGY_PIR_DETECTOR,   // 双鉴移动探测器
        TRIPLE_TECHNOLOGY_PIR_DETECTOR, // 三技术探测器
        HUMIDITY_DETECTOR,              // 湿度探测器
        TEMPERATURE_DETECTOR,           // 温感探测器
        COMBUSTIBLE_GAS_DETECTOR,        // 可燃气体探测器
        DYNAMIC_SWITCH,                    //随动开关
        CONTROL_SWITCH,                    //控制开关
        SMART_LOCK,                        //智能锁
        OTHER_DETECTOR = 0xffff          // 其他探测器   
}DETECTOR_TYPE;

typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区 0xff-无
    BYTE    byUploadAlarmRecoveryReport;    //是否上传防区报警恢复报告，0-不上传，1-上传        
    DWORD    dwParam;    // 防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*布防时间时间段*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // 报警输入关联报警输出
    BYTE    byAssociateSirenOut[8];        //  警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    BYTE    bySensitivityParam;//防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
    BYTE    byArrayBypass;//是否加入旁路组,0-不支持组旁路,1-支持组旁路
    BYTE    byJointSubSystem; //防区所属的子系统号，该参数只能获取  
    BYTE    byModuleStatus;    //模块状态 1-在线 2-离线
    WORD    wModuleAddress;    //模块地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byModuleChan;    //模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    BYTE    byModuleType;    //模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器
    WORD    wZoneIndex;        //防区号，该参数只能获取      
    WORD    wInDelay;    //进入延时，0-255秒
    WORD    wOutDelay;    //退出延时，0-255秒
    BYTE    byAlarmType;     //报警器类型 0-无效，1-常开，2-常闭
    BYTE    byZoneResistor;    //防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
    float    fZoneResistorManual;/*防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效*/
    BYTE    byRes2[32];      // 保留字节
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             // 结构体大小
    BYTE    byName[NAME_LEN];   // 名称
    WORD    wDelay;             // 输出延迟 单位s, 范围：0~3599s 0 表示一直有输出
    WORD    wTriggerIndex;        //触发器号，该参数只能获取
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //表示警号跟随的报警输入通道 （多个报警输入同时触发一个警号输出）数组下标0表示报警输入1，依次类推 0-不跟随 1-跟随
    BYTE    byModuleType;    //外接触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器 4-单防区触发器，5-32路触发器
    BYTE    byModuleStatus;    //外接触发器状态 1-在线 2-离线
    WORD    wModuleAddress;    //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byModuleChan;    //外接触发器通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    BYTE    byWorkMode;        //工作模式，1-联动，2-随动
    BYTE    byAlarmOutMode;    //输出模式，1-非脉冲模式，2-脉冲模式
    BYTE    byTimeOn;        //开时间 1~60s
    BYTE    byTimeOff;        //关时间 1~60s
    BYTE       byRes2[51];             //保留字节
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//报警输入通道 数组下标0对应报警输入口1，依次类推
    BYTE byRes[100];//保留字节
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize; 
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口布防状态，(最大支持512个报警输入口查询)，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口报警状态，(最大支持512个报警输入口查询)，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//报警输出口状态，(最大支持512个报警输出口查询)，0-对应报警输出口无报警，1-对应报警输出口有报警
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // 旁路状态 数组下标表示0对应报警输入口1 0-表示报警输入口没有旁路 1-表示报警输入口旁路
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口故障状态，0-对应报警输入口处于正常状态，1-对应报警输入口处于故障状态
    BYTE   byRes[56];      //  保留字节
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize; 
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//防区布防状态，(最大支持512个防区查询)，0-对应防区处于撤防状态，1-对应防区处于布防状态
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//防区报警状态，(最大支持512个防区查询)，0-对应防区当前无报警，1-对应防区当前有报警
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//触发器状态，(最大支持512个触发器查询)，0-对应触发器无报警，1-对应触发器有报警
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // 旁路状态 数组下标表示0对应防区1 0-表示防区没有旁路 1-表示防区旁路
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//防区故障状态，0-对应防区处于正常状态，1-对应防区处于故障状态
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM];//防区报警记忆状态， 0-对应防区当前无报警，1-对应防区当前有报警，0xffffff
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; // 防区防拆状态，0-对应防区无报警，1-对应防区有报警
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM];/* 0-无效，1-外出布防，2-即时布防，3-留守布防*/
    BYTE   byRes[448];      //  保留字节
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    // 警号输出状态 0-警号处于无报警状态，1-警号处于有报警状态
    BYTE   byRes[92];             // 保留字节
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

//使能状态配置
typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//语音输出使能，0-禁能，1-使能
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//电锁使能，0-禁能，1-使能
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//移动门使能，0-禁能，1-使能
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//警号使能， 0-禁能，1-使能
    BYTE  bySerialPurpose;//串口用途，0-用于级联报警主机，1-用于PTZ控制
    BYTE  byRes[63];    
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;                      // 结构体大小
    WORD    wTotalAlarmInNum;         // 报警输入口总数(防区),包括级联
    WORD    wLocalAlarmInNum;         // 本地报警输入口
    WORD    wExpandAlarmInNum;        // 可扩展的报警输入口
    WORD    wTotalAlarmOutNum;        // 报警输出口总数 （设备支持的总数）
    WORD    wLocalAlarmOutNum;        // 本地报警输出口个数
    WORD    wExpandAlarmOutNum;       // 可扩展的报警输出口
    WORD    wTotalRs485Num;           // 报警输出口总数 （设备支持的总数）
    WORD    wLocalRs485Num;           // 本地485口数
    WORD    wExpandRs485Num;          // 可扩展的485口数
    WORD    wFullDuplexRs485Num;    // 全双工的485口数
    WORD    wTotalSensorNum;          // 模拟量最大个数 (设备支持的总数)
    WORD    wLocalSensorNum;        // 本地模拟量个数
    WORD    wExpandSensorNum;         // 可扩展的模拟量个数
    WORD    wAudioOutNum;                //语音输出个数
    WORD    wGatewayNum;            //门禁个数
    WORD    wElectroLockNum;            //电锁个数
    WORD    wSirenNum;                 // 主机警号数目
    WORD    wSubSystemNum;            // 可划分子系统数目
    WORD    wNetUserNum;            // 网络用户数
    WORD    wKeyboardNum;           // 键盘数
    WORD    wOperatorUserNum;           // 操作用户数
    BYTE    bySupportDetector;//是否支持常开、常闭探测器，1-支持，0-不支持
    BYTE    bySupportSensitivity;//是否支持防区灵敏度，1-支持，0-不支持
    BYTE    bySupportArrayBypass;//是否支持组旁路，1-支持，0-不支持
    BYTE    bySupportAlarmInDelay;//是否支持防区延迟,1-支持，0-不支持
    //如果bySupportAlarmInDelay为1时，表示客户端应该使用NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间，动环报警主机和自助行报警主机使用这种配置延时方式;
    //如果bySupportAlarmInDelay为0时，表示通过NET_DVR_ALARMSUBSYSTEMPARAM 中的wEnterDelay 、wExitDelay 来设置
    BYTE    bySupportAlarmInType[16];//支持的防区类型,数组0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区 15-无
    BYTE    byTelNum;        //支持电话个数
    BYTE    byCenterGroupNum;    //中心组个数
    BYTE    byGPRSNum;        //GPRS中心数，最多4个
    BYTE    byNetNum;        //网络中心数，最多4个
    BYTE    byAudioNum;        //音频个数
    BYTE    by3GNum;        //3G模块个数
    BYTE    byAnalogVideoChanNum;        //模拟视频通道个数
    BYTE    byDigitalVideoChanNum;        //数字视频通道个数
    BYTE    bySubSystemArmType;        //子系统布防类型，0-表示不支持，1-表示支持。bit0-普通布防（注：网络小主机只支持普通布防，在能力集中加这个字段的时候网络小主机已经发布，所以网络小主机中该字段为0，所以用0表示支持，1表示不支持。对外接口中SDK内部会做兼容），bit1-即时布防，bit2-留守布防。    
    BYTE    byPublicSubSystemNum;    //公共子系统个数
    DWORD    dwSupport1;    //按位表示，结果非0表示支持，0表示不支持
    // bit0:     是否支持子系统内配置警号输出时间，如果支持则警号输出时间在每个子系统内配置，如果不支持，警号时间在警号参数配置里面设置
    // bit1:    是否支持事件触发报警输出开启
    // bit2:    是否支持事件触发报警输出关闭
    // bit3:    是否支持子系统使能
    // bit4;    是否支持防区布防
    // bit5;    是否支持子系统自动布撤防
    // bit6:    是否支持具体故障关联声音输出
    // bit7:    是否支持故障状态查询
    // bit8:    是否支持子系统扩展配置
    // bit9:    是否支持钥匙防区操作子系统
    // bit10:   是否支持"键盘提示成功发送报告"配置
    // bit11:   是否支持导入导出参数配置
    // bit12:   是否支持LED屏幕参数配置
    // bit13: 是否支持故障关联本地故障灯输出
    DWORD    dwSubSystemEvent;        //子系统事件，按位表示，0表示不支持，非0表示支持,bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆
    DWORD    dwOverallEvent;            //全局事件，按位表示，0表示不支持，非0表示支持，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常
    DWORD    dwFaultType;            //设备支持的故障类型，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-主键盘掉线，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常    
    BYTE    byPublicSubsystemAssociateSubsystemNum;    //公共子系统可关联的子系统个数
    BYTE    byOverallKeyboard;    //全局键盘个数
    WORD    wSafetyCabinSupport; //防护舱控制器能力，按位表示，结果非0表示支持，0表示不支持    
    //bit0: 是否支持防护舱控制器工作模式配置
    //bit1: 是否支持人信号传感器类型配置
    //bit2: 是否支持幕帘传感器参数配置（探测延迟时间、人状态变化响应时间）
    //bit3: 是否支持红外对射传感器参数配置（滤波）
    //bit4: 是否支持防护舱使用超时时间配置
    BYTE    by485SlotNum;        //485虚拟槽位号
    BYTE    bySubSystemAttributeAbility;  // 值恒为1，禁止1号子系统关闭使能
    WORD    wKeyboardAddrNum;      // 键盘地址数
    BYTE    byRes[118];            //  保留字节
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

#define MAX_485CHAN                256    //485通道号
#define MAX_485SLOT                256    //485槽位号
typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-不是全部获取，1-全部获取
    BYTE        byres[3];
    BYTE        byIndex[MAX_485SLOT];            //485槽位号
    BYTE           byRes[64];      //保留
}NET_DVR_485_SLOT_LIST_INFO,* LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-不是全部获取，1-全部获取
    BYTE        byres[3];
    BYTE        byIndex[MAX_485CHAN];            //485通道号 下标表示通道号，值0-表示不使用，1表示使用
    BYTE       byRes[64];      //保留
}NET_DVR_485LIST_INFO,*LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    sDeviceName[NAME_LEN];  // 前端设备名称 
    WORD    wDeviceType;            // 前端设备类型,通过NET_DVR_GetDeviceTypeList获取
    WORD    wDeviceProtocol;        // 前端设备协议 通过获取协议列表获取    
    DWORD   dwBaudRate;             //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k 
    BYTE    byDataBit;              // 数据有几位：0-5位，1-6位，2-7位，3-8位 
    BYTE    byStopBit;              // 停止位：0-1位，1-2位 
    BYTE    byParity;               //是否校验：0-无校验，1-奇校验，2-偶校验 
    BYTE    byFlowcontrol;           // 是否流控：0-无，1-软流控,2-硬流控 
    BYTE    byDuplex;                // 0 - 半双工1- 全双工  只有通道1可以是全双工其他都只能是半双工
    BYTE    byWorkMode;                // 工作模式 0-控制台 1-透明通道,2-梯控，3-读卡器,0xfe-自定义，0xff-禁用
    BYTE    byChannel;                //485通道号
    BYTE    bySerialType;            //串口类型: 0--485, 1--232
    BYTE    byMode;                 //模式 0-连接读卡器 1-连接客户端 2-连接扩展模块
    BYTE    byRes[35];              // 保留字节
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

#define MAX_DEVICE_PROTO_NUM       256
#define MAX_DEVICE_TYPE_NUM            256

// 485前端设备支持协议列表
typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             // 结构体大小
    DWORD   dwProtoNum;         // 协议个数
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  // 协议类型
    BYTE    byRes[12];          // 保留字节
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD    dwType;
    BYTE    byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD    dwSize;                // 结构体大小
    DWORD    dwTypeNum;            // 类型个数
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE    byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

#define    MAX_ALARMHOST_VIDEO_CHAN    64
typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                 // 结构体大小
    BYTE   sUserName[NAME_LEN];    // 用户名
    BYTE   sPassword[PASSWD_LEN];    // 密码
    NET_DVR_IPADDR    struUserIP;                    /* 用户IP地址(为0时表示允许任何地址) */
    BYTE   byMACAddr[MACADDR_LEN];            /* 物理地址 */
    BYTE   byUserType; // 0-普通用户 1-管理员用户
    BYTE   byAlarmOnRight;         // 布防权限
    BYTE   byAlarmOffRight;        // 撤防权限
    BYTE   byBypassRight;          // 旁路权限
    BYTE   byOtherRight[MAX_RIGHT];  // 其他权限
    // 0 -- 日志权限
    // 1 -- 重启关机
    // 2 -- 参数设置权限
    // 3 --    参数获取权限
    // 4 -- 恢复默认参数权限
    // 5 -- 警号输出权限
    // 6 -- PTZ 控制权限
    // 7 -- 远程升级权限
    // 8 -- 远程预览
    // 9 -- 远程手动录像
    // 10 -- 远程回放
    BYTE    byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // 远程可以预览的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // 远程可以录像的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN/8]; // 远程可以回放的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN/8];        // 远程可以PTZ的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    //BYTE    byPriority;                                        // 优先级，0xff-无，0--低，1--中，2--高
    //无（表示不支持优先级的设置）
    //低（默认权限：包括远程回放，远程查看日志和状态，远程关机/重启）
    //中（包括远程控制云台，远程手动录像，远程回放，语音对讲和远程预览，本地备份，本地/远程关机/重启）
    //高（管理员）
    BYTE    byRes2[168];              // 保留字节
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;

typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD     dwSize;     // 结构体大小
    DWORD    dwID;        // 键盘用户ID
    BYTE    byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //防区权限  按数组下标表示 最大支持512个防区 0 - 无权限 1- 有权限
    BYTE    byRes[560];        // 保留字节
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;

typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD     dwSize;        // 结构体大小
    BYTE    sUserName[NAME_LEN];    // 用户名
    BYTE    sPassword[PASSWD_LEN];  // 密码
                                    BYTE   bySubSystemPermission;/*0-安装员权限 操作员权限（所有子系统）如下： 1-单布防，无布防报告，不能旁路 2-单撤防，无撤防报告，不能旁路 3-布撤防，无布撤防报告，不能旁路 
                                                                 4-单布防，有布//防报告，不能旁路 5-单撤防，有撤防报告，不能旁路 6-布撤防，有布撤防报告，不能旁路  7-单布防，无布撤防报告，允许旁路 
                                                                 8-单撤防，无布撤防报告，允许旁路 9-布撤防，无布撤防报告，允许旁路 10-单布防，有布防报告，允许旁路 11-单撤防，有撤防报告，允许旁路 1
                                    2-布撤防，有布撤防报告，允许旁路*/
                                    BYTE    byRes[63];             //  保留字节
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byName[NAME_LEN];    //  门禁名称    
    BYTE    byEnable;    // 是否启用
    BYTE    byLocalEnable;  //  本地是否启用
    WORD    wDelayTime;    // 开启延时时间    单位为秒0-65535 0为一直开启
    BYTE    byLockWorkMode;//电锁工作模式，0-通电启动，1-断电启动
    BYTE    byRes[31];    // 保留字节
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD   dwSize;                // 结构体大小
    DWORD   dwAbsTime;            // 绝对时标信息  OSD显示信息
    BYTE    byName[NAME_LEN];     // sensor 名称
    BYTE    bySensorChannel;    // 模拟量通道
    BYTE    byType;             // 模拟量类型
    BYTE    byAlarmType;        // 1-上4、2-上3、3-上2、4-上1、5-下1、6-下2、7-下3、8-下4 和当前模式有关
    // 例如当为1000时,有上1下1，2，3报警四种报警
    BYTE    byAlarmMode;        //报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL， 作为平台报警程度判断功能,即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下) 
    float    fValue;                // 但前模拟量的值
    BYTE    byRes2[32];            // 保留字节
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;

typedef struct 
{
    /*预留，目前报警主机的报警没有类型(布防网络序，监听主机序)*/
    DWORD  dwAlarmType;             
    /*数组0对应第1个输入端口*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE    byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO,*LPNET_DVR_ALARMHOST_ALARMINFO;
// 开关量报警上传
typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN];     // switch 名称
    WORD  wSwitchChannel;     // 开关量通道, 0-255
    BYTE    byAlarmType;        // 报警类型 0--正常，1--短路，2--断路,3-异常 
    BYTE     byRes[41];            // 保留字节
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;

typedef union tagNET_DVR_ALARMHOST_EXCEPTION_PARAM
{
    DWORD   dwUnionSize[20];        // 联合体大小    
}NET_DVR_ALARMHOST_EXCEPTION_PARAM, *LPNET_DVR_ALARMHOST_EXCEPTION_PARAM;

typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // 结构体大小
    // 异常参数  1-设备防拆报警 2-设备防拆后后恢复正常 3-主电源掉电报警 4-主电源掉电后恢复正常 5-内部通信故障报警 
    // 6-内部通信故障后恢复正常  7-电话线断线 8-电话线断线恢复 9-自检失败报警  10-自检失败后恢复正常    
    // 11蓄电池欠压  12蓄电池电压恢复正常，13-蓄电池故障；14-MBUS模块掉线；15-MBUS模块掉线恢复；16-键盘掉线；
    //17-键盘掉线恢复；18-设备被移动；19-设备被移动复位  20-485外设线路断报警  21-485外设线路断后恢复正常
    //25-子板1插上,26-子板1拔出, 27-子板2插上,28-子板2拔出
    DWORD   dwExceptionType;    
    BYTE   byRes[36];          // 保留
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

//自助行拨号参数配置及启用方式配置
#define MAX_CENTERNUM            4        //G1,G2 G3 G4或者N1，N2，N3，N4或者T1，T2，T3，T4
typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //中心号码  
    BYTE byRepeatCall;          //重复拨号次数，1~15次
    BYTE byPstnProtocol;        //通信协议，0-CID；
    BYTE byDialDelay;           //拨号延时，最大150s, 0-150
    BYTE byPstnTransMode;       //传输方式，0-DTMF 5/S，1-DTMF 10/S；
    BYTE byRes1[6];
    BYTE byReceiverId[6];         //接收机识别账号；
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//主中心参数
    WORD wReportPeriod;      //测试报告上传周期，小时，（最大值支持7天，即168小时), 范围；1-168
    WORD wFirstReportTime;     //从设备启动到第一条测试报告上传，1~3600分钟
    BYTE  byReportValid;    //0-不启用测试报告上传 1-启用测试报告上传
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//启用方式，0：不启用，1：一直启用，2:网线断启用，正常时关闭；
    BYTE byCallType; //上传中心方式，1-单中心，2-双中心，3，一报一备
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

#define  MAX_PU_CHAN_NUM    512

typedef struct tagNET_DVR_PU_CHAN_INFO
{
    NET_DVR_IPADDR  struIpAddr;     // ip地址
    WORD            wPort;          // 端口
    WORD            wChannel;       // 通道     
    BYTE            byRes[24];      // 
}NET_DVR_PU_CHAN_INFO, *LPNET_DVR_PU_CHAN_INFO;

typedef struct tagNET_DVR_PU_CHAN_LIST
{
    DWORD   dwSize;     // 结构体
    DWORD   dwNum;      // 前端通道个数
    NET_DVR_PU_CHAN_INFO struPuChanInfo[MAX_PU_CHAN_NUM];
}NET_DVR_PU_CHAN_LIST, *LPNET_DVR_PU_CHAN_LIST;

#define  MAX_ALARM_CAM_NUM    32        // 报警触发CAM最大个数

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   // 是否启用PTZ控制
    BYTE    byType;     // PTZ 控制的类型 1- 预置点 2 -巡航  3-轨迹
    BYTE    byPtzNo;    //  ptz 控制的预置点 巡航 轨迹号
    BYTE    byRes[5];    // 保留字节
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD            dwCamID;      // 触发的CAM通道操作
    DWORD           dwRecordTime;   // 触发录像时间 单位为s  -1表示一直录像 0 表示不录像
    DWORD           dwMonID;      // 触发Cam到Mon号显示
    DWORD           dwResidentTime; // 轮巡停留时间单位为s  -1表示一直停留 0 表示不停留
    NET_DVR_PTZ_CTRL struPtzCtrl;    // PTZ控制信息
    BYTE            byAlarmOffMode;        // 报警切换上墙取消模式   0-立即取消，1-自动取消，2-手动取消 立即取消，报警取消时立即取消解码上墙   自动取消，报警取消时等待一定时间后取消解码上墙，我们约定是20秒  手动取消，用户通过手动的方式取消
    BYTE            byDevType;        // 当设备为智能设备时，生效表示智能报警设备取流源 1-解码卡     2-编码卡
    BYTE            byDecChan;        // 当为解码通道为解码通道号
    BYTE            byRes[17];      // 保留字节
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD        dwSize;            // 结构体大小
    BYTE        byEnable;       // 是否启用报警触发CAM联动 设备默认不启用
    BYTE        byRes[7];       // 保留字节
    DWORD        dwNum;            // 触发CAM联动的个数 即取数组的前几个有效处理  
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

#define MAX_GATEWAY_NUM         8  // 最大门禁个数
typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD         dwSize;
    BYTE        byEnterDoor[8];    // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE        byExitDoor[8];     // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE         byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  //关联报警输入，下标表示报警输入号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE         byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

//数据上传下载（语音上传下载的扩展）
typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byUploadType;    /*上传方式，1-根据文件名绝对地址读取数据文件上传， 2-从缓冲区读取数据上传*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：上传语音，则该参数表示语音号，增加一条语音号（超时提示音）
    BYTE        byAudioType;        //语音格式，0-wave
    char        sFileName[260];        //数据文件的全路径
    char        *lpBuffer;            //数据缓冲区
    DWORD        dwBufferSize;        //缓冲区大小
    BYTE        byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_ALARMHOST_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：下载语音，则该参数表示语音号，增加一条语音号（超时提示音）
    BYTE        byRes1;
    char        sFileName[260];        //数据文件的全路径
    DATADOWNLOAD lpDataCallBack; //下载时的回调函数句柄
    void*        pUserData;    //用户数据，将在回调函数中传回
    BYTE        byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;


typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：下载语音，则该参数表示语音号，增加一条语音号（超时提示音）
    BYTE        byRes1;
    char        sFileName[260];        //数据文件的全路径
    DATADOWNLOAD lpDataCallBack; //下载时的回调函数句柄
    void*        pUserData;    //用户数据，将在回调函数中传回
    BYTE        byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;

//LED屏幕参数
typedef  struct tagNET_DVR_LED_SCREEN_CFG
{
    DWORD         dwSize;
    BYTE        sLEDName[NAME_LEN/*32*/];    // LED屏幕名称
    BYTE        byTransMode;                 // 现只支持串口通讯 1-串口通信
    BYTE        byProtocolType;                // 协议类型，对应LED屏的厂家
    BYTE        byLEDColor;                 // 1-单色， 2-双色， 3-256级灰度双基色， 4- 全彩色（目前只用单色）
    BYTE        byDataPolarity;                // 数据极性 .0-负极，1-正极
    BYTE        byOEPolarity;                // 0-低有效 1-高有效
    BYTE        byScanMode;                 // 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-静态
    BYTE        byRes1[2];
    //屏幕宽度和高度最小是16*16点，间隔是8个点    
    WORD        wLEDWidth;                     // 16~2048
    WORD         wLEDHeight;                    // 16~2048
    BYTE        byRes2[64];
}NET_DVR_LED_SCREEN_CFG, *LPNET_DVR_LED_SCREEN_CFG;

//LED屏显内容
#define  MAX_CONTENT_LEN  512
typedef  struct tagNET_DVR_LED_CONTENT_CFG
{
    DWORD         dwSize;
    BYTE        sLEDContent[MAX_CONTENT_LEN];    // LED屏幕显示内容
    BYTE        byContentAct;                    // 1-静态，2-快速打出，3-向左移动，4-向右移动， 5-向上移动， 6-向下移动
    BYTE        byContentSpeed;                    // 1-24（1最快，24最慢）    
    BYTE        byContentStayTime;                 // 0-127.5s(精度0.5s， SDK传送时候*2，即传送数值0-255，设备端在使用的时候需除以2)
    BYTE        byRes[33];
}NET_DVR_LED_CONTENT_CFG, *LPNET_DVR_LED_CONTENT_CFG;

//LED定时开关机
#define     LED_TIMER_NUM             3            // LED开机、关机时间组数
#define        TIME_SEGMENT_A_DAY        48            // 时间段个数，一天24小时，半小时一个段

typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE    byValid;                // 该组定时时间是否有效，时间是成对设置的
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTimeOn;     // 开机时间
    NET_DVR_TIME_EX struTimeOff;     // 关机时间
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;


typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD        dwSize;
    NET_DVR_SWITCH_TIME struTimer[LED_TIMER_NUM /*3*/];         //定时开关机时间，结构体中只有小时和分钟两个参数有效，每组开机时间要早于该组的关机时间，但比前一组的关机时间要晚，例如：struTimer[0]的关机时间是10：00那么，struTimer[0]的开机时间须设置为10:00之前， struTimer[1]的开机时间须设置为10：:00以后。
    BYTE        byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

//分时亮度调节
typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD         dwSize;
    BYTE        byValid;        //分时亮度调节是否有效
    BYTE        byRes1[3];
    BYTE         byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/];     //将全天24个小时分为48个时段，每30分钟一个时段，用48个字节表示每个时段的亮度级别，亮度共16级，用0~15表示。
    BYTE        byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD    dwSize;
    BYTE    bySwitchState;        //1-开机状态 2-关机状态
    BYTE    byBrightness;        //亮度值，范围0-15
    BYTE    byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;

//2010-12-28 高清解码卡能力集 begin
//新的解码卡服务器能力集
#define        MAX_DECODE_CARD_NUM            6   //最多高清解码卡数
/********************高清解码卡输出模式宏定义********************/
typedef enum _HD_DISPLAY_FORMAT
{
    HD_DISPLAY_FORMAT_INVALID = 0x00000000,
        HD_DISPLAY_FORMAT_CVBS = 0x00000001,
        HD_DISPLAY_FORMAT_DVI = 0x00000002,
        HD_DISPLAY_FORMAT_VGA = 0x00000004, 
        HD_DISPLAY_FORMAT_HDMI = 0x00000008, 
        HD_DISPLAY_FORMAT_YPbPr = 0x00000010
}HD_DISPLAY_FORMAT,*LPHD_DISPLAY_FORMAT;

/********************高清解码卡输出模式宏定义********************/
typedef struct tagNET_DVR_DECCARD_ABILITY      /*高清解码卡能力集*/
{
    BYTE byCardType;      //解码卡类型(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //解码通道数
    BYTE byDispNums;      //显示通道数
    BYTE byDecStartIdx;     //首个解码通道在所有解码通道中的索引
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byDispResolution[80]; //输出模式支持的分辨率
    BYTE byDispFormat[8];     //支持的输出模式(按HD_DISPLAY_FORMAT)
    BYTE byWindowMode[4][8]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes[35];
} NET_DVR_DECCARD_ABILITY,*LPNET_DVR_DECCARD_ABILITY;

typedef struct tagNET_DVR_DECODESVR_ABILITY
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 解码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY, *LPNET_DVR_DECODESVR_ABILITY;

typedef struct tagNET_MATRIX_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP地址
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byUsedSlotNum;            //是否使用槽位号，0-不使用，1-使用
    BYTE    bySlotNum;//槽位号
    BYTE    byRes[68];
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_MATRIX_DEV_CHAN_INFO,*LPNET_MATRIX_DEV_CHAN_INFO;

typedef struct tagNET_MATRIX_PU_STREAM_CFG
{
    DWORD                            dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_MATRIX_DEV_CHAN_INFO        struDevChanInfo;
} NET_MATRIX_PU_STREAM_CFG,LPNET_MATRIX_PU_STREAM_CFG;

/*camera配置单元结构*/
typedef struct tagNET_DVR_MATRIX_CAMERACFG
{
    DWORD                    dwGlobalIndex;//全局编号
    DWORD                    dwInterIndex;//局部编号
    BYTE                    sCamName[NAME_LEN];
    NET_MATRIX_PU_STREAM_CFG struPuStreamCfg;
} NET_DVR_MATRIX_CAMERACFG,*LPNET_DVR_MATRIX_CAMERACFG;

typedef struct tagNET_DVR_MATRIX_CAMERALIST
{
    DWORD            dwSize;
    BYTE            byRes[12];
    DWORD            dwCamNum;//CAM数量
    BYTE              *pBuffer;
    DWORD             dwBufLen;//所分配指针长度，输入参数
} NET_DVR_MATRIX_CAMERALIST,*LPNET_DVR_MATRIX_CAMERALIST;

typedef struct tagNET_DVR_DISP_CHAN_INFO
{
    NET_DVR_IPADDR    struIP;                /* 解码器 IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byDispChannel;            /* 显示通道号 */
    BYTE    byUsedSlotNum;            //是否使用槽位号，0-使用，1-不使用
    BYTE    bySlotNum;//槽位号
    BYTE    byRes[7];
    BYTE    sUserName[NAME_LEN];    /*登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];    /*密码 */
}NET_DVR_DISP_CHAN_INFO,*LPNET_DVR_DISP_CHAN_INFO;

/*monitor配置单元结构*/
typedef struct tagNET_DVR_MATRIX_MONITORCFG
{
    DWORD                        dwGlobalIndex;//全局编号
    DWORD                        dwInterIndex;
    BYTE                        sMonName[NAME_LEN];
    NET_DVR_DISP_CHAN_INFO        struDispChanCfg;
} NET_DVR_MATRIX_MONITORCFG,*LPNET_DVR_MATRIX_MONITORCFG;
typedef struct tagNET_DVR_MATRIX_MONITORLIST
{
    DWORD        dwSize;
    BYTE        byRes[12];
    DWORD        dwMonNum;//MON数量
    BYTE          *pBuffer;
    DWORD         dwBufLen;//所分配指针长度，输入参数
} NET_DVR_MATRIX_MONITORLIST,*LPNET_DVR_MATRIX_MONITORLIST;

#define     MAX_SUBMATRIX_NUM        8//级联中子最多从系统数量
typedef struct tagNET_DVR_SUBMATRIXINFO
{
    BYTE        byMainMatrix;//是否是主系统，1-是，0-否
    BYTE        bySubMatrixSequence;//级联子视频综合平台系统序号
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        byRes1[9];
    NET_DVR_IPADDR  struSubMatrixIP;        /*IP地址（可修改）*/
    WORD        wSubMatrixPort;        /*子系统端口号（可修改）*/
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubMatrixIPMask;    /*IP地址掩码*/
    NET_DVR_IPADDR    struGatewayIpAddr;         /* 网关地址 */    
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码 （此参数只能获取）*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
    BYTE        byRes3[16];
}NET_DVR_SUBMATRIXINFO, *LPNET_DVR_SUBMATRIXINFO;

typedef struct tagNET_DVR_ALLUNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBMATRIXINFO struSubMatrixInfo[MAX_SUBMATRIX_NUM];
    BYTE  byRes2[32];
}NET_DVR_ALLUNITEDMATRIXINFO, *LPNET_DVR_ALLUNITEDMATRIXINFO;

#define    MAX_GATEWAYTRUNKNUM        1024 //级联视频综合平台中最大路由干线数

typedef struct tagNET_DVR_MATRIXGATEWAYNOTE
{
    WORD    wTrunkInToOutAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
    WORD    wTrunkOutToInAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1，双向光纤时用到此值
    BYTE    byRes[4];
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;
}NET_DVR_MATRIXGATEWAYNOTE, *LPNET_DVR_MATRIXGATEWAYNOTE;

typedef struct tagNET_DVR_MATRIXGATEWAYINFO
{
    DWORD dwSize;
    NET_DVR_MATRIXGATEWAYNOTE struGatewayNote[MAX_GATEWAYTRUNKNUM];
    BYTE  byRes [32];
}NET_DVR_MATRIXGATEWAYINFO, *LPNET_DVR_MATRIXGATEWAYINFO;

typedef struct tagNET_DVR_MATRIXCODESYSTEMINFO
{
    BYTE   byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE    byChan;//编码通道
    BYTE   byRes [13];
}NET_DVR_MATRIXCODESYSTEMINFO,*LPNET_DVR_MATRIXCODESYSTEMINFO;
typedef struct tagNET_DVR_MATRIXDECODESYSTEMINFO
{
    BYTE    byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE    byDispChan;//显示通道
    BYTE    bySubDispChan;//显示通道子通道号
    BYTE    byRes [12];
}NET_DVR_MATRIXDECODESYSTEMINFO,*LPNET_DVR_MATRIXDECODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXSWITCH
{
    NET_DVR_MATRIXCODESYSTEMINFO struInputNote;
    NET_DVR_MATRIXDECODESYSTEMINFO struOutputNote;
    BYTE    byRes[32];
}NET_DVR_MATRIXSWITCH, *LPNET_DVR_MATRIXSWITCH;

typedef enum {
    ENC_CARD = 0,
        DEC_CARD,
        SD_DEC_CARD,
        FPGA_CARD,
        CS_CARD,
        ALERTOR_CARD,
        NAT_0,
        NAT_1,
        VCA_CARD,
        VGA_DEC_CARD,
        VGA_ENC_CARD,
        ERR_CARD,
} DEV_TYPE;

typedef struct tagNET_DVR_MATRIXSWITCHCTRL
{
    DWORD dwCamId;//摄像机全局编号
    DWORD dwMonId;//监视器全局编号
    BYTE  bySubWindowNum;//监视器对应子窗口号
    BYTE   bySwitchType;/*切换类型，0:正常切换，1:报警触发切换，2:报警取消，0xff:表示此MON上所有报警全部取消*/
    WORD   wAlarmType;//报警设备类型，1:报警主机，2：智能设备
    DWORD  dwResidentTime;/* 显示驻留时间，0xFFFFFFFF 时 为常驻情况，保持显示*/
    BYTE   byVcaDevType;//当报警设备类型是"智能设备"时，按DEV_TYPE类型
    BYTE   byRes[19];
}NET_DVR_MATRIXSWITCHCTRL, *LPNET_DVR_MATRIXSWITCHCTRL;

typedef struct tagNET_DVR_MATRIXDATABASE
{
    //配置文件类型，1-域数据库配置文件，2-子域数据库配置文件，3-平台数据库配置文件，4-场景配置文件，0xff最后一次失败的数据库语句
    DWORD dwDevType; 
    DWORD dwParam; //参数，代表域号、子域号、平台号，场景配置文件时此值无用
    BYTE  byFileType;//文件类型，1-sql语句，2-db语句，3-场景配置文件
    BYTE  byRes [3];
} NET_DVR_MATRIXDATABASE, *LPNET_DVR_MATRIXDATABASE;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
/*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，
    9-V6子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板，14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，0-NULL（此参数只能获取）*/
    BYTE        bySubSystemType;
    //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    BYTE        byChan;
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        bySlotNum ;//槽位号，此参数只能获取
    BYTE        byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP地址（可修改）*/
    NET_DVR_IPADDR   struSubSystemIPMask;//子网掩码
    NET_DVR_IPADDR     struGatewayIpAddr;    /* 网关地址 */
    WORD        wSubSystemPort;        //子系统端口号（可修改）
    BYTE        byRes2[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码(可修改)*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
    BYTE        byBelongBoard;//所属子板号，从1开始，0xff表示无效
    BYTE        byInterfaceType;//接口类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，0xff-无效
    BYTE        byInterfaceNums;//接口个数，0xff表示无效
    BYTE        byInterfaceStartNum;//接口起始号，0xff表示无效
    BYTE        byDeviceName[20];//子系统名称
    BYTE        byAudioChanNums; //音频通道个数
    BYTE        byAudioChanStartNum; //音频通道起始号
    BYTE        byAudioChanType;//音频通道类型，0-无效，1-音频输入，2-音频输出
    BYTE        byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

#define  MAX_SUBSYSTEM_NUM_V40  120
typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V40
{
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）*/
    BYTE   bySubSystemType; 
    BYTE   byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE   byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE   bySubSystemNum;//级联子系统槽位号，0~79，子系统类型是3或4时可用
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE   byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE   bySlotNum ;//槽位号，此参数只能获取
    //子系统类型为1的时可用，0-未关联，1-D1，2-720，3-1080
    BYTE   byDecodeAbility; 
    BYTE   byUsedTrunk;
    BYTE   byRes[64];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V40,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V40
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V40 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V40, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

#define  MAX_OPTICALFIBER_NUM  16
typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
/*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，
    10-转码子系统，11-X86服务器子系统，板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，0-NULL（此参数0-NULL（此参数只能获取）*/
    BYTE  bySubSystemType;
    BYTE  byChanNum;//子系统通道数
    BYTE  byStartChan;//子系统起始通道数
    BYTE  bySlotNum ;//槽位号 
    BYTE  byRes1[4];
    union
    {
        BYTE byRes[200];        
        struct
        {
            BYTE byDecode;        //是否是带解码功能的智能板,1-是，0-否
            BYTE byNeedPreAllocDec; //是否需要预分配解码资源，1-是，0-否
            BYTE byVACType;  //智能子系统类型，0-普通型，1-增强型
            BYTE byRes[197];
        }struVACSystemAbility;
        struct
        {
            BYTE  byVGANums;//VGA显示通道个数（从1开始）
            BYTE  byBNCNums;//BNC显示通道个数（从9开始）
            BYTE  byHDMINums;//HDMI显示通道个数（从25开始）
            BYTE  byDVINums;//DVI显示通道个数（从29开始）
            BYTE  byLayerNums ;//大屏拼接中，做主屏时所支持图层数
            BYTE  bySpartan;//畅显功能，0-不支持，1-支持
            BYTE  byDecType; //解码子系统类型，0-普通型,1-增强型(普通型分屏时前4窗口需使用自身资源，增强型无此限制，增强型最多可被其他子系统借16路D1解码资源
            //增强型被大屏关联为子屏后资源可被借用，普通型则不能被借用)
            //2-智能关联解码子系统，3-转码关联解码子系统（智能和转码关联子系统不能用于解码上墙）
            BYTE  byOutputSwitch;//是否支持HDMI/DVI互相切换，0-不支持，1-支持
            BYTE  bySDINums;//SDI显示通道个数（从33开始）
            BYTE  byRes1[38];               
            BYTE  byDecoderType ; //解码板是否支持多厂家码流解码，0-不支持，1-支持
            BYTE  byRes2[152];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byCoderType;//编码器类型，0-标清，1-高清, 2-模拟高清
            BYTE  byOptical;//光端机接入，0-否，1-是
            BYTE  byOpticalSubChan; //每个光口信道数            
            BYTE  bySupportAVSeparate;//是否支持音视频分离，0-不支持，1-支持
            BYTE  byRes[196];
        }struCoderSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
            BYTE    byOpticalFiberNum;//光纤条数
            BYTE    byRes[197];
        }struInputSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
            BYTE    byOpticalFiberNum;//光纤条数
            BYTE    byRes[197];
        }struOutputSystemAbility;
        struct
        {
            BYTE    by485Num;//码分子系统中485数量
            BYTE    bySlotNum;//每个485槽位数
            BYTE    byRes[198];
        }struCodeSpitterSystemAbility;
        struct
        {
            WORD    wAlarmInNums;
            WORD    wAlarmOutNums;
            /* 标识报警盒是否连接， 1表示已连接， 为0 表示未连接 */
            BYTE  byAlarmBoxEnable[4][8];
            BYTE  bySupportContact; /* 视频综合平台内部报警联动，0-不支持,1-支持 */
            BYTE  byRes[163];
        }struAlarmHostSystemAbility;
        struct
        {
            BYTE  byOpticalFiberNum;//光纤条数
            BYTE  byRes1[3];
            //光纤带宽，按D1的标准衡量，如4表示支持4个D1
            WORD    wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
            BYTE  byRes2[164];
        }struInOutputSystemAbility;
        struct
        {
            BYTE  bySupportRingProtocol;   //是否支持环网协议
            BYTE  bySupportRingNums; //支持环网数量
            BYTE  bySupportPortNums;  //支持的端口数量
            BYTE  byRes[1]; 
            DWORD dwPortSupportRingProto; //每个端口是否支持环网协议，按位算，1～32位分别表示1～32端口，0-不支持，1-表示支持 
            BYTE  byRes2[192];
        } struFiberSwitchSystemAbility;    
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;//编码子系统数量
    BYTE    byDecodeSubSystemNums;//解码子系统数量
    BYTE    bySupportNat;//是否支持NAT，0-不支持，1-支持
    BYTE    byInputSubSystemNums;//级联输入子系统数量
    BYTE    byOutputSubSystemNums;//级联输出子系统数量
    BYTE    byCodeSpitterSubSystemNums;//码分子系统数量
    BYTE    byAlarmHostSubSystemNums;//报警子系统数量
    BYTE    bySupportBigScreenNum;//所支持最多组成大屏的个数
    BYTE    byVCASubSystemNums;//智能子系统数量
    BYTE    byV6SubSystemNums;//V6子系统数量
    BYTE    byV6DecoderSubSystemNums;//V6解码子系统数量
    BYTE    bySupportBigScreenX;/*大屏拼接的模式：m×n*/
    BYTE    bySupportBigScreenY;
    BYTE    bySupportSceneNums;//支持场景模式的个数
    BYTE    byVcaSupportChanMode;//智能支持的通道使用模式，0-使用解码通道，1-使用显示通道及子通道号
    BYTE    bySupportScreenNums;//所支持的大屏的屏幕最大个数
    BYTE    bySupportLayerNums;//所支持的图层数，0xff-无效
    BYTE    byNotSupportPreview;//是否支持预览,1-不支持，0-支持
    BYTE    byNotSupportStorage;//是否支持存储,1-不支持，0-支持
    BYTE    byUploadLogoMode;//上传logo模式，0-上传给解码通道，1-上传给显示通道
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE    by485Nums;//485串口个数
    BYTE    by232Nums;//232串口个数
    BYTE    bySerieStartChan;//起始通道
    BYTE    byScreenMode;//大屏模式，0-主屏由客户端分配，1-主屏由设备端分配
    BYTE    byDevVersion;//设备版本，0-B10/B11/B12，1-B20
    BYTE    bySupportBaseMapNums;//所支持的底图数，底图号从1开始
    WORD    wBaseLengthX;//每个屏大小的基准值，B20使用
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;  //是否支持图片回显，0-不支持，1-支持    
    BYTE    bySupportPreAllocDec;   //是否支持智能解码资源预分配，0-不支持，1-支持
    BYTE    bySupportDecAutoManage; //是否支持解码资源管理
    BYTE    byTranDevSubSystemNums; //转码子系统数量
    BYTE    byFiberSwitchNums;  //网络光纤子系统数量
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums;//编码子系统数量
    BYTE  byDecodeSubSystemNums;//解码子系统数量
    BYTE  bySupportNat;//是否支持NAT，0-不支持，1-支持
    BYTE  byInputSubSystemNums;//级联输入子系统数量
    BYTE  byOutputSubSystemNums;//级联输出子系统数量
    BYTE  byCodeSpitterSubSystemNums;//码分子系统数量
    BYTE  byAlarmHostSubSystemNums;//报警子系统数量
    BYTE  bySupportBigScreenNum;//所支持最多大屏拼接数量
    BYTE  byVCASubSystemNums;//智能子系统数量
    BYTE  byRes1[11];   
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  by485Nums;//485串口个数
    BYTE  by232Nums;//485串口个数
    BYTE  bySerieStartChan;//起始通道
    BYTE  byRes2[637];    
}NET_DVR_VIDEOPLATFORM_ABILITY, *LPNET_DVR_VIDEOPLATFORM_ABILITY;
//获取能力集接口

//模式A 
typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;    // 开始月 从1开始
    BYTE    byStartDay;        // 开始日 从1开始
    BYTE    byEndMonth;        // 结束月 
    BYTE    byEndDay;        // 结束日
    BYTE    byRes[4];        // 保留字节
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE    byStartMonth;    // 从1开始
    BYTE    byStartWeekNum;    // 第几个星期 从1开始 
    BYTE    byStartWeekday;    // 星期几
    BYTE    byEndMonth;        // 从1开始
    BYTE    byEndWeekNum;    // 第几个星期 从1开始 
    BYTE    byEndWeekday;    // 星期几    
    BYTE    byRes[2];        // 保留字节 
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD    wStartYear;        // 年
    BYTE    byStartMon;        // 月
    BYTE    byStartDay;        // 日
    WORD    wEndYear;        // 年
    BYTE    byEndMon;        // 月
    BYTE    byEndDay;        // 日
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;

typedef union tagNET_DVR_HOLIDATE_UNION
{    
    // 联合体大小 12字节
    DWORD                    dwSize[3];
    NET_DVR_HOLIDATE_MODEA    struModeA;    // 模式A
    NET_DVR_HOLIDATE_MODEB    struModeB;    // 模式B
    NET_DVR_HOLIDATE_MODEC    struModeC;    // 模式C
}NET_DVR_HOLIDATE_UNION, *LPNET_DVR_HOLIDATE_UNION;

typedef enum tagHOLI_DATE_MODE
{
    HOLIDATE_MODEA = 0,
        HOLIDATE_MODEB,
        HOLIDATE_MODEC
}HOLI_DATE_MODE;

typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE    byEnable;            // 是否启用
    BYTE    byDateMode;            // 日期模式 0-模式A 1-模式B 2-模式C
    BYTE    byRes1[2];            // 保留字节
    NET_DVR_HOLIDATE_UNION uHolidate;    // 假日日期
    BYTE    byName[NAME_LEN];    // 假日名称
    BYTE    byRes2[20];            // 保留字节
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

#define  MAX_HOLIDAY_NUM    32

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD    dwSize;            // 结构体大小
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];    // 假日参数
    DWORD    byRes[40];        // 保留参数
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

// 假日报警处理方式
typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD    dwSize;                // 结构体大小
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];    // 布防时间段
    BYTE    byRes2[240];        // 保留字节
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;                // 结构体大小
    DWORD    dwChannel;            //通道号
    DWORD    dwSMDHandleType;    //简易智能假日布防类型 0-音频异常侦测，1-虚焦侦测，2-场景变更侦测
    BYTE     byRes2[32];        // 保留字节
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD           dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // 录像参数
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // 录像时间段
    BYTE      byRes[20];      //  保留字节
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

#define  MAX_LINK_V30  128

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // 客户端IP
    LONG            lChannel;   // 通道号
    BYTE            byRes[32];  // 保留字节
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      // 结构体大小
    WORD    wLinkNum;    // 连接的数目
    BYTE    byRes1[2];  // 保留字节
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   // 连接的客户端信息
    BYTE    byRes[32];  // 保留字节
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

#define MAX_BOND_NUM  2

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;                // 工作模式0 - 网络容错 1 - 负载均衡
    BYTE    byUseDhcp;            // 是否使能dhcp
    BYTE    byMasterCard;        //  指定哪张网卡为主网卡        
    BYTE    byStatus;           // BONDING的状态  0 - 异常 1-正常 只能获取不能设置
    BYTE    byBond[MAX_NETWORK_CARD];// byBond[0]== 1 表示使用eh0  0表示不使用eh0
    NET_DVR_ETHERNET_V30    struEtherNet;        // 网卡参数
    NET_DVR_IPADDR    struGatewayIpAddr;  // 网关地址
    BYTE    byRes[20];            // 保留字节
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         // 结构体大小
    BYTE    byEnable;       // 是否启用bonding功能
    BYTE    byNum;          // Bonding网卡的个数
    BYTE    byRes1[2];         //  保留字节
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE    byRes2[40];        // 保留字节
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;


// 磁盘配额
typedef struct tagNET_DVR_DISK_QUOTA 
{
    BYTE    byQuotaType;     // 磁盘配额类型,1 - 按容量 2-按比例，3-按时间
    BYTE    byRes1[5];       // 保留字节
    WORD    wStoragePeriod;  //录像存储周期，单位天，配额类型为按时间时有效
    DWORD   dwHCapacity;     // 分配的磁盘容量高32位 单位MB
    DWORD   dwLCapacity;     // 分配的磁盘容量低32位 单位MB
    DWORD   dwHUsedSpace;    // 已使用的磁盘大小高32位 单位MB
    DWORD   dwLUsedSpace;    // 已使用的磁盘大小低32位 单位MB
    BYTE    byQuotaRatio;    //    分配的磁盘比例,单位:%
    BYTE    byRes2[21];      // 保留字节
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         // 结构体大小
    NET_DVR_DISK_QUOTA    struPicQuota;       //  图片配额
    NET_DVR_DISK_QUOTA    struRecordQuota;    //  录像配额
    NET_DVR_DISK_QUOTA    struAddInfoQuota;   //  附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
    BYTE    byRes[12];      //保留字节
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;


typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // 定时抓图图片质量
    DWORD      dwPicInterval;  // 定时抓图时间间隔,单位s   1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    BYTE       byRes[12];      // 保留字节
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    // 按位表示
    BYTE    byRes[20];          // 保留字节
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

#define MAX_PIC_EVENT_NUM      32
#define MAX_ALARMIN_CAPTURE   16

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //最大可触发的关联通道数-只读属性
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //触发的关联抓图通道号，按值表示，采用紧凑型排列,0xffffffff表示后续无效
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   // 事件抓图图片质量
    DWORD   dwPicInterval;   // 事件抓图时间间隔  单位为秒 
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   // 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    DWORD   dwMaxGroupNum;  //设备支持的最大报警输入组数，每组16个报警输入
    BYTE      byCapTimes; //抓图张数
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;


typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // 事件抓图图片质量
    DWORD       dwPicInterval;  // 事件抓图时间间隔  单位为秒  1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    /*
    数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图，2 视频丢失触发抓图,数组3表示PIR报警抓图，
    数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图,数组7 表示人脸侦测抓图，
    数组8 表示-越界侦测侦测抓图，数组9 表示区域入侵侦测抓图,数组10表示场景变更侦测抓图, 
    数组11-进入区域侦测,数组12-离开区域侦测,数组13-徘徊侦测,数组14-人员聚集侦测,数组15-快速运动侦测,
    数组16-停车侦测,数组17-物品遗留侦测,数组18-物品拿取侦测。
    */
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM]; 
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    BYTE       byCapTimes; //抓图张数
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD                             dwSize;               //结构体长度
    NET_DVR_TIMING_CAPTURE        struTimingCapture;    
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;//抓图码流类型 0-主码流，1-子码流
    BYTE       byRes3[19];     // 保留字节
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         // 结构体大小
    NET_DVR_TIMING_CAPTURE struTimingCapture;    
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;//抓图码流类型 0-主码流，1-子码流
    BYTE       byRes3[19];     // 保留字节
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;  

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE    byAllDayCapture;    // 是否全天抓图
    BYTE    byCaptureType;        // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图
    BYTE    byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;        // 抓图时间段
    BYTE        byCaptureType;       // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图
    BYTE        byRes[3];           // 保留字节
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

// 通道抓图计划
typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     // 结构体
    BYTE    byEnable;    // 是否抓图
    BYTE    byRes1[3];    // 保留字节
    NET_DVR_CAPTURE_DAY    struCaptureDay[MAX_DAYS];    // 全天抓图计划
    NET_DVR_CAPTURE_SCHED    struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    // 时间段抓图布防计划
    NET_DVR_CAPTURE_DAY    struCaptureHoliday;            // 假日抓图计划
    NET_DVR_CAPTURE_SCHED    struHolidaySched[MAX_TIMESEGMENT_V30];    // 时间段假日抓图布防计划
    DWORD    dwRecorderDuration;    // 抓图保存最长时间 0xffffffff表示该值无效 
    BYTE    byRes[40];            // 保留字节
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;


typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;              //结构大小
    LONG   lCardIndex;         //网卡索引
    DWORD  dwInterval;         //设备上传流量时间间隔, 单位:100ms
    BYTE   byRes[8];           //保留字节
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //结构大小
    DWORD  dwSendFlowSize;     //发送流量大小,单位kbps
    DWORD  dwRecvFlowSize;     //接收流量大小,单位kbps
    BYTE   byRes[20];          //保留 
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

//  录像标签
#define LABEL_NAME_LEN 40
typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;                    // 结构体大小
    NET_DVR_TIME  struTimeLabel;            // 标签的时间 
    BYTE    byQuickAdd;                // 是否快速添加 快速添加时标签名称无效
    BYTE    byRes1[3];                // 保留字节
    BYTE    sLabelName[LABEL_NAME_LEN];    // 标签的名称 长度为40字节  
    BYTE    byRes2[40];                // 保留字节
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

#define  LABEL_IDENTIFY_LEN     64
typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64字节标识
    BYTE    byRes[8];               // 保留字节
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

#define MAX_DEL_LABEL_IDENTIFY  20// 删除的最大标签标识个数

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       // 结构体大小
    BYTE    byMode;   // 按位表示,0x01表示按标识删除
    BYTE    byRes1;
    WORD    wLabelNum;      // 标签数目      
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; // 标签标识
    BYTE    byRes2[160];   //保留字节    
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //要修改的标签标识
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];    //修改后的标签名称
    BYTE byRes2[40];                
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

// 标签搜索结构体
typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;          // 结构体大小
    LONG        lChannel;        // 查找的通道
    NET_DVR_TIME    struStartTime;    // 开始时间
    NET_DVR_TIME    struStopTime;    // 结束时间
    BYTE        sLabelName[LABEL_NAME_LEN];    //  录像标签名称 如果标签名称为空，则搜索起止时间所有标签
    BYTE        byDrawFrame;        //0:不抽帧，1：抽帧
    BYTE        byRes[39];        // 保留字节
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

// 标签信息结构体
typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE    sLabelName[LABEL_NAME_LEN];    // 标签名称
    NET_DVR_TIME struTimeLabel;        // 标签时间
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; // 标签标识
    BYTE    byRes1[32];            // 保留字节
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;

#define CARDNUM_LEN_V30 40
//国家枚举
typedef enum _COUNTRY_INDEX_
{
    COUNTRY_NONSUPPORT = 0,   //0-算法库不支持牌识国家
        COUNTRY_CZE = 1, //Czech Republic 捷克共和国
        COUNTRY_FRA = 2, //France 法国
        COUNTRY_DEU = 3, //Germany 德国
        COUNTRY_ESP = 4, //Spain  西班牙
        COUNTRY_ITA = 5, //Italy  意大利
        COUNTRY_NLD = 6, //Netherlands 荷兰
        COUNTRY_POL = 7, //Poland  波兰
        COUNTRY_SVK = 8, //Slovakia  斯洛伐克
        COUNTRY_BLR = 9, // Belorussia  白俄罗斯
        COUNTRY_MDA = 10, //Moldova  摩尔多瓦
        COUNTRY_RUS = 11, //Russia  俄罗斯
        COUNTRY_UKR = 12, //Ukraine  乌克兰
        COUNTRY_BEL = 13, //Belgium  比利时
        COUNTRY_BGR = 14, //Bulgaria  保加利亚
        COUNTRY_DNK = 15, //Denmark  丹麦
        COUNTRY_FIN = 16, //Finland  芬兰
        COUNTRY_GBR = 17, //Great Britain  英国
        COUNTRY_GRC = 18, //Greece  希腊
        COUNTRY_HRV = 19, //Croatia  克罗地亚
        COUNTRY_HUN = 20, //Hungary  匈牙利
        COUNTRY_ISR = 21, //Israel  以色列
        COUNTRY_LUX = 22, //Luxembourg  卢森堡
        COUNTRY_MKD = 23, //Macedonia  马其顿共和国
        COUNTRY_NOR = 24, //Norway  挪威
        COUNTRY_PRT = 25, //Portugal  葡萄牙
        COUNTRY_ROU = 26, //Romania  多马尼亚
        COUNTRY_SRB = 27, //Serbia  塞尔维亚
        COUNTRY_AZE = 28, //Azerbaijan 阿塞邦疆共和国
        COUNTRY_GEO = 29, //Georgia  即格鲁吉亚
        COUNTRY_KAZ = 30, //Kazakhstan 哈萨克斯坦
        COUNTRY_LTU = 31, //Lithuania  立陶宛共和国
        COUNTRY_TKM = 32, //Turkmenistan 土库曼斯坦
        COUNTRY_UZB = 33, //Uzbekistan   乌兹别克斯坦
        COUNTRY_LVA = 34, //Latvia       拉脱维亚
        COUNTRY_EST = 35, //Estonia 爱沙尼亚
        COUNTRY_ALB = 36, //Albania 阿尔巴尼亚
        COUNTRY_AUT = 37, //Austria 奥地利
        COUNTRY_BIH = 38, //Bosnia and Herzegovina 波斯尼亚和黑塞哥维那
        COUNTRY_IRL = 39, //Ireland 爱尔兰
        COUNTRY_ISL = 40, //Iceland 冰岛
        COUNTRY_VAT = 41, //Vatican 梵蒂冈
        COUNTRY_MLT = 42, //Malta 马耳他
        COUNTRY_SWE = 43, //Sweden 瑞典
        COUNTRY_CHE = 44, //Switzerland 瑞士
        COUNTRY_CYP = 45, //Cyprus 塞浦路斯
        COUNTRY_TUR = 46, //Turkey 土耳其
        COUNTRY_SVN = 47, //Slovenia 斯洛文尼亚
        COUNTRY_UNRECOGNIZED = 0xfe, //Unrecognized 无法识别
        COUNTRY_ALL = 0xff, //ALL  全部
}COUNTRY_INDEX;

typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         // 结构体大小 
    LONG   lChannel;       // 通道号
    /* 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
    3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
    9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警, 
    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
    0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
    0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
    0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
    0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
    0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
    0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警,0xff- 全部类型*/ 
    BYTE   byFileType;        
    BYTE   byNeedCard;     // 是否需要卡号
                           /*
                           0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
                           8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
                           15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
                           22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
                           29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
    */
    BYTE   byProvince;     //省份索引值
    BYTE   byRes;  //查找结果中是否要求返回人脸坐标信息，0-不返回，1-返回
    BYTE   sCardNum[CARDNUM_LEN_V30];     // 卡号
    NET_DVR_TIME  struStartTime;//查找图片的开始时间
    NET_DVR_TIME  struStopTime;// 查找图片的结束时间
    //ITC3.7 新增
    DWORD    dwTrafficType; //图片检索生效项 参考 VCA_OPERATE _TYPE 
    DWORD    dwVehicleType; //车辆类型 参考 VCA_VEHICLE_TYPE
    //违规检测类型参考 VCA_ILLEGAL_TYPE 当前不支持复选
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //车道号(1~99)
    BYTE     bySubHvtType ;//0-保留,1-机动车(机动车子类型中支持车牌检索，省份检索),2-非机动车,3-行人
    BYTE     byRes2[2];
    char     sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE     byRegion;     // 区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) ,0xff-所有
    BYTE     byCountry;     // 国家索引值，参照：COUNTRY_INDEX 
    BYTE     byRes3[6];     // 保留字节
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

#define PICTURE_NAME_LEN 64

typedef struct
{
    char    sFileName[PICTURE_NAME_LEN];//图片名
    NET_DVR_TIME struTime;//图片的时间
    DWORD dwFileSize;//图片的大小
    char    sCardNum[CARDNUM_LEN_V30];    //卡号
    BYTE   byPlateColor ;//参考结构 VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//参考结构 VLR_VEHICLE_CLASS
    BYTE   byEventSearchStatus; //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    BYTE   byRecogResult ;//识别结果参考结构VTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE   byRes[12];
}NET_DVR_FIND_PICTURE,*LPNET_DVR_FIND_PICTURE;

#define MAX_RECORD_PICTURE_NUM  50      //  最大备份图片张数  

typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         // 结构体大小   
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*是否继续备份 0不继续 1继续*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct 
{    
    DWORD dwSize;           //结构体大小
    DWORD dwChannel;        //通道号
    BYTE  byCompressType;   //待获取的压缩参数类型1,主码流2,子码流3,事件
    BYTE  byRes[15];        //保留
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //当前压缩参数配置
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

#define   STEP_READY       0    //准备升级
#define   STEP_RECV_DATA   1    //接收升级包数据
#define   STEP_UPGRADE     2    //升级系统
#define   STEP_BACKUP      3    //备份系统
#define   STEP_SEARCH      255  //搜索升级文件

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //亮度[0,255]
    DWORD dwContrastValue;    //对比度[0,255]
    DWORD dwSaturationValue;  //饱和度[0,255]
    DWORD dwHueValue;         //色调[0,255]
    DWORD dwSharpness;          //锐度[0,255]
    DWORD dwDenoising;          //去噪[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{    
    DWORD                    dwSize;                //结构体大小
    WORD                    wEffectMode;        //模式 0-标准 1-室内 2-弱光 3-室外  255-自定义
    BYTE                    byRes1[146];        //保留
    NET_DVR_VIDEO_EFFECT    struVideoEffect;    //视频效果参数
    BYTE                    byRes2[60];            //保留
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;


typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD    dwChannel;            // 通道号
    DWORD    dwVideoParamType;      // 视频参数类型 0-亮度 1-对比度 2-饱和度 3-色度 4-锐度 5-去噪
    DWORD    dwVideoParamValue;  //对应的视频参数值，范围依据能力集
    BYTE     byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD    dwSize;            // 结构体大小
    DWORD    dwChannel;        // 通道号
    DWORD    dwVideoMode;    // 模式
    BYTE    byRes[32];      // 保留
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD    dwSize;            // 结构体大小
    BYTE    byJointed;        //  0 没有关联 1 已经关联
    BYTE    byDevType;        // 被关联的设备类型  1 代表智能设备
    BYTE    byRes1[2];        // 保留字节
    NET_DVR_IPADDR    struIP;            // 关联的被取流设备IP地址
    WORD    wPort;            // 关联的被取流设备端口号
    WORD    wChannel;        // 关联的被取流设备通道号
    BYTE    byRes2[20];            // 保留字节
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;    

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE    byJointed;                // 0-没有关联  1-已经关联
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;                    // 关联的取流设备IP地址
    WORD    wPort;                    // 关联的取流设备端口号
    WORD    wChannel;                // 关联的取流设备通道号
    BYTE    byVcaChanStatus;        // 0 - 未启用 1 - 启用
    BYTE    byRes2[19];                // 保留字节
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD    dwSize;            // 结构体大小
    BYTE    byDeviceStatus;    // 设备的状态0 - 正常工作 1- 不正常工作
    BYTE    byCpuLoad;        // CPU使用率0-100 分别代表使用百分率
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD    dwRes[40];        // 保留字节
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{        
    DWORD    dwSize; 
    BYTE   byAudio;            /*音频是否开启*/
    BYTE   byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE     byVgaResolution;      /*分辨率，从能力集获取*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL，0-NULL*/
    DWORD    dwWindowMode;        /*画面模式，能力集获取*/       
    BYTE      byJoinDecChan[MAX_WINDOWS];/*各个子窗口关联的解码通道*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    BYTE    byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
    /*区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    BYTE    byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)*/
            BYTE    byJoinDecoderId[MAX_WINDOWS];
            //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通
            //道都分配给此解码通道
            BYTE    byDecResolution;
            BYTE    byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE    byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE    byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40,*LPNET_DVR_VGA_DISP_CHAN_CFG_V40;

typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE        bySerialTrans;//是否透传，0-否，1-是
    BYTE        byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;




typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //命令：0-进入坏点模式，1-添加坏点，2-保存坏点，3-退出坏点
    DWORD dwDeadPixelX; //坏点X坐标
    DWORD dwDeadPixelY; //坏点Y坐标
    BYTE byRes[12]; //保留
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

#define MAX_REDAREA_NUM   6   //最大红绿灯区域个数

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;//黄灯的间隔时间，单位是秒（s）
    BYTE byDigTrafficLight;//是否是交通数字黄灯，0-不是，1-是
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS,*LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable; //是否开启校正功能，0-关闭，1-开启
    DWORD dwCorrectLevel; //校正级别，1(校正度最低)-10(校正度最高),默认为5
    DWORD dwAreaNum; //校正区域个数
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM]; //校正区域
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/]; //校正区域属性和校正区域对应
    BYTE   byRes2[8]; //保留
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //历史数据个数
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;


#define INQUEST_MESSAGE_LEN     44    //审讯重点标记信息长度
#define INQUEST_MAX_ROOM_NUM    2     //最大审讯室个数
#define MAX_RESUME_SEGMENT      2     //支持同时恢复的片段数目

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE        byRoomIndex;     //审讯室编号
    BYTE        byFileType;        //0-审讯文件，1-开庭上传文件
    BYTE        byRes[22];       //保留
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char         sMessage[INQUEST_MESSAGE_LEN]; //重点标记信息
    BYTE    byRes[46];                     //保留
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD    wDeviceType;    //数据采集设备型号:0-无 1-米乐 2-镭彩 3-优力 4-佳盟 5-永控、6-垅上、7-维纳斯达
    WORD    wDeviceAddr;    //数据采集设备地址    
    BYTE     byRes[28];        //保留
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //支持协议类型,按位表示, 新版本走能力集，不再扩展此字段
    //0x1:米乐 0x2:镭彩 0x4:优力
    BYTE    byRes[120];        //保留
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char        szCDName[NAME_LEN];    //光盘名称，单室双刻光盘名称是一样的
    union
    {
        BYTE     byBitRate;    // byCalcType为0时有效，(0-32、1-48、2-64、3-80、4-96、5-128、
                                //6-160、7-192、8-224、9-256、10-320、11-384、12-448、
                                //13-512、14-640、15-768、16-896前16个值保留)17-1024、18-1280、19-1536、
                                //20-1792、21-2048、22-3072、23-4096、24-8192
        BYTE    byInquestTime;  // byCalcType为1时有效，0-1小时, 1-2小时,2-3小时,3-4小时, 4-6小时,5-8小时,6-10小时,7-12小时
        //8-16小时, 9-20小时,10-22小时,11-24小时
    }uCalcMode;
    BYTE        byCalcType;            //刻录计算类型0-按码率 1-按时间
    BYTE        byAutoDelRecord;    // 是否自动删除录像，0-不删除，即结束时保存录像 1-删除
    BYTE        byAlarmThreshold;        // 声音报警阀值
    BYTE        byInquestChannelResolution;     //审讯通道分辨率，0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE        byRes[11];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD    dwRecordMode;         //刻录模式:1 单室双刻模式 2 单室轮刻模式 3 双室双刻模式（修改需要重启设备）
    DWORD    dwWorkMode;           //工作模式:0 标准模式 1 通用模式(保留，目前只有标准模式)
    DWORD    dwResolutionMode;     //设备分辨率，0:标清 1:D1 2:720P 3:1080P（高清审讯机不用此字段）
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //温湿度传感器配置    
    NET_DVR_INQUEST_ROOM_INFO     struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE    byEnableHashCheck;        //是否启用对光盘数据HASH值校验 0-无意义，1-不启用，2-启用
    BYTE    byEnableInitCD;        //是否启用初始化光盘 0-无意义，1-不启用，2-启用
    BYTE    byRes[22];    
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //事件起始时间
    NET_DVR_TIME  struStopTime;  //事件终止时间
    BYTE    byRoomIndex;         //审讯室编号,从1开始
    BYTE    byDriveIndex;        //刻录机编号,从1开始
    WORD    wSegmetSize;         //本片断的大小, 单位M 
    DWORD   dwSegmentNo;         //本片断在本次审讯中的序号,从1开始 
    BYTE    byRes[24];           //保留
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //需恢复的事件个数
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE    byResumeMode;        //恢复模式，0-单光盘恢复，1-双光盘恢复
    BYTE    byRes[199];        //保留
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
BYTE  byMainVersion;         /*基线主版本.
                             0 : 未知
                             1 : 8000审讯DVR
                             次版本: 1 : 8000HD-S
                             2 : 8100审讯DVR 
                             次版本: 1 : 审讯81SNL
                             2 : 审讯81SH
                             3 : 审讯81SFH
                             3 : 8608高清审讯机NVR 
                             次版本: 1 : DS-8608SN-SP
                             2 : DS-8608SN-ST
*/
BYTE  bySubVersion;          //基线次版本
BYTE  byUpgradeVersion;      //升级版本,未升级为0
BYTE  byCustomizeVersion;     //定制版本,非定制为0
BYTE  byRes[60];             //保留
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

typedef struct tagNET_DVR_DISK_RAID_INFO 
{
    DWORD dwSize;   //结构体大小
    BYTE byEnable;  //磁盘Raid是否禁用
    BYTE bySleepStatus;    //0-无效， 1-休眠，2-不休眠
    BYTE byRes[34];  //保留字节
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;


typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //结构体大小
    BYTE  byEnable;  //是否启用：为前端IPC同步设备参数
    BYTE  byRes[7];  //保留
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //结构体大小
    char sOldPasswd[PASSWD_LEN];  //IPC的旧密码，传给DVR让DVR验证
    char sNewPasswd[PASSWD_LEN];  //IPC的新密码
    BYTE byRes[32];
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

//通过获取DVR的网络状态：单位bps
typedef struct tagNET_DEVICE_NET_USING_INFO 
{
    DWORD dwSize;    //结构体大小
    DWORD dwPreview;   //预览
    DWORD dwPlayback;  //回放
    DWORD dwIPCModule; //IPC接入
    DWORD dwNetDiskRW; //网盘读写
    BYTE res[32];
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

//通过DVR设置前端IPC的IP地址
typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;      //结构体大小
    NET_DVR_IPADDR struIP;       //IPC的IP地址
    WORD wPort;       //IPC的端口
    char res[126];  
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

//按时间锁定
typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //结构体大小
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //通道号, 0xff表示所有通道
    DWORD   dwRecordType;     //录像类型:  0xffffffff－全部，0－定时录像，1-移动侦测，2－报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，7-智能录像(同文件查找)
    DWORD   dwLockDuration;   //锁定持续时间,单位秒,0xffffffff表示永久锁定
    NET_DVR_TIME_EX strUnlockTimePoint;    //加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //结构体大小
    NET_DVR_TIME strBeginTime; 
    NET_DVR_TIME strEndTime;
    BYTE    byRes[20];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;

//67DVS
//证书下载类型
typedef enum 
{
    UPGRADE_CERT_FILE = 0, 
    UPLOAD_CERT_FILE = 1,
    TRIAL_CERT_FILE = 2,
    CONFIGURATION_FILE = 3,
    UPLOAD_RECORD_FILE = 4 , //上传录像文件
    SCENE_CONFIGURATION_FILE = 5, //场景配置文件上传
    UPLOAD_PICTURE_FILE = 6,  //上传图片文件
    UPLOAD_VIOLATION_FILE = 7,  //上传违法字典文件
    UPLOAD_TG_FILE = 8,  //上传TG（Timing Generator）文件（用于T1测试）
    UPLOAD_DATA_TO_DB = 9,        //上传文件到视图库
    UPLOAD_BACKGROUND_PIC = 10, //上传背景图片
    UPLOAD_CALIBRATION_FILE = 11, //上传标定文件
    UPLOAD_TME_FILE = 12, //上传出入口管理文件
    
    //UPLOAD_TME_FILE = 12, //上传出入口管理文件
    UPLOAD_VEHICLE_BLACKWHITELST_FILE = 13,
    UPLOAD_PICTURE_TO_CLOUD = 15,    //上传图片到云存储
    UPLOAD_VIDEO_FILE = 16,  //上传视频文件
    UPLOAD_SCREEN_FILE = 17,    //上传屏幕服务器文件
    UPLOAD_PUBLISH_MATERIAL = 18,    //上传信息发布静态素材文件
    UPLOAD_PUBLISH_UPGRADE_FILE = 19,    //上传信息发升级文件
    UPLOAD_RING_FILE = 20,   //上传铃音文件
    UPLOAD_ENCRYPT_CERT = 21,    //上传加密证书
    UPLOAD_THERMOMETRIC_FILE = 22, //上传测温标定文件
    UPLOAD_SUBBRAND_FILE = 23, //上传车辆子品牌文件
    UPLOAD_LED_CHECK_FILE = 24,    //上传LED校正文件
    BATCH_UPLOAD_PICTURE_FILE = 25  //批量上传图片文件
}NET_SDK_UPLOAD_TYPE;  

typedef enum 
{
    NET_SDK_DOWNLOAD_CERT = 0,        //下载证书
    NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,//下载IPC配置文件
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2, //下载基准场景图片
    NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3,       //下载VQD报警图片
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE=4,   //下载配置文件
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5, //下载场景配置文件
    NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,                //从视图库中下载
   // NET_SDK_DOWNLOAD_TME_FILE = 7  //下载出入口管理文件

    NET_SDK_DOWNLOAD_TME_FILE = 7,  //下载出入口管理文件
    NET_SDK_DOWNLOAD_VEHICLE_BLACKWHITELST_FILE = 8, //下载黑白名单配置文件
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,    //从云存储下载图片
    NET_SDK_DOWNLOAD_PICTURE = 11, //下载图片
    NET_SDK_DOWNLOAD_VIDEO = 12, //下载视频
    NET_DVR_DOWNLOAD_SCREEN_FILE = 13, //下载屏幕服务器文件
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL = 14,    //下载信息发布静态素材文件
    NET_SDK_DOWNLOAD_THERMOMETRIC_FILE = 15,//下载测温标定文件
    NET_SDK_DOWNLOAD_LED_CHECK_FILE = 16,//下载LED校正文件
}NET_SDK_DOWNLOAD_TYPE;

//下载状态
typedef enum 
{
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,    //下载成功
        NET_SDK_DOWNLOAD_STATUS_PROCESSING,        //正在下载
        NET_SDK_DOWNLOAD_STATUS_FAILED,            //下载失败
        NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR    //未知错误 
}NET_SDK_DOWNLOAD_STATUS;

//下载控制命令类型
typedef enum tagNET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM
{
    ENUM_DOWNLOAD_CONTROL_ERR = -1,
    ENUM_DOWNLOAD_CONTROL_QOS = 1        //流控
}NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM;

typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD    dwSize;                // 结构体大小
    BYTE    byEnableBonjour;        // Bonjour使能 0 ：开启 1：关闭
    BYTE     byRes1[3];                
    BYTE     byFriendlyName[MAX_DOMAIN_NAME];     // 服务名
    BYTE     byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD            dwSize;                // 结构体大小
    BYTE            byEnableSocks;          // 使能 0：关闭 1：开启
    BYTE             byVersion;              // SOCKS版本 4：SOCKS4   5：SOCKS5
    WORD            wProxyPort;                // 代理端口，默认1080
    BYTE            byProxyaddr[MAX_DOMAIN_NAME];      // 代理IP地址，可以是域名
    BYTE             byUserName[MAX_DOMAIN_NAME];     // 用户名 SOCKS才用
    BYTE             byPassword[NAME_LEN];            // 密码SOCKS5才用
    BYTE             byLocalAddr[MAX_LOCAL_ADDR_LEN];  //不使用socks代理的网段，格式为"ip/netmask;ip/netmask;…"
    BYTE             byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;



typedef struct tagNET_DVR_QOS_CFG
{
    DWORD        dwSize;
    BYTE        byManageDscp;   // 管理数据的DSCP值 [0-63]
    BYTE        byAlarmDscp;    // 报警数据的DSCP值 [0-63]
    BYTE        byVideoDscp;    // 视频数据的DSCP值 [0-63]，byFlag为0时，表示音视频
    BYTE        byAudioDscp;    // 音频数据的DSCP值 [0-63]，byFlag为1时有效
    BYTE        byFlag;            // 0：音视频合一，1：音视频分开
    BYTE        byEnable;
    BYTE         byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD        dwSize;
    WORD        wHttpsPort;        // HTTPS端口
    BYTE        byEnable;        // 使能 0：关闭 1：开启
    BYTE        byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

//证书相关
typedef struct tagNET_DVR_CERT_NAME
{
    BYTE    byCountry[MAX_COUNTRY_NAME_LEN];              //国家代号 CN等
    BYTE     byState[MAX_DOMAIN_NAME];                //洲或省
    BYTE     byLocality[MAX_DOMAIN_NAME];            //地区
    BYTE     byOrganization[MAX_DOMAIN_NAME];        //组织
    BYTE     byUnit[MAX_DOMAIN_NAME];                //单位
    BYTE     byCommonName[MAX_DOMAIN_NAME];
    BYTE     byEmail[MAX_DOMAIN_NAME];  
    BYTE     byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME ;

typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //证书种类，0-802.1x,1-HTTPS
    WORD wCertType; //证书类型，0-CA，1-Certificate,2-私钥文件
    BYTE byFileType; //证书文件类型，0-PEM,1-PFX
    BYTE byRes[35]; 
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

#define UPLOAD_CERTIFICATE  1 //上传证书


typedef struct tagNET_DVR_CERT_INFO
{
    DWORD                 dwSize;
    NET_DVR_CERT_PARAM     struCertParam;    //证书参数
    DWORD                dwValidDays;   //有效天数，类型为自签名时有效
    BYTE                 byPasswd[NAME_LEN];   //私钥密码
    NET_DVR_CERT_NAME     struCertName;    // 证书名称
    NET_DVR_CERT_NAME     struIssuerName;    // 证书发行者名称（自签名证书信息获取时有效）
    NET_DVR_TIME_EX         struBeginTime;   //证书创建时间（自签名证书信息获取时有效）
    NET_DVR_TIME_EX         struEndTime;   //证书截止时间（自签名证书信息获取时有效）
    BYTE                 serialNumber[NAME_LEN];   //证书标识码（自签名证书信息获取时有效）
    BYTE                 byVersion; 
    BYTE                 byKeyAlgorithm;            //加密类型 0-RSA  1-DSA
    BYTE                  byKeyLen;                //加密长度 0-512  1-1024、 2-2048
    BYTE                 bySignatureAlgorithm; //签名算法类型（自签名证书信息获取时有效）
    BYTE                 byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;


//channel record status
//***通道录像状态*****//
typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE    byValid;       //是否有效
                           /*(只读)录像类型:0: 不在录像；1：在录像 2-空闲 
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中 
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中*/
    BYTE    byRecord;     
    WORD    wChannelNO;   //通道号
    DWORD   dwRelatedHD;  //关联磁盘
    BYTE    byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE    byRes[7];      //保留字节
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;


typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize; 
    DWORD dwIPAlarmInGroup;      //IP通道报警输入组数
    DWORD dwIPAlarmInNum;       //IP通道报警输入个数
    DWORD dwIPAlarmOutGroup;     //IP通道报警输出组数
    DWORD dwIPAlarmOutNum;      //IP通道报警输出个数
    BYTE byRes[64];  
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //结构体大小
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //一组64个
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;


typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; /*矩形左上角起始点X坐标*/
    WORD wYCoordinate; /*矩形左上角Y坐标*/
    WORD wWidth;       /*矩形宽度*/
    WORD wHeight;      /*矩形高度*/
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;
/*窗口信息*/
typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;          /*输入源索引*/
    BYTE  byLayerIdx;          /*图层，0为最底层*/
    BYTE  byTransparency; //透明度，0～100 
    NET_DVR_RECTCFG  struWin;//目的窗口(相对显示墙)
    WORD wScreenHeight;//大屏高
    WORD wScreenWidth;//大屏宽
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

#define  MAX_LAYERNUMS    32

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;//大屏号
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;//图层号
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

//2011-04-18
/*摄像机信息,最多9999个，从1开始 */
typedef struct tagNET_MATRIX_CAMERAINFO
{  
    DWORD dwGlobalCamId;      /* cam的全局编号*/
    BYTE  sCamName[NAME_LEN]; /*cam的名称*/
    DWORD dwMatrixId;          /*cam对应矩阵的编号*/
    DWORD dwLocCamId;         /*cam对应矩阵的内部编号*/ 
    BYTE  byValid;    /*是否有效，0-否，1-是*/
    BYTE  byPtzCtrl; /* 是否可控，0-否，1-是*/
    BYTE  byUseType; //*使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤*/ 
    BYTE  byUsedByTrunk;//当前使用状态，0-没有被使用，1-被干线使用 
    BYTE  byTrunkReq; /*摄像机分辨率,以D1为单位：1 - 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽*/
    BYTE  byRes1[3];
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE  sPurpose[NAME_LEN];/*用途描述*/
    BYTE  byRes2[20];  
}NET_MATRIX_CAMERAINFO, *LPNET_MATRIX_CAMERAINFO;

/*监视器信息，最多2048个*/
typedef struct tagNET_MATRIX_MONITORINFO 
{
    DWORD    dwGloalMonId; /*mon 的统一编号*/
    BYTE    sMonName[NAME_LEN];
    DWORD    dwMatrixId;  /*mon所在矩阵的编号*/
    DWORD    dwLocalMonId; /*mon的内部编号*/
    BYTE    byValid;    /*是否有效，0-否，1-是*/
    BYTE    byTrunkType; /*使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤*/ 
    BYTE    byUsedByTrunk;//当前使用状态，0-没有被使用，1-被干线使用 
    BYTE    byTrunkReq; /*分辨率, 以D1为单位：1- 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽*/
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE    sPurpose[NAME_LEN];/*用途描述*/
    BYTE    byRes[20];  
}NET_MATRIX_MONITORINFO, *LPNET_MATRIX_MONITORINFO;

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress; /*设备为数字设备时的IP信息*/
    WORD    wPort;
    BYTE    byNicNum; /*0 - eth0, 1 - eth1, 考虑双网口如何通信加入绑定的网口*/
    BYTE    byRes[69];   
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;
typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE    bySerPortNum;   /*连接的串口号  0xff-环通接入*/
    BYTE    byMatrixSerPortType;/* 矩阵接入网关的串口与模拟矩阵的键盘口(键盘协议)连接还是与矩阵通信口（矩阵协议）连接 ，0 --- 矩阵协议通讯口 1 --- 键盘通讯口*/
    BYTE    byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;    //232串口参数  环通接入时此参数无效
    BYTE    byRes2[200];      
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;

typedef union tagNET_MATRIX_UNION
{
    NET_MATRIX_DIGITALMATRIX struDigitalMatrix;
    NET_MATRIX_ANALOGMATRIX struAnalogMatrix;
}NET_MATRIX_UNION, *LPNET_MATRIX_UNION;
/*矩阵配置信息，最多20个*/
typedef struct tagNET_MATRIX_MATRIXINFO 
{
    DWORD   dwSize;
    DWORD    dwMatrixId;  /*矩阵编号*/
    BYTE    sDevName[NAME_LEN];
    BYTE    byCtrlType; /*指通讯方式是串口通信, 还是网络通信*/
    BYTE    byProtocolType;/*设置通信控制协议*/
    BYTE    byRes1[6];   /*预留*/
    NET_MATRIX_UNION struMatrixUnion;
    DWORD    dwMaxPortsIn; /*矩阵输入数*/
    DWORD    dwMaxPortsOut;/*矩阵输出数*/
    BYTE    sUserName[NAME_LEN];   /*登录用户名*/
    BYTE    sPassword[PASSWD_LEN];  /*登录密码*/        
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE    sPurpose[NAME_LEN];/*用途描述*/
    BYTE    byRes2[20];   /*预留*/
}NET_MATRIX_MATRIXINFO, *LPNET_MATRIX_MATRIXINFO;


typedef struct tagNET_DVR_MATRIXLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwMatrixNum;//设备返回的矩阵数量
    BYTE    *pBuffer;//矩阵信息缓冲区
    DWORD   dwBufLen;//所分配指针长度，输入参数
}NET_DVR_MATRIXLIST,*LPNET_DVR_MATRIXLIST;

/*串口配置信息*/
typedef struct tagNET_MATRIX_UARTPARAM
{    
    DWORD dwSize;
    BYTE  byPortName[NAME_LEN];
    WORD  wUserId; /*用户编号，当连接设备为键盘时，绑定一个用户，用于权限管理*/
    BYTE  byPortType;    /*串口类型，三种0-RS232/1-RS485/2-RS422*/
    BYTE  byFuncType; /*串口连接的设备的类型0-空闲，1-键盘，2-用作透明通道(485串口不可配置成透明通道),3-模拟矩阵*/     
    BYTE  byProtocolType;  /*串口支持的协议类型, 当连接键盘设备时需要该信息,获取键盘支持协议的编号及描述符*/
    BYTE  byBaudRate;
    BYTE  byDataBits;
    BYTE  byStopBits;   /*停止位*/
    BYTE  byParity;      /*校验*/
    BYTE  byFlowCtrl;   /*流控，软件流控，无流控*/
    BYTE  byRes[22];     /*预留*/
}NET_MATRIX_UARTPARAM, *LPNET_MATRIX_UARTPARAM;

//最多256个用户，1～256
typedef struct tagNET_MATRIX_USERPARAM 
{
    DWORD dwSize;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN/*16*/];
    BYTE    byRole;/*用户角色:0-管理员,1-操作员；只有一个系统管理员，255个操作员*/
    BYTE    byLevel;  /*统一级别，用于操作级别管理,1- 255*/
    BYTE    byRes[18];
}NET_MATRIX_USERPARAM, *LPNET_MATRIX_USERPARAM;

//最多255个资源组
typedef struct tagNET_MATRIX_RESOURSEGROUPPARAM
{
    DWORD dwSize;
    BYTE  byGroupName[NAME_LEN];
    BYTE  byGroupType;/*0-摄像机CAM组，1-监视器MON组*/
    BYTE  byRes1;
    WORD  wMemNum;
    DWORD dwGlobalId[512];
    BYTE  byRes2[20];
}NET_MATRIX_RESOURCEGROUPPARAM,*LPNET_MATRIX_RESOURSEGROUPPARAM;

//最多255个用户组
typedef struct tagNET_MATRIX_USERGROUPPARAM
{
    DWORD dwSize;
    BYTE  sGroupName[NAME_LEN];
    WORD  wUserMember[255];  /*包含的用户成员*/
    WORD  wResorceGroupMember[255]; /*包含的资源组成员*/
    BYTE  byPermission[32];//权限，数组0-ptz权限、切换权限、查询权限
    BYTE  byRes[20];
} NET_MATRIX_USERGROUPPARAM, *LPNET_MATRIX_USERGROUPPARAM;

typedef struct tagNET_MATRIX_TRUNKPARAM
{
    DWORD    dwSize;
    DWORD    dwTrunkId;
    BYTE    sTrunkName[NAME_LEN];
    DWORD    dwSrcMonId;
    DWORD    dwDstCamId;
    BYTE    byTrunkType;  /*使用类型  1-BNC，2-SP3光纤高清，3-SP3光纤D1， 4-V6光纤，5-其他光纤*/
    BYTE    byAbility;     /*表示光纤的带宽，可以传输几路*/
    BYTE    bySubChan;   /*针对光纤干线而言，表示子通道号*/
    BYTE    byLevel;        /* 干线级别 1-255*/
    WORD    wReserveUserID;    //预留的用户ID： 1~256 ，0表示释放预留
    BYTE   byRes[18]; 
} NET_MATRIX_TRUNKPARAM, *LPNET_MATRIX_TRUNKPARAM;

typedef struct tagNET_DVR_MATRIX_TRUNKLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwTrunkNum;//设备返回的干线数量
    BYTE    *pBuffer;//干线信息缓冲区
    DWORD   dwBufLen;//所分配指针长度，输入参数
}NET_DVR_MATRIX_TRUNKLIST,*LPNET_DVR_MATRIX_TRUNKLIST;

#define MATRIX_PROTOCOL_NUM    20    //支持的最大矩阵协议数
#define KEYBOARD_PROTOCOL_NUM  20    //支持的最大键盘协议数
typedef struct tagNET_DVR_PROTO_TYPE_EX
{ 
    WORD wType;               /*ipc协议值*/  
    WORD wCommunitionType;        /*0：模拟 1：数字 2：兼容模拟、数字*/
    BYTE  byDescribe[DESC_LEN]; /*协议描述字段*/    
}NET_DVR_PROTO_TYPE_EX, LPNET_DVR_PROTO_TYPE_EX;

typedef struct tagNET_DVR_MATRIXMANAGE_ABIILITY
{
    DWORD    dwSize;
    DWORD    dwMaxCameraNum;//最大Camera数量
    DWORD    dwMaxMonitorNum;//最大监视器数量
    WORD    wMaxMatrixNum;//最大矩阵数量
    WORD    wMaxSerialNum;//串口数量
    WORD    wMaxUser;//最大用户数
    WORD    wMaxResourceArrayNum;//最大资源组数
    WORD    wMaxUserArrayNum;//最大用户组数
    WORD    wMaxTrunkNum;//最大干线数
    BYTE    nStartUserNum;//起始用户号
    BYTE    nStartUserGroupNum;//起始用户组号
    BYTE    nStartResourceGroupNum;//起始资源组号
    BYTE    nStartSerialNum;//起始串口号
    DWORD   dwMatrixProtoNum;     /*有效的矩阵协议数目，从0开始*/
    NET_DVR_PROTO_TYPE_EX struMatrixProto[MATRIX_PROTOCOL_NUM];/*最大协议列表长度*/    
    DWORD   dwKeyBoardProtoNum;     /*有效的键盘协议数目，从0开始*/
    NET_DVR_PROTO_TYPE_EX struKeyBoardProto[KEYBOARD_PROTOCOL_NUM];/*最大协议列表长度*/   
    BYTE    byRes[32];
} NET_DVR_MATRIXMANAGE_ABILITY, *LPNET_DVR_MATRIXMANAGE_ABILITY;

//人脸抓拍规则(单条)
typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;                //是否激活规则：0-否，1-是
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    //人脸自动ROI开关使能
    BYTE byAutoROIEnable;//0-关闭,1-开启
    BYTE byRes[2]; //保留
    /********* IPC5.1.7 新增参数 End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //尺寸过滤器
    NET_VCA_POLYGON     struVcaPolygon;        //人脸识别区域
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

//人脸抓拍规则参数
typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;                    //单个目标人脸的抓拍次数0-10
    BYTE bySnapInterval;                 //抓拍间隔，单位：帧
    BYTE bySnapThreshold;               //抓拍阈值，0-100
    BYTE byGenerateRate;         //目标生成速度,范围[1, 5]    
    BYTE bySensitive;            //目标检测灵敏度，范围[1, 5]
    BYTE byReferenceBright; //2012-3-27参考亮度[0,100]
    BYTE byMatchType;         //2012-5-3比对报警模式，0-目标消失后报警，1-实时报警
    BYTE byMatchThreshold;  //2012-5-3实时比对阈值，0~100
    NET_DVR_JPEGPARA  struPictureParam; //图片规格结构
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //人脸抓拍规则
    //人脸曝光最短持续时间（两个字节）
    WORD wFaceExposureMinDuration;//范围(1~3600秒，默认60)生效于自动模式下
    //人脸曝光模式
    BYTE byFaceExposureMode;//1-关闭，2-开启，0-自动（根据人脸判断）
    BYTE byBackgroundPic;//背景图上传使能 0-默认值（开启），1-禁止
    DWORD dwValidFaceTime;    //有效人脸最短持续时间，单位：秒
    DWORD dwUploadInterval; //人脸抓拍统计数据上传间隔时间，单位：秒，默认900秒
    BYTE byRes2[88];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

//年龄段
typedef enum tagHUMAN_AGE_GROUP_ENUM
{    
    ENUM_AGE_GROUP_INFANT      = 1,   //婴幼儿
        ENUM_AGE_GROUP_CHILD       = 2,   //儿童
        ENUM_AGE_GROUP_YOUNGSTER   = 3,   //少年
        ENUM_AGE_GROUP_ADOLESCENT  = 4,   //青少年
        ENUM_AGE_GROUP_YOUTH       = 5,   //青年
        ENUM_AGE_GROUP_PRIME       = 6,   //壮年
        ENUM_AGE_GROUP_MIDLIFE     = 7,   //中年
        ENUM_AGE_GROUP_MIDAGE      = 8,   //中老年
        ENUM_AGE_GROUP_OLD         = 9    //老年
}HUMAN_AGE_GROUP_ENUM;

//人脸抓拍结果
typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;             // 结构大小
    DWORD     dwRelativeTime;     // 相对时标
    DWORD    dwAbsTime;            // 绝对时标
    DWORD   dwFacePicID;       //人脸图ID
    DWORD   dwFaceScore;        //人脸评分,0-100
    NET_VCA_TARGET_INFO  struTargetInfo;//报警目标信息
    NET_VCA_RECT         struRect;      //人脸子图区域
    NET_VCA_DEV_INFO       struDevInfo;    //前端设备信息
    DWORD   dwFacePicLen;        //人脸子图的长度，为0表示没有图片，大于0表示有图片
    DWORD   dwBackgroundPicLen; //背景图的长度，为0表示没有图片，大于0表示有图片(保留)
    BYTE    bySmart;            //IDS设备返回0(默认值)，Smart Functiom Return 1
    BYTE    byAlarmEndMark;//报警结束标记0-保留，1-结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，主要提供给NVR使用，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）
    BYTE    byRepeatTimes;   //重复报警次数，0-无意义
    BYTE    byRes;
    NET_VCA_HUMAN_FEATURE   struFeature;  //人体属性
    float   fStayDuration;  //停留画面中时间(单位: 秒)
    char    sStorageIP[16];        //存储服务IP地址
    WORD    wStoragePort;            //存储服务端口号
    BYTE    byRes1[18];              // 保留字节
    BYTE*   pBuffer1;  //人脸子图的图片数据
    BYTE*   pBuffer2;  //背景图的图片数据（保留，通过查找背景图接口可以获取背景图）
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect; //人脸子图区域
    NET_VCA_POINT struLeftEyePoint;  //左眼位置
    NET_VCA_POINT struRightEyePoint; //右眼位置
    BYTE       byDistance;           //两眼间距
    BYTE       bySex;
    BYTE       byAgeGroup; 
    BYTE       byEyeGlass; 
    NET_VCA_RECT struPosRect;  //人脸位置区域
    BYTE       byRes[20];  //保留
    BYTE       *pImage;  //图片数据
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD     dwSize; //结构大小
    DWORD        dwRelativeTime; //相对时标
    DWORD       dwAbsTime; //绝对时标
    DWORD      dwBackgroundPicLen; //背景图的长度，为0表示没有图片，大于0表示有图片
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//人脸子图区域
    BYTE   byFacePicNum;//子图数量
    BYTE   byRes[255];
    BYTE*  pBackgroundPicpBuffer; //背景图的图片数据
}NET_DVR_FACE_DETECTION,*LPNET_DVR_FACE_DETECTION;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
    DWORD dwSize;   //结构大小
    DWORD dwImageId; //大图ID
    BYTE byRes[20]; //保留
    DWORD dwSubImageNum;  //人脸子图张数
    NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];  //单张子图信息
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

//虚焦侦测结果
typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     /*结构长度*/
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    BYTE    byRes[64];        // 保留字节
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     /*结构长度*/
    BYTE  byAlarmType;//报警类型，1-音频输入异常，2-音频输入突变（声强陡升），3-声强陡降，4-音频丢失
    BYTE  byRes1;
    WORD wAudioDecibel;//声音强度（音频输入突变时用到）
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    BYTE    byRes[64];        // 保留字节
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct  tagNET_BUTTON_DOWN_EXCEPTION_ALARM
{
    DWORD      dwSize;     /*结构长度*/
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    BYTE    byRes[64];        // 保留字节
}NET_BUTTON_DOWN_EXCEPTION_ALARM, *LPNET_BUTTON_DOWN_EXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //灰度图像数据宽度
    DWORD   dwHeight;                 //灰度图像高度
    DWORD   dwImageLen;  //灰度图像数据长度
    BYTE     byRes[20];  //保留
    BYTE     *pImage;    //灰度图像数据
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //结构大小
    BYTE     byEnable;         //是否激活规则;
    BYTE     bySensitivity;      //检测灵敏度，[0,5]
    BYTE     byRes1[22];       //保留字节 
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_VCA_POLYGON   struPolygon;    //多边形
    NET_VCA_FD_IMAGE_CFG struFDImage;  //图片信息
    BYTE     byRes2[20];    //保留
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect; //人脸子图区域
    BYTE  byRes[20];  //保留
    BYTE  *pImage;  //图片数据
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;   //结构大小
    DWORD dwImageId; //大图ID
    BYTE byRes[20]; //保留
    DWORD dwSubImageNum;  //人脸子图张数
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //单张子图信息
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwModelLen;  //模型数据长度
    BYTE  byRes[20]; //保留
    BYTE  *pImage;  //人脸图片数据指针
    BYTE  *pModel;  //模型数据指针
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //大图ID
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect;  //人脸子图区域
    BYTE  byRes[20];  //保留
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

#define MAX_HUMAN_PICTURE_NUM  10   //最大照片数
#define MAX_HUMAN_BIRTHDATE_LEN 10   //最大出生年月长度

typedef struct tagNET_DVR_AREAINFOCFG
{ 
    WORD wNationalityID; //国籍
    WORD wProvinceID; //省
    WORD wCityID; //市
    WORD wCountyID; //县
    BYTE byRes[4]; //保留
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //性别：0-男，1-女
    BYTE   byCertificateType; //证件类型：0-身份证，1-警官证
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //出生年月，如：201106
    BYTE   byName[NAME_LEN]; //姓名
    NET_DVR_AREAINFOCFG struNativePlace; //籍贯参数
    BYTE   byCertificateNumber[NAME_LEN];  //证件号
    BYTE   byRes2[20];
}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //性别：0-不启用，1-男，2-女
    BYTE   byCertificateType; //证件类型：0-不启用，1-身份证，2-警官证
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE   byName[NAME_LEN]; //姓名
    NET_DVR_AREAINFOCFG struNativePlace; //籍贯参数
    BYTE   byCertificateNumber[NAME_LEN];  //证件号
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;


typedef struct tagNET_VCA_BLACKLIST_INFO
{
    DWORD  dwSize;   //结构大小
    DWORD  dwRegisterID;  //名单注册ID号（只读）
    DWORD  dwGroupNo; //分组号
    BYTE   byType; //黑白名单标志：0-全部，1-白名单，2-黑名单
    BYTE   byLevel; //黑名单等级，0-全部，1-低，2-中，3-高
    BYTE   byRes1[2];  //保留
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE   byRemark[NAME_LEN]; //备注信息
    BYTE   byRes2[20];
}NET_VCA_BLACKLIST_INFO, *LPNET_VCA_BLACKLIST_INFO;

typedef struct tagNET_VCA_BLACKLIST_PARA
{
    DWORD dwSize;   //结构大小
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //黑名单基本参数
    DWORD dwRegisterPicNum;  //黑名单图个数
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //黑名单图片信息
    BYTE  byRes[40]; //保留
}NET_VCA_BLACKLIST_PARA, *LPNET_VCA_BLACKLIST_PARA;

typedef struct tagNET_VCA_BLACKLIST_COND
{
    LONG  lChannel; //通道号
    DWORD dwGroupNo; //分组号
    BYTE  byType; //黑白名单标志：0-全部，1-白名单，2-黑名单
    BYTE  byLevel; //黑名单等级，0-全部，1-低，2-中，3-高
    BYTE  byRes1[2];  //保留
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //人员信息
    BYTE  byRes[20];
}NET_VCA_BLACKLIST_COND, *LPNET_VCA_BLACKLIST_COND;

typedef struct tagNET_VCA_BLACKLIST_PIC
{
    DWORD dwSize;   //结构大小
    DWORD dwFacePicNum;  //人脸图个数
    BYTE  byRes[20]; //保留
    NET_VCA_PICMODEL_RESULT  struBlackListPic[MAX_HUMAN_PICTURE_NUM];  //单张照片信息
}NET_VCA_BLACKLIST_PIC, *LPNET_VCA_BLACKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE byRes[12]; //保留
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

#define MAX_FACE_PIC_LEN   6144   //最大人脸图片数据长度
typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    NET_DVR_TIME struSnapTime;  //抓拍时间
    DWORD dwSimilarity; //相似度
    BYTE  byRes[16];  //保留
    char  sPicBuf[MAX_FACE_PIC_LEN];  //图片数据
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //人脸图片ID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //大图ID
    DWORD dwFaceScore;  //人脸评分
    NET_VCA_RECT struVcaRect; //人脸子图区域
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;

typedef union tagNET_VCA_FIND_SNAPPIC_UNION
{
    NET_VCA_NORMAL_FIND  struNormalFind; //普通检索
    NET_VCA_ADVANCE_FIND struAdvanceFind; //高级检索
}NET_VCA_FIND_SNAPPIC_UNION, *LPNET_VCA_FIND_SNAPPIC_UNION;

typedef enum _VCA_FIND_SNAPPIC_TYPE_
{
    VCA_NORMAL_FIND  = 0x00000000,   //普通检索
        VCA_ADVANCE_FIND  = 0x00000001  //高级检索
}VCA_FIND_SNAPPIC_TYPE;

typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE byThreshold;  //阈值，0-100
    BYTE byRes[23]; //保留
    VCA_FIND_SNAPPIC_TYPE dwFindType;//检索类型，详见VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //检索参数
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;     // 相对时标
    DWORD dwAbsTime;            // 绝对时标
    DWORD dwSnapFacePicID;       //抓拍人脸图ID
    DWORD dwSnapFacePicLen;        //抓拍人脸子图的长度，为0表示没有图片，大于0表示有图片
    NET_VCA_DEV_INFO struDevInfo;        //前端设备信息
       BYTE  byRes[20];              // 保留字节
    BYTE  *pBuffer1;  //抓拍人脸子图的图片数据
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //黑名单基本信息
    DWORD dwBlackListPicLen;       //黑名单人脸子图的长度，为0表示没有图片，大于0表示有图片
       BYTE  byRes[20];              // 保留字节
    BYTE  *pBuffer1;  //黑名单人脸子图的图片数据
}NET_VCA_BLACKLIST_INFO_ALARM, *LPNET_VCA_BLACKLIST_INFO_ALARM;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;             // 结构大小
    float fSimilarity; //相似度，[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //抓拍信息
    NET_VCA_BLACKLIST_INFO_ALARM struBlackListInfo; //黑名单信息
    char         sStorageIP[16];        //存储服务IP地址
    WORD            wStoragePort;            //存储服务端口号
    BYTE             byRes[42];              // 保留字节
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;


typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //黑名单基本信息
    DWORD dwBlackListPicID;       //黑名单人脸子图ID，用于查找图片
       BYTE  byRes[20];              // 保留字节
}NET_VCA_BLACKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLACKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;     // 相对时标
    DWORD dwAbsTime;            // 绝对时标
    DWORD dwSnapFacePicID;       //抓拍人脸图ID
    NET_VCA_DEV_INFO       struDevInfo;        //前端设备信息
       BYTE  byRes[20];              // 保留字节
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;             // 结构大小
    float fSimilarity; //相似度，[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //抓拍信息
    NET_VCA_BLACKLIST_INFO_ALARM_LOG struBlackListInfoLog; //黑名单信息
    BYTE  byRes[60];              // 保留字节
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;

typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;             // 结构大小
       DWORD dwSnapFaceID; //抓拍人脸子图ID
    DWORD dwBlackListID; //匹配的黑名单ID
    DWORD dwBlackListFaceID; //比对的黑名单人脸子图ID
    BYTE  byRes[20];              // 保留字节
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;             // 结构大小
       DWORD dwSnapFaceLen; //抓拍人脸子图长度
    DWORD dwBlackListFaceLen; //比对的黑名单人脸子图长度
    BYTE  byRes[20];              //保留字节
    BYTE *pSnapFace;  //抓拍人脸子图的图片数据
    BYTE *pBlackListFace;  //比对的黑名单人脸子图数据
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLACKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //结构大小
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //黑名单基本参数
    DWORD dwImageLen;  //图像数据长度
    BYTE  byRes[124];  //保留
    BYTE  *pImage;    //图像数据
}NET_VCA_BLACKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLACKLIST_FASTREGISTER_PARA;

//单个分区配置
typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  // 是否可用,0-否,1-是 
    BYTE  byType;   //0-存储抓拍，1-存储黑名单比对报警，2-存储抓拍和黑名单比对报警，0xff-无效
    BYTE  bySaveAlarmPic; //是否用于保存断网的报警图片，0-否，1-是
    BYTE  byRes1[5]; //保留
    DWORD dwDiskDriver;   //盘符号，从0开始
    DWORD dwLeftSpace;   //预留容量（单位为G）
    BYTE  byRes2[8]; //保留
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

//存储路径设置
typedef struct tagNET_VCA_SAVE_PATH_CFG
{ 
    DWORD dwSize;   //结构大小
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //单个分区
    BYTE  byRes[40]; //保留
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR     struIP;        //接入设备的IP地址
    WORD     wDevicePort;                 //端口号
    BYTE    byEnable;                 //是否启用，0-否，1-是
    BYTE     byRes1;                //保留
    BYTE    sUserName[NAME_LEN];    //接入设备的登录帐号
    BYTE    sPassword[PASSWD_LEN];    //接入设备的登录密码
    BYTE    byRes2[60];
}NET_DVR_DEV_ACCESS_CFG,*LPNET_DVR_DEV_ACCESS_CFG;

/********************************智能人脸识别 end****************************/
//分辨率
#define MAKE_RESOLUTION(_interlace_, _width_, _height_, _fps_) \
    (((_interlace_)<<28) \
    |((((_width_)>>3)&0x1ff)<<19)| \
    ((((_height_)>>1)&0x7ff)<<8)| \
((_fps_)&0xff))
#define GET_RES_INTERLACE(_res_) \
(((_res_)>>28)&0x1)
#define GET_RES_WIDTH(_res_) \
((((_res_)>>19)&0x1ff)<<3)
#define GET_RES_HEIGHT(_res_) \
((((_res_)>>8)&0x7ff)<<1)
#define GET_RES_FPS(_res_) \
((_res_)&0xff)

#define NOT_AVALIABLE    MAKE_RESOLUTION (0,0,0,0)
#define SVGA_60HZ         MAKE_RESOLUTION(0, 800, 600, 60)
#define SVGA_75HZ         MAKE_RESOLUTION(0, 800, 600, 75)
#define XGA_60HZ         MAKE_RESOLUTION(0, 1024, 768, 60) 
#define XGA_75HZ         MAKE_RESOLUTION(0, 1024, 768, 75)
#define SXGA_60HZ          MAKE_RESOLUTION(0, 1280, 1024, 60)
#define SXGA2_60HZ      MAKE_RESOLUTION(0, 1280, 960, 60)
#define _720P_24HZ      MAKE_RESOLUTION(0, 1280, 720, 24)
#define _720P_25HZ      MAKE_RESOLUTION(0, 1280, 720, 25)
#define _720P_30HZ      MAKE_RESOLUTION(0, 1280, 720, 30)  
#define _720P_60HZ      MAKE_RESOLUTION(0, 1280, 720, 60)
#define _720P_50HZ      MAKE_RESOLUTION(0, 1280, 720, 50) 
#define _1080I_60HZ     MAKE_RESOLUTION(1, 1920, 1080, 60)
#define _1080I_50HZ      MAKE_RESOLUTION(1, 1920, 1080, 50)
#define _1080P_60HZ     MAKE_RESOLUTION(0, 1920, 1080, 60)
#define _1080P_50HZ     MAKE_RESOLUTION(0, 1920, 1080, 50)
#define _1080P_30HZ     MAKE_RESOLUTION(0, 1920, 1080, 30)
#define _1080P_25HZ     MAKE_RESOLUTION(0, 1920, 1080, 25)
#define _1080P_24HZ     MAKE_RESOLUTION(0, 1920, 1080, 24)
#define UXGA_60HZ          MAKE_RESOLUTION(0, 1600, 1200, 60)
#define UXGA_30HZ          MAKE_RESOLUTION(0, 1600, 1200, 30)
#define WSXGA_60HZ         MAKE_RESOLUTION(0, 1680, 1050, 60)
#define WUXGA_60HZ      MAKE_RESOLUTION(0, 1920, 1200, 60)
#define WUXGA_30HZ         MAKE_RESOLUTION(0, 1920, 1200, 30)
#define WXGA_60HZ          MAKE_RESOLUTION(0, 1360, 768, 60)
#define SXGA_PLUS_60HZ    MAKE_RESOLUTION(0, 1400, 1050, 60)
#define VGA_MODE_3840x2160_30HZ MAKE_RESOLUTION(0, 3840, 2160, 30)
#define VGA_MODE_3840x2160_60HZ MAKE_RESOLUTION(0, 3840, 2160, 60)



//显示通道画面分割模式
#define  MAX_WINDOWS_NUM 12        //画面分割模式的数量
#define  MAX_SUPPORT_RES 32
#define  MAX_DISPNUM_V41 32
#define  MAX_SDI_RES     16     //SDI显示通道最大支持分辨率数

typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//显示通道类型：0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
    BYTE byDispChanSeq;//显示通道序号,从1开始，如果类型是VGA，则表示第几个VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;

typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//通道个数
    BYTE  byStartChan;//起始通道
    BYTE  byRes[2];
    DWORD    dwSupportResolution[MAX_SUPPORT_RES/*32*/];//支持分辨率
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

//大屏拼接信息
typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//最多大屏拼接数量
    BYTE  byStartBigScreenNum;//大屏拼接起始号
    BYTE  byMaxScreenX;//大屏拼接模式
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//通道个数
    BYTE  byStartChan;//起始通道
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//支持分辨率
}NET_DVR_SDI_INFO,*LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP个数  
    BYTE  byDecChanNums;//解码通道数
    BYTE  byStartChan;//起始解码通道
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//VGA显示通道信息
    NET_DVR_DISPINFO struBncInfo;//BNC显示通道信息
    NET_DVR_DISPINFO struHdmiInfo;//HDMI显示通道信息
    NET_DVR_DISPINFO struDviInfo;//DVI显示通道信息
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //是否支持自动重启，0-不支持，1-支持
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI显示通道信息
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;

//显示通道配置
#define  MAX_WINDOWS                16
#define  MAX_WINDOWS_V41            36

#define  STARTDISPCHAN_VGA        1
#define  STARTDISPCHAN_BNC        9
#define  STARTDISPCHAN_HDMI        25
#define  STARTDISPCHAN_DVI        29

typedef union tagNET_DVR_VIDEO_PLATFORM
{
    BYTE byRes[160];
    struct
    {
        /*各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)*/
        //如果综合平台支持自动分配解码资源，此参数不需要填充
        BYTE    byJoinDecoderId[MAX_WINDOWS_V41];
        //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
        BYTE    byDecResolution[MAX_WINDOWS_V41];
        NET_DVR_RECTCFG struPosition; //显示通道在电视墙中位置
        BYTE    byRes[80];
    }struVideoPlatform;
    struct
    {
        BYTE    byRes[160];
    }struNotVideoPlatform;
}NET_DVR_VIDEO_PLATFORM, LPNET_DVR_VIDEO_PLATFORM;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*音频是否开启*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE    byDispChanType;      /*显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI，4-YPbPr(解码卡服务器DECODER_SERVER专用)*/   
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL，0-NULL*/
    DWORD    dwResolution;//分辨率
    DWORD    dwWindowMode;        /*画面模式，能力集获取*/       
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*各个子窗口关联的解码通道,设备支持解码资源自动分配时此参数不用填充*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    BYTE    byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
    BYTE    byUnionType;/*区分共用体,0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    NET_DVR_VIDEO_PLATFORM        struDiff;
    DWORD   dwDispChanNum; //显示输出号，此参数在全部获取时有效
    WORD     wLEDWidth;     //LED分辨率宽，0为无效   
    WORD     wLEDHeight;    //LED分辨率高，0为无效
    BYTE      byEnableVideoEffect;  //显示效果使能， 0-不使能， !0-使能
    BYTE      byRes[3];  //保留字段
    NET_DVR_VIDEOEFFECT struVideoEffect;   //显示效果
    BYTE    byRes2[60];
}NET_DVR_MATRIX_VOUTCFG,*LPNET_DVR_MATRIX_VOUTCFG;

/*解码器设备状态*/
typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*显示状态：0：未显示，1：启动显示*/
    BYTE  byBVGA;              /*0-BNC，1-VGA， 2-HDMI，3-DVI，4-SDI 0xff-无效*/
    BYTE  byVideoFormat;     /*视频制式，1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;       /*画面模式*/
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*各个子画面关联的解码通道*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*每个子画面的显示帧率*/
    BYTE  byScreenMode;        /*屏幕模式0-普通 1-大屏*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*获取全部显示通道状态时有效，设置时可填0*/
    BYTE  byRes2[24];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

/*解码器设备状态*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*解码通道状态*/
    /*显示通道状态*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];     
    BYTE byAlarmInStatus[32];         /*报警输入状态*/
    BYTE byAlarmOutStatus[32];       /*报警输出状态*/
    BYTE byAudioInChanStatus;          /*语音对讲状态*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41,*LPNET_DVR_DECODER_WORK_STATUS_V41;
/*******************************文件回放-远程回放设置*******************************/
typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struIP;        /* DVR IP地址 */    
    WORD    wDVRPort;            /* 端口号 */    
    BYTE    byChannel;            /* 通道号 */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE    byRes[64];        /*保留*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;


#define  MAX_BIGSCREENNUM_SCENE 100
#define  MAX_LAYERNUMS    32

//显示通道配置结构
typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; /*矩形左上角起始点X坐标*/
    WORD wYCoordinate; /*矩形左上角Y坐标*/
    WORD wWidth;       /*矩形宽度*/
    WORD wHeight;      /*矩形高度*/
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{       
    BYTE    byEnable;//是否启用，0-不启用，1-启用
    BYTE    bySoltNum;//槽位号
    BYTE    byRes1[2]; 
    BYTE    byDispChanNum; 
    BYTE    byAudio;                /*音频是否开启,0-否，1-是*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE    byVedioFormat;          /*1:NTSC,2:PAL，0-NULL*/
    BYTE    byWindowMode;            /*画面模式，从能力集获取*/   
    BYTE    byEnlargeStatus;         /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号    
    BYTE    byScale; /*显示模式，0-真实显示，1-缩放显示( 针对BNC )*/
    DWORD   dwResolution;//分辨率
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*各个子窗口关联的解码通道*/
    BYTE    byJoinDecoderId[MAX_WINDOWS_V41];/*槽位号*/
    //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
    BYTE    byDecResolution[MAX_WINDOWS_V41];
    BYTE    byRow;//大屏所在的行的序号
    BYTE    byColumn;//大屏所在的列的序号
    BYTE    byRes2[5];
    NET_DVR_RECTCFG struDisp; //电视墙显示位置
} NET_DVR_SCENEDISPCFG,*LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;                /* DVR IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byChannel;        /* 通道号，对于9000等设备的IPC接入，通道号从33开始 */
    BYTE    byTransProtocol;        /* 传输协议类型0-TCP，1-UDP ，2-MCAST，3-RTP*/
    BYTE    byTransMode;            /* 传输码流模式 0－主码流 1－子码流*/
    BYTE    byFactoryType;                /*前端设备厂家类型*/
    BYTE    byDeviceType;            //设备类型，1-IPC，2- ENCODER
    BYTE    byRes[5];
    BYTE    sUserName[NAME_LEN];    /* 监控主机登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];    /* 监控主机密码 */
} NET_DVR_DEV_CHAN_INFO_SCENE,*LPNET_DVR_DEV_CHAN_INFO_SCENE;

/*流媒体服务器基本配置*/
typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE    byValid;            /*是否启用流媒体服务器取流,0表示无效*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR struDevIP;    /*流媒体服务器地址*/
    WORD    wDevPort;            /*流媒体服务器端口*/
    BYTE    byTransmitType;        /*传输协议类型0-TCP，1-UDP */
    BYTE    byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE,*LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE                            byEnable;    /* 是否启用 0－否 1－启用*/
    BYTE                            byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    struStreamMediaSvrCfg;    
    NET_DVR_DEV_CHAN_INFO_SCENE            struDecChanInfo;    /*轮巡解码通道信息*/
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE,*LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//轮巡解码结构
typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD    wPoolTime;        /*轮询间隔*/
    BYTE    byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE    struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE,*LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//单个解码通道配置结构体
typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE    byDecodeEnable;//解码起停标志，0-停止，1-启用动态解码，2-启用轮巡解码
    BYTE    bySlotNum;//槽位号
    BYTE    byDecChan;
    BYTE    byJointAllDecodeChan;        //是否关联万能解码通道 0-不关联，1-关联
    BYTE    byJointSlotNum;            //关联的槽位号（万能解码板的槽位号）
    BYTE    byJointChanNum;        //关联的通道号（万能解码板通道号）
    BYTE    byRes[2];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg; 
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE,*LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid; /*漫游使能标志 */
    BYTE byAssociateBaseMap;//关联的底图序号，0代表不关联
    BYTE byEnableSpartan;//大屏畅显使能，1-开，0-关
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;//大屏的个数，最大值通过能力集获取
    BYTE  byRes1[3];
    WORD  wDecChanNums;//场景中解码通道的个数
    WORD  wDispChanNums;//场景中显示通道的个数
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//大屏配置缓冲区, byBigScreenNums×sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;//解码通道配置缓冲区, wDecChanNums×sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;//显示通道配置缓冲区, wDispChanNums×sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;



typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;//使能底图显示
    BYTE  byAssociateBaseMap;//关联的底图序号，0代表不关联
    BYTE  byEnableSpartan;//大屏畅显使能，1-开，0-关
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;
/*******************************窗口设置*******************************/
#define MAX_WIN_COUNT  224 //支持的最大开窗数

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD    dwSize;
    BYTE    byVaild;
    BYTE    byInputType;        //见CAM_MDOE
    WORD    wInputIdx;            /*输入源索引*/
    DWORD    dwLayerIdx;            /*图层，0为最底层*/
    NET_DVR_RECTCFG  struWin;    //目的窗口(相对显示墙)
    BYTE    byWndIndex;            //窗口号
    BYTE    byCBD;                //0-无，1-带背景，2-不带背景
    BYTE    bySubWnd;            //0不是，1是
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//设备序号
    BYTE    byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD    dwSize;
    WORD    wScreenSeq;    //设备序号
    BYTE    byRes[10];
    DWORD    dwWinNum;    //设备返回的窗口数量
    BYTE    *pBuffer;    //窗口信息缓冲区，最大为224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;    //所分配指针长度
}NET_DVR_WINLIST,*LPNET_DVR_WINLIST;

#define MAX_LAYOUT_COUNT 16        //最大布局数
typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;                                //布局是否有效
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];            //布局名称            
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];    //布局内窗口参数
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];   //所有布局
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;

#define MAX_CAM_COUNT  224

typedef enum tagNET_DVR_CAM_MODE
{
    NET_DVR_UNKNOW  = 0,//无效
        NET_DVR_CAM_BNC,
        NET_DVR_CAM_VGA,
        NET_DVR_CAM_DVI,
        NET_DVR_CAM_HDMI,
        NET_DVR_CAM_IP,
        NET_DVR_CAM_RGB,
        NET_DVR_CAM_DECODER,
        NET_DVR_CAM_MATRIX,
        NET_DVR_CAM_YPBPR,
        NET_DVR_CAM_USB,
        NET_DVR_CAM_SDI,
        NET_DVR_CAM_HDI,
        NET_DVR_CAM_DP,
        NET_DVR_CAM_HDTVI,
        NET_DVR_CAM_JOINT,   //拼接信号源
        NET_DVR_CAM_HDBASET,
}NET_DVR_CAM_MODE;

typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD    dwSize ;
    BYTE    byValid;
    BYTE    byCamMode;                        //信号输入源类型，见NET_DVR_CAM_MODE
    WORD    wInputNo;                        //信号源序号0-224
    BYTE    sCamName[NAME_LEN] ;            //信号输入源名称
    NET_DVR_VIDEOEFFECT struVideoEffect;    //视频参数
    NET_DVR_PU_STREAM_CFG    struPuStream;    //ip输入时使用
    WORD    wBoardNum ;                        //信号源所在的板卡号
    WORD    wInputIdxOnBoard;                //信号源在板卡上的位置
    DWORD   dwResolution;//分辨率
    BYTE    byVideoFormat;//视频制式，见VIDEO_STANDARD
    BYTE    byStatus;    //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常 
    BYTE    sGroupName[NAME_LEN/*32*/];    //网络信号源分组 组名
    BYTE    byJointMatrix;            //  关联矩阵 ，0-不关联  1-关联
    BYTE    byRes;  
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT]; //所有信号源
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

/*******************************输出参数配置*******************************/
/*输出通道管理*/
typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;        /*输出连接模式,1-BNC,2-VGA,3-DVI,4-HDMI*/
    BYTE   byRes1[3];
    DWORD  dwResolution;    /*分辨率，根据能力集获取所支持的进行设置*/
    NET_DVR_VIDEOEFFECT  struVideoEffect;    /*输出通道视频参数配置*/
    BYTE    byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD    dwSize;
    BYTE    byScreenLayX;                        //大屏布局-横坐标
    BYTE    byScreenLayY;                        //大屏布局-纵坐标
    WORD    wOutputChanNum;                    //输出通道个数，0表示设备支持的最大输出通道个数，最大个数从能力集获取，其他值表示实际输出通道个数
    BYTE    byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;    /*输出通道视频参数配置*/
    BYTE    sWallName[16];                    //电视墙名称
    BYTE    byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

/*******************************能力集*******************************/
#define SCREEN_PROTOCOL_NUM      20    //支持的最大大屏控制器协议数
//多屏服务器能力集
typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;               /*结构长度*/
    BYTE byIsSupportScreenNum; /*所支持大屏控制器的数目*/
    BYTE bySerialNums;            //串口个数
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//大屏布局-最大横坐标大屏数
    BYTE byMaxScreenLayY;//大屏布局-最大纵坐标大屏数
    WORD wMatrixProtoNum; /*有效的大屏协议数目*/
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];/*最大协议列表*/
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

//多屏控制器能力集
typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;           /*结构长度*/
    BYTE byLayoutNum;         /* 布局个数*/
    BYTE byWinNum;             /*屏幕窗口个数*/
    BYTE byOsdNum;          /*OSD个数*/
    BYTE byLogoNum;         /*Logo个数*/
    BYTE byInputStreamNum;  //输入源个数 ---设备支持最大输入通道个数（包括本地输入源和网络输入源）
    BYTE byOutputChanNum;    //输出通道个数---设备支持最大输出通道个数
    BYTE byCamGroupNum;        /*分组个数*/
    BYTE byPlanNum;            /*预案个数*/
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  /*是否支持回放*/    
    BYTE byMatrixInputNum;  //支持输入矩阵最大个数
    BYTE byMatrixOutputNum; //支持输出矩阵最大个数
    NET_DVR_DISPINFO struVgaInfo;//VGA输出信息
    NET_DVR_DISPINFO struBncInfo;//BNC输出信息
    NET_DVR_DISPINFO struHdmiInfo;//HDMI输出信息
    NET_DVR_DISPINFO struDviInfo;//DVI输出信息
    BYTE byMaxUserNums;//支持用户数
    BYTE byPicSpan;        //底图跨度，一张底图最多可覆盖的屏幕数
    WORD wDVCSDevNum;    //分布式大屏控制器最大设备数
    WORD wNetSignalNum;    //最大网络输入源个数
    WORD wBaseCoordinateX;//基准坐标
    WORD wBaseCoordinateY; 
    BYTE byExternalMatrixNum;    //最大外接矩阵个数
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

/*******************************输入信号状态*******************************/
typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD    dwLostFrame;        /*视频输入丢帧数*/
    BYTE    byHaveSignal;        /*是否有视频信号输入*/
    BYTE    byVideoFormat;        /*视频制式，1：NTSC,2：PAL,0：无*/
    BYTE    byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;

typedef union tagNET_DVR_INPUTSTATUS_UNION
{
    NET_DVR_MATRIX_CHAN_STATUS struIpInputStatus;
    NET_DVR_ANALOGINPUTSTATUS struAnalogInputStatus;
} NET_DVR_INPUTSTATUS_UNION, *LPNET_DVR_INPUTSTATUS_UNION;

typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD    wInputNo;        /*信号源序号*/
    BYTE    byInputType;    //见NET_DVR_CAM_MODE
    BYTE    byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE    byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwNums;        //设备返回的输入源状态的数量
    BYTE    *pBuffer;    //缓冲区
    DWORD   dwBufLen;    //所分配指针长度，输入参数
}NET_DVR_SCREENINPUTSTATUS,*LPNET_DVR_SCREENINPUTSTATUS;

typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD    dwSize;
    BYTE    byAlarmType;    //报警类型，1-子板拔出，2-子板插入，3-子系统状态异常，4-子系统恢复恢复 5-输入源异常   6-温度报警 7-FPGA版本不匹配 8-预案开始 9-预案结束 10-解码板断网 11-解码板IP地址冲突，12-风扇异常
    BYTE    byBoardType;    // 1-输入板 2-输出板 ，3-主板，4-背板，报警类型为1，2，3，6的时候使用 
    BYTE    bySubException;    //输入异常时具体子异常 1- 分辨率正常改变 2-输入端口类型改变3-分辨率错误4-分辨率改变导致解码资源不足，关闭该输入源对应窗口。5-分辨率改变，导致已开窗的缩放比例不在1/8到8倍范围。6-分辨率恢复正常,7-分辨率改变导致输出板数据量超限,设备关闭窗口 
    BYTE    byRes1;
    WORD    wStartInputNum; // 异常输入源（异常起点） 
    WORD    wEndInputNum;    // 异常输入源（异常终点） 
    BYTE    byRes2[16];       
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;                //判断是否是模拟矩阵（是否有效）
    BYTE  byCommandProtocol;    //模拟矩阵的指令（4种）
    BYTE  byScreenType;            //保留    
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];    //模拟矩阵的输出与屏幕的对应关系
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;/*设备为数字设备时的IP信息*/
    WORD            wPort;        //通道号
    BYTE            byRes[26];  //保留
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;
typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE    byDevSerPortNum;   /*连接设备的串口号*/
    BYTE    byScreenSerPort;  /*连接大屏的串口号*/
    BYTE    byRes[130];   
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;

typedef union tagNET_DVR_SCREEN_UNION
{
    NET_DVR_DIGITALSCREEN struDigitalScreen;
    NET_DVR_ANALOGSCREEN struAnalogScreen;
}NET_DVR_SCREEN_UNION, *LPNET_DVR_SCREEN_UNION;
typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;                //是否有效
    BYTE nLinkMode;                //连接方式，0-串口，1-网口
    BYTE byDeviceType;            //设备型号，能力集获取
    BYTE byScreenLayX;            //大屏布局-横坐标
    BYTE byScreenLayY;            //大屏布局-纵坐标
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];    /*登录用户名*/
    BYTE sPassword[PASSWD_LEN]; /*登录密码*/   
    BYTE sDevName[NAME_LEN];    /*设备名称*/
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;            // 输入源个数
    BYTE byOutputNum;            // 输出源个数
    BYTE byCBDNum;                //CBD个数
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

/*******************************底图上传*******************************/
typedef struct tagNET_DVR_BASEMAP_CFG
{    
    BYTE byScreenIndex;         //屏幕的序号
    BYTE byMapNum;                /*被分割成了多少块 */
    BYTE res[2];
    WORD wSourWidth;            /* 原图片的宽度 */
    WORD wSourHeight;            /* 原图片的高度 */
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;


typedef struct tagNET_DVR_PICCFG
{
    DWORD    dwSize;        //大小
    BYTE    byUseType;    //1-底图，2-GIF图片，3-CAD图片 4-输出口图片
    BYTE    bySequence;//序号    
    BYTE    byRes[2];
    NET_DVR_BASEMAP_CFG    struBasemapCfg;
    BYTE    sPicName[NAME_LEN];//图片名称
    DWORD   dwVideoWall;       //墙号 1字节墙号+3字节保留
    BYTE    byRes2[28];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;

/*******************************OSD*******************************/
#define MAX_OSDCHAR_NUM 256
typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*是否有效 0无效 1有效*/
    BYTE    byDispMode;  //显示模式，1-透明，2-半透明，3-覆盖三种模式
    BYTE    byFontColorY; /*字体颜色Y,0-255*/
    BYTE    byFontColorU; /*字体颜色U,0-255*/
    BYTE    byFontColorV; /*字体颜色V,0-255*/
    BYTE    byBackColorY; /*背景颜色Y,0-255*/
    BYTE    byBackColorU; /*背景颜色U,0-255*/
    BYTE    byBackColorV; /*背景颜色V,0-255*/
    WORD    wXCoordinate;   /*OSD在屏幕左上角位置x*/
    WORD    wYCoordinate;   /*OSD在屏幕左上角位置y*/
    WORD    wWidth;       /*OSD宽度*/
    WORD    wHeight;      /*OSD高度*/
    DWORD   dwCharCnt;     /*字符的个数*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM];       /*OSD字符内容*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;


/*******************************获取串口信息*******************************/
typedef struct tagNET_DVR_SERIAL_CONTROL
{ 
    DWORD    dwSize ;
    BYTE    bySerialNum;        // 串口个数
    BYTE    byRes1[3];
    BYTE    bySerial[32];
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;

/*******************************屏幕控制*******************************/
//屏幕输入源控制
typedef enum tagINPUT_INTERFACE_TYPE
{
    INTERFACE_VGA = 0,
        INTERFACE_SVIDEO, // 2046NL不支持，2046NH支持
        INTERFACE_YPBPR,
        INTERFACE_DVI ,
        INTERFACE_BNC , 
        INTERFACE_DVI_LOOP,//(环通) 2046NH不支持，2046NL支持
        INTERFACE_BNC_LOOP, //(环通) 2046NH不支持，2046NL.支持
        INTERFACE_HDMI,
        INTERFACE_IP,
        INTERFACE_USB,
        INTERFACE_SDI,
        INTERFACE_DP,
        INTERFACE_HDBASET
}INPUT_INTERFACE_TYPE;
typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE    byInputSourceType;    //见INPUT_INTERFACE_TYPE
    BYTE    byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;
//显示单元颜色控制
typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE    byColorType;        //1-亮度 2-对比度 3-饱和度 4-清晰度
    char    byScale;            //-1 、0、+1三个值
    BYTE    byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;
//显示单元位置控制
typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE    byPositionType;    //1-水平位置 2-垂直位置，
    char    byScale;            //-1 、0、+1三个值
    BYTE    byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;


/*******************************屏幕控制V41*******************************/
typedef struct tagNET_DVR_RECTCFG_EX 
{
    DWORD dwXCoordinate; /*矩形左上角起始点X坐标*/
    DWORD dwYCoordinate; /*矩形左上角Y坐标*/
    DWORD dwWidth;       /*矩形宽度*/
    DWORD dwHeight;      /*矩形高度*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;

/*******************************预案管理*******************************/
#define        MAX_PLAN_ACTION_NUM     32     //预案动作个数
#define        DAYS_A_WEEK                7    //一周7天
#define        MAX_PLAN_COUNT            16    //预案个数


typedef enum
{
    NET_DVR_SWITCH_LAYOUT = 1,         // 布局切换 默认
        NET_DVR_SCREEN_POWER_OFF,          // 关闭大屏幕显示
        NET_DVR_SCREEN_POWER_ON,           // 打开大屏幕显示
}NET_DVR_PLAN_OPERATE_TYPE;

/*预案项信息*/
typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE      byValid;          // 该项是否有效
    BYTE      byType;           // 见定义NET_DVR_PLAN_OPERATE_TYPE
    WORD      wLayoutNo;      // 布局号
    BYTE    byScreenStyle;    //屏幕型号，开关机所用，1是低亮，2是高亮
    BYTE    byRes1[3];
    DWORD      dwDelayTime;      // 一个项的运行时间, 单位秒
    DWORD   dwSerialNo;        //串口号，屏幕控制时使用
    BYTE    byRes2[28];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;
typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE    byValid; 
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;
/*预案管理*/
typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD     dwSize;
    BYTE      byValid;          // 该预案是否有效
    BYTE      byWorkMode;      // 预案工作模式 1表示手动，2自动，3预案循环
    BYTE    byWallNo;        //电视墙号，从1开始
    BYTE    byPlanNo;    //预案号，获取预案列表时有效，0-无效或不支持
    BYTE      byPlanName[NAME_LEN/*32*/]; //预案名称
    NET_DVR_TIME_EX struTime; // 工作模式为自动时使用
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*循环时间，周期为一个星期，年、月、日三个参数不使用。如：struTimeCycle[0]中的byValid的值是1，表示星期天执行该预案。星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推*/
    DWORD     dwWorkCount;      // 预案内容执行次数，0为一直循环播放，其他值表示次数
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // 预案执行的内容
    BYTE    byRes2[64];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;


/*******************************获取设备状态*******************************/
/*预案列表*/
typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD        dwSize;
    DWORD        dwPlanNums;            //设备输入信号源数量
    BYTE          *pBuffer;            //指向dwInputSignalNums个NET_DVR_PLAN_CFG结构大小的缓冲区
    BYTE        byWallNo;            //墙号，从1开始
    BYTE        byRes1[2];
    DWORD         dwBufLen;            //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_PLAN_CFG结构大小）
    BYTE        byRes2[64];
} NET_DVR_PLAN_LIST,*LPNET_DVR_PLAN_LIST;


/*******************************预案控制*******************************/
//该结构体可作为通用控制结构体
typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD    dwSize;
    BYTE    sDeviceID[NAME_LEN]; //被控设备的设备ID
    WORD    wChan;                 //被控通道
    BYTE    byIndex;             //控制索引，根据命令确定具体表示什么索引
    BYTE    byRes1;
    DWORD    dwControlParam;
    BYTE    byMandatoryAlarm;    //1-使能  0-不使能
    BYTE    byRes2[31];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

/*******************************获取设备状态*******************************/
typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD     dwSize;
    DWORD    dwMemoryTotal;        //内存总量    单位Kbyte
    DWORD    dwMemoryUsage;        //内存使用量 单位Kbyte
    BYTE    byCPUUsage;            //CPU使用率 0-100
    BYTE    byMainFrameTemp;   //机箱温度，单位：摄氏度
    BYTE    byBackPanelTemp;    //背板温度，单位：摄氏度
    BYTE    byRes1[1];
    BYTE    byLeftDecResource[32];   //各解码板剩余解码资源，以解D1分辨率资源为单位，byLeftDecResource[i],表示槽位号i解码板剩余资源,0xff表示无效（非解码板或没插板子）
    float    fNetworkFlow;    //网络流量,单位：KB/s，保留小数点后两位
    BYTE    byRes[88];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

// 91系列HD-SDI高清DVR 相机信息
typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;
       char  sCameraInfo[32];        // 前端相机信息
    BYTE  byInterfaceType;        // 前端接入接口类型，1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
       BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //音频输入类型，0-mic in，1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter; //是否开启声音过滤-关，-开
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-不启用，1-自动模式，2-开
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD        dwSize;
    DWORD        dwInputSignalNums;    //设备输入信号源数量
    BYTE          *pBuffer;            //指向dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小的缓冲区
    BYTE        byRes1[3];
    DWORD         dwBufLen;            //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小）
    BYTE        byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST,*LPNET_DVR_INPUT_SIGNAL_LIST;

// 安全拔盘状态
#define PULL_DISK_SUCCESS        1   // 安全拔盘成功
#define PULL_DISK_FAIL            2   // 安全拔盘失败
#define PULL_DISK_PROCESSING    3   // 正在停止阵列
#define PULL_DISK_NO_ARRAY         4    // 阵列不存在 
#define PULL_DISK_NOT_SUPPORT    5     // 不支持安全拔盘

// 扫描阵列状态
#define SCAN_RAID_SUC            1     // 扫描阵列成功
#define SCAN_RAID_FAIL            2     // 扫描阵列失败
#define SCAN_RAID_PROCESSING    3    // 正在扫描阵列
#define SCAN_RAID_NOT_SUPPORT    4     // 不支持阵列扫描

// 设置前端相机类型状态
#define SET_CAMERA_TYPE_SUCCESS            1   // 成功
#define SET_CAMERA_TYPE_FAIL            2   // 失败
#define SET_CAMERA_TYPE_PROCESSING        3   // 正在处理

//9000 2.2
typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD    dwSize;    //结构体大小
    BYTE    byType;    //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    BYTE     byRes[63]; //保留
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD          dwSize;        //结构体大小
    NET_DVR_TIME  strBeginTime;  //开始时间
    NET_DVR_TIME  strEndTime;    //结束时间
    BYTE          byType;        //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    BYTE           byRes[35];     //保留
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;                    //结构体大小
    BYTE     byPicQuota;                //图片百分比     [0%,  30%]
    BYTE     byRecordQuota;                //普通录像百分比 [20%, 40%]
    BYTE     byDrawFrameRecordQuota;    //抽帧录像百分比 [30%, 80%]
    BYTE     byRes[61];                    //保留字节
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //该端口是否使能映射
    WORD wExtPort;        //映射的外部端口号
    BYTE byRes[12];       //保留
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //结构体大小
    WORD wEnableUpnp;     //UPNP功能是否启用
    WORD wEnableNat;        //UPNP端口映射（NAT）功能是否启用(保留，与wEnableUpnp保持一致)
    NET_DVR_IPADDR  struIpAddr;      //NAT路由器LAN IP地址
    NET_DVR_NAT_PORT    struHttpPort;   //web server http端口映射配置
    NET_DVR_NAT_PORT    struCmdPort; //命令端口映射配置(8000)
    NET_DVR_NAT_PORT    struRtspPort;  //rtsp端口映射配置
    BYTE byFriendName[64]; //服务名
    BYTE byNatType; //UPNP端口映射类型，0-手动，1-自动
    BYTE            byRes1[3];    //保留
    NET_DVR_NAT_PORT    struHttpsPort;     //https端口映射配置
    BYTE            byres[76];    //保留
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;

typedef struct
{
    DWORD  dwEnabled;               //该端口是否被使能映射
    WORD   wInternalPort;           //映射前的端口
    WORD   wExternalPort;           //映射后的端口
                                    DWORD  dwStatus;                 /*端口映射状态
                                                                     0 未生效
                                                                     1 未生效：映射源端口与目的端口需一致
                                                                     2 未生效:  映射端口号已被使用
                                                                     3 生效
                                    */
                                    NET_DVR_IPADDR    struNatExternalIp;       //映射后的外部地址
                                    NET_DVR_IPADDR    struNatInternalIp;       //NAT路由器LAN IP地址
                                    BYTE   byRes[16];               //保留
}NET_DVR_UPNP_PORT_STATE, *LPNET_DVR_UPNP_PORT_STATE;


typedef struct
{
    NET_DVR_UPNP_PORT_STATE strUpnpPort[UPNP_PORT_NUM];     //端口映射状态,数组0 web server端口 数组1 管理端口 数组2 rtsp端口
    BYTE   byRes[200];              //保留
}NET_DVR_UPNP_NAT_STATE, *LPNET_DVR_UPNP_NAT_STATE;

typedef struct tagNET_DVR_PLAYCOND
{
    DWORD             dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE             byDrawFrame;  //0:不抽帧，1：抽帧
    BYTE             byStreamType ; //码流类型，0-主码流 1-子码流 2-码流三
    BYTE             byStreamID[STREAM_ID_LEN];
    BYTE             byRes[30];    //保留
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //交易类型 0-全部，1-查询， 2-取款， 3-存款， 4-修改密码，5-转账， 6-无卡查询 7-无卡存款， 8-吞钞 9-吞卡 10-自定义
    BYTE    byRes[3] ;    //保留
    DWORD  dwTransationAmount ;     //交易金额 ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO ;

typedef union  tagNET_DVR_SPECIAL_FINDINFO_UNION
{
    BYTE  byLenth[8] ;
    NET_DVR_ATMFINDINFO      struATMFindInfo;           //ATM查询
}NET_DVR_SPECIAL_FINDINFO_UNION, *LPNET_DVR_SPECIAL_FINDINFO_UNION;


typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;/*不带卡号录象文件类型0xff-全部，0-定时录像，1-移动侦测，2-报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，
    7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件，15-越界侦测，16-区域入侵，17-声音异常，18-场景变更侦测，19-智能侦测（越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测），
    20-人脸侦测， 21-信号量，22-回传，23-回迁录像，24-遮挡，25-pos录像，26-进入区域侦测, 27-离开区域侦测,28-徘徊侦测,29-人员聚集侦测,30-快速运动侦测,31-停车侦测,32-物品遗留侦测,33-物品拿取侦测, 
    34-火点侦测，35-防破坏检测，36-船只检测，37-测温预警，38-测温报警,39-打架斗殴报警，40-起身检测，41-瞌睡检测，42-测差报警*/
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;//是否带ATM信息进行查询：0-不带ATM信息，1-按交易卡号查询，2-按交易类型查询，3-按交易金额查询，4-按卡号、交易类型及交易金额的组合查询 5-按课程名称查找，此时卡号表示课程名称
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0:不抽帧，1：抽帧
    BYTE        byFindType; //0:查询普通卷，1：查询存档卷
    BYTE        byQuickSearch; //0:普通查询，1：快速（日历）查询
    BYTE        bySpecialFindInfoType ;    //专有查询条件类型 0-无效， 1-带ATM查询条件  
    DWORD       dwVolumeNum;  //存档卷号
    BYTE        byWorkingDeviceGUID[GUID_LEN];    //工作机GUID，通过获取N+1得到
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo ;   //专有查询条件
    BYTE        byStreamType;    //0-主码流，1-子码流，2-三码流，0xff-全部
    BYTE        byAudioFile;                //音频文件 0-非音频文件，1-音频文件
    BYTE        byRes2[30];    //保留
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

typedef struct 
{
    BYTE    sAESKey[16];        /*码流加密密钥*/
    BYTE    byRes[64];          /*保留字节*/
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;

typedef struct
{
    NET_DVR_IPADDR struIP;     //IP地址
    BYTE  byRes[128]; //保留
}NET_DVR_POE_CFG, *LPNET_DVR_POE_CFG;

#define MAX_PRO_PATH         256    //最大协议路径长度

typedef struct
{
    DWORD dwSize;              //结构体大小
    DWORD dwEnabled;           //是否启用该协议0 不启用 1 启用
    char  sProtocalName[DESC_LEN];   //自定义协议名称, 16位
    BYTE  byRes1[64];          //保留,用于协议名称扩展
    DWORD dwEnableSubStream;   //子码流是否启用0 不启用 1 启用
    
    BYTE  byMainProType;        //主码流协议类型 1 RTSP
    BYTE  byMainTransType;        //主码流传输类型 0：Auto 1：udp 2：rtp over rtsp
    WORD  wMainPort;           //主码流端口    
    char  sMainPath[MAX_PRO_PATH];  //主码流路径
    
    BYTE  bySubProType;         //子码流协议类型 1 RTSP
    BYTE  bySubTransType;        //子码流传输类型 0：Auto 1：udp 2：rtp over rtsp
    WORD  wSubPort;            //子码流端口
    char  sSubPath[MAX_PRO_PATH];   //子码流路径 
    
    BYTE  byRes2[200];          //保留
}NET_DVR_CUSTOM_PROTOCAL, *LPNET_DVR_CUSTOM_PROTOCAL;


//B10能支持PSIA设备
//循环上墙结构体（实时）
typedef struct  
{
    DWORD    dwEnable; /* 是否启用 0－否 1－启用*/
    BYTE    byType; //设备类型 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    BYTE    byRes[3];  //保留
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg; 
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; /* 轮循解码通道信息 */
    BYTE    sRtspUrl[128];//流地址
}NET_DVR_MATRIX_CHAN_INFO_EX,*LPNET_DVR_MATRIX_CHAN_INFO_EX;

typedef struct
{
    DWORD    dwSize;
    DWORD    dwPoolTime;    /*轮询间隔*/
    NET_DVR_MATRIX_CHAN_INFO_EX        struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE    byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_EX,*LPNET_DVR_MATRIX_LOOP_DECINFO_EX;

//实时预览上墙结构体
typedef struct
{
    DWORD dwSize;
    BYTE byType; //设备类型 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    BYTE byRes[3]; //保留
    NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO struDevChanInfo;
    BYTE sRtspUrl[128];//流地址
}NET_DVR_PU_STREAM_CFG_EX,*LPNET_DVR_PU_STREAM_CFG_EX;

typedef struct tagNET_DVR_MATRIX_TRUNKCFG
{
    DWORD     dwGlobalIndex;  //主键
    DWORD     dwInterIndex;   //本地全局编号
    BYTE      sTrunkName[NAME_LEN];
    BYTE      byType;   //设备类型1-bnc, 2-SP3, 3-V6
    BYTE      byDir;   //干线方向 1-输入2-输出
    BYTE      byAbility;   //干线能力，D1衡量
    BYTE      bySubsys;   //子系统ID
    BYTE      byChan;     //通道ID
    BYTE      byRes[255];     //预留
} NET_DVR_MATRIX_TRUNKCFG,*LPNET_DVR_MATRIX_TRUNKCFG;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//关联状态，0-没有关联，1-已经关联，通过其他字段判断被自己关联或被其他子系统关联，2-被占用，byDecodeAbility大于1时有效，3-被大屏主屏关联，4-被大屏子屏关联
    BYTE        byJoinSubSystem;// 所关联或占用的子系统槽位号
    BYTE        byJoinDispNum;// 所关联或占用的显示通道号
    BYTE        byJoinSubWindowNum;// 所关联或占用的子窗口号
    BYTE        byDecodeAbility;   //解码通道的当前解码能力，0-未关联，1-D1，2-720，3-1080
    BYTE        byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）*/
    BYTE    bySubSystemType; 
    BYTE    byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE    byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE    bySubSystemNum;//级联子系统槽位号，子系统类型是3或4时可用
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE    byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE    bySlotNum ;//槽位号，此参数只能获取
    BYTE    byUsedTrunk;//是否被干线使用，0-未被使用，1-被使用
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;

//////////子系统配置/////////////
#define MAX_ALARMHOSTKEYBOARD 64 //网络报警主机最大键盘数
typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //关联子系统号，按位表示，bit0表示该公共子系统关联子系统1.
    DWORD    dwJointSubSystem;
    BYTE    byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //表示被哪些公共子系统关联，按位表示，bit0 表示，该子系统.被关联到公共子系统1
    DWORD    dwBeJoinedSubSystem;
    BYTE    byRes[16];    
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;

typedef union tagNET_DVR_JOINT_SUB_SYSTEM
{
    // byPublicAttributeEnable为0时使用该变量
    NET_DVR_NOAMAL_SUB_SYSTEM     struNormalSubSystem;
    //byPublicAttributeEnable为1时使用该变量
    NET_DVR_PUBLIC_SUB_SYSTEM        struPublicSubSystem;
    BYTE    byRes[20];    
}NET_DVR_JOINT_SUB_SYSTEM,*LPNET_DVR_JOINT_SUB_SYSTEM;

#define MAX_SUBSYSTEM_ID_LEN 16 //子系统ID最大长度

//////////GPRS参数配置/////////////
#define    ACCOUNTNUM_LEN             6
#define ACCOUNTNUM_LEN_32             32
#define ACCOUNTNUM_LEN_V40      9
#define    APN_NAME_LEN            32
#define    APN_USERNAME_LEN        24
#define    APN_USERPASSWORD_LEN    16

typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD        dwSize;
    WORD        wEnterDelay;                    //进入延时,单位:秒, 范围：10-150 动环报警主机和自助行报警主机的延时时间在 NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间
    //具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    WORD        wExitDelay;//退出延时,单位:秒， 范围10-300
    BYTE        byHostageReport;                //挟持报告，0禁能 1使能
    BYTE        bySubsystemEnable;                //子系统使能
    BYTE        byKeyToneOfArmOrDisarm;            // 成功发送布撤防报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    BYTE        byKeyToneOfManualTestReport;    //成功发送测试报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    WORD        wDelayTime;                        //警号输出延时，当能力集中dwSupport1中的bit0位为1时，使用该参数设置警号输出时间。bit0为0时，使用NET_DVR_SIREN_PARAM中的wDelay参数设置警号输出时间
    BYTE        byEnableAlarmInDelay;//0--不启用(使用子系统延时),1--启用(使用防区延时)，默认不启用
    BYTE         byPublicAttributeEnable;        //是否为公共子系统
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;        
    BYTE        byKeyZoneArm;                    //是否支持钥匙防区对子系统进行布防操作
    BYTE        byKeyZoneArmReport;                //是否支持钥匙防区对子系统布防时发送布防报告
    BYTE        byKeyZoneDisarm;                //是否支持钥匙防区对子系统进行撤防操作
    BYTE        byKeyZoneDisarmReport;            //是否支持钥匙防区对子系统进行撤防操作时发送撤防报告
    BYTE        bySubSystemID[MAX_SUBSYSTEM_ID_LEN];    //子系统ID
    BYTE        byKeyZoneArmReportEnable;    //钥匙防区上传布防报告使能 0-禁能 1-使能
    BYTE        byKeyZoneArmEnable;    //钥匙防区使能， 0 -禁能 1-使能
    BYTE        byOneKeySetupAlarmEnable;          //一键布防使能
    BYTE        bySingleZoneSetupAlarmEnable;       //单防区布撤防使能
    BYTE        byCenterType;                    //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    BYTE        sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //中心帐号
    BYTE        sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //中心账号V40,使用此字段时sCenterAccount无效
    BYTE        byRes2[565];                    // 保留字节
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;//是否启用本次提醒 0-不启用，1-启用
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME,*LPNET_DVR_REMIND_TIME;

//子系统参数配置扩展
#define    MAX_KEYBOARD_USER_NUM    256
typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD     dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //布撤防时间
    BYTE    byAlarmInAdvance;            // 布撤防提前提示时间0~45分
    BYTE    byRes1[3];
    BYTE     byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//按位，表示子系统关联的报警输入通道号，0-不加入，1-加入
    BYTE     byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//按位，表示支持的键盘号，0-不加入，1-加入
    BYTE    byJointOpetaterUser[MAX_KEYBOARD_USER_NUM/8];//按位表示，bit0表示键盘操作用户1 ，0-不关联 1-关联
    NET_DVR_REMIND_TIME    struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];//MAX_TIMESEGMENT_V30表示每天最多支持8个提醒
    BYTE             byRes2[288];            // 保留字节
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;


typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD     dwSize;
    BYTE     byPrinterEnable;        //是否启用打印机
    BYTE    byPrintTime;            //是否打印时间
    BYTE     byFaultDetect;            //是否检测打印机故障
    BYTE    byRes1;
    DWORD    dwAlarmInfo;            //报警信息，按位表示。bit0-防区报警，bit1-防区报警恢复，bit2-紧急报警，bit-3挟持报警
    DWORD    dwDeviceInfo;            //设备信息，按位表示。bit0-交流电断电、bit1-交流电断电恢复，bit2-蓄电池欠压、bit3-蓄电池欠压恢复，bit4-电话线断线、bit5-电话线断线恢复，bit6-测试报告、bit7-防拆、bit8-防拆恢复、bit9-485设备掉线、bit10-485设备掉线恢复、bit11-无线网络异常、bit12-无线网络恢复正常、bit13-有线网络异常、bit14-有线网络恢复正常、bit15-扩展总线异常、bit17-扩展总线恢复正常、bit17-硬盘故障、bit18-硬盘故障恢复
    DWORD    dwOperateInfo;            //操作信息，按位表示。bit0-布防、bit1-撤防、bit2-消警、bit3-旁路、bit4-旁路恢复、bit5-进入编程、bit6-退出编程、bit7-主机复位
    BYTE     byRes2[256];            // 保留字节
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{ 
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    byAddressType;    //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE    byRes1[1];
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //域名，GPRS参数配置、网络参数配置时该字段均有效
    BYTE    byReportProtocol;        //1-private 2-NAL2300
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //协议为NAL2300时有效
    BYTE    byRes2[7]; //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
}NET_DVR_ALARMHOST_NETPARAM,  *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_REGISTER_RS485CFG
{
    DWORD   dwSize;                 // 结构体大小
    WORD    wDeviceProtocol;        // 前端设备协议 通过获取协议列表获取    
    BYTE    byRes[2];
    DWORD   dwBaudRate;             //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k 
    BYTE    byRes1[124];              // 保留字节
}NET_DVR_REGISTER_RS485CFG, *LPNET_DVR_REGISTER_RS485CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD    dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //中心 GPRS网络相关参数的配置 
    BYTE     byAPNName[APN_NAME_LEN/*32*/];
    BYTE    byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE    byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE    byReconnTime;    //重连时间，连接失效后启用重连的时间，10秒为单位,取值范围1-30
    BYTE    byOverTime;        //超时时间，超过OverTime时间没有收到有效数据则重连，范围1-254，单位30秒
    BYTE    byDetectLinkTime;    //    //探测链路是否还保持，范围1-30，单位10s
    BYTE    byRes1;
    BYTE    bySIMNum[NAME_LEN/*32*/]; //SIM卡号（手机号）
    NET_DVR_IPADDR    struSIMIP;      //登陆网络后网络给分配的IP地址，只能获取
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////网络参数配置/////////////
typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM     struNetCenter[MAX_CENTERNUM];
    BYTE    byRes1[32];
}NET_DVR_ALARMHOST_NETCFG,  *LPNET_DVR_ALARMHOST_NETCFG;

//////////积木上传方式/////////////
#define    MAX_REPORTCHAN_NUM        4
#define    MAX_CENTERGROUP_NUM        16
typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD    dwSize;
    BYTE    byValid;                //是否启用
    BYTE    byRes[3]; //保留1
    BYTE    byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2
    BYTE    byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    BYTE    byDataType;    //1-报警数据 2-非报警数据 3-所有数据
    BYTE    byRes2[15];    //保留2
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

#define MAX_EVENT_NUM 32//网络报警主机最大事件数
typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD        dwSize;            
    BYTE        byValid;            //是否启用
    BYTE        byDataType;            //1-所有报警数据 2-所有非报警数据 3-所有数据，4-防区报警报告，5-非防区报警报告
    BYTE        byRes[2];             //保留1
    BYTE        byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2(如果设备支持3G，G1，G2表示3G模块，如果不支持，表示GPRS模块，一款设备中3G模块和GPRS模块只会出现一种)
    BYTE        byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    BYTE         byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];    //防区报告类型，0-不上传，1-上传 
    BYTE        byNonZoneReport[MAX_EVENT_NUM]; //非防区报警报告, 每一个元素表示一种事件类型，0-不上传，1-上传，byNonZoneReport[0]-软防区报告 byNonZoneReport[1]-系统状态报告 byNonZoneReport[2]-取消报告 byNonZoneReport[3]-测试报告 byNonZoneReport[4]-布防报告 byNonZoneReport[5]-撤防报告 byNonZoneReport[6]-挟持报告 byNonZoneReport[7]-报警恢复报告 byNonZoneReport[8]-旁路报告 byNonZoneReport[9]-旁路恢复报告。
    BYTE        byRes2[256];            //保留2
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;


//////////防护舱状态上传/////////////
typedef  struct tagNET_DVR_ALARMHOST_SAFETYCABINSTATE
{
    DWORD    dwSize;
    BYTE    byEnterButton;    //进门按钮状态 0-不按下 1-按钮按下
    BYTE    byExitButton;    //出门按钮状态 0-不按下 1-按钮按下
    BYTE    byDoorState;    //门状态    0-门关闭 1-门打开
    BYTE    byLockState;    //锁状态 0-锁关    1-锁开
    BYTE    byUrgencyButton;    //紧急按钮状态    0-不按下 1-按钮按下
    BYTE    byManState;        //人状态     0-没人 1-有人
    BYTE    byAbnormal; //异常状态  0-正常 1-异常(防护舱使用超时上传异常)
    BYTE    byLightState;   //灯光状态 0-关 ，1-开
    BYTE    byFanState;     //风扇状态 0-关，1-开
    BYTE    byRes[63];
}NET_DVR_ALARMHOST_SAFETYCABINSTATE,*LPNET_DVR_ALARMHOST_SAFETYCABINSTATE;

/////////警号输出口，警号状态上传/////////////
typedef  struct tagNET_DVR_ALARMHOST_ALARMOUTSTATUS
{
    DWORD    dwSize;
    BYTE    byName[32];        //报警输出口名称或警号名称
    BYTE    byAlarmType;    //1-报警输出口状态， 2-警号状态
    WORD    wChan;            //如果是报警输出口状态，该值的范围为0-511；如果是警号状态，范围1-8（防护舱只有1个警号输出）
    BYTE    byAlarmStatus; //报警状态 0-无报警 1-有报警
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_ALARMOUTSTATUS,*LPNET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////语音上传下载/////////////
typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD        dwSize;
    BYTE        byAudioFormat;      //音频格式，1-G711，2-G722 
    BYTE        byRes1;
    WORD        wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD        dwSamplesPerSec;    //采样率
    BYTE        byRes2[20];            //保留
    DWORD        dwAudioSize;        //音频长度大小，压缩后的大小
}NET_DVR_AUDIO_PARAM,*LPNET_DVR_AUDIO_PARAM;

//预览V40接口
typedef struct tagNET_DVR_PREVIEWINFO
{
    LONG lChannel;//通道号
    DWORD dwStreamType;    // 码流类型，0-主码流，1-子码流，2-码流3，3-码流4 等以此类推
    DWORD dwLinkMode;// 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;//播放窗口的句柄,为NULL表示不播放图象
    DWORD bBlocked;  //0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
    DWORD bPassbackRecord; //0-不启用录像回传,1启用录像回传
    BYTE byPreviewMode;//预览模式，0-正常预览，1-延迟预览
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//流ID，lChannel为0xffffffff时启用此参数
    BYTE byProtoType; //应用层取流协议，0-私有协议，1-RTSP协议
    BYTE byRes1;
    BYTE byVideoCodingType; //码流数据编解码类型 0-通用编码类型(YUV)（一个像素点8BIT） 1-裸码流类型（一个像素点14BIT）（SDK内部头文件中保留，不开放给用户）
    DWORD dwDisplayBufNum; //播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1 
    BYTE byRes[216];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;


//事件触发报警输出

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD    dwSize;
    DWORD    dwOverallEventTriggerAlarmoutOn;    //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障
    DWORD    dwOverallEventTriggerAlarmoutOff;    //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障
    DWORD    dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统事件触发报警输出开启,dwSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    DWORD    dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统事件触发报警输出关闭,wSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    BYTE    byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

//故障处理配置
typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD     dwSize;
    DWORD    dwCheckFault;    //是否检测故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，, bit11-防区扩展板异常，具体支持的故障类型从能力集获取
    DWORD    dwOverallFaultJointLED;        //故障关联全局键盘指示灯输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    DWORD    dwOverallFaultJointSound;    //故障关联全局键盘声音输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    DWORD    dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*故障关联子系统键盘指示灯输出，dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointLED[0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointLED[1]表示子系统2，以此类推*/
    DWORD    dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*故障关联子系统键盘声音输出（声音在键盘上输出）dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointSound [0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointSound [1]表示子系统2，以此类推*/
    DWORD    dwFaultJointFaultLight;//故障关联故障灯输出
    BYTE    byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD    dwSize;
    BYTE    byIndex;            //子系统号，0xff表示所有子系统
    BYTE       byRes[63];      //保留
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;

#define CID_CODE_LEN 4
typedef enum tagNET_DVR_ALARMHOST_REPORT_TYPE
{
    NET_DVR_DEFENCE_ALARM = 1,        //防区报警
        NET_DVR_VIDEO_ALARM,            //视频报警
        NET_DVR_VIRTUAL_DEFENCE_ALARM,    //软防区报警
        NET_DVR_HOSTAGE_ALARM,            //挟持报警
        NET_DVR_KNOCK_DOWN_ALARM,        //防拆报警
        NET_DVR_OPERATE_ALARM,            //操作报告
        NET_DVR_OHTER_ABNORMAL_ALARM    //异常报告
}NET_DVR_ALARMHOST_REPORT_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MAIN_TYPE
{
    CID_ENTER = 1000,    /*触发报告的基数*/
    CID_EXIT = 3000        /*恢复报告的基数*/
}NET_DVR_ALARMHOST_CID_MAIN_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MINOR_TYPE
{
    CID_ALARM = 103,            /*报警*/
    CID_FIRE_ALARM = 110,       /*火警*/
    CID_ABDUCT_REPORT = 121,    /*挟持报告*/
    CID_SILENT_24 = 122,        /*24小时无声*/
    CID_AUDIO_24 = 123,         /*24小时有声*/
    CID_AUXILIARY_24 = 124,     /*24小时辅助*/
    CID_SHOCK_24 = 125,         /*24小时震动*/
    CID_PERIMETER_ALARM = 131,  /*周界*/
    CID_INNET_ALARM = 132,      /*内部防区*/
    CID_ENTER_EXIT = 134,       /*出入*/
    CID_DEVICE_OPEN = 137,      /*设备防拆*/
    CID_ZONE_BUS_BREAK = 141,   // 总线开路
    CID_ZONE_BUS_SHORT = 142,   // 总线短路
    
    CID_AC_LOSS = 301,          /*交流掉电*/
    CID_LOW_BATT_VOL = 302,     /*蓄电池电压低*/
    CID_DEV_RESET = 305,        /*主机复位*/
    CID_MBUS_MODEL_FAULT = 333, // 扩展模块故障
    CID_PRINTER_FAIL = 336,     /*打印机掉线*/
    CID_LINE_LOSS = 354,          // 电话线通讯失败
    CID_BUS_LOSS = 382,         /*扩展总线模块掉线*/
    CID_DETECTOR_OPEN = 383,     /*防区感应器被拆*/

    CID_GUARD = 401,            /*布防撤防*/
    CID_GUARD_AUTO = 403,       /*自动布撤防*/
    CID_CANCEL_ARM = 406,       /*消警*/
    CID_GUARD_IMME = 408,       /*即时布撤防*/
    CID_KEY_ZONE_GUARD = 409,   /*钥匙防区布撤防*/
    CID_GUARD_STAY = 441,       /*留守布撤防*/
    CID_FORCED_ARM = 442,       /*强制布防*/
    CID_AUTOCTRL_TRIG = 443,    /*定时开/关触发器*/
    CID_ONETOUCH_AWAY_ARMING = 444, /*一键外出布防*/
    CID_ONETOUCH_STAY_ARMING = 445, /*一键留守布防*/
    CID_CARD_ARMING_OR_DISARMING = 446, /*刷卡布撤防*/
    CID_AUTOGUARD_FAIL = 455,   /*自动布防失败*/
    CID_AOPEN_TRIG_FAIL = 460,  /*定时开启触发器失败*/
    CID_ACLOSE_TRIG_FAIL = 461, /*定时关闭触发器失败*/
    CID_AUTOUNGUARD_FAIL = 462, /*自动撤防失败*/

    CID_BYPASS = 570,           /*旁路事件*/
    CID_GROUP_BYPASS = 574,     /*组旁路*/

    CID_MANUAL_TEST_RPT = 601,  /*手动测试报告*/
    CID_AUTO_TEST_RPT = 602,    /*定时测试报告*/
    CID_ENTER_PROG = 627,       /*进入编程*/
    CID_EXIT_PROG = 628,        /*退出编程*/

    CID_SOFT_INSTAND = 810,     /*软防区紧急报警*/
    CID_SOFT_FIRE = 811,        /*软防区火警*/
    CID_SOFT_MOBS = 812,        /*软防区匪警mobster*/
    
    CID_KEY_FAIL = 910,         /*键盘掉线*/
    CID_TRIGGER_FAIL = 911,     /*键盘总线上触发器掉线*/
    CID_GPK_FAIL = 912,         /*键盘总线上GP/K掉线*/
    CID_MODULE_FAIL = 913,      /*键盘总线上MN/K掉线*/
    CID_WRIE_LESS_NET = 920,    /*无线网络故障*/
    CID_SIM_FAULT = 921,        /*SIM卡故障*/
    CID_IPADDR_CONFLICT = 930,  /*IP冲突*/
    CID_ETHERNET_BROKEN = 931,  /*网线断*/
    CID_GROUP_OUT_RP = 932,       // 组间通讯失败
    CID_GROUP_IN_RP = 933,        // 通道通讯失败
    CID_MOTION_DECTECT = 940,   /*移动侦测报警开始/结束*/
    CID_MASK_ALARM = 941,       /*遮挡报警开始/结束*/
    CID_VI_LOST = 942,          /*视频丢失开始/结束*/
    CID_VS_MISMATCH = 943,      /*输入/输出视频制式不匹配*/
    CID_VI_EXCEPTION = 944,     /*视频输入异常/恢复正常*/
    CID_HD_FULL = 945,          /*硬盘满/恢复正常*/
    CID_HD_ERROR = 946,         /*硬盘错/恢复正常*/
    CID_PIC_SEND_FAILED = 947,  /*图片上传失败*/
    CID_KEY_LOCKED = 948,      /*键盘锁定*/
    CID_ZONE_BUS_SEARCH = 970,    // 总线搜索
    CID_ZONE_BUS_REGIST = 971,    // 总线注册
    CID_GUARD_DELAY_OP = 972,     // 自动布撤防延时操作
    CID_GUARD_SINGLE = 973     /*单防区布撤防*/
}NET_DVR_ALARMHOST_CID_MINOR_TYPE;


typedef struct tagNET_DVR_CID_ALARM
{
    DWORD    dwSize;
    BYTE    sCIDCode[CID_CODE_LEN/*4*/];    //CID事件号
    BYTE    sCIDDescribe[NAME_LEN/*32*/];    //CID事件名
    NET_DVR_TIME_EX struTriggerTime;            //触发报警的时间点
    NET_DVR_TIME_EX struUploadTime;                //上传报警的时间点
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //中心帐号
    BYTE    byReportType;                    //见定义NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE    byUserType;                        //用户类型，0-网络用户 1-键盘用户,2-手机用户,3-系统用户
    BYTE    sUserName[NAME_LEN/*32*/];        //网络用户用户名
    WORD    wKeyUserNo;                        //键盘用户号    0xFFFF表示无效
    BYTE    byKeypadNo;                        //键盘号        0xFF表示无效
    BYTE    bySubSysNo;                        //子系统号        0xFF表示无效
    WORD    wDefenceNo;                        //防区号        0xFFFF表示无效
    BYTE    byVideoChanNo;                    //视频通道号    0xFF表示无效
    BYTE    byDiskNo;                        //硬盘号        0xFF表示无效
    WORD    wModuleAddr;                    //模块地址        0xFFFF表示无效
    BYTE    byCenterType;                    //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    BYTE    byRes1;
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //中心账号V40,使用此字段时sCenterAccount无效
    BYTE    byRes2[28];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;

#define MODULE_INFO_LEN            32    //模块信息长度
#define VERSION_INFO_LEN        32    //版本信息长度

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD dwSize;
    BYTE    byModuleType;    //1-防区，2-触发器 3-防区触发器      
    BYTE    byZoneType;        //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区，6-单防区触发器，0xff表示该参数无效
    BYTE    byTriggerType;    //触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，0xff表示该参数无效
    BYTE    byRes1[1];
    char    sModelInfo[MODULE_INFO_LEN];                //模块信息
    char    sDeviceVersionInfo[VERSION_INFO_LEN];                /* 版本信息*/
    BYTE    byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;


#define MAX_DECODE_CARD_SUPPORTDISPNUMS 8//每个解码卡最多支持的显示通道数
#define MAX_SUPPORT_RES 32
typedef struct tagNET_DVR_DECCARD_ABILITY_V41 /*高清解码卡能力集*/
{
    BYTE byCardType;      //解码卡类型(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //解码通道数 
    BYTE byDispNums;      //显示通道数 
    BYTE byDecStartIdx;     //首个解码通道在所有解码通道中的索引 
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    BYTE byDispFormat[MAX_DECODE_CARD_SUPPORTDISPNUMS];   //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举) 
    BYTE byWindowMode[MAX_DECODE_CARD_SUPPORTDISPNUMS][12]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes2[36];
} NET_DVR_DECCARD_ABILITY_V41,*LPNET_DVR_DECCARD_ABILITY_V41;

#define        MAX_DECODE_CARD_NUM            6   //最多高清解码卡数
typedef struct tagNET_DVR_DECODESVR_ABILITY_V41
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 解码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY_V41 struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY_V41, *LPNET_DVR_DECODESVR_ABILITY_V41;

// 流录像状态
typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD           dwSize;
    BYTE            byRecord;         //(只读)录像类型, 0：不在录像，1：在录像 2-空闲 
    //3-无连接 4-无输入视频 5-未加载 6-存档中
    //7-回传中 8-用户名或密码错 9-未验证
    //10-存档中和录像中 11-录像回传中和录像中
    BYTE            byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE            byRes1[2];        //保留字节
    DWORD            dwRelatedHD;      //关联磁盘
    BYTE            byRes2[8];        //保留字节
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

#define  CHAN_NO_LEN   24

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE        byEnable;                    //是否启用
    BYTE        byProType;                    //协议类型，0-私有协议(default), (需要从设备获取能力)
    BYTE          byZeroChan;                    //是否是零通道,0-不是，1-是
    BYTE        byPriority;                //优先级
    BYTE        sUserName[NAME_LEN];        //用户名
    BYTE        sPassword[PASSWD_LEN];        //密码
    BYTE        byDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR  struIP;                        //IP地址
    WORD        wDVRPort;                     //端口号
    BYTE        byStreamType;               //主码流:0; 子码流：1
    BYTE        byOnline;                    //只读，0-不在线 1-在线
    DWORD        dwChannel;                  //通道号
    BYTE        byTransProtocol;            //协议类型，0-TCP，1-UDP，2-多播
    BYTE        byLocalBackUp;                //本地备份: 0-不启用CVR本地备份，1-启用CVR本地备份--即回放时的流一份在录像卷，一份在存档卷（本地备份）
    WORD        wDirectLastTime;            //导播持续时间
    BYTE        byChanNo[CHAN_NO_LEN];     //通道编号--用于VAG取流
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE    byEnable;                    //是否启用
    BYTE    byProType;                    //协议类型，0-私有协议(default), 1-松下协议，2-索尼, 3-大华 (需要从设备获取能力)
    BYTE    byZeroChan;                    //是否是零通道,0-不是，1-是
    BYTE    byRes1;                        //保留字段，置0
    BYTE    sUserName[NAME_LEN];        //用户名
    BYTE    sPassword[PASSWD_LEN];        //密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //前端IP或者域名,需要设备 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wDVRPort;                     //端口号
    BYTE    byStreamType;               //主码流:0; 子码流：1
    BYTE    byOnline;                    //只读，0-不在线 1-在线
    DWORD   dwChannel;                //通道号
    BYTE    byTransProtocol;            //传输协议类型，0-TCP，1-UDP 2-多播
    BYTE    byLocalBackUp;                     //本地备份，0-不启用CVR本地备份，1-启用CVR本地备份--即录像时的流一份在录像卷，一份在存档卷（本地备份）
    BYTE    byRes2[2];                //保留字段，置0
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //协议类型为VAG时，对应的VAG通道编号
    BYTE    byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//流媒体IP 
    WORD    wStreamMediaPort; //流媒体端口
    BYTE    byTransmitType; //流媒体传输协议 0- TCP  1- UDP
    BYTE    byRes1[33];
    BYTE    byDevIP[64]; //设备IP 
    WORD    wDevPort; //设备端口
    BYTE    byChannel; //通道号
    BYTE    byTransMode; //传输模式 0-主码流 1- 子码流 
    BYTE    byProType;    
    //厂家类型 0-私有 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    BYTE    byTransProtocol; //传输协议类型0-TCP,  1-UDP,  2-多播方式,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byRes2[28];  //预留  
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//流媒体IP 
    WORD   wStreamMediaPort; //流媒体端口
    BYTE    byTransmitType; //流媒体传输协议 0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64]; //设备IP 
    WORD   wDevPort; //设备端口
    BYTE    byChannel; //通道号
    BYTE    byTransMode; //传输模式 0-主码流 1- 子码流 
    BYTE    byProType;    
    //厂家类型 0-海康 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    BYTE    byTransProtocol; //传输协议类型0-TCP,  1-UDP  2-多播方式
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byRes2[308];  //预留  
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable; 
    BYTE    byStreamType; //主子码流
    BYTE    byLocalBackUp; //是否本地备份
    BYTE     byRes;
    BYTE    strURL[URL_LEN_V40]; //流媒体URL，可以级联
    DWORD   dwProtocalType;   //IPC协议类型值，可以通过获取IPC协议列表得到
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //流来源IP或者域名,需要解析 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wIPPort;  //流来源对应的端口号
    WORD    wChanNo; //流来源设备IP通道号
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //流来源通道编号,用于VAG功能
    BYTE     byRes1[88];   
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;

typedef union tagNET_DVR_STREAM_TYPE_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO    struChanInfo;          //IP通道信息  类型值为0
    NET_DVR_PU_STREAM_URL                struStreamUrl;        //通过流媒体到url取流，类型值为4
    NET_DVR_PU_STREAM_URL_CFG           struStreamUrlCfg; //通过流媒体到指定监控设备上取流，类型值为6
}NET_DVR_STREAM_TYPE_UNION, *LPNET_DVR_STREAM_TYPE_UNION;

typedef union tagNET_DVR_STREAM_TYPE_V40_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40    struChanInfo;     //IP通道信息，类型值为0
    NET_DVR_PU_STREAM_URL struPuStreamUrl;        //通过流媒体到url取流，类型值为4
    NET_DVR_PU_STREAM_URL_CFG_V40   struStreamUrlCfg; //通过流媒体到组合url取流，类型值为6
    NET_DVR_RTSP_PROTOCAL_CFG struRtspCfg;        //由标准RTSP接入取流 类型值7
    NET_DVR_STREAM_URL_V40  struStreamUrlV40;  //通过流媒体（支持级联方式）向流来源取流，类型值为8
}NET_DVR_STREAM_TYPE_V40_UNION, *LPNET_DVR_STREAM_TYPE_V40_UNION;


typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE                    byGetStreamType;    //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流
    BYTE                    byRes[3];            // 保留字节
    NET_DVR_STREAM_TYPE_UNION    uGetStream;            // 不同取流方式结构体
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

// 流来源信息
typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD                        dwSize;
    NET_DVR_STREAM_MODE_TYPE    struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO,*LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD                    dwSize;
    BYTE                    byGetStreamType;    //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流 6-通过流媒体到指定监控设备上取流
    BYTE                    byRes1[3];            // 保留字节
    NET_DVR_STREAM_TYPE_V40_UNION    uGetStream;            // 不同取流方式结构体
    BYTE                    byRes[512];            // 保留字节
}NET_DVR_STREAM_SRC_INFO_V40,*LPNET_DVR_STREAM_SRC_INFO_V40;


// 流录像信息
typedef struct 
{
    DWORD            dwSize;
    NET_DVR_RECORD_V30    struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

// 按流ID对时间段加锁
typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD            dwSize;                // 结构体大小
    NET_DVR_TIME    strBeginTime;        // 开始时间
    NET_DVR_TIME    strEndTime;            // 结束时间
    NET_DVR_STREAM_INFO struStreamInfo;        // 流信息
    DWORD            dwRecordType;        // 录像类型:  0xffffffff－全部，－定时录像，-移动侦测，－报警触发，-报警触发或移动侦测，-报警触发和移动侦测，-命令触发，-手动录像，-智能录像(同文件查找)
    DWORD            dwLockDuration;        // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    NET_DVR_TIME_EX        strUnlockTimePoint;    // 加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    BYTE                byRes[4];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;

// 按ID+时间回放结构体
typedef struct tagNET_DVR_VOD_PARA
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO struIDInfo; 
    NET_DVR_TIME        struBeginTime;
    NET_DVR_TIME        struEndTime;
    HWND                hWnd;
    BYTE                byDrawFrame; //0:不抽帧，1：抽帧
    BYTE                byVolumeType;  //0-普通录像卷  1-存档卷
    BYTE                byVolumeNum;  //卷号，目前指存档卷号
    BYTE                byStreamType;   //码流类型 0-主码流， 1-子码流，2-码流三
    DWORD                   dwFileIndex;      //存档卷上的录像文件索引，搜索存档卷录像时返回的值
    BYTE                byAudioFile;    //音频文件0-否，1-是
    BYTE                byRes2[23];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

// 手动录像
typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo; 
    DWORD            lRecordType;
    BYTE            byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;


// CABAC码流压缩性能选项，开启可提高20%，只有模拟通道可以用
typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD        dwSize;                  //结构体大小
    BYTE         byCabacEnable;           //码流压缩性能选项值0 不提升 1 提升
    BYTE          byRes1[31];                  //保留
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

#define  MAX_IOSPEED_GROUP_NUM      4 //IO测速组个数
#define  MAX_IOOUT_NUM              4  //最大IO输出口个数
#define  MAX_IOIN_NUM               8  //最大IO输入口个数
#define  MAX_RELAY_NUM              12 //继电器控制设备最大数 2013-11-04
#define  MAX_VEHICLE_TYPE_NUM        8  //车辆信息管控最大数2013-11-04
#define  MAX_IOIN_NUMEX             10 //最大IO输入口个数(扩展)
#define  MAX_ITC_LANE_NUM           6  //最大车道个数
#define  MAX_LANEAREA_NUM           2  //单车道最大区域个数
#define  ITC_MAX_POLYGON_POINT_NUM    20    //检测区域最多支持20个点的多边形
#define  MAX_ITC_SERIALCHECK_NUM    8 //串口校验类型个数
#define  MAX_LIGHT_NUM              6 //最大交通灯数
#define  MAX_VIDEO_INTERVAL_NUM     2  //最大抓拍间隔数
#define  MAX_VIDEO_DETECT_LIGHT_NUM  12  //视频检测的最大检测区域
#define  MAX_CALIB_RECOG_NUM        2  //标定区域个数
#define  MAX_RS485_NUM  12 //485口最大支持数
#define  MAX_MOBILE_POLYGON_NUM     3 //移动布控支持最大牌识区域个数
#define  MAX_MOBILE_DETECTLINE_NUM  3 //移动布控支持最大违规检测线个数
#define  MAX_IOOUT_K_NUM            8  //K系列最大IO输出口个数

//IO输出口参数（3.1版本（含）之后）
typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IO默认状态：0-低电平，1-高电平 
    BYTE     byIOOutStatus;//IO起效时状态：0-低电平，1-高电平，2-脉冲
    BYTE     byMode; //闪光灯工作方式,按位表示，0-表示工作，1-表示不工作，bit0-视频，bit1-卡口，bit2-违章
    BYTE     byIOWorkMode;//IO输出口工作模式：0-闪光灯，1-偏振镜,  2-常亮灯
    DWORD    dwTimeDelay;//IO有效持续时间，单位us
    WORD     wAheadTime;//输出IO提前时间，单位us
    BYTE     byFreqMulti;        //倍频，数值范围[1,15]
    BYTE     byDutyRate;        //占空比，[0,40%]
    BYTE     byDetectBrightness;/*自动检测亮度使能闪光灯0-不检测；1-检测*/
    BYTE     byBrightnessThreld;/*使能闪光灯亮度阈值，范围[0,100],高于阈值闪*/
    BYTE     byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
    BYTE     byStartHour;        //开始时间-小时,取值范围0-23
    BYTE     byStartMinute;        //开始时间-分,取值范围0-59
    BYTE     byEndHour;        //结束时间-小时,取值范围0-23
    BYTE     byEndMinute;        //结束时间-分,取值范围0-59
    BYTE     byAutoPlateBrightness;// 车牌亮度自动使能闪光灯 0-不启用 1-启用
    BYTE     byRes[8];
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;

typedef enum _ITC_TRIGGERMODE_TYPE_
{
    ITC_POST_IOSPEED_TYPE              = 0x1,  //IO测速（卡口）
        ITC_POST_SINGLEIO_TYPE             = 0x2,  //单IO触发（卡口）
        ITC_POST_RS485_TYPE                = 0x4,  //RS485车检器触发（卡口）
        ITC_POST_RS485_RADAR_TYPE          = 0x8,  //RS485雷达触发（卡口）
        ITC_POST_VIRTUALCOIL_TYPE          = 0x10,   //虚拟线圈触发（卡口）
        ITC_POST_HVT_TYPE_V50               = 0x20,    //混行卡口视频触发V50
        ITC_POST_MPR_TYPE                  = 0x40,   //多帧识别(卡口)(Ver3.7)
        ITC_POST_PRS_TYPE                  = 0x80,   //视频检测触发配置
        ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE  = 0x100,  //IO红绿灯（电警）
        ITC_EPOLICE_RS485_TYPE             = 0x200,  //RS485车检器电警触发（电警）
        ITC_POST_HVT_TYPE                   = 0x400,    //混行卡口视频触发（卡口）
        ITC_PE_RS485_TYPE                  = 0x10000,  //RS485车检器卡式电警触发（卡式电警）
        ITC_VIDEO_EPOLICE_TYPE             = 0x20000, //视频电警触发（卡式电警）
        ITC_VIA_VIRTUALCOIL_TYPE           = 0x40000,  //VIA触发配置
        ITC_POST_IMT_TYPE                   = 0x80000,   //智慧监控配置
        IPC_POST_HVT_TYPE                   = 0x100000,    //IPC支持的HVT
        ITC_POST_MOBILE_TYPE               = 0x200000, //移动交通触发模式
        ITC_REDLIGHT_PEDESTRIAN_TYPE       = 0x400000,    //行人闯红灯触发
        ITC_NOCOMITY_PEDESTRIAN_TYPE       = 0x800000    //不礼让行人触发
}ITC_TRIGGERMODE_TYPE;

//能力集接口的输出参数，对应pOutBuf参数
typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //触发类型，按位表示，定义ITC_TRIGGERMODE_ABILITY定义，根据输入的能力类型不同，此处返回的触发类型也不同
    BYTE byRes[16]; 
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM    
{
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

//牌识参数
typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写*/
    BYTE byEnable; //是否启用该区域牌识，0-否，1-是
    DWORD dwRecogMode;  
    /*识别的类型，
       bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ； 
       bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
       bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
       bit3-农用车识别：0-不采用农用车识别，1-农用车识别； 
       bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
       bit5-帧定位或场定位：0-帧定位，1-场定位；
       bit6-帧识别或场识别：0-帧识别，1-场识别； 
       bit7-晚上或白天：0-白天，1-晚上 
       bit8-摩托车识别：0-不采用摩托车识别，1-摩托车识别;
       bit9-场景模式：0-电警/多帧，1-卡口；
       bit10-微小车牌：0-不启用，1-启用微小车牌识别(像素60～80)
       bit11-安全带检测：0-不启用，1-启用安全带检测
       bit12-民航车牌识别: 0-不启用，1-开启民航车牌识别
       bit13-车牌过渡倾斜处理: 0-不启用，1-开启过渡倾斜处理（PRS）
       bit14-超大车牌识别: 0-不启用，1-开启超大车牌识别（PRS）
       bit15-遮阳板检测：0-不启用，1-启用遮阳板检测
       bit16-黄标车检测：0-不启用，1-启用黄标车检测
       bit17-危险品车辆检测：0-不启用，1-启用危险品车辆检测
       bit18-使馆车牌识别：0-不启用，1-启用使馆车牌识别 
       bit19-车辆子品牌识别：0-不启用，1-启用车辆子品牌识别
    */
    BYTE byVehicleLogoRecog;//车标识别 0-不启用，1-启用  
   /*
       0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，8-贵，9-琼，10-冀，11-豫，
       12-黑，13-鄂，14-湘，15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，22-鲁，
       23-晋，24-陕，25-沪，26-川，27-台，28-津，29-藏，30-港，31-新，32-云，33-浙，
       34-皖，0xff-全部
    */
    BYTE byProvince;//省份索引值
    BYTE byRegion;// 区域索引值 0-保留，1-欧洲，2-俄语区域, 3-欧洲&俄罗斯(EU&CIS)
    BYTE byRes1;
    WORD wPlatePixelWidthMin;//车牌像素识别宽度最小值（单位是像素）当前推荐范围[130,500]
    WORD wPlatePixelWidthMax;//车牌像素识别宽度最大值（单位是像素）当前推荐范围[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

//多边型结构体
typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域 
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //多边形边界点,最多20个 
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM    
{
    BYTE byMode; //区域类型，0-矩形，1-多边形
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //矩形区域
        NET_ITC_POLYGON struPolygon; //多边形区域
    }uRegion;
    BYTE  byRes[16];    //保留
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

//单组IO测速参数
typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //是否启用，0-不启用，1-启用
    BYTE byTrigCoil1; //第一线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil1IOStatus;//第一线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byTrigCoil2; //第二线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil2IOStatus;//第二线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE byTimeOut;//超时时间（默认10），单位s
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    DWORD dwDistance;//线圈距离（默认1000）,单位：厘米
    BYTE byCapSpeed;//起拍速度（默认30），单位km/h
    BYTE bySpeedLimit;//限速值（默认60），单位km/h
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySnapTimes1; //线圈1抓拍次数（默认不抓拍），0-不抓拍，非0-连拍次数，最大5次 
    BYTE bySnapTimes2; //线圈2抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5次
    BYTE byBigCarSpeedLimit; //大车车速限制值
    BYTE byBigCarSignSpeed;//标志限速(大车)，单位km/h(3.7Ver)
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wInterval1[MAX_INTERVAL_NUM];//线圈1连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    WORD wInterval2[MAX_INTERVAL_NUM];//线圈2连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byCarSignSpeed;//标志限速，单位km/h(3.7Ver)
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识参数(可用牌识区域1个，保留一个)
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                        //小车限底速值，单位km/h
    BYTE byBigCarLowSpeedLimit;                //大车限底速值，单位km/h
    BYTE byLowSpeedCapEn;                 //是否启用低速抓拍，0-否，1-是
    BYTE byEmergencyCapEn;                //是否启用应急车道抓拍，0-否，1-是
    BYTE byRes[27];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

//卡口IO测速参数
typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //单个IO测速组参数
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

//单IO参数
typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO触发默认状态：0-低电平，1-高电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byEnable;//单IO使能标志0-不启用，1-启用 (Remark:在能力返回支持 bySupport&0x20，表示是否支持单IO触发界面IO使能配置 时生效)
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    BYTE byEmergencyCapEn;  //是否启用应急车道抓拍，0-否，1-是
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识参数
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

//单IO触发参数
typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //单个IO触发参数
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //是否启用该车道，0-不启用，1-启用
    BYTE byRelatedDriveWay;//关联的车道号
    WORD wDistance; //线圈距离，计算速度
    WORD wTrigDelayTime; //触发延迟时间（默认200），单位：毫秒
    BYTE byTrigDelayDistance; //触发延迟距离（默认0），单位：分米
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySignSpeed;//标志限速，单位km/h
    BYTE bySpeedLimit;//限速值，单位km/h
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byOverlayDriveWay; //OSD叠加的车道号
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byCartSignSpeed;//标志限速(大车)，单位km/h
    BYTE byCartSpeedLimit;//限速值（大车），单位km/h
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                    //小车限底速值，单位km/h
    BYTE byBigCarLowSpeedLimit;                //大车限底速值，单位km/h
    BYTE byLowSpeedCapEn;                   //是否启用低速抓拍，0-否，1-是
    BYTE byEmergencyCapEn;                 //是否启用应急车道抓拍，0-否，1-是
    BYTE byRes[9];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

//卡口RS485车检器触发参数
typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byTriggerSpareMode; //触发备用模式，0-默认，1-卡口虚拟线圈模式,2-卡口混合车道模式
    BYTE byFaultToleranceTime;//容错时间(单位:分钟)，用于检测车检器是否正常的最大时间
    BYTE byRes1; 
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;    //雷达类型，0-无雷达,1-安道雷雷达，2-奥利维亚，3-川速微波4,雷达接IO扩展盒(此参数在卡口虚拟线圈、混行卡口界面中使用，卡口RS485雷达不使用),0xff-其它类型
    BYTE    byLevelAngle;   //与水平线所成角度,默认为25°(0到90度)
    WORD    wRadarSensitivity; //雷达灵敏度 
    WORD    wRadarSpeedValidTime;//雷达速度有效时间(0~2000] ,0表示不支持
    BYTE    byRes1[2];
    float      fLineCorrectParam;//线性矫正参数[0.0~2.0]
    int      iConstCorrectParam;//常量矫正参数[-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND  //条件结构
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;//关联的RS485号 1～5 (唯一值)
    //    BYTE  byModeType; //0～预留，1～雷达，2～车检器，3～信号灯检测器
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND,*LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;//24
    BYTE  byAssociateLaneNo;//关联的车道号1～99 (这个值可以在不同RS485口重复)
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;

typedef union tagNET_ITC_ACCESS_DEVINFO_PARAM_UNION
{
    BYTE uLen[128];
    NET_ITC_RADAR_INFO_PARAM struRadarInfoParam;//雷达参数配置
}NET_ITC_ACCESS_DEVINFO_PARAM_UNION, *LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION;

typedef struct tagNET_ITC_RS485_ACCESS_CFG //144  配置结构
{
    DWORD dwSize;
    BYTE  byModeType;//0～预留，bit1～雷达，bit2～车检器，bit3～信号灯检测器
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam; //64
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG,*LPNET_ITC_RS485_ACCESS_CFG;

//2013-07-09 雷达关联车道扩展
typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];//多车道雷达信息
    //根据能力集开发显示，不支持的默认为0，不显示  （有几个车道支持几个）
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;


//卡口RS485雷达触发参数
typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    NET_ITC_RADAR_PARAM struRadar;  //雷达参数
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySignSpeed;//标志限速，单位km/h
    BYTE bySpeedLimit;//限速值，单位km/h
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byBigCarSignSpeed;///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLowSpeedLimit;/*限低速，单位km/h*/
    BYTE byBigCarLowSpeedLimit; /*大车限低速，单位km/h*/
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    NET_VCA_LINE struLine; //车道线
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  /*虚拟线圈区域*/
    BYTE byTrigFlag; //触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
    BYTE byTrigSensitive;  //触发灵敏度，1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byEnableRadar; //是否启用雷达测速，0-否，1-是
    NET_ITC_VTLANE_PARAM struLane; //关联的车道参数
    //车道用途类型，详见ITC_LANE_USEAGE_TYPE，使用1和8两种类型(3.7Ver)
    BYTE byUseageType; 
    //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

//卡口虚拟线圈触发参数
typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE    byRelatedLaneNum;//关联的车道个数
    BYTE    byIsDisplay; //视频中是否显示虚拟线圈，0-不显示，1-显示
    BYTE    byLoopPos; //晚间触发线圈的偏向（默认10）
    BYTE    byPolarLenType; /*偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。*/
    BYTE    byDayAuxLightMode; /*白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明*/
    BYTE    byVideoLaneNO; //视频参考亮度的参考车道号
    BYTE    byVideoLowTh; /*视频参考亮度低阈值初始化值（默认40）*/
    BYTE    byVideoHighTh; /*视频参考亮度高阈值初始化值（默认55）*/
    BYTE    byRecordMode; //录像标志：0-不录像，1-录像
    BYTE     bySnapMode;//抓拍模式：0-频闪模式；1-爆闪模式
    /*测速方式：0-不测速，0x1-雷达测速，0x2-视频测速*/
    BYTE    bySpeedDetector;
    BYTE    byRes2;
    WORD    wResolutionX;/* 设备当前分辨率宽*/
    WORD    wResolutionY;/* 设备当前分辨率高*/
    DWORD   dwDayInitExp; /*视频白天曝光时间的初始值2000*/
    DWORD   dwDayMaxExp; /*视频白天曝光时间的最大值20000*/
    DWORD   dwNightExp; /*晚间视频曝光时间的设置值3000*/
    DWORD   dwSnapExp; /*抓拍曝光时间*/
    BYTE    byDayInitGain; /*视频白天增益的初始值200*/
    BYTE    byDayMaxGain; /*视频白天增益的最大值400*/
    BYTE    byNightGain; /*晚间视频增益*/
    BYTE    bySnapGain; /*抓拍增益*/
    DWORD   dwSceneMode; //场景模式， 详见SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //地址位置(默认浙江)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //虚拟线圈参数
    NET_ITC_RADAR_PARAM struRadar;  //雷达参数
    NET_VCA_LINE struLine; //右车道线
    //违规检测类型，按位表示，详见ITC_VIOLATION_DETECT_TYPE，0-不启用，1-启用(3.7Ver)
    DWORD dwVioDetectType;    
    BYTE  byDebugMode; /*调试模式，0-不启用，1-启用*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

//单组IO红绿灯参数
typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable; //是否启用，0-不启用，1-启用
    BYTE byLightIO; //红绿灯IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrafficLight; //红绿灯有效状态0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    BYTE byTrigIO;//触发的IO号，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrigIOStatus;//触发IO口的状态（默认0），0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE byRedSnapTimes; //红灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    BYTE byGreenSnapTimes; //绿灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    BYTE byRes1;
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wRedInterval[MAX_INTERVAL_NUM];//红灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    WORD wGreenInterval[MAX_INTERVAL_NUM];//绿灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识区域参数
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

//电警IO红绿灯参数
typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //单组IO红绿灯参数
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;

typedef enum _ITC_SERIAL_PROTOCOL_
{
    ITC_PROTOCOL_UNKNOW = 0, /*未知*/
        ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1, /*单线圈车检器协议模式1（显示为：单_进1_出1_延1_1），到达、离开、离开延时抓拍，离开牌识，上传3张车辆图片和车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2, /*双线圈车检器协议模式1（显示为：双_进1_出1_出2_1），到达1、离开1、离开2抓拍，离开1牌识，上传3张车辆图片和车牌结果（默认）*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3, /*双线圈车检器协议模式2（显示为：双_出1_出2_延2_1），离开1、离开2、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4, /*双线圈车检器协议模式3（显示为：双_进2_出1_延2_1），进入2、离开1、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5, /*双线圈车检器协议模式4（显示为：双/三_进2_出2_延2_1），到达2、离开2、离开2延时抓拍，离开1牌识，上传3张车辆图片和车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6, /*双线圈车检器协议模式5（显示为：双/三_进2_出2_延2_2），到达2、离开2、离开2延时抓拍，到达2、离开1均牌识，上传3张车辆图片和置信度高的车牌结果（默认）*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7, /*双线圈车检器协议模式6（显示为：双/三_进1_出2_延2_2），到达1、离开2、离开2延时抓拍，到达1、离开1均牌识，上传3张车辆图片和置信度高的车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8, /*双线圈车检器协议模式7（显示为：双_进1_出1_延2_1），到达1、离开1、离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，闯红灯到达1、离开1、离开2延时）和车牌结果*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9, /*双线圈车检器协议模式8（显示为：双_进1_出1_延2_2），到达1、离开1、离开2延时抓拍，到达1、离开1均牌识，上传车辆图片（卡口离开1，闯红灯到达1、离开1、离开2延时）和置信度高的车牌结果（默认）*/
        ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10, /*单线圈车检器协议模式2（显示为：单_进1_出1_延1_2），到达、离开、离开延时抓拍，到达、离开均牌识，上传车辆图片（卡口离开，闯红灯到达、离开、离开延时）和置信度高的车牌结果（默认）*/
        ITC_OTHER_PROTOCOL = 0xff /*其它车检器协议(用于老demo参数配置，3.3之后版本关联的demo和控件均不支持此值)*/
}ITC_SERIAL_PROTOCOL;

//正常过车逻辑抓拍类型
typedef enum _ITC_NORMAL_PASS_SERIAL_PROTOCOL_
{
    ITC_NORMAL_PASS_SERIAL_UNKNOW     =  0,   //未知
        ITC_NORMAL_PASS_PROTOCOL_MODE1  = 1,  //单线圈，离开抓拍，牌识上传（默认）
        ITC_NORMAL_PASS_PROTOCOL_MODE2 =2,  //单线圈，到达、离开抓拍，均牌识，仅上传离开车辆图片和置信度高的车牌结果
        ITC_NORMAL_PASS_PROTOCOL_MODE3 =3,  //双线圈，离开1抓拍，牌识上传（默认）
        ITC_NORMAL_PASS_PROTOCOL_MODE4 =4, //双线圈，到达1、离开1抓拍，均牌识，仅上传离开1车辆图片和置信度高的车牌结果
        ITC_NORMAL_PASS_PROTOCOL_MODE5 =5, //双线圈，到达2、离开1抓拍，均牌识，仅上传离开1车辆图片和置信度高的车牌结果
}ITC_NORMAL_PASS_SERIAL_PROTOCOL;

//逆行违规逻辑抓拍类型
typedef enum _ITC_INVERSE_SERIAL_PROTOCOL_
{
    ITC_INVERSE_SERIAL_UNKNOW     =  0,   //未知
        ITC_INVERSE_PROTOCOL_MODE1  = 1,  //不抓拍
        ITC_INVERSE_PROTOCOL_MODE2 =2,  //到达1连抓2张、离开2抓拍，到达1两张均牌识，上传3张车辆图片和置信度高的车牌结果
        ITC_INVERSE_PROTOCOL_MODE3 =3,  //到达1、离开2抓拍，到达1牌识，上传2张车辆图片和车牌结果
}ITC_INVERSE_SERIAL_PROTOCOL;

//超速违规逻辑抓拍类型
typedef enum _ITC_SPEED_SERIAL_PROTOCOL_
{
    ITC_SPEED_SERIAL_UNKNOW     =  0,   //未知
        ITC_SPEED_PROTOCOL_MODE1  = 1,  //不抓拍
        ITC_SPEED_PROTOCOL_MODE2 =2,  //双/三线圈，离开1，离开2，离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，超速离开1、离开2、离开2延时）和车牌结果
        ITC_SPEED_PROTOCOL_MODE3 =3,  //双/三线圈，离开1，离开2，离开2延时抓拍，离开1牌识，上传车辆图片（卡口离开1，超速离开1、离开2）和车牌结果
}ITC_SPEED_SERIAL_PROTOCOL;

//车检器参数
typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //车检器协议类型，详见ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wInterval;//连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byNormalPassProtocol; //正常过车抓拍协议类型，详见ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //逆行抓拍协议类型，详见ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //超速抓拍协议类型，详见ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //是否启用该车道，0-不启用，1-启用
    BYTE byRelatedDriveWay;//关联的车道号
    WORD wDistance; //线圈距离，单位厘米
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE bySignSpeed;//标志限速(卡式电警模式有效)，单位km/h
    BYTE bySpeedLimit;//限速值(卡式电警模式有效)，单位km/h
    BYTE byOverlayDriveWay; //OSD叠加的车道号
    NET_ITC_SERIAL_INFO struSerialInfo; //车检器参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE bySerialType; //车检器类型，0-私有车检器，1-私有OEM车检器，2-其他车检器
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    BYTE bySnapPicPreRecord; //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    BYTE byBigCarSignSpeed;    ///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/    
    BYTE byRedTrafficLightChan;//红灯通道号：1～16（红绿灯检测器）
    BYTE byYellowTrafficLightChan;//黄灯通道号：1～16（红绿灯检测器）
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

//电警/卡式电警RS485车检器触发参数
typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byTrafficLightSignalSrc;//交通灯信号来源 0～车检器 1～红绿灯检测器
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

//车道属性参数结构
typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType;     //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType;  //车道方向类型，详见ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT 
    BYTE byRes[33];        //保留
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

//视频电警线结构
typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //线参数
    BYTE byLineType; //线类型，详见ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE     byVehicleCapMode;//机动车抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byNoVehicleCapMode;//非机动车抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byPasserCapMode;//行人抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

//size = 128
typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD         dwCapShutter;            //抓拍快门0~65535
    WORD         wCapGain;            //抓拍增益0～100
    BYTE          byRes[2];
    DWORD         dwDayTimeVideoShutter;    //白天曝光时间最大值
    WORD         wDayTimeVideoGain;        //白天增益最大值
    WORD         wNightVideoGain;            //晚上增益最大值
    DWORD         wNightVideoShutter;        //晚上曝光时间最大值
    BYTE          byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //关联的车道号 1~255（用于叠加和上传）
    BYTE bySignSpeed;    //标志限速，单位km/h 0～255  70
    BYTE bySpeedLimit;    //限速值，单位km/h 0～255    80 实际起效
    BYTE byBigCarSignSpeed;///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE byCaptureCount;//抓拍张数1～5(正常)
    BYTE byRelatedIOOut;    /*关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联*/
    BYTE byFlashMode;        /*闪光灯闪烁模式，0-同时闪，1-轮流闪*/
    BYTE byEnableRadar; //是否启用雷达测速，0-否，1-是
    BYTE byRes2[2];
    DWORD dwCapTarget;    //抓拍类型 bit0 表示机动车 bit1 表示非机动车 bit2 表示行人 0～表示不选择 1～表示选择
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //车道属性，用byUseageType和byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;          //左车道线，线类型为虚线、实线、单黄线和双黄线
    NET_ITC_LINE struRightLaneLine;          //右车道线，线类型为虚线、实线、单黄线和双黄线
    NET_ITC_POLYGON struPlateRecog;         //牌识区域参数
    NET_ITC_POLYGON struTraceArea;          //视频触发焦点区域
    NET_VCA_LINE  struForwardTrigLine;      //正向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存。（一般配置为正向车辆的最佳触发位置）     
    NET_VCA_LINE  struBackwardTrigLine;     //背向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存（一般配置为背向车辆的最佳触发位置）
    NET_VCA_LINE  struLeftTrigLine;          //左边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从左边进入车辆的最佳触发位置）
    NET_VCA_LINE  struRightTrigLine;          //右边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从右边进入车辆的最佳触发位置）
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//识别的车道个数，1-6 
    BYTE bySceneMode;//0-未知1-城区道路；2-小区出入口
    BYTE byRoadExpBright;//路面期望亮度（视频曝光参数调整的依据之一。在无机动车时，依据此亮度期望值，调整视频曝光参数）
    BYTE byPlateExpBright;//车牌期望亮度（视频曝光参数调整的依据之一。在有机动车通过并识别到车牌时，依据此亮度期望值，对视频曝光参数调整）
    NET_ITC_POLYGON struDetectArea;                    //视频检测区域  
    NET_ITC_SNAPMODE_PARAM  struCapMode;//抓拍模式  
    NET_ITC_HVT_EC_PARAM struEcParam;    //曝光控制参数  
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //单车道属性
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;    //牌识参数
    NET_DVR_GEOGLOCATION struGeogLocation;    //地址位置（默认浙江）
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

/*************************MPR触发模式 begin 2013-12-07****************/
typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO号[1, byIoInNum+1] 最小从1开始，最大值根据接口能力返回NET_DVR_SNAP_ABILITY的字段byIoInNum
            BYTE  byTriggerType;//0-下降沿，1-上升沿
            BYTE  byRes1[2];
        }struIO;//IO模式下生效
        struct
        {
            BYTE  byRelateChan;//关联车检器通道号[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_MPR_PARAM,*LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR触发（视频触发）,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    BYTE byPicUploadType;//图片上传类型，0~全部上传，1-正向上传，2-背向上传
    BYTE byRoadType;//模式选择 0-出入口，1-城市道路，2-自定义
    BYTE byRes2;
    WORD wCustomDelayTime;//自定义抓拍延时时间（在byRoadType为 "自定义"的时候生效），范围在[0,15000]ms
    BYTE byRes[56];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char szSceneName[NAME_LEN/*32*/]; //场景名称
    BYTE byRes1[408];
}NET_ITC_POST_MPR_PARAM,*LPNET_ITC_POST_MPR_PARAM;
/*************************MPR触发模式 end 2013-12-07****************/

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //关联车道号
    BYTE byRes[63]; //保留 
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //车道属性参数
    NET_ITC_LINE  struLaneLine;//车道线  
    NET_ITC_POLYGON  struPlateRecog;//牌识区域  
    BYTE byRes1[300]; //保留 
} NET_DVR_VIA_LANE_PARAM,*LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;    //使能 0-不开启 1-开启
    BYTE byLaneNum; //车道数
    BYTE byRes[62]; //保留     
    NET_ITC_LINE  struLaneBoundaryLine;//车道边界线（最左边车道的左边界线） 
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//牌识参数      
    BYTE byRes1[624];//保留
}NET_DVR_VIA_VTCOIL_PARAM,*LPNET_DVR_VIA_VTCOIL_PARAM;

//配置条件接口
typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //结构体大小
    DWORD  dwChannel;    //通道号
    DWORD  dwTriggerMode;//触发方式，参考 ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//检测场景号[1,4], IPC默认是0
    BYTE   byRes[63];    //保留留
}NET_DVR_TRIGGER_COND,*LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;//叠加车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;//车道线
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM,*LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySnapMode; //抓拍类型；0~机动车，1~机非人
    BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//牌识参数 
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最右边车道的边界线）
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM,*LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO号[1,4]
            BYTE  byTriggerType;//0-下降沿，1-上升沿
            BYTE  byRes1[2];
        }struIO;//IO模式下生效
        struct
        {
            BYTE  byRelateChan;//关联车检器通道号[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_PRS_PARAM,*LPNET_ITC_LANE_PRS_PARAM;


typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-视频检测,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    BYTE bySnapMode;//0-全景图，1-全景图+特写
    BYTE byCapMode;//bySourceType为0视频检测时使用，0-频闪模式；1-爆闪模式
    BYTE byRes[59];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM,*LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM,*LPNET_IPC_LANE_HVT_PARAM;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;    
    BYTE  byLaneNum;
    BYTE  byRes[62];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char    szSceneName[NAME_LEN/*32*/]; //场景名称
    BYTE  byRes1[408];
} NET_IPC_POST_HVT_PARAM,*LPNET_IPC_POST_HVT_PARAM;

//抓拍机4.0新增
typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE  byLaneNO;        //关联的车道号1～255(用于叠加和上传)
    BYTE  byFlashMode;    //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE  bySignSpeed;    //小车标志限高速，单位km/h
    BYTE  bySpeedLimit;    //小车限高速值，单位km/h
    BYTE  bySignLowSpeed;    //小车标志限底速，单位km/h
    BYTE  byLowSpeedLimit;    //小车限底速值，单位km/h
    BYTE  byBigCarSignSpeed;    //大车标志限高速，单位km/h（新交规）
    BYTE  byBigCarSpeedLimit;    //大车限高速值，单位km/h（新交规）
    BYTE  byBigCarSignLowSpeed;    //大车标志限底速，单位km/h
    BYTE  byBigCarLowSpeedLimit;    //大车限底速值，单位km/h
    BYTE  bySnapTimes;    //卡口抓拍张数，1~3
    BYTE  byDriveLineSnapTime;// 压线抓拍张数 1~3
    BYTE  byHighSpeedSnapTime;// 超高速抓拍张数1~3
    BYTE  byLowSpeedSnapTime;// 超低速抓拍张数1~3
    BYTE  byBanSnapTime;// 违反禁令抓拍张数  1~3
    BYTE  byReverseSnapTime;//逆行抓拍张数  1~3
    BYTE  byRelatedDriveWay;                //关联车道号，用于匹配车检器
    BYTE  byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号byRelatedDriveWay对应，确保车道唯一性。
    BYTE  byRelaLaneDirectionType;
    BYTE  byRes1[29];
    //目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    //类型, 按位表示,0-不启用,1-启用参考 ITC_VIOLATION_DETECT_TYPE
    DWORD  dwVioDetectType;
    DWORD  dwRelatedIOOut;  //关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
    NET_ITC_LINE struTrigLine; //触发线，目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    NET_ITC_LINE struLineLeft;                //左车道线
    NET_ITC_POLYGON struPlateRecog;       //牌识区域
    NET_ITC_LANE_LOGIC_PARAM struLane;   //车道属性，用byUseageType和byCarDriveDirect
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;


typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;    //识别的车道个数，1-6
    BYTE byCapType;        //抓拍类型，0-机、非、人（默认），1-机动车
    BYTE byCapMode;    //抓拍方式，0-视频抽帧，1-打断抓拍，2-混合模式， 
    BYTE bySecneMode;    //场景模式，0-城区道路（默认），1-小区出入口，2-高速公路    
    BYTE bySpeedMode;  //测速模式，0-无测速，1-雷达测速，2-视频测速
    BYTE byLineRuleEffect; //触发规则线有效性,每一位代表一条触发线,0-无效;1-有效。bit0-左触发线;bit1-右触发线;bit2-视频检测区域
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;    //左触发线(一条垂直线)
    NET_ITC_LINE struRigtTrigLine;    //右触发线(一条垂直线)
    NET_ITC_LINE struLaneBoundaryLine;        //车道边界线（最右边车道的右车道线）
    NET_ITC_POLYGON struDetectArea;    //视频检测区域
    NET_DVR_GEOGLOCATION struGeogLocation; //地理位置（默认浙江省）计算时区
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //单车道属性
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;    //牌识参数
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;


//车道参数
typedef struct tagNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byRelatedDriveWay;//关联的车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byPedestriansNum;//行人数量阈值：范围1-100，默认值1
    BYTE byVehicleSpeed;//车辆速度阈值：范围0-100，默认值0
    DWORD dwVehicleInterval; //跟车检测阈值：范围0-65536，默认值0
    BYTE byPedesDetRule; //行人检测规则；代表行人检测区域中行人行驶方向； 0~向左， 1~向右。
    BYTE byRes[3];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_LINE struStopLine;//停止线
    NET_ITC_POLYGON struPlateRecog;       //牌识区域 
    BYTE byRes1[280];
} NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;

//不礼让行人参数
typedef struct tagNET_ITC_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //使能
    BYTE byLaneNum;// 关联车道总数：范围1-3，默认值3
    BYTE byRes[74];
    NET_ITC_LINE struLaneBoundaryLine;//车道右边界线
    NET_ITC_LINE struTriggerLine;//不礼让行人触发线
    NET_ITC_POLYGON struPedesDetRecog;//行人检测区域
    NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    //车道参数
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    BYTE byRes1[400];
}NET_ITC_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM;

//单个IO接入信号灯参数
typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //交通灯导向类型,0-左转灯,1-直行灯,2-右转灯
    BYTE byRelatedIO; //关联的IO口号
    BYTE byRedLightState; //红灯电平状态，0-高电平红灯，1-低电平红灯
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO接入信号灯参数
typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //单个IO接入信号灯参数
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

//单个485接入信号灯参数
typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //交通灯导向类型，0-左转灯，1-直行灯，2-右转灯
    BYTE byRelatedLightChan; //关联的红绿灯检测器通道号
    BYTE byInputLight;    //接入的信号灯类型，0-接红灯，1-接绿灯
    BYTE byRelatedYLightChan; //关联的黄灯检测器通道号
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

//485接入信号灯参数
typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //单个485接入信号灯参数
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

//单组视频检测交通信号灯参数结构
typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //交通灯个数
    BYTE byStraightLight; //是否有直行标志灯，0-否 ，1-是
    BYTE byLeftLight; //是否有左转标志灯，0-否，1-是
    BYTE byRightLight; //是否有右转标志灯，0-否，1-是
    BYTE byRedLight;//是否有红灯，0-否，1-是
    BYTE byGreenLight; //是否有绿灯，0-否，1-是
    BYTE byYellowLight; //是否有黄灯，0-否，1-是
    BYTE byYellowLightTime;//取值范围（0～10s）（ITC3.7Ver）
    NET_POS_PARAM struLightRect; //交通灯区域
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//视频检测交通信号灯参数结构(最大可有12个区域检测，488字节)
typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //单个视频检测信号灯参数
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//交通信号灯接入参数
typedef union tagNET_ITC_LIGHT_ACCESSPARAM_UNION
{
    DWORD uLen[122];
    NET_ITC_IO_LIGHT_PARAM struIOLight; //IO接入信号灯参数
    NET_ITC_RS485_LIGHT_PARAM struRS485Light; //485接入信号灯参数
    NET_ITC_VIDEO_DETECT_LIGHT_PARAM struVideoDelectLight; //视频检测信号灯参数
}NET_ITC_LIGHT_ACCESSPARAM_UNION, *LPNET_ITC_LIGHT_ACCESSPARAM_UNION;

//交通信号灯参数结构
typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //交通信号灯接入源，0-IO接入，1-RS485接入
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//信号灯接入参数
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

//违规检测线参数结构
typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //车道线参数
    NET_ITC_LINE  struStopLine; //停止线参数
    NET_ITC_LINE  struRedLightLine; //闯红灯触发线参数
    NET_ITC_LINE  struCancelLine; //直行触发位置取消线
    NET_ITC_LINE struWaitLine; //待行区停止线参数
    NET_ITC_LINE struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

//行人闯红灯参数
typedef struct tagNET_ITC_REDLIGHT_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //使能
    BYTE bySnapNumTimes; //抓拍张数：1-3，默认3张
    BYTE byPedesDir; //行人方向：0~正向，1~背向，2~双向
    BYTE byDelayTime; //延时时间1-5s
    BYTE byStackTargetEnble;//叠加目标框（即抓拍第一张图片上框住闯红灯的行人），0~不叠加，1~叠加
    BYTE byCalibRecogCtrl;//标定区域控制；0~移除标定区域，1~添加标定区域
    BYTE byRes1[2];
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //交通信号灯参数
    NET_ITC_LINE struStopLine;//停止线
    NET_ITC_POLYGON struCalibRecog[MAX_CALIB_RECOG_NUM/*2*/];//标定区域
    BYTE byRes[440];
}NET_ITC_REDLIGHT_PEDESTRIAN_PARAM,
*LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM;

typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;    
    BYTE  bySceneMode;//场景模式 0-高速公路 1-城市道路
    /*抓拍类型
    bit0-卡口,bit1-大车占道,bit2-压硬路肩
    */
    WORD  wExpressWayCapType;//高速公路
    /*抓拍类型
    bit0-卡口,bit1-机占非,bit2-占用专用车道
    */
    WORD  wUrbanRoadCapType;//城市道路
    BYTE  byCapNum;//抓拍张数 [2,3]
    BYTE  byRecordEnable;//违章录像使能 0-关闭，1-开启
    DWORD dwPreRecordTime;//录像预录时间(s)
    DWORD dwOverRecordTime;//录像超时时间(s)
    NET_ITC_LANE_LOGIC_PARAM struLane;   //车道属性
    NET_ITC_POLYGON struPolygon[MAX_MOBILE_POLYGON_NUM/*3*/]; //牌识区域参数
    NET_ITC_VIOLATION_DETECT_LINE struLine[MAX_MOBILE_DETECTLINE_NUM/*3*/]; //违规检测线
    NET_ITC_LINE struLaneBoundaryLine;        //车道边界线（最右边车道的右车道线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM,*LPNET_ITC_POST_MOBILE_PARAM;

typedef union tagNET_ITC_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1070];            //参数
    NET_ITC_POST_IOSPEED_PARAM      struIOSpeed;    //（卡口）IO测速参数 
    NET_ITC_POST_SINGLEIO_PARAM     struSingleIO;   //（卡口）单IO参数
    NET_ITC_POST_RS485_PARAM        struPostRs485;  //（卡口）RS485车检器参数
    NET_ITC_POST_RS485_RADAR_PARAM  struPostRadar;  //（卡口）RS485雷达参数
    NET_ITC_POST_VTCOIL_PARAM       struVtCoil;     //（卡口）虚拟线圈参数
    NET_ITC_POST_HVT_PARAM          struHvt;        //（卡口）混行卡口参数
    NET_ITC_EPOLICE_IOTL_PARAM      struIOTL;        //（电警）IO红绿灯参数
    NET_ITC_EPOLICE_RS485_PARAM     struEpoliceRs485; //（电警）RS485车检器触发参数
    NET_ITC_EPOLICE_RS485_PARAM     struPERs485;    //（卡式电警）RS485车检器触发参数
    NET_ITC_POST_MPR_PARAM          struPostMpr;    //多帧检测触发（MPR）
    NET_DVR_VIA_VTCOIL_PARAM        struViaVtCoil;  //(VIA)视频检测参数
    NET_ITC_POST_IMT_PARAM          struPostImt;//智慧监控触发
    NET_ITC_POST_PRS_PARAM          struPostPrs;//视频检测触发
    NET_IPC_POST_HVT_PARAM          struIpcHvt;//(IPC) 混行卡口参数
    NET_ITC_POST_HVT_PARAM_V50      struHvtV50;  /*（卡口）混行卡口参数V50*/
    NET_ITC_POST_MOBILE_PARAM       struPostMobile;// 移动交通触发模式
    NET_ITC_NOCOMITY_PEDESTRIAN_PARAM struNoComityPed;//不礼让行人参数
    NET_ITC_REDLIGHT_PEDESTRIAN_PARAM struRedLightPed;//行人闯红灯参数
}NET_ITC_TRIGGER_PARAM_UNION, *LPNET_ITC_TRIGGER_PARAM_UNION;

//单个触发参数结构
typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;    //是否启用该触发模式，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwTriggerType; //触发类型，详见ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //触发参数
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

//触发参数结构
typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;            //结构长度
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //单个触发参数
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;


//违规检测类型宏定义
typedef enum _ITC_VIOLATION_DETECT_TYPE_
{
    ITC_VIOLATION_POST = 0x01, //卡口抓拍
        ITC_VIOLATION_DRIVELINE = 0x02,//压车道线抓拍
        ITC_VIOLATION_REVERSE = 0x04,//逆行抓拍
        ITC_VIOLATION_REDLIGHT = 0x08,//闯红灯抓拍
        ITC_VIOLATION_DIRECTION = 0x10,//不按导向行驶抓拍
        ITC_VIOLATION_INTERSECTION_CONGEST = 0x20,//路口滞留抓拍
        ITC_VIOLATION_NONDRIVEWAY = 0x40,  //机占非抓拍
        ITC_VIOLATION_CHANGELANE = 0x80, //违法变道
        ITC_VIOLATION_BAN = 0x100, //违法禁令
        ITC_VIOLATION_INTERSECTION_PARK=0x200,//红灯越线
        ITC_VIOLATION_GREEN_PARK=0x400,//绿灯停车
        ITC_VIOLATION_HIGH_SPEED = 0x800, /*超速*/
        ITC_VIOLATION_LOW_SPEED = 0x1000, /*低速*/
        ITC_VIOLATION_EMERGENCY = 0x2000, /*占用应急车道*/
        ITC_VIOLATION_TURN_AROUND = 0x8000,/*违法掉头*/
        ITC_VIOLATION_CONGESTION = 0x10000 /*拥堵*/
}ITC_VIOLATION_DETECT_TYPE;


//违规检测参数结构
typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //违规检测类型, 按位表示, 详见ITC_VIOLATION_DETECT_TYPE ,0-不启用,1-启用
    BYTE byDriveLineSnapTimes; //压车道线抓拍张数,2-3
    BYTE byReverseSnapTimes; //逆行抓拍,2-3
    WORD wStayTime; //机占非停留时间（该时间后抓拍），单位s
    BYTE byNonDriveSnapTimes;//机占非抓拍张数2-3
    BYTE byChangeLaneTimes;//违法变道抓拍张数 2-3
    BYTE bybanTimes;//违法禁令抓拍张数2-3
    BYTE byDriveLineSnapSen;// 压线灵敏度(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //第2,3张抓拍位置最小偏移(违反信号灯时起效)（单位：像素） 命名需改进
    BYTE bySpeedTimes;//违法超速抓拍张数2-3(3.8Ver)
    BYTE byTurnAroundEnable;//违章掉头使能 0~关闭 1~开启
    BYTE byThirdPlateRecogTime;//第三张牌识时间 0~180s
    BYTE byPostSnapTimes;//卡口抓拍张数,1-2张
    BYTE byRes1[18];
    WORD wStopLineDis;  //电警第2张违规图片与停止线的最短距离，[0,300]单位(像素)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;

//关联车道方向类型定义
typedef enum _ITC_RELA_LANE_DIRECTION_TYPE_
{
    ITC_RELA_LANE_DIRECTION_UNKNOW      = 0,   //其它
        ITC_RELA_LANE_EAST_WEST               = 1,    //从东向西
        ITC_RELA_LANE_WEST_EAST               = 2,    //从西向东
        ITC_RELA_LANE_SOUTH_NORTH            = 3,    //从南向北
        ITC_RELA_LANE_NORTH_SOUTH            = 4,    //从北向南
        ITC_RELA_LANE_EASTSOUTH_WESTNORTH  = 5,    //从东南向西北
        ITC_RELA_LANE_WESTNORTH_EASTSOUTH  = 6,    //从西北向东南
        ITC_RELA_LANE_EASTNORTH_WESTSOUTH  = 7,    //从东北向西南
        ITC_RELA_LANE_WESTSOUTH_EASTNORTH  = 8     //从西南向东北
} ITC_RELA_LANE_DIRECTION_TYPE;


//车道用途类型定义
typedef enum _ITC_LANE_USEAGE_TYPE_
{
    ITC_LANE_USEAGE_UNKNOW     =  0,   //未知
        ITC_LANE_CARRIAGEWAY  = 1,  //正常车道
        ITC_LANE_BUS      = 2,  //公交车专用道
        ITC_LANE_FAST  = 3,  //快车道
        ITC_LANE_SLOW  = 4,  //慢车道
        ITC_LANE_MOTOR     = 5,   //摩托车道
        ITC_LANE_NONMOTOR  = 6,  //非机动车道
        ITC_LANE_REVERSE_LANE = 7, //反向车道
        ITC_LANE_BAN_TRUCKS  = 8, // 禁止货车车道
        ITC_LANE_MIX = 9, //混合车道
        ITC_LANE_EMERGENCY = 10, //应急车道
        ITC_LANE_BAN_LEFT  = 11, // 禁左车道
        ITC_LANE_BAN_RIGHT  = 12 // 禁右车道
}ITC_LANE_USEAGE_TYPE;

//车道方向类型定义
typedef enum _ITC_LANE_DIRECTION_TYPE_
{
    ITC_LANE_DIRECTION_UNKNOW     =  0,   //未知
        ITC_LANE_LEFT      = 1,  //左转
        ITC_LANE_STRAIGHT  = 2,  //直行
        ITC_LANE_LEFT_STRAIGHT = 3, //左转+直行
        ITC_LANE_RIGHT  = 4,  //右转
        ITC_LANE_LEFT_RIGHT = 5, //左转+右转
        ITC_LANE_RIGHT_STRAIGHT = 6, //右转+直行
        ITC_LANE_LEFT_RIGHT_STRAIGHT = 7, //左转+右转+直行
        ITC_LANE_LEFT_WAIT  =  9,  //左转待行
        ITC_LANE_STRAIGHT_WAIT = 10, //直行待行
        ITC_LANE_FORWARD = 11, //正向行驶
        ITC_LANE_BACKWARD = 12, //背向行驶
        ITC_LANE_BOTHWAY = 13, //双向行驶
        ITC_LANE_STRAIGHT_WAIT_RIGHT = 14 //直行待行 + 右转
}ITC_LANE_DIRECTION_TYPE; 

//车辆行驶方向类型定义 
typedef enum _ITC_LANE_CAR_DRIVE_DIRECT_
{
    ITC_LANE_DRIVE_UNKNOW        = 0, //未知
        ITC_LANE_DRIVE_UP_TO_DOWN    = 1, //从上往下行驶(下行)
        ITC_LANE_DRIVE_DOWN_TO_UP    = 2  //从下往上行驶(上行)        
}ITC_LANE_CAR_DRIVE_DIRECT;

//线类型定义
typedef enum _ITC_LINE_TYPE_
{
    ITC_LINT_UNKNOW     =  0,   //未知
        ITC_LINE_WHITE      = 1,  //车道间的白实线
        ITC_LINE_STOP       = 2, //车道停止线
        ITC_LINE_SINGLE_YELLOW = 3, //单黄线
        ITC_LINE_DOUBLE_YELLOW = 4, //双黄线
        ITC_LINE_GUARD_RAIL = 5, //车道线上有护栏
        ITC_LINE_NO_CROSS = 6, //车辆无法跨越的车道线
        ITC_LINE_DOTTED = 7 //虚线
}ITC_LINE_TYPE;


//单个车道视频电警触发参数结构
typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //关联的车道号
    BYTE bySensitivity; //线圈灵敏度，[1,100]
    BYTE byEnableRadar;//启用雷达测试0-不启用，1-启用
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //车道参数
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //违规检测参数
    NET_ITC_VIOLATION_DETECT_LINE struLine; //违规检测线
    NET_ITC_POLYGON struPlateRecog; //牌识区域参数
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE byCarSpeedLimit; //车速限制值，单位km/h
    BYTE byCarSignSpeed;//标志限速，单位km/h
    BYTE bySnapPicPreRecord; //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE byRes[36];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//视频电警触发参数结构
typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;    //是否启用，0-不启用，1-启用
    BYTE byLaneNum; //识别的车道个数
    BYTE byLogicJudge;//闯红灯违规判断逻辑，设置值为：0-按方向，1-按车道
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //交通信号灯参数
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //单车道参数
    NET_ITC_LINE  struLaneBoundaryLine; //车道边界线（最右边车道的边界线）
    NET_ITC_LINE  struLeftLine; //左转弯分界线
    NET_ITC_LINE  struRightLine; //右转弯分界线
    NET_ITC_LINE  struTopZebraLine; //上部斑马线
    NET_ITC_LINE  struBotZebraLine; //下部斑马线
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;

typedef union tagNET_ITC_VIDEO_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1150];            
    NET_ITC_VIDEO_EPOLICE_PARAM struVideoEP; //视频电警参数
}NET_ITC_VIDEO_TRIGGER_PARAM_UNION, *LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION;

typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //触发模式，详见ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //触发模式参数
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;            //结构长度
    BYTE   byEnableTrigIODetect; //开启触发IO状态检测，1-是，0-否
    BYTE   byEnableFlashOutDetect; //开启同步输出状态检测，1-是，0-否
    BYTE   byEnableRS485Detect; //开启RS485接收状态检测，1-是，0-否
    BYTE   byEnableTrafficLightDetect;//开启交通灯状态检测，1-是，0-否
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;

typedef enum _ITC_STATUS_DETECT_TYPE_
{
    ITC_STATUS_DETECT_NULL = 0,        //未知
        ITC_STATUS_DETECT_TRIGGERIO,    //触发IO
        ITC_STATUS_DETECT_FLASHOUT,     //同步输出
        ITC_STATUS_DETECT_RS485, //RS485
        ITC_STATUS_DETECT_TRIGGERTYPE, //触发类型（保留）
        ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //交通灯（区分颜色）
        ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //交通灯（区分转向）
}ITC_STATUS_DETECT_TYPE;

typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //触发IO号
    BYTE byRes[40]; 
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //同步输出号
    BYTE byRes[40]; 
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //485串口校验结果，0-无效,1-有效, bySerialIndex[0]表示正确的头, bySerialIndex[1]表示正确的尾
    BYTE byRes[40]; 
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //触发类型值
    BYTE byRes[47]; 
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

//视频电警
typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//左转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byRightLight; //右转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byStraightLight; //直行灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

//非视频电警
typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;

typedef union tagNET_ITC_STATUS_UNION
{
    BYTE   uLen[48];            //参数
    NET_ITC_TRIGGERIO_INFO struTrigIO; //触发IO口号
    NET_ITC_FLASHOUT_INFO struFlashOut; //同步输出
    NET_ITC_SERIAL_CHECKINFO struSerial;  //串口
    NET_ITC_TRIGGERTYPE_INFO struTrigType; //触发类型（保留）
    NET_ITC_TRAFFIC_LIGHT_COLOR struTrafficLightColor; //交通灯（区分颜色）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    NET_ITC_TRAFFIC_LIGHT_TURN struTrafficLightTurn;//交通灯（区分转向）对应类型ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
}NET_ITC_STATUS_UNION, *LPNET_ITC_STATUS_UNION;

typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//状态检测类型，详见ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //状态检测结果
    DWORD dwHoldTime; //灯亮持续时间（保留），单位：ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
    BYTE  byAlarmInfoType; //上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
    //1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    BYTE  bySupport; //Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
    //断网续传类型 
    //bit0-车牌检测（IPC） （0-不续传，1-续传）
    //bit1-客流统计（IPC）  （0-不续传，1-续传）
    //bit2-热度图统计（IPC） （0-不续传，1-续传）
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    BYTE  byRes1[5];
    BYTE  byCustomCtrl;//Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传,(注：只在公司内部8600/8200等平台开放)
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //视频触发模式类型，详见ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

//条件结构
typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;//通道号
    BYTE    byWorkMode;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
    BYTE    byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;

//配置结构
typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE                byEnable;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE                 byAddressType;   //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    WORD                wFTPPort;            /*端口*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];//服务器地址，域名 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP地址*/        //IPv4 IPv6地址, 144字节
        } struAddrIP;
    }unionServer;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64    
    BYTE                szUserName[NAME_LEN];        /*用户名*/
    BYTE                szPassWORD[PASSWD_LEN];        /*密码*/
    BYTE                byRes4;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
                                 BYTE                byDirLevel;    /*0 = 不使用目录结构，直接保存在根目录,
                                                                1 = 使用1级目录,2=使用2级目录,
                                 3 = 使用3级目录,4=使用4级目录*/                    
                                 BYTE                 byIsFilterCarPic;/*车牌小图是否上传，0-上传,1-不上传*/
                                 BYTE                    byUploadDataType;//0-全部，1-卡口，2-违章 (单FTP时默认选择全部，双FTP时支持卡口，违章的选择)
                                 NET_DVR_PICTURE_NAME     struPicNameRule;/* 图片命名规则 */
                                                                        BYTE                byTopDirMode; /*一级目录, 0x1 = 使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                bySubDirMode; /*二级目录, 0x1 =使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                byThreeDirMode; /*三级目录, 0x1 = 使用设备名,
                                                                                                            0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                            0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                            0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                byFourDirMode; /*四级目录, 0x1 =使用设备名,
                                                                                                           0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                           0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                           0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        /*图片命名自定义 当PICNAME_ITEM_CUSTOM 时 生效*/
                                                                        BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver 生效)
                                                                        BYTE                szTopCustomDir[MAX_CUSTOMDIR_LEN]; /*自定义一级目录*/  
                                                                        BYTE                szSubCustomDir[MAX_CUSTOMDIR_LEN];/*自定义二级目录*/
                                                                        BYTE                szThreeCustomDir[MAX_CUSTOMDIR_LEN];    /*自定义三级目录*/
                                                                        BYTE                szFourCustomDir[MAX_CUSTOMDIR_LEN];    /*自定义四级目录*/
                                                                        BYTE                 byRes3[900]; //满足12级扩展预留 支持透传
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//度[0,179]
    BYTE byMinute;//分[0,59]
    BYTE bySec;//秒[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//度[0,179]
    BYTE byMinute;//分[0,59]
    BYTE bySec;//秒[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD     dwSize;
    BYTE byGpsDataMode;//GPS数据获取 0-自动，1-手动
    BYTE byLongitudeType;//经度 0-东经，1-西经
    BYTE byLatitudeType;//纬度 0-南纬，1-北纬
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM    struLatitude;     /*纬度*/
    NET_DVR_LONGITUDE_PARAM    struLongitude; /*经度*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG,*LPNET_DVR_GPS_DATACFG;

typedef enum _VCA_DATABASE_TYPE_
{
    DATABASE_NULL = 0, //未知
        DATABASE_SNAP,    //抓拍数据库
        DATABASE_FACE    //人脸数据库
}VCA_DATABASE_TYPE;

typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //数据库ID（设备生成，添加时无效，修改和删除时有效）
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //数据库名称
    BYTE byAttribute[64]; //数据库属性
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //数据库类型，详见VCA_DATABASE_TYPE
    BYTE byRes[12]; //保留
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    BYTE byRes[64]; //保留
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    BYTE byRes[12]; //保留
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_DVR_TIME struSnapTime;  //抓拍时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;

typedef union tagNET_VCA_DELETE_SNAPRECORD_COND_UNION
{ 
    NET_VCA_INQUIRE_SNAPDB_COND struAttribute;  //人员信息（批量删除）
    DWORD dwRecordID; //记录ID（单条删除）
}NET_VCA_DELETE_SNAPRECORD_COND_UNION, *LPNET_VCA_DELETE_SNAPRECORD_COND_UNION;

typedef enum _VCA_DELETE_RECORD_TYPE_
{
    DELETE_RECORD_SINGLE = 0, //单条删除
        DELETE_RECORD_BATCH    //批量删除
}VCA_DELETE_RECORD_TYPE;

typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //删除记录类型
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //删除参数
    BYTE  byRes[40]; //保留
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;

typedef enum _VCA_SEARCH_DATABASE_TYPE_
{
    VCA_NORMAL_SEARCH_DATABASE  = 0x00000000,   //普通检索
        VCA_ADVANCE_SEARCH_DATABASE  = 0x00000001  //高级检索
}VCA_SEARCH_DATABASE_TYPE;

typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //数据库类型，详见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwFacePicID; //人脸图片ID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;

typedef union tagNET_VCA_SEARCH_DATABASE_COND_UNION
{
    DWORD uLen[25];
    NET_VCA_REGISTER_PIC struNormalFind; //普通检索
    NET_VCA_ADVANCE_SEARCH_DATABASE_COND struAdvanceFind; //高级检索
}NET_VCA_SEARCH_DATABASE_COND_UNION, *LPNET_VCA_SEARCH_DATABASE_COND_UNION;

typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //检索类型，详见VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //检索参数
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{ 
    DWORD dwChannel; //通道
    DWORD dwDataBaseID; //数据库ID
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //检索参数
    DWORD dwMaxSearchNum; //最大检索条数
    WORD wThreshold;  //阈值，0-100
    BYTE  byRes[78]; //保留
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_DVR_TIME struSnapTime;//抓拍时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    float fSimilarity; //相似度，[0.001,1]
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{ 
    DWORD dwSize; //结构体大小
    DWORD dwRecordID; //记录ID，添加时无效，修改时有效
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    NET_VCA_REGISTER_PIC struRegisterPic;  //人员图片信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    BYTE  byRes[32]; //保留
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{ 
    DWORD dwSize; //结构体大小
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    DWORD dwImageLen;  //图像数据长度
    BYTE  byRes[80];  //保留
    BYTE *pImage;    //图像数据
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    float fSimilarity; //相似度，[0.001,1]
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{ 
    DWORD dwDataBaseID; //数据库ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //人员信息
    BYTE byRes[80];  //保留
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;

typedef union tagNET_VCA_DELETE_RECORD_COND_UNION
{ 
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //人员信息（批量删除）
    DWORD dwRecordID; //记录ID（单条删除）
}NET_VCA_DELETE_RECORD_COND_UNION, *LPNET_VCA_DELETE_RECORD_COND_UNION;

typedef struct tagNET_VCA_DELETE_RECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //删除记录类型
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //删除参数
    BYTE  byRes[40]; //保留
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{ 
    DWORD dwDataBaseID; //数据库ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //人员信息
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //检索参数
    DWORD dwMaxSearchNum; //最大检索条数
    WORD wThreshold;  //阈值，0-100
    BYTE  byRes[78]; //保留
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwRecordID; //记录ID
    BYTE byRes[64]; //保留
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwRecordID; //记录ID
    DWORD dwPicLen; //图片长度
    BYTE byRes[64]; //保留
    BYTE *pPicBuffer; //图片数据指针
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    WORD wDealyTime; //延迟时间，单位s
    BYTE  byRes[30]; 
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byRes[16]; 
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byIndex;  //无线报警序号，1-8
    BYTE  byRes[15]; 
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;

#define MAX_AUX_ALARM_NUM 8 //最大辅助报警个数
#define MAX_WIRELESS_ALARM_NUM 8 //最大无线报警个数
typedef enum _IPC_AUX_ALARM_TYPE_
{
    IPC_AUXALARM_UNKNOW = 0, //未知
        IPC_AUXALARM_PIR = 1, //PIR报警
        IPC_AUXALARM_WIRELESS = 2,   //无线报警
        IPC_AUXALARM_CALLHELP = 3  //呼救报警
}IPC_AUX_ALARM_TYPE;

typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//使能
    BYTE    byRes1[3];
    DWORD    dwDecibelLimit; //分贝告警阀值
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //异常处理方式
    BYTE    byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG,*LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//使能
    BYTE    byRes1[3]; 
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //异常处理方式
    BYTE    byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG,*LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

//呼救报警
typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byID; //无线报警ID，1-8
    BYTE byRes1[2];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道    
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //单个无线报警参数
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;

typedef union tagNET_IPC_AUX_ALARMCFG_UNION
{
    DWORD uLen[472];
    NET_IPC_PIR_ALARMCFG_EX struPIRAlarm; //PIR报警参数
    NET_IPC_WIRELESS_ALARMCFG struWirelessAlarm; //无线报警参数
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //呼救报警参数
}NET_IPC_AUX_ALARMCFG_UNION, *LPNET_IPC_AUX_ALARMCFG_UNION;

typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;       //报警器类型，详见IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];            
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //报警参数
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //报警参数
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;

typedef union tagNET_IPC_AUXALARM_UPLOAD_UNION
{
    DWORD uLen[66];
    NET_IPC_PIR_ALARMCFG struPIRAlarm; //PIR报警参数
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm; //无线报警参数
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //呼救报警参数
}NET_IPC_AUXALARM_UPLOAD_UNION, *LPNET_IPC_AUXALARM_UPLOAD_UNION;

typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE byAlarmType;       //报警器类型，详见IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //报警结果参数
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;         // 结构体大小 
    BYTE   byCorrectMode;   //校正模式，0-软件校正，1-芯片校正
    BYTE   byMountType;     //安装类型，0-吸顶，1-桌面，2-墙面
    /*
    0-模式1：鱼眼+全景+3PTZ (与原有非实时模式一致)；
    1-模式2：鱼眼+4PTZ(与原有实时模式一致)；
    2-模式3：鱼眼(主)+鱼眼(子)+3PTZ；
    3-模式4：全景展开(主码流+子码流)；
    4-模式5：4PTZ；
    5-模式6：鱼眼；
    */
    BYTE   byRealTimeOutput;  //实时输出，0 -不启用，1- 启用
    BYTE   byRes[61];
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZCommand; //PTZ控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    DWORD dwSpeed; //控制的速度，取值范围[0,7]
    DWORD dwStop; //停止动作或开始动作：0-开始；1-停止
    BYTE  byRes[32]; 
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZPresetCmd; //预置点控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    DWORD dwPresetIndex; //预置点的序号（从1开始），最多支持255个预置点
    WORD  wZoomCoordinate;///<预置点窗口Zoom值
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZCruiseCmd; //巡航控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    WORD wCruiseRoute; //巡航路径，最多支持32条路径（序号从1开始）
    WORD wCruisePoint; //巡航点，最多支持32个点（序号从1开始）
    WORD wInput; //不同巡航命令时的值不同，预置点(最大255)、时间(最大255)、速度(最大40)
    WORD wZoomCoordinate;///<预置点窗口Zoom值
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //启用WPS，0-否，1-是
    BYTE byRes[31]; 
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN码
    BYTE byRes[32]; 
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS连接方式，0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN码(WPS连接方式为AP PIN时有效)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS连接方式为AP PIN时有效)
    BYTE byRes[32]; 
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byJointed;        //  0 没有关联 1 已经关联
    BYTE    byRes1[3];        // 保留字节
    NET_DVR_IPADDR    struIP;    // 被关联解码器的IP地址
    WORD    wPort;            // 被关联解码器的端口号
    WORD    wChannel;        // 被关联解码器的解码通道号
    BYTE    sDeviceName[NAME_LEN];    //被关联解码器的设备名称
    BYTE    sChanName[NAME_LEN];    //被关联解码器的解码通道名称
    BYTE    byRes2[32];        // 保留字节
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struCuIp; //CU端IP地址
    WORD    wPort;/*CU端口*/
    BYTE    bySourceIndex;    //信号源通道号
    BYTE    byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

#define DVCS_DEVICEID_LEN   16
//2012-03-13图片回显注册消息回调
typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD    dwUserID;
    BYTE    sDeviceID[DVCS_DEVICEID_LEN];
    LONG    nPicViewHandle; //回显句柄
    WORD    wSignalIndex;    //信号源索引
    WORD    wHeadLen;        //文件头长度 私有的码流文件头都是40
    BYTE    byHeadBuf[100]; //文件头
    BYTE    byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

#define DEVICEID_LEN      32

typedef struct tagNET_DVR_DEVICEID_INFO
{
    DWORD        dwSize;
    DWORD        dwDeviceIndex;    //设备序号
    BYTE        byWallNo;     //墙号，从1开始
    BYTE        byRes1[27];
    DWORD        dwChan;        //通道号
    DWORD        dwInputSignalIndex; //信号源索引，集中式大屏控制器使用
    BYTE        byRes2[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;


typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;                 //是否启用DHCP 0xff-无效 0-不启用 1-启用
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // 设备IP地址
    NET_DVR_IPADDR  struSubnetMask;  // 设备子网掩码
    NET_DVR_IPADDR  struGateway;     // 设备网关
    WORD    wDevPort;                 // 设备端口号
    BYTE    byMACAddr[MACADDR_LEN];   // MAC 地址(只能获取)
    BYTE    byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD    dwSize;
    BYTE    byValid;                //0-无效 1-有效
    BYTE    byRes1[3];
    BYTE    sChanName[NAME_LEN];    //通道名称
    NET_DVR_COLOR struVideoColor;   //信号源颜色
    WORD    wResolutionX;        //当前分辨率---宽 
    WORD    wResolutionY;        //当前分辨率---高
    BYTE   byRes2[40];
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

//编码子设备信息
typedef struct tagNET_DVR_CODEDEV_INFO 
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];/*设备通道信息*/ 
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

//解码子设备信息
typedef struct tagNET_DVR_DECODEDEV_INFO 
{
    BYTE    byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

//网络信号源信息
typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD    dwSize;
    BYTE    byDevName[NAME_LEN/*32*/];//网络信号源名称
    NET_DVR_PU_STREAM_CFG struPuStream;  
    BYTE    byValid;            //是否有效，0-无效，删除时设为0  1-有效，添加和修改时设为1/
    BYTE     byRes1[3];    //保留
    BYTE    sGroupName[NAME_LEN/*32*/];//网络信号源所在组的组名，网络信号源根据这个组名来分类
    WORD    wResolutionX;        //当前分辨率---宽 
    WORD    wResolutionY;        //当前分辨率---高
    BYTE    byRes2[24];        
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE    byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;

typedef union tagNET_DVR_DIFFDEV_INFO 
{
    NET_DVR_CODEDEV_INFO struCodeDevInfo;        //编码设备信息
    NET_DVR_DECODEDEV_INFO struDecodeDevInfo;    //解码设备信息
    NET_DVR_NETSIGNALDEV_INFO struNetSignalInfo;    //网络信号源信息
} NET_DVR_DIFFDEV_INFO, *LPNET_DVR_DIFFDEV_INFO;

/*注册设备信息*/
typedef enum tagNET_DVCS_DEVICE_TYPE
{
    NET_DVR_BNC_PROC = 1,                       /* BNC处理器 */
        NET_DVR_RGB_PROC,                       /* RGB处理器 */
        NET_DVR_STP_PROC,                       /* 转码处理器 */
        NET_DVR_DISP_PROC,                      /* 显示处理器 */
        NET_DVR_NETSIGNAL,                        //网络信号源
        NET_DVR_SDI_PROC,                       //SDI处理器
        NET_DVR_BIW_PROC,                       //8路BNC处理器
        NET_DVR_DON_PROC,                        //显示处理器
        NET_DVR_TVI_PROC,                       //TVI处理器
        NET_DVR_DI2_PROC                        //2路DVI处理器
}NET_DVCS_DEVICE_TYPE;

typedef struct  tagNET_DVR_SINGLE_DEV_INFO 
{
    DWORD    dwSize;
    DWORD    dwSoftVersion;            /*设备软件版本号(只能获取) 最高8位为主版本号，次高8位为次版本号，低16位为修复版本号*/
    DWORD    dwSoftwareBuildDate;         //版本编译日期Build, 0xYYYYMMDD
    BYTE    byUseInSys;                /*是否在系统中使用*/
    BYTE    byDevStatus;            /*设备当前状态，0-下线，1-上线(只能获取)*/ 
    BYTE    byDeviceType;            /*设备类型(只能获取)  见DEVICE_TYPE*/ 
    BYTE    byRes1[17];
    BYTE    sDevName[NAME_LEN];     /*设备名称*/
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; /*设备网络参数*/
    BYTE    sSerialNumber[SERIALNO_LEN];    /*设备序列号*/
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;        /*设备信息*/ 
    DWORD    dwDeviceIndex;//设备序号，每个设备唯一确定
    BYTE    byRes2[48];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD        dwSize;
    DWORD        dwDevNums;//设备返回的分布式子设备数量
    BYTE          *pBuffer;
    BYTE        byRes1[3];
    DWORD         dwBufLen;//所分配指针长度，输入参数
    BYTE        byRes2[64];
} NET_DVR_DEVLIST,*LPNET_DVR_DEVLIST;

typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;          /*是否在系统中使用*/
    BYTE   byDeviceType;      /*设备类型(只能获取)*/ 
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN]; /*设备名称*/ 
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO,*LPNET_DVR_DEV_BASE_INFO;

/*网络配置信息*/
typedef  struct tagNET_DVR_NETPARAM
{    
    DWORD dwSize;
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET];//以太网口    
    BYTE   byRes[64];
} NET_DVR_NETPARAM, *LPNET_DVR_NETPARAM;

// 绑定屏幕和设备关系(16个字节)
typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD    dwSize;
    WORD    wScreenID;        // 屏幕ID号, ID号从1开始
    BYTE    byWallNo;        // 电视墙号
    BYTE    byRes1;            // 保留1
    DWORD    dwDeviceIndex;    // 输出设备序号
    BYTE    byRes2[16];        // 保留2
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

// 屏幕控制
typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//是否显示文字，1-显示文字，0-不显示文字
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD        dwSize;
    BYTE        byWallNo;    //电视墙号，从1开始
    BYTE        byRes[11];
    DWORD        dwScreenNums;//设备返回的映射显示屏数量
    BYTE          *pBuffer;
    DWORD         dwBufLen;//所分配指针长度，输入参数
} NET_DVR_SCREENLIST,*LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD    dwSize;
    DWORD    dwSubCommand;    //设置设备的命令，1-设备开始升级，2-停止升级
    DWORD    dwDeviceIndex;//设备序号
    BYTE    byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

//设备升级
typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD    dwProgress; // 0-100
    BYTE     byState;  //升级进度：1-升级完成 2-正在升级 3-升级失败
    BYTE    byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;
typedef void (CALLBACK *DVCS_UPGRADESTATE_CB)(LONG nUpgradeHandle, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

typedef enum
{
    NET_DVR_DATA_BMP = 0,
        NET_DVR_START_CALLBACK, 
        NET_DVR_STREAM_SYSHEAD,
        NET_DVR_STREAM_DATA
}PIC_PREVIEW_DATATYPE;

typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD    dwSize;
    DWORD    dwSignalIndex;    //信号源序号，该参数用于大屏控制器，其他设备该值设为0
    DWORD    dwDeviceIndex;//设备序号
    BYTE    byRes1[12];
    BYTE    byChanIndex;    //通道号
    BYTE    byRes2[3];
    //视频综合平台回显参数
    DWORD   dwScreenNum; //大屏序号：从零开始
    DWORD   dwLayer;     //图层号：从零开始
    DWORD   dwResolution;//回显分辨率,1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//帧率，单位：帧/秒
    BYTE    bySupportStreamView; //客户端是否支持码流回显，0-不支持，1-支持
    BYTE    byRes3[14];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD    dwSize;
    BYTE    byAlarmType;        // 报警类型,1-设备上线，2-设备离线 3-服务器上线 4-服务器离线 5-管理员登陆 6-预案开始,7-预案结束，8-分辨率变化，9-图像切割失败，10-设备资源不足，11-温度异常  12-窗口大小与信号源分辨率不符合*/
    BYTE    byDeviceType;        // 设备类型 见定义NET_DVCS_DEVICE_TYPE */ 
    BYTE    byWallNo;            // 墙号，从1开始， 0表示无效
    BYTE    byDeviceChanIndex;     // 设备通道号，0表示无效，其他值表示通道号
    DWORD    dwDeviceIndex;        // 设备序号， 0表示无效
    WORD    wResolutionX;        // 分辨率-宽  0表示无效
    WORD    wResolutionY;        // 分辨率-高  0表示无效
    WORD    wTemperature;       // 设备温度 单位：摄氏度, 0表示无效 
    BYTE    byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD        dwSize;
    BYTE        bySubCommand;        //见宏定义DECODEPIC_LEFTADJUST等
    BYTE        byScale;            //调整的量值
    BYTE        byPictureProportion;    //图像缩放比例 0-无效 1-4:3, 2-16:9
    BYTE        byRes[29];            
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD    dwSize;        
    BYTE    byControlCommand;    //切换命令，1-显示，2-隐藏，3-全部删除（针对GIF图片    ）
    BYTE    byUseType;            //图片类型，1-OSD 2-底图，3-GIF
    BYTE    byWallNo;            //电视墙墙号，从1开始
    BYTE    byPictureNo;        //图片序号
    BYTE    byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;

// 76SP设备POE通道添加方式配置
typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD        dwSize;                  //结构体大小
    BYTE         byAddMode;                 //添加方式 0: 即插即用 1: 手动添加    
    BYTE          byRes1[127];              //保留
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

#define MAX_ESATA_NUM 16
#define MAX_MINISAS_NUM 96

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD        dwSize;
    BYTE        byESATAUsage[MAX_ESATA_NUM];        // 数组索引表示第几个eSATA，0：默认备份 1：默认录像
    BYTE        byMiniSASUsage[MAX_MINISAS_NUM];    // 数组索引表示第几个miniSAS，0：默认备份 1：默认录像
    BYTE         byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

#define MAX_DISK_NUM 128

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD        dwSize;
    BYTE        byDiskDesc[DESC_LEN_32];        //备份磁盘描述
    BYTE        byHardDisk[MAX_DISK_NUM];        //需备份的硬盘号，备份几个取前几个 
    BYTE        byBackupHardDiskNum;              //需备份的硬盘个数
    BYTE        byContinue;                        //是否继续备份，0-不继续，1-继续
    BYTE        byAllLogBackUp ;        /*是否全部备份，0-按磁盘号备份，1-备份所有日志，当为1时，需备份的磁盘号和硬盘个数无效*/
    BYTE         byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD    dwSize;
    BYTE    byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //表示数字语音通道的对讲状态 0-未使用，1-使用中, 0xff无效
    BYTE    byDigitalChanState[MAX_CHANNUM_V30];  /*数字通道的连接状态 byDigitalChanErrState[0] 
                                               表示第一个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0xff表示无效通道或未添加IPC*/
    BYTE    byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30*3];  //表示数字语音通道的对讲状态，从第MAX_CHANNUM_V30+1 到第MAX_CHANNUM_V30*4个， 0-未使用，1-使用中, 0xff无效
    BYTE    byDigitalChanStateEx[MAX_CHANNUM_V30*3];  /*数字通道的连接状态 byDigitalChanErrStateEx[0]表示第从第MAX_CHANNUM_V30+1个个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效*/
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];//表示模拟通道是否启用,0-禁用,1-启用
    BYTE    byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;

//数字通道状态
typedef enum
{
    NET_SDK_DC_STATUS_CONNECTED = 1,                //已连接
        NET_SDK_DC_STATUS_CONNECTING,                    //正在连接
        NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,        //超过系统带宽
        NET_SDK_DC_STATUS_DOMAIN_ERROR,                //域名错误
        NET_SDK_DC_STATUS_CHANNEL_ERROR,                //通道号错误
        NET_SDK_DC_STATUS_ACCOUNT_ERROR,                //用户名或密码错误
        NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,    //流类型不支持
        NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,            //和设备IP地址冲突
        NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,            //和IPC IP地址冲突
        NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,    //网络不可达
        NET_SDK_DC_STATUS_IPC_NOT_EXIST,                //IP通道未接入
        NET_SDK_DC_STATUS_IPC_EXCEPTION,                //IP通道异常
        NET_SDK_DC_STATUS_OTHER_ERROR,                //其他错误
        NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,    //IPC分辨率不支持
        NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,         //IPC语言与NVR语言不匹配
        NET_SDK_DC_STATUS_USER_LOCKED = 16,         //用户被锁定
        NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,        //设备未激活
        NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,      //用户不存在
        NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,     //IP通道对应设备未注册(GB28181协议接入)
        NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20   //POE通道检测中
}NET_SDK_DIGITAL_CHANNEL_STATUS;

/*************************************ITS****************************/
#define VERSION_LEN                 32 //版本长度
#define    MAX_OVERLAP_ITEM_NUM        50 //最大字符叠加种数
#define    ITS_MAX_DEVICE_NUM            32 //最大设备个数

//终端基本信息
typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;    
    BYTE    byMainVer[VERSION_LEN];    // 算法主流程版本
    BYTE    byMprVer[VERSION_LEN];    // 多帧识别库版本
    BYTE    byBvtVer[VERSION_LEN];    // 背向视频库版本
    BYTE    byLptVer[VERSION_LEN];    // 视频跟踪库版本
    BYTE    byTvdVer[VERSION_LEN];    // 违章检测库版本
    BYTE    byTldVer[VERSION_LEN];    // 信号灯检测库版本
    BYTE    byRes[252];        // 预留字段
}NET_ITS_BASEINFO,*LPNET_ITS_BASEINFO;

//图片合成参数
typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE   byIsMerge;        //是否需要合成（0：不合成；1：合成）
    BYTE   byCloseupProportion;//特写图比例 1-原始分辨率大小，2-宽高为原始分辨率两倍，以此类推(1～8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;    //抓拍单张图合成方式（可能会截取特写图）
    /************************************************************************/
    /* 201 两张图片上下排列合成,合成后图片宽为单张图的1倍,高为2倍         */
    /* 202 两张图片左右排列合成,合成后图片宽为单张图的2倍,高为1倍         */
    /* 203 上下合成，特写在最上边.                                          */
    /* 204 上下合成，特写在最下边.                                        */
    /* 205 左右合成，特写在最右边。                                       */
    /* 206 左右合成，特写在最左边                                         */
    /* 207 品字合成，特写图在上边                                         */
    /* 208 倒品字合成，特写图在下边                                       */
    /* 209 唱字形，左边1张为特写                                          */
    /* 210 反唱字形，右边1张为特写                                        */
    /* 301 三张图片上下排列合成,合成后图片宽为单张图的1倍,高为3倍         */
    /* 302 三张图片左右排列合成,合成后图片宽为单张图的3倍,高为1倍          */
    /* 303 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的2倍,高为2倍                      */
    /* 304 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的1倍,高为1倍                      */
    /* 305 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;合成后图片宽为单张图的2倍,高为2倍                      */
    /* 306 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      */
    /* 307 三张图片"品"字型排列合成                                          */
    /* 308 三张图片倒"品"字型排列合成                                      */
    /* 309 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的2倍,高为2倍                          */
    /* 310 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的1倍,高为1倍                          */
    /* 311 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;合成后图片宽为单张图的2倍,高为2倍                          */
    /* 312 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      */
    
    /* 313 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         */
    /* 314 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         */
    /* 315 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         */                   
    /* 316 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         */  
    /* 317 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         */
    /* 318 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         */  
    /* 319 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         */ 
    /* 320 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         */     
    /************************************************************************/
    DWORD  dwTwoMergeType;    //抓拍两张图合成方式
    DWORD  dwThreeMergeType;    //抓拍三张图合成方式
    DWORD  dwJpegQuality;      //压缩质量（0~100）
    DWORD  dwCloseupIndex;     //特写图抓拍第几张
    DWORD  dwMerageMaxSize;   //合成图片大小的上限,300-10240(单位KB)
    WORD   wCloseupDeviation; // 特写图偏移量(50~图片高度)，单位:像素
    BYTE   byRes[30];
}NET_ITS_IMGMERGE_CFG,*LPNET_ITS_IMGMERGE_CFG;

//交通数据主机
typedef    struct    tagNET_ITS_TRAFFIC_DATA_HOST
{
    NET_DVR_IPADDR    struHostAddr;    // 远程主机IP
    WORD            wHostPort;    // 远程主机Port
    BYTE            byRes1[2];
    DWORD            dwDataType;    // 上传远程主机的数据类型（定义见下），按位表示
    BYTE            bySuspendUpload;    // 是否暂停数据上传：0-正常上传；1-暂停上传
    BYTE            byUploadStrategy;    // 上传策略：0-最新数据优先上传；1-按照通行时间上传
    WORD            wUploadInterval;    // 上传间隔时间（ms，1~2000），该参数只对历史数据有效
    DWORD            dwUploadTimeOut; //上传超时时间
    BYTE            byRes[24];
}NET_ITS_TRAFFIC_DATA_HOST,*LPNET_ITS_TRAFFIC_DATA_HOST;

//数据上传参数
typedef  struct    tagNET_ITS_UPLOAD_CFG
{
    DWORD                  dwSize;
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost1;       //接收交通数据主机1
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost2;        //接收交通数据主机2 
}NET_ITS_UPLOAD_CFG,*LPNET_ITS_UPLOAD_CFG;

typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;           //年
    WORD  wMonth;          //月
    WORD  wDay;            //日
    WORD  wHour;           //时
    WORD  wMinute;      //分
    WORD  wSecond;      //秒
    WORD  wMilliSec;    //毫秒
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;

//交通数据主机状态信息
typedef    struct tagNET_ITS_TRAFFIC_DATA_INFO
{
    DWORD    dwDataQuantity;      //数据总量
    DWORD    dwDataRsendQuantity;     //未发送数量（需要上传交通数据主机的）
    NET_DVR_SYSTEM_TIME      struStartTime;        //未发送数据的最早时间
    NET_DVR_SYSTEM_TIME      struEndTime;        //未发送数据的最晚时间
    NET_DVR_IPADDR   struDataHost;    //接收交通数据主机
}NET_ITS_TRAFFIC_DATA_INFO, *LPNET_ITS_TRAFFIC_DATA_INFO;

//终端工作状态
typedef  struct tagNET_ITS_WORKSTATE
{ 
    DWORD  dwSize ;
    BYTE   byDevName[NAME_LEN];    // 设备名称
    DWORD  dwRunTime;        // 系统运行时间，单位s
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //支持两台主机（数据上传配置的主机）
    DWORD  dwMemoryUsage;    // 内存占用率（如果内存占用率为30%，此处填30）
    DWORD  dwCpuUsage;        // cpu占用率（如果cpu占用率为30%，此处填30）
    DWORD  dwDevTemperature;    // 本机温度
    DWORD  dwDeviceStatic;     // 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //硬盘状态
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //通道的状态
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //报警输入口的状态,0-没有报警,1-有报警
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD dwLocalDisplay;            //本地显示状态,0-正常,1-不正常
    BYTE  byAudioInChanStatus[8];      //表示语音通道的状态 0-未使用，1-使用中，数组0表示第1个语音通道
    BYTE  byRes[36];             //保留
}NET_ITS_WORKSTATE, *LPNET_ITS_WORKSTATE;

//出入口交通配置获取参数
typedef  struct tagNET_ITS_ECT_WORKSTATE_COMMAND
{ 
    DWORD    dwSize;
    DWORD   dwChannel;
    BYTE    byRes[256];             //保留
}NET_ITS_ECT_WORKSTATE_COMMAND, *LPNET_ITS_ECT_WORKSTATE_COMMAND;

typedef struct tagNET_ITS_ECTWORKSTATE
{ 
    DWORD     dwSize ;
    BYTE     byDevName[NAME_LEN];    // 设备名称
    DWORD    dwRunTime;        // 系统运行时间，单位s
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //支持两台主机（数据上传配置的主机）
    DWORD    dwMemoryUsage;    // 内存占用率（如果内存占用率为30%，此处填30）
    DWORD    dwCpuUsage;        // cpu占用率（如果cpu占用率为30%，此处填30）
    DWORD    dwDevTemperature;    // 本机温度
    DWORD    dwDeviceStatic;     // 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //硬盘状态
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //报警输入口的状态,0-没有报警,1-有报警
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD    dwLocalDisplay;            //本地显示状态,0-正常,1-不正常
    BYTE     byRes[256];             //保留
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

// 图片信息（后续会加入码流）
typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;            //媒体数据长度
    BYTE    byType;            // 0:车牌图;1:车辆图;2:合成图; 3:特写图;4:二直图;5:码流;6:人脸子图(主驾驶);7:人脸子图(副驾驶)成图;8-非机动车;9-行人;10-称重原始裸数据;11-目标图
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE    byDataType;
    BYTE    byCloseUpType;//特写图类型，0-保留,1-非机动车,2-行人
    BYTE    byPicRecogMode;  //图片背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
    DWORD   dwRedLightTime;        //经过的红灯时间  （s）
    BYTE    byAbsTime[32];        //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    NET_VCA_RECT   struPlateRect;    //车牌位置
    NET_VCA_RECT  struPlateRecgRect;   //牌识区域坐标
    BYTE    *pBuffer;    //数据指针
    DWORD   dwUTCTime;//UTC时间定义
    BYTE    byCompatibleAblity; //兼容能力字段 0表示无效，1表示有效; bit0-表示dwUTCTime字段有效
    BYTE    byRes2[7];           //保留
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;


typedef struct tagNET_ITS_ILLEGAL_INFO
{
    BYTE  byIllegalInfo[MAX_ILLEGAL_LEN/*64*/];// 违章类型信息（字符格式）
    BYTE  byRes[256];
}NET_ITS_ILLEGAL_INFO,*LPNET_ITS_ILLEGAL_INFO;


// 检测结果
typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    BYTE    byPicNo;        //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    BYTE    byFeaturePicNo; //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    BYTE    byDriveChan;        //触发车道号
    BYTE    byVehicleType;     //车辆类型，参考VTR_RESULT
    BYTE    byDetSceneID;//检测场景号[1,4], IPC默认是0
    BYTE    byVehicleAttribute;//车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    WORD    wIllegalType;       //违章类型采用国标定义
    BYTE    byIllegalSubType[8];   //违章子类型
    BYTE    byPostPicNo;    //违章时取第几张图片作为卡口图,0xff-表示不取
    //通道号(有效，报警通道号和所在设备上传报警通道号一致，在后端和所接入的 通道号一致)
    BYTE    byChanIndex;        
    WORD    wSpeedLimit;        //限速上限（超速时有效）
    BYTE    byRes2[2];
    NET_DVR_PLATE_INFO  struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //车辆信息
    BYTE    byMonitoringSiteID[48];        //监测点编号
    BYTE    byDeviceID[48];                //设备编号
    BYTE    byDir;            //监测方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    BYTE    byDetectType;    //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    DWORD   dwCustomIllegalType; //违章类型定义(用户自定义)
    /*为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
      为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码*/
    BYTE*   pIllegalInfoBuf;    //违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO 
    BYTE    byIllegalFromatType; //违章信息格式类型； 0~数字格式， 1~字符格式
    BYTE    byRes4; //保留
    BYTE    byDataAnalysis;            //0-数据未分析, 1-数据已分析
    BYTE    byYellowLabelCar;        //0-表示未知, 1-非黄标车,2-黄标车
    BYTE    byDangerousVehicles;    //0-表示未知, 1-非危险品车,2-危险品车
    BYTE    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据黑白名单匹配后，是否开闸成功的标志)
    BYTE    byBarrierGateCtrlType; 
    BYTE    byAlarmDataType;//0-实时数据，1-历史数据
    NET_DVR_TIME_V30  struSnapFirstPicTime;//端点时间(ms)（抓拍第一张图片的时间）
    DWORD   dwIllegalTime;//违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //图片信息,单张回调，最多6张图，由序号区分
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

//出入口车辆抓拍数据上传
typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码 默认0
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）默认 1 抓拍类型下图片数据 控制后续接收延时操作
    BYTE    byPicNo;        //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成。
    //接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）标示前后相机抓拍图片
    BYTE    byRes; //标记为预留
    WORD    wLaneid;            //车道号1～32（索引车道号，可以跳跃）
    BYTE    byCamLaneId;    //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE    byRes1;            //保留
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //自定义报警类型 默认为中文
    WORD    wBackList;    //标记为是否报警数据 0 表示为正常过车数据 1 表示黑名单
    WORD    wSpeedLimit;        //限速上限（超速时有效）km/h
    DWORD   dwChanIndex;        //通道号
    NET_DVR_PLATE_INFO    struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO  struVehicleInfo;    //车辆信息  含速度
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN];                //设备编号 
    BYTE    byDir;            //监测方向，0-其它 1 入场，2 出场
    BYTE    byDetectType;    //检测方式, 0-其他 1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN]; // 卡号
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[4];         //图片信息,单张回调，最多4张图，由序号区分
    //2013-11-19 出入口车辆抓拍数据上传（监听方式）新增参数
    BYTE    bySwipeTime[MAX_TIME_LEN];//增加刷卡时间  时间格式为yyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;

//出入口人脸识别
typedef  struct  tagNET_ITS_GATE_FACE
{
    DWORD   dwSize;            //结构体长度
    BYTE    byGroupNum;    //图片组数量（一个行人相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    BYTE    byPicNo;        //连拍的图片序号（接收到图片组数量后，表示接收完成。
    //接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    byFeaturePicNo; //连抓时取第几张图作为特写图,0xff-表示不取
    BYTE    byRes;   //保留
    WORD    wLaneid;            //车道号1～32（索引车道号，可以跳跃）
    BYTE    byCamLaneId;    //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE    byDir;        //监测方向，0-其他 1 入场， 2 出场
    DWORD   dwChanIndex;        //通道号 
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN];                //设备编号
    NET_VCA_FACESNAP_RESULT     struFaceInfo;   //人脸抓拍数据    
    BYTE    byRes2[256];   //预留
}NET_ITS_GATE_FACE, *LPNET_ITS_GATE_FACE;

//停车场数据上传
typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize; //结构长度
    BYTE    byGroupNum; //图片组数量（单次轮询抓拍的图片数量）
    BYTE    byPicNo; //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成
    //接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    byLocationNum; //单张图片所管理的车位数
    BYTE    byParkError; //停车异常，0-正常 1 异常
    BYTE    byParkingNo[MAX_PARKNO_LEN];//车位编号
    BYTE    byLocationStatus; //车位车辆状态，0-无车，1有车
    BYTE    bylogicalLaneNum;//逻辑车位号，0-3，一个相机最大能管4个车位 （0代表最左边，3代表最右边）
    WORD    wUpLoadType;//第零位表示：0~轮训上传、1~变化上传
    BYTE    byRes1[4]; //保留字节
    DWORD   dwChanIndex; //通道号数字通道
    NET_DVR_PLATE_INFO   struPlateInfo;  //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    byMonitoringSiteID[MAX_ID_LEN]; //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN]; //设备编号 
    DWORD   dwPicNum; //图片数量（与picGroupNum不同，代表本条信息附带的图片数量
    //，图片信息由struVehicleInfoEx定义 
    NET_ITS_PICTURE_INFO struPicInfo[2];  //图片信息,单张回调，最多2张图，由序号区分
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

//交通取证报警
typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //结构体大小
    DWORD                   dwRelativeTime;        //相对时标
    DWORD                   dwAbsTime;               //绝对时标
    DWORD                   dwIllegalType;         //违章类型，采用国标定义
    DWORD                   dwIllegalDuration;     //违法持续时间（单位：秒） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//监测点编号（路口编号、内部编号）
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //设备编号
    NET_VCA_DEV_INFO        struDevInfo;           //前端设备信息
    NET_DVR_SCENE_INFO      struSceneInfo;         //场景信息
    NET_DVR_TIME_EX         struBeginRecTime;      //录像开始时间 
    NET_DVR_TIME_EX         struEndRecTime;        //录像结束时间 
    NET_DVR_AID_INFO        struAIDInfo;           //交通事件信息
    NET_DVR_PLATE_INFO      struPlateInfo;         //车牌信息
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //车辆信息
    DWORD                   dwPicNum;              //图片数量
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //图片信息，最多8张 
    BYTE                    bySpecificVehicleType;     //具体车辆种类  参考识别结果类型VTR_RESULT
    BYTE                    byLaneNo;  //关联车道号
    BYTE                    byRes1[2]; //保留
    NET_DVR_TIME_V30        struTime;//手动跟踪定位，当前时间。
    DWORD                   dwSerialNo;//序号；
    BYTE                    byVehicleAttribute;//车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    BYTE                    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE                    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE                    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE                    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE                    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    BYTE                    byRes[102]; //保留
}NET_DVR_TFS_ALARM,*LPNET_DVR_TFS_ALARM;

typedef struct _tagNET_ITS_ECT_BLACKLIST_
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  bylogicalLaneNo;//逻辑车道号
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];//车道名称 32
    NET_DVR_PLATE_INFO  struPlateInfo;  //车牌信息结构  
    BYTE  byRes2[256];       // 保留字节    
}NET_ITS_ECT_BLACKLIST, *LPNET_ITS_ECT_BLACKLIST;

//IPC通道参数配置
typedef    struct     tagNET_ITS_IPC_CHAN_CFG
{
    DWORD        dwSize; 
    BYTE        byCameraType;        //相机种类，0-监控用相机；1-线圈触发相机；2-视频分析用相机,3-一体机
    BYTE        byRes1[3];           //保留
    BYTE        byMonitoringSiteID[48];        //监测点编号
    BYTE        byDeviceID[48];                //设备编号
    BYTE        byDirectionNo;         //监测方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
    BYTE        byMonitorInfo[48];      //监测点信息描述
    BYTE        byRes2[15];        //保留
}NET_ITS_IPC_CHAN_CFG, *LPNET_ITS_IPC_CHAN_CFG;

//单个设备信息
typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;  //设备类型：0-终端，1-相机，2-补光灯，3-车检器，4-线圈1，5-线圈2，6-线圈3，7-红绿灯检测器，8-机柜，
    //9-雷达，10-道闸，11-出入口控制机(票箱)，12-LED显示屏，13-远距离读卡器，14-近距离读卡器，15-红外扫描枪，
    //16-票据打印机，17-节点管理器(诱导服务器相关) , 18-机柜检测仪
    DWORD  dwDirID;               //方向编号
    DWORD  dwLaneID;             //车道编号
    DWORD  dwDeviceState;         //设备状态  0正常 非0 异常（参考设备异常代码表）
    BYTE   byDeviceName[32];     //设备名称
    BYTE   byDeviceID[48];           //设备编号，一般用序列号，车检器用地址
    NET_DVR_TIME_V30  struTriggerTime;//触发时间
    BYTE   byRelateChan; //关联通道号（传感器是1~8  AC端子1~4  AC插座1~2）
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO,*LPNET_ITS_SINGLE_DEVICE_INFO;

//路口信息
typedef struct tagNET_ITS_ROADINFO
{    
    DWORD     dwSize;
    DWORD     dwChannel;          //通道号,0xffffffff表示终端，其它表示对应的相机
    BYTE     byTriggerMode;    //  0:线圈触发;  1:视频触发
    BYTE     byRes1[3];
    DWORD    dwDeviceNum;       //实际设备个数 
    BYTE     byMonitoringSiteID[48];    //监测点编号
    BYTE       byRoadInfo[48];       //监测点信息
    NET_ITS_SINGLE_DEVICE_INFO        struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE     byRes[16];
}NET_ITS_ROADINFO,*LPNET_ITS_ROADINFO;

//单个车道路况信息
typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;        //车道号
    BYTE   byRes1[3];            // 预留
    WORD   wCarFlux;            //汽车流量数
    WORD   wPasserbyFlux;        //行人流量数
    WORD   wShayFlux;        //二轮车流量数
    float  fAverOccpancy;       //平均车道占有率百分比
    WORD   wAverSpeed;         //平均车速(km/h)
    WORD   wAverCarDis;        //平均车距(单位待定)
    BYTE   byRes2[16];            // 预留
}NET_ITS_TRAFFIC_DRIVE_CHAN,*LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;        //结构大小
    BYTE   byMonitoringSiteID[48];        //监测点编号
    BYTE   byDeviceID[48];                //设备编号
    BYTE   byLaneNum;    //车道总数
    BYTE   byDir;        //监测方向
    BYTE   byDetectType;    //检测方式1-地感线圈、2-视频触发、3、多帧识别、4雷达触发
    BYTE   byRes1;           //预留     
    DWORD  dwChannel; //通道号
    NET_DVR_SYSTEM_TIME     struStartTime;        //统计开始时间
    DWORD  dwSamplePeriod;    //统计时间,单位秒
    NET_ITS_TRAFFIC_DRIVE_CHAN    struDriveChan[6];         //交通流量数据,每个相机支持6个车道
    BYTE   byRes2[24];     //预留
}NET_ITS_TRAFFIC_COLLECT,*LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //配置模式，0-终端，1-前端(直连前端或终端接前端)
    BYTE  byPicModeType;//0-表示小图(独立图)，1-表示大图(合成图)
                        /*
                        0表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
                        1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    */
    BYTE  byRelateType; 
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;

typedef enum ITS_OVERLAP_ITEM_TYPE
{
    OVERLAP_ITEM_NULL = 0,          //0-未知
        OVERLAP_ITEM_SITE,                //1-地点
        OVERLAP_ITEM_ROADNUM,             //2-路口编号
        OVERLAP_ITEM_INSTRUMENTNUM,       //3-设备编号
        OVERLAP_ITEM_DIRECTION,           //4-方向编号
        OVERLAP_ITEM_DIRECTIONDESC,       //5-方向
        OVERLAP_ITEM_LANENUM,             //6-车道号
        OVERLAP_ITEM_LANEDES,             //7-车道
        OVERLAP_ITEM_CAPTIME,             //8-抓拍时间(不带毫秒)
        OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-抓拍时间(带毫秒)
        OVERLAP_ITEM_PLATENUM,            //10-车牌号
        OVERLAP_ITEM_CARCOLOR,            //11-车身颜色
        OVERLAP_ITEM_CARTYPE,             //12-车辆类型
        OVERLAP_ITEM_CARBRAND,            //13-车辆品牌
        OVERLAP_ITEM_CARSPEED,            //14-车辆速度
        OVERLAP_ITEM_SPEEDLIMIT,          //15-限速标志
        OVERLAP_ITEM_CARLENGTH,           //16-车辆长度1~99m
        OVERLAP_ITEM_ILLEGALNUM,          //17-违法代码(违法代码叠加应该没用的，应该直接叠加违法信息，比如正常、低速、超速、逆行、闯红灯、占道、压黄线等)
        OVERLAP_ITEM_MONITOR_INFO,      //18-监测点信息
        OVERLAP_ITEM_ILLEGALDES,          //19-违法行为
        OVERLAP_ITEM_OVERSPEED_PERCENT,    //20-超速比
        OVERLAP_ITEM_RED_STARTTIME,           //21-红灯开始时间
        OVERLAP_ITEM_RED_STOPTIME,        //22-红灯结束时间
        OVERLAP_ITEM_RED_DURATION,        //23-红灯已亮时间
        OVERLAP_ITEM_SECUNITY_CODE,        //24-防伪码
        OVERLAP_ITEM_CAP_CODE,        //25-抓拍编号
        OVERLAP_ITEM_SEATBELT,      //26-安全带  
        OVERLAP_ITEM_MONITOR_ID,    //27-监测点编号
        OVERLAP_ITEM_SUN_VISOR,     //28-遮阳板 
        OVERLAP_ITEM_LANE_DIRECTION,  //29-车道行驶方向 
        OVERLAP_ITEM_LICENSE_PLATE_COLOR,  // 30-车牌颜色
        OVERLAP_ITEM_SCENE_NUMBER,  //31-场景编号
        OVERLAP_ITEM_SCENE_NAME,   //32-场景名称
        OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-黄标车
        OVERLAP_ITEM_DANGEROUS_CAR,    //34-危险品车
        OVERLAP_ITEM_CAR_SUBBRAND  //35-车辆子品牌
}ITS_OVERLAP_ITEM_TYPE;

//字符叠加每一条信息结构体
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                   // 保留
    BYTE byItemType;   //类型，详见OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //叠加项后的换行数[0-10](默认0)
    BYTE bySpaceNum;                   //叠加项后的空格数[0-255](默认0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //是否启用坐标显示
    WORD wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //单条字符参数
    DWORD dwLinePercent;  //叠加行百分比(0-100),(默认100)
    DWORD dwItemsStlye;   //叠加方式：0-横排,1-竖排(默认横排)
    WORD  wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wCharStyle;    //字体类型,0-宋体1-魏体(默认)
    WORD  wCharSize;    //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    WORD  wCharInterval;    //字符间距，[0～16]，可设单位：像素(默认)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    DWORD dwBackClorRGB; //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    BYTE  byColorAdapt;    //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //起始上坐标,只对图片内部叠加有效[0~2448](默认0) 
    WORD  wStartSPicPosLeft; //起始左坐标,只对图片内部叠加有效[0~2448](默认0) 
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    BYTE       byOsdLocate;
    BYTE         byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

//叠加项具体信息
typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //地点描述
    BYTE byRoadNum[32];  //路口编号
    BYTE byInstrumentNum[32];                //设备编号
    BYTE byDirection[32];        //方向编号
    BYTE byDirectionDesc[32];    //方向描述
    BYTE byLaneDes[32];        //车道描述
    BYTE byRes1[32];     //保留
    BYTE byMonitoringSite1[44];        //监测点1信息
    BYTE byMonitoringSite2[32];        //监测点2信息
    BYTE byRes[64];        //保留
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;    
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM        struOverLapItem; //字符串参数
    NET_ITS_OVERLAP_INFO_PARAM     struOverLapInfo;  //字符串内容信息
    BYTE  byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

//字符叠加每一条信息结构体
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                   // 保留
    BYTE byItemType;   //类型，详见OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //叠加项后的换行数[0-10](默认0)
    BYTE bySpaceNum;                   //叠加项后的空格数[0-255](默认0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //是否启用坐标显示
    WORD wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    //自定义类型；与byItemType参数对应。可将byItemType参数类型自定义名称。若自定义内容为空，便默认以byItemType参数中的类型命名。
    BYTE byItemTypeCustom[32]; 
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //单条字符参数
    DWORD dwLinePercent;  //叠加行百分比(0-100),(默认100)
    DWORD dwItemsStlye;   //叠加方式：0-横排,1-竖排(默认横排)
    WORD  wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wCharStyle;    //字体类型,0-宋体1-魏体(默认)
    WORD  wCharSize;    //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    WORD  wCharInterval;    //字符间距，[0～16]，可设单位：像素(默认)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    DWORD dwBackClorRGB; //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    BYTE  byColorAdapt;    //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //起始上坐标,只对图片内部叠加有效[0~2448](默认0) 
    WORD  wStartSPicPosLeft; //起始左坐标,只对图片内部叠加有效[0~2448](默认0) 
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    BYTE  byOsdLocate;
    BYTE  byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;    
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM_V50        struOverLapItemV50; //字符串参数
    NET_ITS_OVERLAP_INFO_PARAM             struOverLapInfo;  //字符串内容信息
    BYTE  byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;

#define  MAX_PTZCRUISE_POINT_NUM   32   //最大支持32个巡航点


//预置点信息
typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum; //预置点个数
    DWORD dwGroupNum;  //组数
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;

//输入参数
typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //组号
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;

//输出参数
typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //预置点序号
    NET_VCA_POINT struVcaPoint; //预置点坐标
    WORD wZoomCoordinate; ///<预置点窗口Zoom值
    BYTE  byRes[30]; 
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

//获取巡航路径的数目
typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum; //路径个数
    DWORD dwGroupNum; //组数
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

//输入参数：
typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //组号
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;

//输出参数
typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //预置点序号
    NET_VCA_POINT struVcaPoint; //预置点坐标
    BYTE    byDwell;        //停留时间
    BYTE    bySpeed;        //速度
    WORD  wZoomCoordinate;///<预置点窗口Zoom值
    BYTE   byRes[28]; 
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute; //巡航路径序号
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM]; //最大支持32个巡航点
    BYTE  byRes[32]; 
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;

//跟踪模式结构
typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize; 
    BYTE byEnableTrack;   //启用跟踪，0-否，1-是
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;

//一天的定时计划
typedef struct tagNET_DVR_DAY_SCHEDULE
{   
    BYTE byWorkMode ;            //0-全天开，1-全天关，2-定时
    BYTE byRes1[3] ;
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];  //时间段
    BYTE byRes2[8];                  //保留
}NET_DVR_DAY_SCHEDULE ,*LPNET_DVR_DAY_SCHEDULE;

//定时智能跟踪参数结构
typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD    dwSize;    //结构长度
    BYTE     byEnableTrack;            //启用跟踪：0- 否，1- 是
    BYTE    byRes1[3] ;
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];    //定时智能跟踪时间段，不在这8个时间段内的时间，默认定时智能跟踪关闭
    BYTE    byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG,*LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD    dwSize;                    //结构长度
    BYTE    sStreamID[STREAM_ID_LEN/*32*/] ; //流ID
    DWORD    dwChan;                     //被控通道号
    BYTE    byStreamType;             //0-主码流，1-子码流，2-码流3，3-码流4，4-码流5     
    BYTE    byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //星期几，1-7代表星期一到星期日
    BYTE byHour;   //时
    BYTE byMinute; //分    
    BYTE byRes1;
    BYTE byRebootMode; //0-按周重启，1-按月重启（此参数只能获取，不能设置）
    BYTE byRes[11]; //保留
}NET_DVR_REBOOT_TIME,*LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG,*LPNET_DVR_AUTO_REBOOT_CFG;

#define NET_DVR_GPS_FINDING       0   //正在查找
#define NET_DVR_GPS_RECV          1   //接收数据
#define NET_DVR_GPS_OVER          2   //查找结束
#define NET_DVR_GPS_EXCEPTION     3   //接收异常
typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD        dwSize;
    BYTE        byMenuOutputMode; //非同源设备：0-Auto 1-主CVBS 2-HDMI 3-VGA 同源设备：0-Auto 1-主CVBS 2-HDMI/VGA
    BYTE        byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP地址
    WORD        wPort;   //端口号
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR,*LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //设备id
    BYTE byPassword[PASSWD_LEN];  //密码
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //设备id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{   
    DWORD dwSize;
    BYTE byNetEnvironment;/*网络环境,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*< 当前平台0 - WVS, 1 - E家, 2 - 推模式 */
    BYTE byRes1[2];    
    NET_DVR_MB_WVSPARA  struWVSPara; /*车载平台(平台登入)*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E家平台车载平台不设置设备登入密码 */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE        byGPSModule;      /*gps模块, 0: 不存在, 1: 正常*/
    BYTE        byPositionStatus;      /*gps定位状态, 0: 定位失败, 1: 定位成功*/
    BYTE        bySignalStrength;    /*信号强度, 0: 弱, 1: 正常, 2: 强*/
    BYTE        byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE        byGsensorModule;    /*g-sensor模块, 0: not exist, 1: 内置, 2: 外置*/
    BYTE        byCurAccX[10];     /*当前X轴加速度*/
    BYTE        byCurAccY[10];    /*当前Y轴加速度*/
    BYTE        byCurAccZ[10];    /*当前Z轴加速度*/
    BYTE        byRefAccX[10];    /* X轴加速度标定值*/
    BYTE        byRefAccY[10];    /* Y轴加速度标定值*/
    BYTE        byRefAccZ[10];    /* Z轴加速度标定值*/
    BYTE        byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

#define IP_ADDR_LEN         16
#define IW_ESSID_MAX_SIZE    32

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE        byEnableWiFi; /* 无线, 0 关, 1 开 */
    BYTE         byWiFiConnectStatus;  /* WIFI状态, 0: 连接失败, 1: 连接成功 2: 无模块*/
    BYTE        bySignalStrength;             /* 信号强度, 0 弱, 1 正常, 2 强 */
    BYTE        byIPaddress[IP_ADDR_LEN];   /*WIFI 设备 ip*/
    BYTE        byEssid[IW_ESSID_MAX_SIZE];  /*无线接入点essid*/
    BYTE        byres[5];
}NET_DVR_MB_WIFI_STATUS,*LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE        byCurPlat;      /*当前平台, 0: wvs, 1: ivms, 2: 推模式(net_3g_sdk)*/
    BYTE        byLoginStatus;     /*login 状态, 0: login failed, 1: login success*/
    BYTE        byExceptionInfo;      /*异常信息*/
    /*
    WVS :exception info:
    0: 连接服务器失败
    1: 注册中
    2: 用户名密码错误
    3: 注册超时
    4: 心跳超时
    5: 注册成功
    iVMS :exception info:
    0未注册    
    1注册中    
    2注册连接出错
    3注册超时
    4长时间没有心跳，连接中断
    5重新注册
    6 CMS中注册设备数量已经超过限定的台数
    7 CMS中注册通道数量已经超过限定通道数
    8设备在WEB管理中心中没有配置
    9CMS和WEB管理中心通信失败
    10登录未知错误
    11注册成功
    推模式 :exception info:    
    0未注册
    1: 注册中
    2: 重复注册
    3: 注册连接失败
    4: 服务器IP变化
    5: 注册成功
    6: 用户注销
    7: 心跳超时
    */                        
    BYTE        byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;


typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD        dwSize;      /*结构大小*/
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

#define NET_DVR_GPS_STATUS       0
#define NET_DVR_GSENSOR_STATUS   1
#define NET_DVR_WIFI_STATUS      2
#define NET_DVR_PLATFORM_STATUS  3

//GPS点信息结构
typedef struct tagNET_DVR_GPS_INFO
{
    /* 经纬度为S*100 */
    BYTE    byDirection[2];        /*direction[0]0or1(东经/西经), direction[1]:0or1(北纬/南纬)  */
    BYTE    bySvs;         /* satellite vehicles(初值0)：有效定位星数 */
    BYTE    byLocateMode;  /* 定位模式(初值0)：仅NMEA0183 3.00版本输出，0=自主定位，1=差分，2=估算，3=数据无效 */
    WORD    wHDOP;  /* 水平精度因子，度量GPS精确度，0.5-99.9，6以内定位精度高，20以上需丢弃，这里存储的是乘以10以后的整数 */     
    WORD    wHeight;             /* 高度 */
    DWORD   dwLatitude;     /*纬度latitude = 实际度*3600*100+实际分*60*100+实际秒*100 */
    DWORD   dwLongitude; /*经度longitude =实际度*3600*100+实际分*60*100+实际秒*100 */
    DWORD   dwVehicleSpeed;        /* mobile speed =实际速度*100000 实际单位kph*/
    DWORD    dwVehicleDirection;    /* mobile direction= 实际方向*100，实际数值是方向角，正北为0度，顺时针 */
    BYTE    byRes[8];            // 保留
}NET_DVR_GPS_INFO,*LPNET_DVR_GPS_INFO; //32字节

//GPS关联时间
typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS坐标点
    NET_DVR_TIME      struTime;            //GPS坐标对应的时间点，UTC时间
    BYTE        byRes[12];             // 保留
}NET_DVR_GPS_DATA,*LPNET_DVR_GPS_DATA;

//GPS查找条件结构
typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{    
    DWORD dwCmdType;              //0-按时间段查找GPS数据,1-按时间点查找GPS数据    
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //GPS数据查找起始时间       
            NET_DVR_TIME struEndTime;                 //GPS数据查找结束时间
            DWORD dwInterval;                  //GPS点时间间隔，单位秒
            BYTE  byRes[76];                    // 保留
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //GPS数据查找起始时间单位秒
            BYTE  byRes[104];              // 保留
        }TimePoint;    
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM,*LPNET_DVR_GET_GPS_DATA_PARAM;

typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE    byEnableAbilityParse;    //使用能力集解析库,0-不使用,1-使用,默认不使用
    BYTE    byVoiceComMode;          //对讲模式，0-使用对讲库（默认），1-使用windows api模式    
    BYTE    byLoginWithSimXml;  //登录时使用模拟能力,0-不使用,1-使用,默认不使用
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE    byProtectKey[128];    //默认设置为0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;

typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE    byEnableAbilityParse;    //使用能力集解析库,0-不使用,1-使用,默认不使用
    BYTE    byRes[127];                
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE    byTalkMode;                //对讲模式，0-使用对讲库（默认），1-使用windows api模式
    BYTE    byRes[127];                
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;


typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE    byProtectKey[128];        //默认设置为0
    BYTE    byRes[128];            
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //登录时使用模拟能力校正结构体能力字段,0-不使用,1-使用
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;

typedef enum tagNET_SDK_LOCAL_CFG_TYPE
{
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,        //本地TCP端口绑定配置，对应结构体NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,            //本地UDP端口绑定配置，对应结构体NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,                //内存池本地配置，对应结构体NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,        //按模块配置超时时间，对应结构体NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,            //是否使用能力集解析库，对应结构体NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,                //对讲模式，对应结构体NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,                //密钥设置，对应结构体NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,             //用于测试版本头的设备端兼容情NET_DVR_LOCAL_MEM_POOL_CFG况, 只有在设置参数时才起作用。
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,                //rtsp参数配置，对于结构体NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            //在登录时使用模拟能力补充support字段, 对应结构NET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                //心跳交互间隔时间
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  //SDK本次安全配置，
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            //配置萤石云通信库地址，
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               //13.配置字符编码相关处理回调
    NET_SDK_LOCAL_CFG_TYPE_PROXYS,                     //设置获取代
    NET_DVR_LOCAL_CFG_TYPE_LOG,                       //日志参数配置  NET_DVR_LOCAL_LOG_CFG
    NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK           //码流回调参数配置 NET_DVR_LOCAL_STREAM_CALLBACK_CFG
}NET_SDK_LOCAL_CFG_TYPE;

typedef struct tagNET_DVR_LOCAL_STREAM_CALLBACK_CFG
{
    BYTE     byPlayBackEndFlag;      //0-不回调回放结束标记，1-回调回放结束标记
    BYTE     byRes[255];      //保留
}NET_DVR_LOCAL_STREAM_CALLBACK_CFG, *LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG;

typedef struct tagNET_DVR_LOCAL_LOG_CFG
{
    WORD    wSDKLogNum;      //sdk在覆盖模式下，日志生成的个数 0为默认值（10个）
    BYTE     byRes[254];      //保留
}NET_DVR_LOCAL_LOG_CFG, *LPNET_DVR_LOCAL_LOG_CFG;

typedef int(CALLBACK * CHAR_ENCODE_CONVERT)(char * pInput, DWORD dwInputLen, DWORD dwInEncodeType, char *pOutput, DWORD dwOutputLen, DWORD dwOutEncodeType);

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;//私有协议通信模式， //0-兼容模式（默认），允许所有的SDK登录协议通过，1-安全模式（MD5）, 允许RSA和MD5登录，开启校验2-安全模式（RSA）RSA登录，开启校验
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //巡检时间间隔，单位ms  最小值为30s，最大值120s。为0时，表示用默认值(120s)
    DWORD   dwCheckOnlineNetFailMax;  //由于网络原因失败的最大累加次数；超过该值SDK才回调用户异常，为0时，表示使用默认值1
    BYTE    byRes[256];
}NET_DVR_LOCAL_CHECK_DEV,*LPNET_DVR_LOCAL_CHECK_DEV;


typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE    byVersion;                        //版本信息
    BYTE    byRes[63];                        //保留
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD    wLocalBindTcpMinPort;            //本地绑定Tcp最小端口
    WORD    wLocalBindTcpMaxPort;            //本地绑定Tcp最大端口
    BYTE    byRes[60];                        //保留
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD    wLocalBindUdpMinPort;            //本地绑定Udp最小端口
    WORD    wLocalBindUdpMaxPort;            //本地绑定Udp最大端口
    BYTE    byRes[60];                        //保留
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD    dwAlarmMaxBlockNum;        //报警模块内存池最多向系统申请的内存块（block）个数，每个block为64MB, 超过这个上限则不向系统申请，0表示无上限
    DWORD    dwAlarmReleaseInterval;                //报警模块空闲内存释放的间隔，单位秒，为0表示不释放
    DWORD   dwObjectReleaseInterval;   //对象申请模块空闲内存释放的间隔，单位秒，为0表示不释放
    BYTE    byRes[508];                //保留
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD        dwPreviewTime;        //预览模块超时时间
    DWORD        dwAlarmTime;        //报警模块超时时间
    DWORD        dwVodTime;            //回放模块超时时间
    DWORD        dwElse;                //其他模块
    BYTE        byRes[512];                            //保留
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD    dwMaxBuffRoomNum;    //rtp over udp排序开辟的最大缓冲区个数，0为无效，使用默认值20
    //一个缓冲区开辟内存为10K多一点，缓冲区个数越多，处理乱序的能力则越强，流畅性越好，延时也越大
    BYTE    byUseSort;    //是否开启rtp over udp排序， 0-不开启  1-开启
    BYTE    byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;

typedef  struct  tagNET_DVR_OPTICAL_CHANNEL_BIND
{
    WORD wChannelIndex;    //光口号(0-7)
    WORD wSubChannel;      //光口子通道号，取值范围从能力集获取
    BYTE  byBind;      //0-不绑定或清除绑定，1-绑定
    BYTE  byRes[3];
}NET_DVR_OPTICAL_CHANNEL_BIND,*LPNET_DVR_OPTICAL_CHANNEL_BIND;

typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//视频绑定
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//音频绑定
    BYTE  byRes[16];           //保留   
}NET_DVR_OPTICAL_CHANNEL_CFG,*LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//编码子系统槽位号
    BYTE  byChannel; //编码通道号
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO,*LPNET_DVR_OPTICAL_INFO;

//音频切换
typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //音频是否开启，1-开，0-关
    BYTE  byRes1[3];
    //以下参数当byStatus == 1时有效
    DWORD dwSubWinNum; //关联的子窗口号
    DWORD dwSurChanNum;             /*监控通道号  */   
    NET_DVR_IPADDR struIpaddr;            /*监控通道地址 */
    WORD   wPort;                          /*监控通道端口 */     
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

//端口聚合
#define MAX_ETHERNET_PORT_NUM       8//每条链路最大端口数
typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j表示将第i个端口加入到第j条链路，j的取值为1-8,j=0表示移除
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO,*LPNET_DVR_ETHERNET_CHANNEL_INFO;

//畅显
typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-畅显关，1-畅显开
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO,*LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //启用IP地址过滤，0-否，1-是
    BYTE byFilterType; //过滤类型，0-禁用，1-允许
    BYTE byRes[18];
    BYTE byIPAddr[1024];    //IP地址信息，格式192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwCoordinateX;    //图片显示区域X坐标
    DWORD dwCoordinateY;    //图片显示区域Y坐标
    WORD  wPicWidth; //图片宽
    WORD  wPicHeight; //图片高
    BYTE  byRes[16];        //保留
}NET_DVR_LOGO_OVERLAYCFG,*LPNET_DVR_LOGO_OVERLAYCFG;


typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // 磁盘号
    BYTE                byDelAll;            // 0-删除dwDiskNo  1-删除全部无效磁盘
    BYTE                 byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;


typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // 磁盘号
    BYTE                 byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;

// 长连接回调类型
typedef enum
{
    NET_SDK_CALLBACK_TYPE_STATUS = 0,        // 回调状态值
        NET_SDK_CALLBACK_TYPE_PROGRESS,            // 回调进度值
        NET_SDK_CALLBACK_TYPE_DATA                // 回调数据内容
}NET_SDK_CALLBACK_TYPE;


// 回调类型为NET_SDK_CALLBACK_TYPE_STATUS时的状态值
typedef enum
{
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,        // 成功
        NET_SDK_CALLBACK_STATUS_PROCESSING,            // 处理中
        NET_SDK_CALLBACK_STATUS_FAILED,                // 失败
        NET_SDK_CALLBACK_STATUS_EXCEPTION,            // 异常
        NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,    //（IPC配置文件导入）语言不匹配
        NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,    //（IPC配置文件导入）设备类型不匹配
        NET_DVR_CALLBACK_STATUS_SEND_WAIT           // 发送等待
}NET_SDK_CALLBACK_STATUS_NORMAL;


//一键配置通用状态
#define NET_SDK_OKC_STATUS_SUCCESS                1000  //一键配置成功
#define NET_SDK_OKC_STATUS_FAILED                1002  //一键配置失败

//一键配置CVR状态
#define NET_SDK_OKC_STATUS_START_CONFIG            1003  //开始配置
#define NET_SDK_OKC_CHECK_HD                    1004  //检测磁盘
#define NET_SDK_OKC_INIT_HD                        1005  //初始化磁盘
#define NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK    1006  //创建阵列或者单盘模式
#define NET_SDK_OKC_INIT_CVR_SERVICE            1007  //初始化CVR服务
#define NET_SDK_OKC_CREATE_RECORD_VOLUME        1008  //创建录像卷

//以下为一键配置失败的状态码
#define NET_SDK_OKC_ERR_LOAD_CONF_FAILED              1009 //加载配置文件失败
#define NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE        1010 //不支持此种类型的raid 
#define NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT          1011 //系统已经存在raid或存储池
#define NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED          1012 //获取磁盘信息失败
#define NET_SDK_OKC_ERR_CHECK_DISK_FAILED             1013 //检测磁盘失败
#define NET_SDK_OKC_ERR_INIT_DISK_FAILED              1014 //初始化磁盘失败
#define NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL           1015 //磁盘总容量不足
#define NET_SDK_OKC_ERR_BOTH_SV_NS                    1016 //同时存在SV盘和NS盘
#define NET_SDK_OKC_ERR_CREATE_RAID_FAILED            1017 //创建raid失败
#define NET_SDK_OKC_ERR_GET_RAID_FAILED               1018 //获取raid失败
#define NET_SDK_OKC_ERR_CREATE_SPARE_FAILED           1019 //创建热备盘失败
#define NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED    1020 //创建存储池失败
#define NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED          1021 //获取存储池信息失败
#define NET_SDK_OKC_ERR_CREATE_LUN_FAILED             1022 //创建lun卷失败
#define NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED           1023 //获取lun信息失败
#define NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED          1024 //创建预留卷失败
#define NET_SDK_OKC_ERR_GET_BACKUP_FAILED                1025 //获取预留卷失败
#define NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED        1026 //创建私有卷失败
#define NET_SDK_OKC_ERR_CREATE_RV_FAILED              1027 //创建录像卷失败
#define NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED         1028 //创建存档卷失败
#define NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED      1029 //开启CVR服务失败

//一键配置SAN状态
#define NET_SDK_OKC_CREATING_ARRAY                    1030  //创建阵列阶段
#define NET_SDK_OKC_CREATING_STORAGE_POOL            1031  //创建存储池阶段
#define NET_SDK_OKC_CREATING_LUN_VOL                1032  //创建逻辑卷阶段
#define NET_SDK_OKC_CREATING_ISCSI                    1033  //创建ISCSI阶段
#define NET_SDK_OKC_ERR_HOT_SPARE_CONFICT            1034  //已存在热备盘
#define NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT        1035  //已存在存储池

typedef enum
{
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,    // 成功读取到数据，客户端处理完本次数据后需要再次调用NET_DVR_RemoteConfigGetNext获取下一条数据
        NET_SDK_GET_NETX_STATUS_NEED_WAIT,        // 需等待设备发送数据，继续调用NET_DVR_RemoteConfigGetNext函数
        NET_SDK_GET_NEXT_STATUS_FINISH,            // 数据全部取完，此时客户端可调用NET_DVR_StopRemoteConfig结束长连接
        NET_SDK_GET_NEXT_STATUS_FAILED,            // 出现异常，客户端可调用NET_DVR_StopRemoteConfig结束长连接
}NET_SDK_GET_NEXT_STATUS;

//导入配置文件错误码
typedef enum tagNET_SDK_IPC_CFG_FILE_ERR_CODE
{
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,                                /* 没出错 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,       /* 通道ID非法 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,         /* 通道ID重复 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,              /* 通道IP或域名非法 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,           /* 通道IP或域名重复 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL, /* 通道IP与本地IP冲突 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,         /* 协议错误 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,             /* 管理端口错误 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,   /* 设备通道号错误 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,       /* 用户名含非法字符 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,             /* 密码含非法字符 */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID /*传输协议错误*/
}NET_SDK_IPC_CFG_FILE_ERR_CODE;

//IPC升级错误码
typedef enum
{
    NET_SDK_UPGRADE_IPC_INVALID = 0,                //无效通道或未选择该通道升级
        NET_SDK_UPGRADE_IPC_SUCCESS,                    //升级成功
        NET_SDK_UPGRADE_IPC_OFFLINE,                    //IPC不在线
        NET_SDK_UPGRADE_IPC_NOT_SUPPORT,                //IPC不支持升级命令
        NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,            //语言不匹配
        NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,            //写flsh失败
        NET_SDK_UPGRADE_IPC_OTHER_ERROR                    //其他错误
}NET_SDK_UPGRADE_IPC_ERR_CODE;

typedef enum
{
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,//录播主机一键发布成功
        NET_SDK_REMOTE_CONFIG_STATUS_FAILED,    //录播主机一键发布失败
        NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING    //录播主机一键发布正在获取
}NET_SDK_REMOTE_CONFIG_STATUS;

#define MAX_CODE_CARD_SUPPORTDISPNUMS 8//每个编码卡最多支持的显示通道数
#define MAX_SUPPORT_RES 32

typedef enum _BOARD_TYPE
{
    DS4004HC_BOARD        =2,  //4004HC
        DS4008HC_BOARD        =3,  //4008HC
        DS4016HC_BOARD        =4,  //4016HC
        DS4001HF_BOARD        =5,  //4001HF
        DS4004HF_BOARD        =6,  //4004HF
        DS4002MD_BOARD        =7,  //4002MD
        DS4004MD_BOARD        =8,  //4004MD
        DS4016HCS_BOARD        =9,  //4016HCS
        DS4004HC_PLUS_BOARD    =13, //4004HC+
        DS4008HC_PLUS_BOARD    =14, //4008HC+
        DS4016HC_PLUS_BOARD    =15, //4016HC+
        DS4008HF_BOARD        =16, //4008HF
        DS4008MD_BOARD        =17, //4008MD
        DS4008HS_BOARD        =18, //4008HS
        DS4016HS_BOARD        =19, //4016HS
        
        DS4108HCV_BOARD        =20, //4108HCV
        DS4116HCV_BOARD        =21, //4116HCV
        DS5016HC_BOARD        =22, //5016HC
        
        DS4208HFV_BOARD        =23, //4208HFV
        DS4216HC_BOARD        =24, //4216HC
        DS4216HFV_BOARD        =25, //4216HFV
        
        DS5008HF_BOARD        =26, //5008HF
        DS5116HF_BOARD        =27, //5116HF
        
        DS5216HC_BOARD        =28, //5216HC
        DS5208HF_BOARD        =29, //5208HF
        DS5216HF_BOARD        =30, //5216HF
        
        DS4101HD_BOARD        =31, //4101HD
        DS4102HD_BOARD        =32, //4102HD
        DS4104HD_BOARD        =33, //4104HD
        
        DS4002MD_PLUS_BOARD =34, //4002MD+  
        DS4004MD_PLUS_BOARD =35, //4004MD+
        
        DS4204HFV_BOARD        =36, //4204HFV
        DS4308HCV_BOARD        =37, //4308HCV
        DS4308HFV_BOARD        =38, //4308HFV
        DS4316HCV_BOARD        =39, //4316HCV
        DS4316HFV_BOARD        =40, //4316HFV
        DS4304HD_BOARD        =41, //4304HD
        DS4304HFH_BOARD     =42, //4304HFH
        DS4304HFV_BOARD     =43, //4304HFV
        DS4302HFH_BOARD     =44, //4302HFH
        DS5316HF_BOARD      =45, //5316HF
        DS4308HW_BOARD      =46, //4308HW
        DS4316HW_BOARD      =47, //4316HW
        DS4308MD_BOARD      =48, //4308MD
        UNKNOWN_BOARD_TYPE  =0xffffffff,
}BOARD_TYPE;

typedef struct tagNET_DVR_CODECARD_ABILITY /*高清编码卡能力集*/
{
    BYTE byCardType;      //编码卡类型(按BOARD_TYPE中的枚举)
    BYTE byCodeNums;      //编码通道数 
    BYTE byDispNums;      //显示通道数 
    BYTE byCodeStartIdx;     //首个编码通道在所有编码通道中的索引 
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举) 
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY,*LPNET_DVR_CODECARD_ABILITY;

#define        MAX_CODE_CARD_NUM            8   //最多高清编码卡数
typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 编码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;        /*显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI*/ //此参数只能获取
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL，0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //分辨率
    DWORD  dwWindowMode;        /*画面模式，支持模式从能力集获取*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG,*LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO 
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //显示通道号
    DWORD  dwCodeChan; //编码通道号
    DWORD  dwWinNum;   //窗口号，从1起
    BYTE   byEnableAudio; //开启音频，0-关，1-开
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO,*LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//显示通道号
    DWORD dwWinNum;     //窗口号，从1开始
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO,*LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;         //结构大小
    DWORD  dwCodeChan;      /*编码通道号*/
    BYTE   byDisplay;              /*是否输出，0-否，1-是*/
    BYTE   byAudio;            /*音频是否开启,0-否，1-是*/   
    BYTE   byRes[30];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_WINDOW_STATUS,*LPNET_DVR_WINDOW_STATUS;

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD     dwSize;              //结构体大小
    BYTE     byPercentage;        //百分比，取值范围[0,100]
    BYTE      byRes[31];          //保留
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD             dwSize;             //结构体大小
    NET_DVR_STREAM_INFO struStreasmInfo;     //流ID
    DWORD              dwBeginTime;    //录像总的开始时间
    DWORD             dwEndTime;        //录像总的结束时间
    BYTE              byRes[32];       //保留
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO        struStreamInfo; 
    DWORD                    dwCmdType;                         //外部触发类型 
    DWORD                    dwRecordTimeLen;                //录像持续时间，单位：秒
    BYTE                    byEventID[MAX_EVENTID_LEN];        //事件ID，作为附加信息
    BYTE                    byRes[128];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE                byFileName[NAME_LEN];     // 录像文件名，老协议只传32个文件名
    DWORD                dwLockDuration;            // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    BYTE                byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD                    dwSize;
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwStreamType; //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    BYTE                    byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD                            dwSize;
    DWORD                            dwStreamType;        //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    NET_DVR_COMPRESSION_INFO_V30    struStreamPara;        //码流压缩参数
    BYTE                            byRes[80];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 */
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;    /*按位,第0位对应第0个输入端口,dwAlarmType为0时需要设置*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*按位,第0位对应第0个输出端口, */
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*按位,第0位对应第0个通道*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; // ID信息
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*按位,0x2表示第1通道，第1位对应第1个通道(从通道1开始)，dwAlarmType为2或3, 6，9，10时需要设置, */
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*按位,第0位对应第0个硬盘,dwAlarmType为1,4,5时需要设置*/
            BYTE byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;

typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    DWORD             dwPackageInterval;    // 打包时间间隔 ，时间单位：分钟
    BYTE              byRes[32];               // 保留
}NET_DVR_RECORD_PACK,*LPNET_DVR_RECORD_PACK;

#define NET_DVR_FIND_NAS_DIRECTORY     6161        //查找NAS目录
#define NET_DVR_NAS_FINDING       0   //正在查找
#define NET_DVR_NAS_RECV          1   //接收数据
#define NET_DVR_NAS_OVER          2   //查找结束
#define NET_DVR_NAS_EXCEPTION     3   //接收异常
typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR              struIP;         // IP地址
    WORD              wPort;      // IP端口
    BYTE                byRes[10];  // 保留字节
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;


typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // 返回的文件目录
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE              byWD1Enable;         //WD1使能开关 0 关闭 1 开启    
    BYTE                 byRes[31];      //保留
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;

typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE                byEnableFTP;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE                byProtocolType;             /*协议类型 0-FTP，1-SFTP*/
    WORD                wFTPPort;                /*端口*/
    union 
    {
        struct
        {
            BYTE            szDomain[64];        //服务器地址，可以使IPv4 IPv6或是域名
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP地址:IPv4 IPv6地址, 144字节*/
        }struAddrIP;
    }unionServer;  //使用联合体结构，防止既是IP地址又是域名的情况
    BYTE                szUserName[32];            /*用户名*/
    BYTE                szPassWORD[16];            /*密码*/
    BYTE                szTopCustomDir[64];        /*自定义一级目录*/
    BYTE                szSubCustomDir[64];        /*自定义二级目录*/
    BYTE                byDirLevel;                /*0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录*/
    BYTE                 byTopDirMode;            /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                0x4=使用监测点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,0x8=方向,0x9=地点*/
    BYTE                 bySubDirMode;           /*二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,0x9 = 车位编号*/
    BYTE                byType;                    /* 0-主服务器，1-备服务器*/
    BYTE                byEnableAnony;          /*启用匿名 0-否 1是*/
    BYTE                byAddresType;           /*0 使用IPV4、IPV6  1- 使用域名*/
    BYTE                byFTPPicType;           //0-保留，1-停车场抓拍图片命名规则
    BYTE                 byPicArchivingInterval; //图片归档间隔[1~30],0表示关闭
    NET_DVR_PICTURE_NAME_EX     struPicNameRule;   /* 图片命名规则:     
    byFTPPicType ==1的时候,自数组内的命名规则是停车场抓拍图片命名规则*/
    BYTE                byPicNameRuleType;      //图片命令规则类型；0~默认类型，1~图片前缀名定义(启用struPicNameRule中的byPicNamePrefix字段)
    BYTE                 byRes[203];             /*保留*/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE    byType;  // 0-主服务器，1-备服务器
    BYTE    byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

//FTP服务器测试参数结构体
typedef struct 
{
    DWORD     dwSize;
    BYTE    byEnableFTP;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE    byProtocolType;             /*协议类型 0-FTP，1-SFTP*/
    WORD    wFTPPort;                /*端口*/
    union 
    {
        BYTE    byRes[144];
        struct
        {
            BYTE    szDomain[MAX_DOMAIN_NAME];        //服务器地址，可以使IPv4 IPv6或是域名
            BYTE    byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP地址:IPv4 IPv6地址, 144字节*/
        }struAddrIP;
    }unionServer;  //使用联合体结构，防止既是IP地址又是域名的情况
    
    BYTE    szUserName[NAME_LEN];            /*用户名*/
    BYTE    szPassWORD[PASSWD_LEN];            /*密码*/
    BYTE    szTopCustomDir[MAX_CUSTOM_DIR];        /*自定义一级目录*/
    BYTE    szSubCustomDir[MAX_CUSTOM_DIR];        /*自定义二级目录*/
    BYTE    byDirLevel;                /*0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录*/
                                    BYTE    byTopDirMode;            /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                                    0x4=使用监测点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,
                                    0x8=方向,0x9=地点*/
                                    BYTE    bySubDirMode;           /*二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                                    0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,
                                    0x9 = 车位编号*/
                                    BYTE    byType;                    /* 0-主服务器，1-备服务器*/
                                    BYTE    byEnableAnony;          /*启用匿名 0-否 1是*/
                                    BYTE    byAddresType;           /*0 使用IPV4、IPV6  1- 使用域名*/
                                    
                                    BYTE    byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

//服务器测试结构体
typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD    dwSize;
    union 
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA    struNtpPara;                    /*NTP服务器测试参数80字节*/           
            BYTE    byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40    struNasPara;   /*NAS服务器测试参数480字节*/         
            BYTE    byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA    struFtpPara;   /*FTP服务器测试参数528字节*/          
            BYTE    byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30    struEmailPara;            /*Email服务器测试参数660字节*/        
            BYTE    byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR    struIp;                            /*IP冲突测试参数24字节*/
            BYTE    byRes1[716];
        }struIpPara;
        struct  
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //端口号
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //用户名
            char  szPassword[CLOUD_PASSWD_LEN/*48*/];     // 密码
            NET_DVR_POOLPARAM  struPoolInfo[16];// 数组0表示卡口图片数据池，数组1表示违章图片数据池，数组2表示车辆侦测数据池（IPC/D）
            BYTE byRes1[486];
        }struCloudStoragePara;
        struct 
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];
            BYTE byRes1[708];
        }struPhoneNumPara;//短信测试
    }unionServerPara; 
    BYTE byRes2[800]; 
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO  //获取GOP索引信息结构体,建立连接时使用
{
    DWORD      dwSize;          //结构体大小
    LONG      lChannel;       //通道号
    NET_DVR_TIME_EX   struStartTime;    //开始时间
    NET_DVR_TIME_EX   struEndTime;     //结束时间
    BYTE                 byRes[256];      // 保留字节  
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;    //Gop信息时间点
    DWORD         dwDuration;    //信息持续时间
    DWORD         dwDataSize;     //指针pBuf大小
    BYTE          byRes[128];
    char* pBuf;//Gop信息块
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK   //智能数据信息回填
{
    DWORD       dwSize;                 //结构体大小
    NET_DVR_TIME_V30  struTime;         //开始时间,当数据类型为智能元数据时，表示的开始时间，当为缩略图时，表示的是图片时间
    DWORD       dwDuration;             //信息持续时间，仅当数据类型为智能元数据时有效
    DWORD       dwMetaDataSize;         //数据源的大小
    DWORD       dwPicDataSize;          //图片数据大小
    char*        pMetaDataBuffer;        //智能元数据缓冲区
    char*       pPicDataBuf;            //图片缓冲区
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;    
    BYTE   byRes1[3];
    DWORD  dwWallNum;//电视墙输出号
    //坐标须为基准坐标的整数倍（128×128），宽度和高度值不用设置，即为基准值
    NET_DVR_RECTCFG struRectCfg;
    BYTE    byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

/*窗口信息*/
typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//窗口号
    DWORD dwLayerIndex;//窗口相对应的图层号
    NET_DVR_RECTCFG struWinPosition;//目的窗口(相对显示墙)
    DWORD dwDeviceIndex;//分布式大屏控制器设备序号
    WORD wInputIndex;//输入信号源
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD    dwSize;
    BYTE    byWallNo;    //电视墙序号，从1开始
    BYTE    bySceneNo;    //场景序号
    BYTE    byRes1[2];
    DWORD    dwDeviceID;    //分布式子设备ID
    DWORD    dwWindowNo;    //窗口序号/信号源序号
    BYTE    byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //使能透明度，0-关，非0-开    
    BYTE  byWinMode;//窗口分屏模式，能力集获取
    BYTE  byEnableSpartan;//畅显使能，0-关，1-开
    BYTE  byDecResource;  //为窗口分配的解码资源，1-D1,2-720P,3-1080P
    BYTE  byWndShowMode; //窗口显示模式，0-此字段不用，1-子窗口模式，2-子窗口全屏模式
    BYTE  byRes1[3];
    DWORD dwAmplifyingSubWndNo; //全屏子窗口号（1字节墙号+1字节子窗口号+2字节窗口号）
                                                                  //当byWndShowMode为2时有效，表示当前全屏显示的子窗口
    BYTE  byRes[24];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD    dwSize;
    BYTE    sSceneName[NAME_LEN];    //场景名称
    BYTE    byEnable;                //场景是否有效，0-无效，1-有效
    BYTE    bySceneIndex;            //场景号，只能获取。获取所有场景时使用该参数
    BYTE    byRes [78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //窗口号
    DWORD dwSubWinNum;//子窗口号
    DWORD dwWallNo; //墙号
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO,*LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize ;
    BYTE  byDecodeStatus; /*当前解码状态:0:未启动,1 :已启动*/
    BYTE  byStreamType;    /*码流类型*/
    BYTE  byPacketType;    /*打包方式*/
    BYTE  byFpsDecV; /*视频解码帧率*/
    BYTE  byFpsDecA; /*音频解码帧率*/
    BYTE  byRes1[7];    
    DWORD dwDecodedV; /*解码的视频帧*/
    DWORD dwDecodedA; /*解码的音频帧*/
    WORD  wImgW; /*当前码流源的图像大小*/
    WORD  wImgH; 
    BYTE  byStreamMode ; //码流源(此参数对视频综合平台有效)：1-网络，2-综合平台内部编码子系统,0xff-无效
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //窗口号
    DWORD dwSubWinIndex;//子窗口号
    BYTE  byType ;//资源类型，1-解码，2-回显
    BYTE  byWallNo ; //墙号
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize ;
    BYTE   sAddress[MAX_DOMAIN_NAME];//ip地址，或是域名
    WORD   wDVRPort;                 /* 端口号 */
    WORD   wChannel;                /* 通道号 */
    BYTE   sUserName[NAME_LEN];    /* 监控主机登陆帐号 */
    BYTE   sPassword[PASSWD_LEN];    /* 监控主机密码 */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO,*LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //分辨率    
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat; //视频制式，见VIDEO_STANDARD
    BYTE  byDisplayMode;/*输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，0xff-无效*/
    BYTE  byBackgroundColor; //背景色，0-无效，不支持背景色，1-红，2-绿，3-蓝，4-黄，5-紫，6-青，7-黑，8-白
    BYTE  byRes1[1];     //保留
    WORD  wLEDWidth;     //LED屏输出分辨率宽
    WORD  wLEDHeight;    //LED屏输出分辨率高
    BYTE  byRes2[56];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

#define     MAX_UNITEDMATRIX_NUM        8  //级联中最多视频综合平台数量

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    //平台号，0表示无此平台
    DWORD        dwSequence;
    BYTE        sAddress[MAX_DOMAIN_NAME];//ip地址，或是域名
    WORD        wSubMatrixPort;        /*子系统端口号*/
    BYTE        byRes1[6];   
    BYTE        sUserName[NAME_LEN];    /*用户名*/
    BYTE        sPassword[PASSWD_LEN];    /*密码 */   
    BYTE        byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO,*LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //视频综合平台信息
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM]; 
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO,*LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_SUBSTREAM_SWITCH_CFG
{
    BYTE  byAutoSwitchEnable; //子码流自动切换，0 - 不启用，1 - 启用
    BYTE     byRes1[3];
    WORD  wSubWndWidth; //子窗口宽度设定值，byAutoSwitchEnable为1时有效
    WORD  wSubWndHeight; //子窗口高度设定值，byAutoSwitchEnable为1时有效
}NET_DVR_SUBSTREAM_SWITCH_CFG, *LPNET_DVR_SUBSTREAM_SWITCH_CFG;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD  dwSize;
    BYTE  byTransparency;//透明度,0-100,0为不透明
    BYTE  byWinStaticMode; //窗口解码停止显示模式，1-黑屏，2-显示最后一帧图像
    BYTE  byRes1[2];
    NET_DVR_SUBSTREAM_SWITCH_CFG  struSubStreamSwitch; //子码流切换
    BYTE  byLEDShowMode; //LED窗口显示模式，0-普通模式，1-平铺模式
    BYTE  byRes[51];
}NET_DVR_WALL_CFG, *LPNET_DVR_WALL_CFG;

typedef    struct tagNET_DVR_LEDDISPLAYINFO
{
    DWORD            dwSize;
    BYTE              byAddressType;   //0-实际ipv4 ipv6地址 1-域名
    BYTE        byRes1[3];
    // 控制unionServer是使用实际地址还是域名
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];//服务器地址，域名 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP地址*/        //IPv4 IPv6地址, 144字节
        } struAddrIP;
    }unionServer;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64    
    char        szDisplayInfo[MAX_LEDDISPLAYINFO_LEN/*1024*/];
    BYTE        byRes[128];
}NET_DVR_LEDDISPLAYINFO,*LPNET_DVR_LEDDISPLAYINFO;


typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD dwSize;
    BYTE  byLowLightLimt; /* 低照度电子快门: 0-关，1-开 */
    BYTE  byLowLightLimtLevel; 
    /*球机0-关，1-慢快门*2，2-慢快门*3，3-慢快门*4，4-慢快门*6，5-慢快门*8，6-慢快门*12，7-慢快门*16，
    8-慢快门*24，9-慢快门*32，10-慢快门*48，11-慢快门*64，12-慢快门*96，13-慢快门*128，14-慢快门*256，
    15-慢快门*512, 16-慢快门*1.25, 17-慢快门*1.5 */
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD dwSize;
    BYTE  byFocusMode;  /* 聚焦模式，0-自动，1-手动，2-半自动 */
    BYTE  byAutoFocusMode; /* 自动聚焦模式，0-关，1-模式A，2-模式B，3-模式AB，4-模式C 自动聚焦模式，需要在聚焦模式为自动时才显示*/
    WORD  wMinFocusDistance; /* 最小聚焦距离，单位CM,  0-自动，0xffff-无穷远 */
    BYTE  byZoomSpeedLevel;  /* 变倍速度，为实际取值，1-3 */
    BYTE  byFocusSpeedLevel; /* 聚焦速度，为实际取值，1-3 */
    BYTE  byOpticalZoom;        /* 光学变倍，0-255 */
    BYTE  byDigtitalZoom;        /* 数字变倍，0-255 */
    float fOpticalZoomLevel; /* 光学变倍(倍率值) [1,32], 最小间隔0.5 ，内部设备交互的时候*1000 */
    DWORD dwFocusPos;/* dwFocusPos 是focus值（聚焦值），范围为[0x1000,0xC000]，这个值是sony坐标值，使用这个值是为了对外统一，保证不同的镜头对外focus值都转换在这个范围内 (手动聚焦模式下下应用)*/
    BYTE  byRes[56];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;  /* 红外球机配置-控制模式：0-自动，1-手动 */
    BYTE  byIrBrightness;    /* 红外球机配置-红外亮度：0-100 */
    BYTE  byIrSensitivity;    /* 红外球机配置-红外灯灵敏度：0-100 */
    BYTE  byIrTrigMode; /* 触发模式 0-机芯触发，1-光敏触发 自动模式下生效*/
    BYTE  byIrBrightnessLimit;/* 亮度限制 如果此值为80，表示的意义是当前红外灯的亮度为原先根据自动策略计算出的亮度值×80% 自动模式下生效*/   
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int   iIrisSet;    /* 光圈，为实际取值*100的值，0-关 */
    int   iGainSet;    /* 快球增益，曝光补偿，为实际取值*100的值，有可能是负值 */
    int   iGainLimit;/* 增益限制，曝光补偿，为实际取值*100的值，有可能是负值 */
    int   iExposureCompensate; /* 曝光补偿，为实际取值*100的值，比如1050代表10.5dB, -750代表-7.5dB */
    BYTE  byExposureModeSet;    /* 球机的曝光模式,0-手动模式，1-自动曝光，2-光圈优先，3-快门优先，4-增益优先 */
    BYTE  byShutterSet;         /* 快门，0-关，1-自动x1，2-自动x2，3-自动x4，4-自动x8，5-自动x16，6-自动x32，7-自动x64，8-自动x128，9-1/1，10-1/2，
    11-1/3，12-1/4，13-1/6，14-1/8，15-1/12，16-1/15，17-1/25，18-1/30，19-1/50，20-1/60，21-1/75，
    22-1/90，23-1/100，24-1/120，25-1/125，26-1/150，27-1/180，28-1/200，29-1/215，30-1/250，31-1/300，
    32-1/350，33-1/425，34-1/500，35-1/600，36-1/725，37-1/1000，38-1/1250，39-1500,40-1/1750，41-1/2000，
    42-1/2500，43-3000,44-1/3500，45-1/4000，46-1/6000，47-1/10000，48-1/30000，49-1/100000,50-1/175，
    51-1/195，52-1/225，53-1/230 */
    BYTE  byImageStabilizeLevel;  /* 防抖动等级: 0-3 */
    BYTE  byCameraIrCorrect; /* 红外校正: 0-自动，1-开，2,关 */
    BYTE  byHighSensitivity; /* 高灵敏度设置: 0-关，1-开 */
    BYTE  byInitializeLens;  /* 初始化镜头: 0-关，1-开 */
    BYTE  byChromaSuppress; /* 色彩抑制 :0-255*/
    BYTE  byMaxShutterSet;     //最大快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    BYTE  byMinShutterSet;     //最小快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    BYTE  byMaxIrisSet; //最大光圈限制值(自动曝光、快门优先模式) [0,100] ;
    BYTE  byMinIrisSet;    //最小光圈限制值(自动曝光、快门优先模式) [0,100] ;
    BYTE  byRes[61];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD        dwSize;
    BYTE        byValid;            // 有效时为设置，无效时为删除
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // 矩阵的名称
    DWORD          dwMatrixID;        // 矩阵的ID号，只能获取
    WORD        wMatrixInputChanNum;                // 矩阵的输入通道数目
    WORD        wMatrixOutputChanNum;            // 矩阵的输出通道数目
    WORD           wMatrixOutputChanRef[MAX_CAM_COUNT];   //// 设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
    //元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
    BYTE        byMatrixChanType;// 矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
    BYTE        byMatrixProtocol;    // 矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
    BYTE        byMatrixType;        //1-模拟矩阵，2-数字矩阵
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;    
    BYTE        byRes3[128];        
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;


#define MAX_INPUTNUMS 1024
#define MAX_OUTPUTNUMS 256
typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE byEnable;
    BYTE byRes1[3];
    DWORD dwDeviceIndex;//分布式大屏控制器设备序号
    WORD wInputIndex;//输入信号源
    BYTE  byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byWallNo;        //墙号，从1开始
    BYTE    byRes1[2];
    DWORD    dwOutputIndex;    //输出显示屏的序号    
    BYTE    byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM,*LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD   dwSize;
    BYTE    sUserName[NAME_LEN];            // 用户名，最大16字节
    BYTE    sPassWord[PASSWD_LEN];        // 密码
    NET_DVR_IPADDR    struUserIP;    // 用户IP地址(为0时表示允许任何地址)
    BYTE    byMacAddr[MACADDR_LEN];            // 物理地址
    BYTE    byPriority;        // 优先级，1-管理员，2-操作员 ，管理员具有任何权限，操作员没有"管理用户"的权限
    BYTE    byRes1;
    DWORD    dwRight;/*远程操作权限，按位表示，0-不支持，1-支持，各32位代表的权限类型*/    
    //bit0-获取设置基本参数
    //bit1-显示屏管理
    //bit2-窗口管理
    //bit3-信号源管理
    //bit4-布局管理
    //bit5-预案管理
    //bit6-底图管理
    //bit7-OSD管理
    //bit8-回显权限
    //bit9-报警布防
    //bit10-远程升级
    //bit11-恢复默认设置
    //bit12-导入导出配置配置文件
    //bit13-日志查询
    //bit14-远程重启
    //bit15-屏幕区域管理
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //屏幕管理区域
    BYTE   byWallNo;    //开启屏幕管理区域的墙号，对只支持单墙的设备，此字段无效
    BYTE   byRes[107];                /* 保留 */
} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{    
    BYTE    byValid; //是否启用，0-否，1-是
    BYTE    byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP或者域名   
    WORD    wDevPort;            /*流媒体服务器端口*/    
    BYTE    byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

//设备通道信息
typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];    //设备域名
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byUseZeroChan; //是否使用零通道，0-否，1-是
    BYTE    byRes;   
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO_V41,*LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE    byChanType;              //通道类型，0-普通通道,1-零通道,2-流ID,3-本地输入源，4-虚拟屏服务器通道，5-拼接通道
    BYTE    byStreamId[STREAM_ID_LEN];//流ID
    
    BYTE    byRes1[3];
    DWORD   dwChannel;  //通道号，通道类型为普通通道，零通道，本地输入源，虚拟屏服务器通道时填此字段
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];    //设备域名
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号,dwChannel不为0时此字段无效
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byRes[2];   
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO_EX,*LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{    
    BYTE   byValid; //是否启用，0-否，1-是
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP或者域名 
    WORD   wDevPort;            /*流媒体服务器端口*/    
    BYTE   byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER,*LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];    //域名(IPServer或hiDDNS时可填序列号或者别名)
    BYTE   byTransProtocol;        //传输协议类型0-TCP，1-UDP, 2-MCAST
    BYTE   byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE   byDdnsType;         //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS服务器地址
    WORD   wDdnsPort;                 //DDNS服务器端口号
    BYTE   byChanType;              //0-普通通道,1-零通道,2-流ID
    BYTE   byFactoryType;            //前端设备厂家类型,通过接口获取
    DWORD  dwChannel; //通道号
    BYTE   byStreamId[STREAM_ID_LEN]; //流ID
    BYTE   sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE   sPassword[PASSWD_LEN];    //监控主机密码
    WORD   wDevPort;                //前端设备通信端口
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO,*LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX,*LPNET_DVR_DEC_STREAM_DEV_EX;


//DDNS方式取流
typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV,*LPNET_DVR_DEC_DDNS_DEV;

typedef union tagNET_DVR_DEC_STREAM_MODE
{
    NET_DVR_DEC_STREAM_DEV_EX struDecStreamDev;
    NET_DVR_PU_STREAM_URL struUrlInfo;
    NET_DVR_DEC_DDNS_DEV struDdnsDecInfo;
    BYTE byRes[300];    
}NET_DVR_DEC_STREAM_MODE,*LPNET_DVR_DEC_STREAM_MODE;

typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD dwSize;
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
    BYTE  byRes2[64];
}NET_DVR_PU_STREAM_CFG_V41,*LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE byEnable; //是否启用，0-否，1-是
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byRes[2];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
}NET_DVR_MATRIX_CHAN_INFO_V41,*LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔*/
    NET_DVR_MATRIX_CHAN_INFO_V41    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                           byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_V41,*LPNET_DVR_MATRIX_LOOP_DECINFO_V41;

typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD    dwSize;
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
    DWORD    dwPlayMode;        /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    BYTE    sFileName[128];        /* 按文件回放文件名 */
    DWORD   dwGetStreamMode;    /*取流模式:1-主动，2-被动*/
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE    byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE    byDevAddress[MAX_DOMAIN_NAME];    /*设备IP地址*/
    WORD    wDevPort;       //设备端口
    BYTE     byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];    /*DDNS域名*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];    /*设备地址*/
    BYTE byDdnsType; //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //设备端口
    WORD wDdnsPort; //域名服务器端口
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;

typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD    dwSize;
    DWORD    dwDecChannel;  //解码通道号
    BYTE    byAddressType;  //设备地址类型，0-IP，1-DDNS
    BYTE    byChannelType;  //通道类型，0-普通通道，1-零通道，2-流ID
    BYTE    byres[2];
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwChannel;            /* 设备通道号 */
    BYTE    byStreamId[STREAM_ID_LEN];  //流ID,此参数在通道类型为流ID时有效
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;
    
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //按时间回放时文件信息
        char sFileName[128];    //按文件名回放时文件信息
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

typedef struct tagNET_DVR_DISPLAY_EFFECT_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR  struColor;      //显示相关参数/
    BYTE byRes[32];
}NET_DVR_DISPLAY_EFFECT_CFG,*LPNET_DVR_DISPLAY_EFFECT_CFG;

//获取干线状态
typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD        dwSize;
    DWORD        dwTrunkID;    //干线ID
    WORD        wReserveUserID;    //预留的用户ID： 1~256 ，0表示释放预留
    BYTE        byStatus;  //1-空闲，2-占用，3-复用 */
    BYTE        byRes1;
    BYTE          byUserId[256];  //数组下标表示用户ID号，数组元素的值表示是否使用干线。如：byUserID[0] 的值为1，表示用户ID为0的用户正在使用，byUserID[0] 的值为0表示用户ID为0的用户没有使用这条干线
    BYTE           byRes2[64];  
}NET_DVR_TRUNK_USE_STATE,  *LPNET_DVR_TRUNK_USE_STATE;


//PTZ控制参数
typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD    dwSize;
    DWORD    dwCtrlDelayTime;        //PTZ控制持续时间，指PTZ控制后在dwCtrlDelayTime时间内，其他同级别或低级别用户对其操作无效。单位：秒
    BYTE    byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

//显示路径
#define        MAX_MATRIX_CASCADE        32
typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD        dwSize;
    DWORD           dwCamNo;
    DWORD       dwMonNo;
    DWORD        dwSubWin;
    DWORD        dwUserId;
    DWORD       dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId成员对应级联级数从1到32，从CAM端开始，trunkId[0]表示第一级级联，trunkId[1]表示第二级级联, trunkId[i] = 0 表示无干线
    BYTE        byRes[64];      /* 预留 */
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;


//获取PTZ状态
typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD        dwSize;
    DWORD        dwUserID;    //1~256，0 表示无用户
    DWORD       dwStatus;      // PTZ控制状态0-停止、1-运行
    DWORD        dwRestTime;  //剩余时间
    BYTE        byRes[64];  
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;

typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //工作模式，0-无人门常开，1-无人门常锁
    BYTE  byRes[15];
}NET_DVR_SAFETYCABIN_WORK_MODE,*LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //传感器类型，0-红外对射型，1-幕帘传感器
    BYTE  bySensitivity; //传感器敏感度，范围：0-100%
    BYTE  byDevUseTimeout; //防护舱使用超时时间，单位：分,范围：5-30，默认超时15min,超时后通过布防通道上传报警
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //幕帘传感器探测延时时间，单位：秒，范围：0-10
    WORD  wCurtainResponseTime; //幕帘人状态变化控制器响应时间，单位：秒，范围：0-300    
    BYTE  byRes2[32];
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG,*LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;    

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD        dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //网卡的物理地址
    BYTE  byRes[64];      //保留
}NET_DVR_ETHERNET_IPV6_COND,*LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD        dwSize;
    BYTE  byState; //IPv6状态，0-路由分配，1-自动设置
    BYTE  byRes1[3]; 
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6地址
    BYTE  byRes[64];      //保留
}NET_DVR_ETHERNET_IPV6_CFG,*LPNET_DVR_ETHERNET_IPV6_CFG;

typedef struct  
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME,*LPNET_DVR_DAYTIME;

typedef struct
{
    NET_DVR_DAYTIME  struStartTime; //开始时间
    NET_DVR_DAYTIME  struStopTime; //结束时间
}NET_DVR_SCHEDULE_DAYTIME, *LPNET_DVR_SCHEDULE_DAYTIME;

typedef struct
{
    BYTE byObjectSize;//占比参数(0~100)
    BYTE byMotionSensitive; /*移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭*/
    BYTE byRes[6];
}NET_DVR_DNMODE, *LPNET_DVR_DNMODE;

typedef struct 
{
    BYTE byAreaNo;//区域编号(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;//单个区域的坐标信息(矩形) size = 16;
    NET_DVR_DNMODE  struDayNightDisable;//关闭模式
    NET_DVR_DNMODE  struDayModeParam;//白天模式
    NET_DVR_DNMODE  struNightModeParam;//夜晚模式
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;

typedef struct
{
    BYTE byDayNightCtrl;//日夜控制 0~关闭,1~自动切换,2~定时切换(默认关闭)
    BYTE byRes[3];
    NET_DVR_SCHEDULE_DAYTIME struScheduleTime;//切换时间  16
    NET_DVR_MOTION_MULTI_AREAPARAM struMotionMultiAreaParam[MAX_MULTI_AREA_NUM];//最大支持24个区域
    BYTE byRes1[60];
}NET_DVR_MOTION_MULTI_AREA,*LPNET_DVR_MOTION_MULTI_AREA; //1328

typedef struct
{
    BYTE byMotionScope[64][96];        /*侦测区域,0-96位,表示64行,共有96*64个小宏块,目前有效的是22*18,为1表示是移动侦测区域,0-表示不是*/
    BYTE byMotionSensitive;            /*移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭*/
    BYTE byRes[3];
}NET_DVR_MOTION_SINGLE_AREA, *LPNET_DVR_MOTION_SINGLE_AREA;

typedef struct 
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //普通模式下的单区域设
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //专家模式下的多区域设置    
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct 
{    
    NET_DVR_MOTION_MODE_PARAM  struMotionMode; //(5.1.0新增)
    BYTE byEnableHandleMotion;        /* 是否处理移动侦测 0－否 1－是*/ 
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    BYTE byConfigurationMode; //0~普通,1~专家(5.1.0新增)
    BYTE byRes1; //保留字节
    /* 异常处理方式 */
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000: 抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    /*触发的录像通道*/
    DWORD     dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwRelRecordChan -1有效，如果中间遇到0xffffffff,则后续无效*/  
    BYTE  byRes[128]; //保留字节
}NET_DVR_MOTION_V40,*LPNET_DVR_MOTION_V40;

typedef struct
{
    DWORD dwEnableHideAlarm;                /* 是否启动遮挡报警，0-否，1-低灵敏度，2-中灵敏度，3-高灵敏度*/
    WORD wHideAlarmAreaTopLeftX;            /* 遮挡区域的x坐标 */
    WORD wHideAlarmAreaTopLeftY;            /* 遮挡区域的y坐标 */
    WORD wHideAlarmAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAlarmAreaHeight;                /*遮挡区域的高*/ 
    /* 信号丢失触发报警输出 */    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000:抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效*/  
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE  byRes[64]; //保留
}NET_DVR_HIDEALARM_V40,*LPNET_DVR_HIDEALARM_V40; //遮挡报警

typedef struct
{
    DWORD dwEnableVILostAlarm;                /* 是否启动信号丢失报警 ,0-否,1-是*/
    /* 信号丢失触发报警输出 */    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000:抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE    byVILostAlarmThreshold;    /*信号丢失报警阈值，当值低于阈值，认为信号丢失，取值0-99*/
    BYTE    byRes[63]; //保留
}NET_DVR_VILOST_V40,*LPNET_DVR_VILOST_V40;    //信号丢失报警

typedef struct
{
    NET_DVR_COLOR      struColor[MAX_TIMESEGMENT_V30];/*图象参数(第一个有效，其他三个保留)*/
    NET_DVR_SCHEDTIME  struHandleTime[MAX_TIMESEGMENT_V30];/*处理时间段(保留)*/
}NET_DVR_VICOLOR, *LPNET_DVR_VICOLOR;

typedef struct
{
    DWORD  dwSize;
    BYTE  sChanName[NAME_LEN]; 
    DWORD  dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL  */
    NET_DVR_VICOLOR struViColor;//    图像参数按时间段设置
    //显示通道名
    DWORD  dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示
    WORD    wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD    wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //隐私遮挡
    DWORD  dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD  dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示
    WORD   wOSDTopLeftX;                /* OSD的x坐标 */
    WORD   wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE    byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE    byDispWeek;                /* 是否显示星期 */
    BYTE    byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 0: 不显示OSD */
    /* 1: 透明，闪烁 */
    /* 2: 透明，不闪烁 */
    /* 3: 不透明，闪烁 */
    /* 4: 不透明，不闪烁 */    
    BYTE    byHourOSDType;                /* OSD小时制:0-24小时制,1-12小时制 */
    BYTE    byFontSize;      //16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 4-24*24(中)/12*24(英) 5-96*96(中)/48*96(英) 6-128*128(中)/64*128(英) 0xff-自适应(adaptive)
    BYTE    byOSDColorType;     //0-默认（黑白）；1-自定义
    BYTE    byAlignment;//对齐方式 0-自适应，1-右对齐, 2-左对齐
    BYTE    byOSDMilliSecondEnable;//视频叠加时间支持毫秒；0~不叠加, 1-叠加
    NET_DVR_VILOST_V40 struVILost;  //视频信号丢失报警（支持组）
    NET_DVR_VILOST_V40 struAULost;  /*音频信号丢失报警（支持组）*/
    NET_DVR_MOTION_V40 struMotion;  //移动侦测报警（支持组）
    NET_DVR_HIDEALARM_V40 struHideAlarm;  //遮挡报警（支持组）
    NET_DVR_RGB_COLOR    struOsdColor;//OSD颜色
    BYTE    byRes[124];
}NET_DVR_PICCFG_V40,*LPNET_DVR_PICCFG_V40;

typedef struct  //
{
    DWORD                   dwSize; 
    BYTE   byWorkType;// 0-自适应, 1-定时模式
    BYTE   byRes[3];
    //定时模式参数
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;//日夜定时切换模式(白天时间)
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam; //自适应参数
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;//白天参数
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;//夜晚参数
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG,*LPNET_DVR_ISP_CAMERAPARAMCFG;

typedef struct
{
    DWORD       dwSize; 
    BYTE        byIrLampServer;//红外灯设置 0～禁用，1～启用
    BYTE        bytelnetServer;//telnet设置 0～禁用，1～启用
    BYTE        byABFServer;//ABF设置 0～启用，1～禁用
    BYTE        byEnableLEDStatus;//状态指示灯控制 0～禁用，1～启用
    BYTE        byEnableAutoDefog;//自动除雾控制 0～启用，1～禁用
    BYTE        byEnableSupplementLight;//补光灯控制0-启用，1-禁用
    BYTE        byEnableDeicing;//除冰功能 0-关闭，1-开启
    BYTE        byRes[249];
}NET_DVR_DEVSERVER_CFG,*LPNET_DVR_DEVSERVER_CFG;

typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD       dwSize;
    BYTE       byEnable;//28181协议使能 0-关闭 1-开启
    BYTE       byTransProtocol;//传输协议:0-UDP、1-TCP、默认0-UDP
    WORD       wLocalSipPort;//1024-65535(IPC设备端)
    char       szServerID[MAX_SERVERID_LEN];//服务器ID：64字节字符串，仅限数字
    char       szServerDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// 服务器域
    char       szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN] ;// SIP服务器地址支持域名和IP地址
    WORD       wServerSipPort;//服务器SIP端口：1024-65535
    BYTE       byProtocolVersion;//协议版本 0-GB/T28181-2011(仅支持UDP),1-GB/T28181-2015(支持TCP,UDP)
    BYTE       byRes3;
    char       szSipUserName[MAX_SERVERNAME_LEN];//SIP用户名称：64字节字符串(第三方SIP终端请求IPC服务时使用)
    char       szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];//SIP用户认证ID：64字节字符串
    char       szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];//SIP用户认证密码：32字节字符串(IPC设备注册到SIP服务器时使用)
    DWORD      dwRegisterValid;//注册有效期：单位秒，默认3600；
    BYTE       byHeartbeatInterval;//心跳间隔：单位秒，默认10秒；
    BYTE       byMaxHeartbeatTimeOut;//最大心跳超时次数：默认3次；
    BYTE       byStreamType;// 取流类型0～主码流，1～子码流，2～3码流
    BYTE          byDeviceStatus; //设备是否在线状态，0-保留，1-在线，2-离线
    DWORD      dwRegisterInterval;//注册间隔:注册失败后再次注册的时间间隔,范围60-600s，默认60s
    DWORD      dwAutoAllocChannelID ; //是否自动分配通道ID,按位表示，0为手动配置，1为自动分配，bit1-自动分配编码通道ID,bit2-自动分配报警输入通道,bit3-自动分配解码通道ID 
    char       szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// 设备域
    BYTE       byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG,*LPNET_DVR_GBT28181_ACCESS_CFG;

//GBT28181协议的设备编码通道配置
typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD                   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];//设备视频通道编码ID：64字节字符串，仅限数字
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG,*LPNET_DVR_GBT28181_CHANINFO_CFG;

//GBT28181协议的报警输入通道配置 条件结构
typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;//报警输入通道号
    BYTE  byRes[32]; //保留
}NET_DVR_ALARMIN_INFO,*LPNET_DVR_ALARMIN_INFO;

//GBT28181协议的报警输入通道配置 配置结构
typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD                   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//设备报警输入编码ID（每一路报警输入不同）：20字节字符串，仅限数字
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG,*LPNET_DVR_GBT28181_ALARMINCFG;

typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD  wSetupHeight; //架设高度[0,20]，单位：米
    BYTE  byLensType; //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE  bySetupHeightUnit;// 架设高度单位0～M,1~CM
    DWORD dwSceneDis; //图像下边缘位置与相机之间的水平距离，单位：厘米
    float fPitchAngle;//相机俯仰角度[-180°, 180°],
    float fInclineAngle;//相机倾斜角度[-180°,180°]
    float fRotateAngle;//相机旋转角度[-180°,180°]
    WORD  wVideoDetCoefficient; //视频测试系数[0,300](3.6新增)
    BYTE  byErectMethod; //架设方式0-正装，1-侧装(3.6新增)
    BYTE  byCameraViewAngle;//摄像机安装视野角度(0-垂直，1-倾斜，默认0-垂直)
    DWORD dwHorizontalDistance;//摄像机与出入口水平距离：范围1-1000，默认30，单位cm，注意摄像机角度为倾斜时该项有效
    BYTE  byDetailLensType;//范围1-100，默认28，单位0.1mm
    BYTE  byRes[3]; 
    float fHorFieldAngle; //相机水平视场角角度[0°, 360°]（抓拍机）
    float fVerFieldAngle; //相机垂直视场角角度[0°, 360°]（抓拍机）
    BYTE  byRes1[24];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

//起止日期段参数结构体
typedef struct tagNET_DVR_SCHEDDATE
{   
    BYTE   byStartMonth;   //起始（月）
    BYTE   byStartDay;     //起始（日）
    BYTE   byStopMonth;    //结束（月）
    BYTE   byStopDay;      //结束（日）
}NET_DVR_SCHEDDATE,*LPNET_DVR_SCHEDDATE;

//时控输出参数
typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{   
    NET_DVR_SCHEDTIME struTime;  //时间段
    BYTE byState;                //0C关闭, 1C开启
    BYTE byRes[11];              //保留
} NET_DVR_OUTPUT_SCHEDULE ,*LPNET_DVR_OUTPUT_SCHEDULE;

//单条时控输出规则参数
typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{   
    BYTE                     byEnable;    //是否启用规则,0-否,1-是
    BYTE                     byRes1[3];   //保留
    NET_DVR_SCHEDDATE        struDate;    //日期区段
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //最多支持8个时间段的时控输出
    BYTE                     byRes2[16];  //保留
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

//时控输出规则参数
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{   
    DWORD  dwSize; //结构体大小
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //最多支持8个日期区段的规则配置
    BYTE   byRes[64];  //保留
}NET_DVR_OUTPUT_SCHEDULE_RULECFG,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

//交通统计报警参数
typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用交通统计报警上传
    BYTE byRes1[3];    //
    DWORD dwInterval;//统计间隔时间（单位：分钟）
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;    //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;

typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//1-4，0xff， 其中1-4表示具体的IO通道号，0xff表示不启用
    BYTE  byCabinetState;//0~低电平,1~高电平
    BYTE  byAlarmIntervalTime;//取值范围1-60，单位：秒
    BYTE  byRes1[25]; 
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0~不启用，1～启用
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;

typedef  struct  tagNET_ITS_GATE_LANE_CFG
{ 
    BYTE      byGateSiteID[MAX_ID_LEN];    //出入口编号
    BYTE      byGateInfo[MAX_ID_LEN];      //出入口信息描述
    BYTE      byLaneName[NAME_LEN];     //车道名称
    BYTE      byValid;              //是否启用 0 表示未启用，1表示启用
    BYTE      byCamLaneId;     //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    WORD      wLaneid;            //车道号1～32（索引车道号，可以跳跃 逻辑车道）
    BYTE      byRelativeIoNum;         //逻辑车道号关联的输出口编号      
    BYTE      byDirection;          //方向编号;  0 -其他 1 入场  2 出场 3 双向
    BYTE      byLprMode; //牌识放行配置0 全部进1 除黑名单进2 白名单进
    BYTE       byCardMode; //卡片放行配置0 全部进1 除黑名单进2 白名单进 
    BYTE       byGateLaneMode;//出入口放行配置模式 0-全部进 1-只有牌识匹配放行2 只有刷卡匹配放//行 3-牌识或卡片有一个匹配则放行 4-牌识且卡片同时匹配则放行 5-全不进
    //2013-11-19 新增参数
    BYTE      byCharge;//是否收费 0-不收费，1-收费
    BYTE      byChargeMode;//收费类型 0-车牌收费，1-卡号收费
    BYTE      byRes1;
    BYTE      byLedRelativeIndex[MAX_INDEX_LED];//LED 索引 (1~255) 紧凑排列，0表示无效，不解析后面的数据
    BYTE      byGateRelativeIndex;//出入口控制机相对索引
    BYTE      byFarRrRelativeIndex;// 远距离读卡器相对索引
    BYTE      byRes[82]; //预留
}NET_ITS_GATE_LANE_CFG, *LPNET_ITS_GATE_LANE_CFG;

typedef    struct  tagNET_ITS_IPC_CHAN_LANE_CFG
{
    DWORD     dwSize; 
    BYTE      byIpcType;  //0-无，1-车牌抓拍，2-人脸抓拍，3-监控相机
    BYTE      byRes[135];
    NET_ITS_GATE_LANE_CFG  struGateLane[4]; //车道配置结构体
}NET_ITS_IPC_CHAN_LANE_CFG, *LPNET_ITS_IPC_CHAN_LANE_CFG;

//设备远程控制
typedef    struct    tagNET_ITS_REMOTE_COMMAND
{
    WORD            wLaneid; //车道号1～32（索引车道号，可以跳跃）
    BYTE             byCamLaneId;    //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE            byRes;     //预留
    DWORD           dwCode;       //命令码 0x0 开闸 0x1 关闸，其它待扩展
    BYTE            byRes1[128];
}NET_ITS_REMOTE_COMMAND,*LPNET_ITS_REMOTE_COMMAND;

typedef  struct    tagNET_ITS_REMOTE_CONTROL_
{
    DWORD          dwSize;
    NET_ITS_REMOTE_COMMAND    struRemoteCommand;   //远程命令结构
}NET_ITS_REMOTE_CONTROL,*LPNET_ITS_REMOTE_CONTROL;

//长连接获取通道状态
typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE  bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE  byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    BYTE  byChannelArmState; //接入IPC的布防状态
    DWORD dwChannel; //通道号
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    NET_DVR_IPADDR struClientIP[MAX_LINK];//客户端的IP地址
    DWORD dwIPLinkNum;//如果该通道为IP接入，那么表示IP接入当前的连接数
    BYTE  byExceedMaxLink;    // 是否超出了128路连接数 0 - 未超出, 1-超出     
    BYTE  byRes[139];       // 保留字节    
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

//外接灯
typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 ～ 不开启 1 ～ 开启
    BYTE   byFlicker;//0 ～ 不闪烁 1 ～ 闪烁
    BYTE   byIOState;//0 ～ 低电平 1 ～ 高电平 (外置灯起效)
    BYTE   byLampColor;// 0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 (内置灯起效)
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0～不闪烁 1 ～闪烁
    BYTE   byLampColor;//0-灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效) 
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//有车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//无车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//特殊车位有车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//特殊车位无车io电平状态
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*外接灯的情况下车位信息，一个通道最大4个车位 (从左到右车位 数组0～3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0~不闪烁 1 ～闪烁(车位指示灯闪烁)
    BYTE   byLampColor;//0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (车位指示灯颜色)
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

//内置外置灯模式
typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0~不闪烁 1 ～闪烁
    BYTE   byLampColor;//0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

//内置外置灯模式
typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP; 

/*内置灯加外置灯模式下 内置灯控制结构子信息 */
typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;     //0～不开启 1 ～开启
    BYTE   byFlicker;    //0~不闪烁 1 ～闪烁
    BYTE   byLampColor;  //0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)  
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

/* 混合控制模式结构 */ 
typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];//外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3) 
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];//内置灯 按照车位状态区分，车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

/* 单控外接灯控制模式结构 */ 
typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE //单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];//外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
    BYTE byLampType; /* 1-外置灯1，2-外置灯2，3-外置灯3*/
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;

typedef union tagNET_DVR_LAMP_CTRL_MODE_UNION
{
    BYTE uLen[288];
    NET_DVR_INLAY_LAMP_CTRL_MODE struInlayLampCtrlMode;/*内置灯控制模式结构*/ 
    NET_DVR_EXTERNAL_LAMP_CTRL_MODE struExternalLampCtrlMode;/*外接灯控制模式结构*/
    NET_DVR_PARKLAMP_CTRL_MODE struParkLampCtrlMode[MAX_PARKING_NUM/*4*/];/*内置外置灯模式，一个通道最大4个车位 (从左到右车位 数组0～3)  当模式为内外置灯的时候生效*/
    //车位检测相机内外置灯，混合控制模式（区分与上面内外置灯模式，该模式下内置灯不作为外置灯使用（内置外置灯模式下，内置灯作为外置灯使用））；
    //混合控制模式下，内置灯显示当前监测车位状态中，优先级最高的车位状态(压线>特殊车位>有无车状态)关联灯的状态
    NET_DVR_MIXLAMP_CTRL_MODE  struMixLampCtrlMode;
    //单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
    NET_DVR_SINGLELAMP_CTRL_MODE struSingleExternalLampCtrlMode;
}NET_DVR_LAMP_CTRL_MODE_UNION, *LPNET_DVR_LAMP_CTRL_MODE_UNION;/*灯控制模式联合体*/ 

typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*控灯模式：1代表内置灯,2代表外接灯,3代表内外置灯,4代表混合灯模式（内置灯只做高优先级指示灯),5-代表单外置灯模式*/
    BYTE      byCtrlChannelIndex;/*交替控制通道号(33~48)*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;/*灯控制模式联合体*/
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

//车位属性配置（默认都是normal）
typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~普通车位 1～特殊车位
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//一个通道最大4个车位 (从左到右车位 数组0～3)
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

//指示灯外控
typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0~不闪烁 1 ～闪烁
    BYTE      byParkingIndex;//车位号1～3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //外控使能 0～不启用 1～启用
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;//指示灯外控
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

//车位强制抓图 一个通道最多四车位
typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE       byParkIndex;/*车位序号从左到右 （0-表示当前有几个车位，就上传几张图片）1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

//外控报警结构
typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD      dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;//指示灯外控状态
    NET_DVR_TIME      struExternalBeginTime;/*外控开始时间*/ 
    BYTE      byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;

/* 设备类型 */
typedef enum tagEXTERNAL_DEVICES_TYPE
{
    DEVICES_TYPE_RES1 = 0,                //保留1    
    DEVICES_TYPE_FAR_SCR = 1,            //远距离读卡器
    DEVICES_TYPE_ENTRANCE_CONTROL = 2,    //出入口控制机
    DEVICES_TYPE_WJ_LED_DEV = 3,        //外接LED
    DEVICES_TYPE_NJ_LED_DEV = 4,        //内接LED
    DEVICES_TYPE_VEH_DETECT_DEV = 5,    //车检器设备
    DEVICES_TYPE_DZ_DEV = 6,            //道闸
    DEVICES_TYPE_PX_SCR_DEV = 7,         //票箱读卡器
    DEVICES_TYPE_KJ_SCR_DEV = 8,         //卡机读卡器
    DEVICES_TYPE_FKJ_DEV = 9,            //发卡机
    DEVICES_TYPE_SKJ_DEV = 10,            //收卡机
    DEVICES_TYPE_HDD_DEV = 11,            //硬盘(裸盘 1G)
    DEVICES_TYPE_DZ_LOCK = 12,            //道闸锁闸状态，0表示未锁闸，1表示锁闸
    DEVICES_TYPE_PAPER_PRINTER = 13,    //纸票打印机 
    DEVICES_TYPE_PAPER_SCANNERS = 14,   //纸票扫描仪
    DEVICES_TYPE_IPC_ALARM = 15         //IPC布防状态
}EXTERNAL_DEVICES_TYPE;

/* 设备状态 */
typedef enum tagEXTERNAL_DEVICES_STATUS
{
    /* 通用设备状态码 0~19*/
    DEVICES_STATUS_NORMAL = 0,            //状态正常
    DEVICES_STATUS_ABNORMAL = 1,        //状态异常
    
    /* 发卡机设备状态码 20~39*/
    DEVICES_STATUS_TOO_LESS_CARD = 20,         //发卡机少卡
    DEVICES_STATUS_NO_CARD = 21,             //发卡机无卡
    DEVICES_STATUS_SENDCARD_ERROR = 22,     //预发卡错误
    DEVICES_STATUS_CARD_BLOCKED = 23,         //堵卡
    DEVICES_STATUS_CARD_FULL = 24,             //回收仓卡满

    
    /* 道闸设备状态码 40~60*/
    DEVICES_STATUS_OPENING = 40,             //道闸正在开
    DEVICES_STATUS_CLOSING = 41,             //道闸正在关
    DEVICES_STATUS_OPENED  = 42,             //道闸开到位
    DEVICES_STATUS_CLOSED  = 43,             //道闸关到位    
    DEVICES_STATUS_NOSIGNAL = 44,             //道闸无信号
    DEVICES_STATUS_LOCK= 45,                 //锁闸

    /* 纸票打印机状态 61~90*/
    PP_STATUS_OFFLINE = 61,                   //脱机
    PP_STATUS_PRINT_HEADER_UP,           // 打印头抬起       
    PP_STATUS_FEED_BUTTON_FEEDING,       //正在用进纸键进纸                      
    PP_STATUS_ONLINE_WAITING,            //联机等待               
    PP_STATUS_FEED_BUTTON_ENABLE,        //按键进纸使能为开           
    PP_STATUS_JAMR_PAPER_ERROR,          //卡纸错误
    PP_STATUS_CUT_PAPER_ERROR,           //切刀错误
    PP_STATUS_AUTO_FEED_ERROR,           //自动上纸错误
    PP_STATUS_EXIT_RECOVERY_ERROR,       //有可恢复错误
    PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,  //有可自动恢复错误
    PP_STATUS_PULL_PAPER_ERROR,          //拉纸错误
    PP_STATUS_LESS_PAPER ,               //纸将尽
    PP_STATUS_NO_PAPER,                  //无纸
    PP_STATUS_PRINT_FAIL,                //打印失败
    PP_STATUS_PRINTING,                  //正在打印  
}EXTERNAL_DEVICES_STATUS;

typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1车辆非法侵入报警
    //0x2道闸超时未关报警
    //0x3车辆压线圈超时报警
    //0x4发卡报警（无卡）
    //0x5发卡报警（少卡）
    //0x6发卡报警（发卡异常）
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//外接设备类型(EXTERNAL_DEVICES_TYPE)
    BYTE  byExternalDevStatus;//外接设备类型(EXTERNAL_DEVICES_STATUS)
    BYTE  byRes;
    NET_DVR_TIME_V30  struAlarmTime;//报警时间        
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
            /*车辆类型0-保留 1-固定车，2-临时车，3-预订车，4-联检车，5-授权车*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//当struAlarmType为(0x1车辆非法侵入报警)
    }uAlarmInfo;
    BYTE  byRes2[64]; //预留
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;            //A相电压
    int iPhaseBVol;            //B相电压
    int iPhaseCVol;            //C相电压
    int iAveragePhaseVol;    //相电压平均值
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;            //AB线电压
    int iLineVolBC;            //BC线电压
    int iLineVolCA;            //CA线电压
    int iAverageLineVol;    //线电压平均值
} NET_DVR_LINE_VOLTAGE,*LPNET_DVR_LINE_VOLTAGE;


//电流
typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;            //A相电流
    int iPhaseBCurrent;            //B相电流
    int iPhaseCCurrent;            //C相电流
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

//功率
typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;            //A相功率
    int iPhaseBPower;            //B相功率
    int iPhaseCPower;            //C相功率
    int iSysTotalPower;            //系统总功率
}NET_DVR_POWER, *LPNET_DVR_POWER;

//功率因素
typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;    //A相功率因素
    int iPhaseBPowerFactor;        //B相功率因素
    int iPhaseCPowerFactor;        //C相功率因素
    int iTotalPowerFactor;        //总功率因素
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

//频率
typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;        //A相频率
    int iPhaseBFrequency;        //B相频率
    int iPhaseCFrequency;        //C相频率
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

//负载率
typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;        //A相负载率
    int iPhaseBLoadFactor;        //B相负载率
    int iPhaseCLoadFactor;        //C相负载率
    BYTE    byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

//UPS状态
typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE        struInputVoltage;    //输入电压
    NET_DVR_VOLTAGE        struBypassVoltage;    //旁路电压
    NET_DVR_VOLTAGE        struOutputVoltage;    //输出电压
    int iRectifierVol;            //整流器电压
    int iInverterVol;            //逆变器电压
    
    NET_DVR_CURRENT    struInputCurrent;    //输入电流
    NET_DVR_CURRENT    struBypassCurrent;    //旁路电流
    NET_DVR_CURRENT    struOutputCurrent;    //输出电流
    int iInverterCurrent;        //逆变器电流
    
    NET_DVR_FREQUENCY    struInputFrequency;    //输入频率
    NET_DVR_FREQUENCY    struBypassFrequency;    //旁路频率
    NET_DVR_FREQUENCY    struOutputFrequency;    //输出频率
    int iInverterFre;            //逆变器频率
    
    NET_DVR_POWER         struInputPower;    //输入功率
    NET_DVR_POWER        struBypassPower;    //旁路功率
    NET_DVR_POWER        struOutputPower;    //输出功率
    NET_DVR_POWER        struComplexPower;    //复功率
    
    int iNormalPower;            //标称功率
    int iPowerFacter;            //功率因素
    
    NET_DVR_LOAD_FACTOR    struBatteryLoadFactor;    //电池负载率
    int iBatteryEstimated;        //电池备份时间(min)
    int iBatteryTemperature;        //电池温度
    int iBatteryVoltage;            //电池电压
    
    
    BYTE    byRectifierState;        //整流器运行状态/*1正常 2异常*/
    BYTE    byInverterState;        //逆变器运行状态/*1正常 2异常*/
    BYTE    byChargeState;        //充电器运行状态/*1正常 2异常*/
    BYTE    byBatteryState;        //电池运行状态/*1正常 2异常*/
    BYTE    byAutoBypassState;    //自动旁路状态/*1正常 2异常*/
    BYTE    byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE; 

//开关电源状态
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE        struACVoltage;    //交流电压
    int     iDCConvertVoltage;    //DC转换器电压
    NET_DVR_CURRENT        struACCurrent;    //交流电流
    int     iTotalCurrent;            //负载总电流
    int     iBattery1Temperature;    //电池1温度
    int     iBattery2Temperature;    //电池2温度
    int     iBattery1Current;        //电池1电流
    int     iBattery2Current;        //电池2电流
    int     iBattery3Current;        //电池3电流
    int     iBattery4Current;        //电池4电流
    int     iBatteryTestVoltage;    //电池测试电压
    int     iRectifierOutputVoltage;    //整流模块输出电压
    int     iRectifierOutputCurrent;    //整流模块输出电流
    int     iDCOutputVoltage;        //直流输出电压
    BYTE    byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE, 
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

//气体探测器状态
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int        iSF6;            //SF6，单位ppm
    int      iFlow;           //流量，ml/min       
    int        iTemperature;        //温度，单位摄氏度
    int        iO2;            //氧气，单位%
    int        iHumidity;        //湿度，单位%
    BYTE    byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,
*LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

//温湿度传感器状态
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int        iTemperature;    //温度，单位摄氏度
    int        iHumidity;        //湿度，单位%
    BYTE    byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

//空调状态
typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int        iTemperature;    //温度，单位摄氏度
    int        iHumidity;        //湿度，单位%
    BYTE   byRunState;        //运行状态 1-正常，2-停机
    BYTE    byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;


//电量表状态
typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int        iDCVoltage;        //直流电压
    int        iDCCurrent;        //直流电流
    NET_DVR_VOLTAGE        struPhaseVoltage;    //相电压
    NET_DVR_LINE_VOLTAGE struLineVoltage;    //线电压
    NET_DVR_CURRENT    struCurrent[4];        //电流，struCurrent[0]表示第1路, 以此类推 
    int iAverageCurrent;    //平均电流
    int iNeutralCurrent;        //中线电流
    NET_DVR_POWER    struActivePower[4];    //有功功率 struActivePower[0]表示第一路有功功率，以此类推
    NET_DVR_POWER    struReactivePower[4];    //无功功率 struReactivePower[0]表示第一路无功功率，以此类推
    NET_DVR_POWER    struApparentPower[4];    //视在功率 struApprentPower[0]表示第一路视在功率，以此类推
    NET_DVR_POWER_FACTOR    struPowerFactor[4];    //功率因素，struPowerFactor[0]表示第一路功率因素，以此类推
    NET_DVR_FREQUENCY        struFrequency;            //频率
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

//变电器温显表状态
typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int        iPhaseATemperature;        //A相温度
    int        iPhaseBTemperature;        //B相温度
    int        iPhaseCTemperature;        //C相温度
    int        iPhaseDTemperature;        //D相温度
    BYTE     byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;

//水位传感器
typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG        iWaterLevel;        //水位
    BYTE        byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//扬尘噪声传感器
typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG        iDust;        //扬尘
    LONG        iNoise;        //噪声
    BYTE        byRes[504];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//环境采集仪
typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG        iAmmoniaNitrogen;    //氨氮
    LONG        iCOD;                //COD
    LONG        iPH;                //PH
    LONG        iOxygen;            //氧气
    LONG        iSulfurDioxide;    //二氧化硫
    LONG        iSoot;            //烟尘
    LONG        iFluoride;        //氟化物
    LONG        iPollutedWater;    //污水
    LONG        iTotalPhosphorus;    //总磷
    LONG        iExhaust;            //废气
    LONG        iNitrogenOxides;    //氮氧化物
    LONG        iFlueGasTemperature;//烟气温度
    LONG        iFlueGasPressure;    //烟气压力
    BYTE        byRes[460];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

typedef union tagNET_DVR_EXTERNAL_DEVICE_STATE_UNION
{
    NET_DVR_ALARMHOST_UPS_STATE struUpsState;        //UPS状态
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE struSwitchPowerState;//开关电源状态
    NET_DVR_ALARMHOST_GAS_DETECTOR_STATE struGasDetectorState;//气体检测系统状态
    NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE struTempHumiSensorState;//温湿度传感器状态
    NET_DVR_ALARMHOST_AIRCONDITION_STATE struAirConditionState;//空调状态
    NET_DVR_ALARMHOST_ELECTRICITY_STATE struElectricityState;//电量表状态
    NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE struTransformerTempState;    //变电器状态
    NET_DVR_ALARMHOST_WATERLEVEL_SENSOR struWaterLevelSensor;//水位传感器
    NET_DVR_ALARMHOST_DUSTNOISE_SENSOR struDustNoiseSensor;//扬尘噪声传感器
    NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER struEnvironmentLogger;//环境采集仪
    BYTE    byRes[512];
} NET_DVR_EXTERNAL_DEVICE_STATE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS，2-开关电源，3-气体检测系统，4-温湿度传感器，5-空调，6-电量表，7-变电器状态, 8-水位传感器、9-扬尘噪声传感器、10-环境采集仪
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE    byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;


//UPS报警限值
typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;        //越限输入电压值(高值)
    int iInputVolLow;        //越限输入电压值(低值)
    int iInputFreHigh;        //越限输入频率值(高值)
    int iInputFreLow;        //越限输入频率值(低值)
    int iOutputVolHigh;    //越界输出电压值(高值)
    int iOutputVolLow;        //越界输出电压值(低值)
    int iBatteryVoltageLow;    //电池低电压限值
    int iBatterySurplus;        //电池后备时间低 限值
    int iBatteryTemperatureHigh;//电池温度高限值
    BYTE    byRes[64];            //保留
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

//温湿度传感器限值
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;    //温度高限值，单位摄氏度
    int iTemperatureLowLimit;    //温度低限值，单位摄氏度
    int iHumidityHighLimit;        //湿度高限值，单位%
    int iHumidityLowLimit;        //湿度低限值，单位%
    BYTE    byRes[84];        
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

typedef union tagNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION
{
    NET_DVR_ALARMHOST_UPS_LIMIT_VALUE struUpsLimitValue;
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE struTempHumidityLimitValue;
}NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION,*LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS，2-温湿度传感器
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE    byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

#define    ALARMHOST_ALARMOUT_NUM    64  //触发器个数
typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD         dwSize;
    BYTE        bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];//模拟量联动触发器，0-不联动，1-联动
    BYTE        bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];//模拟量联动警号
    BYTE        bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//模拟量按类型联动触发器，该字段是bySensorJointAlarmOut的扩展。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    BYTE        bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //模拟量按类型联动警号，该字段是bySensorJointSiren的扩展。数组下标表示警号序号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    BYTE        byChan;        //通道号
    BYTE        byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

//UPS报警信息上传
typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE    byAlarmType;/*报警类型：1.A相输入电压越限 2.B相输入电压越限 3.C相输入电压越限 4.A相输出电压越限5.B相输出电压越限 6.C相输出电压越限7.A相输入频率越限 8.B相输入频率越限9.C相输入频率越限10.整流器电压越限报警 11.过载报警 12.电池电压低报警 13.电池后备时间超低报警 14.电池温度超高报警 15.逆变器关闭报警 16.自动旁路开报警 17.整流器故障报警 18.逆变器故障报警 19.充电器故障报警    20.电池故障报警     21.自动旁路故障报警 */    
    BYTE    byChanNo;    //485通道号，从1开始
    BYTE    bySlotNo;    //485虚拟槽位号
    BYTE    byRes1;        //保留
    int        iAlarmValue;//报警值
    BYTE    byRes2[64];        //保留
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

//开关电源报警上传
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE    byAlarmType;    /*报警类型：1-电池测试失败 2-AC-DC转换器故障，3-输入线/相电压AB/A越限，4-输入线/相电压BC/B越限，5-输入线/相电压CA/C越限，6-输出电流A越限，7-输出电流B越限，8-输出电流C越限，9整流模块故障，10-风扇故障，11-直流电压越限*/
    BYTE    byChanNo;        //485通道号，从1开始
    BYTE    bySlotNo;        //485虚拟槽位号
    BYTE    byRes1;
    int     iAlarmValue;        //报警值
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO, 
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

//气体检测系统报警
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE    byAlarmType;    /*报警类型：1- SF6气体含量异常，2-氧气含量异常，3-温度值异常，4-湿度值异常，5-流量*/
    BYTE    byChanNo;    //485通道号，从1开始
    BYTE    bySlotNo;    //485虚拟槽位号
    BYTE    byRes1;
    int     iAlarmValue;        //报警值
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO, 
*LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;


//温湿度传感器报警
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE    byAlarmType;    //1-温度异常，2-湿度异常
    BYTE    byChanNo;        //485通道号
    BYTE    bySlotNo;        //485槽位号
    BYTE    byRes1;
    int         iAlarmValue;    //报警值
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

typedef union  tagNET_DVR_485_DEVICE_ALARM_UNION
{
    NET_DVR_ALARMHOST_UPS_ALARMINFO struUPSAlarm; //UPS报警
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO struSwitchPowerAlarm; //开关电源报警
    NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO struGasDetectSystemAlarm; //气体检测系统报警
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO struTempHumiditySensorAlarm; //温湿度传感器报警
    BYTE    byRes[72];
} NET_DVR_485_DEVICE_ALARM_UNION, *LPNET_DVR_485_DEVICE_ALARM_UNION;

//485外接设备报警信息
typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE    byAlarmType;    //1-UPS报警，2-开关电源报警，3-气体检测系统报警，4-温湿度传感器报警
    BYTE    byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE    byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD       dwSize;              // 结构体大小
    BYTE        sDeviceName[NAME_LEN];      // 前端设备名称 
    WORD        wDeviceType;            // 前端设备类型ALARM_FRONT_DEVICE _TYPE
    WORD        wDeviceProtocol;     // 前端设备协议 通过获取协议列表获取
    WORD        wAddress;            //设备地址    
    BYTE        byChannel;          //485通道号
    BYTE        bySlotChan;         //槽位号
    BYTE        byRes[60];          // 保留字节
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

//走廊模式
typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD        dwSize;
    BYTE        byEnableCorridorMode; //是否启用走廊模式 0～不启用， 1～启用
    BYTE        byMirrorMode;            //镜像方式，0 关闭;1 左右;2 上下;3 中间 
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

//人脸侦测
typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD     dwSize;
    BYTE     byEnableDetectFace; //是否启用 0～不启用， 1～启用
    BYTE     byDetectSensitive; //灵敏度 10个等级 1～10
    BYTE     byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    BYTE     byEnableFaceRecog;  //是否启用人脸识别，0-不启用，1-启用
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*处理方式*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间 */
    DWORD    dwMaxRelRecordChanNum;     //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum;     //报警触发的录象通道数 实际支持数
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];    /* 报警触发的录象通道*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    WORD     wDuration;  //报警持续时间 5s 能力集
    BYTE     byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD        dwSize;                 // 结构体大小
    DWORD       dwGroup ;             //组号
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //多码流配置
    BYTE         byRes[64] ;        
}NET_DVR_MUL_STREAM_CHANNEL_GROUP,*LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD        dwSize;       // 结构体大小
    DWORD       dwChannel; //通道号
    DWORD       dwGroup;   //组号 
    BYTE        byID;      //设备区域设置ID
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //场景位置索引号,IPC是0，IPD是从1开始
    BYTE        byRes[56];              
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;


typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //时间
    BYTE   byDetSceneID;//检测场景号[1,4],IPC默认是0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION,*LPNET_DVR_TIME_DETECTION;

//抓拍触发模式支持关联布防时间段和上传中心条件
typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    /*
    0表示无效， 
    1表示关联 抓拍VIA模式（视频触发抓拍 IPC使用）;
    2 表示关联 抓拍 HVT 模式 （混卡IPC使用）
    */
    BYTE   byRelateType; 
    BYTE   byGroupNo;  //组号
    BYTE   byRes[62];
}NET_DVR_GUARD_COND,*LPNET_DVR_GUARD_COND;

//抓拍触发模式支持关联布防时间段和上传中心
typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //布防时间
    NET_DVR_TIME_DETECTION    struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //本组内实际触发的录象通道数
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];    //报警触发的录象通道(0xffff ffff表示后续无效）
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间 
    BYTE   byRes[88];
}NET_DVR_GUARD_CFG,*LPNET_DVR_GUARD_CFG;

//抓拍图片参数配置扩展条件结构
typedef    struct  tagNET_DVR_SNAPINFO_COND_
{
    DWORD    dwSize; 
    DWORD    dwChan;
    /*
    0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
    1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    */
    BYTE     byRelateType;
    BYTE     byRes[63];        //保留
}NET_DVR_SNAPINFO_COND, *LPNET_DVR_SNAPINFO_COND;


//抓拍图片参数配置
typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0-表示的图片质量，1-表示图片大小
    BYTE  byPicQuality;//图片质量[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//图片大小[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG,*LPNET_DVR_SNAPINFOCFG;

//ptz跟踪方式
typedef enum _PTZ_TRACK_MODE_
{
    PTZ_TRACK_MODE_ALWAYS  = 1,   //一直跟踪
        PTZ_TRACK_MODE_BYTIME  = 2,   //跟踪指定时间
        PTZ_TRACK_MODE_NEXT    = 3,   //跟踪下一目标
}PTZ_TRACK_MODE;

//ptz跟踪参数
typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //结构体大小
    BYTE  byTrackMode; //跟踪方式,参考PTZ_TRACK_MODE
    BYTE  byLinkageTarget; //联动目标0-默认,1-球机1,2-球机2…..依次类推
    BYTE  byAutoTrackEnable;//跟踪使能 0-自动跟踪开启，1-自动跟踪关闭（枪球设备才支持自动跟踪关闭功能，故在此特殊扩展）
    BYTE  byRes1; //保留
    DWORD dwTrackTime; //跟踪时间，
    //当跟踪模式为PTZ_TRACK_MODE_ALWAYS，此字段无效
    //当跟踪模式为PTZ_TRACK MODE_BYTIME时，范围[1,60]，默认10秒
    //当跟踪模式为PTZ_TRACK MODE_NEXT时，范围[1,10]，默认2秒
    BYTE  byRes2[256]; //保留
}NET_DVR_PTZ_TRACK_PARAM,*LPNET_DVR_PTZ_TRACK_PARAM;

typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD dwSize;
    BYTE    byEnable;//使能
    BYTE    byEnableDualVca;// 启用支持智能后检索 0-不启用，1-启用
    BYTE   byRes1[2];
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];  //警戒线参数
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//触发录像的通道号
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;


typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable; //使能，是否开启
    BYTE byEnableDualVca;// 启用支持智能后检索 0-不启用，1-启用
    BYTE byRes1[2];
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];//每个区域的参数设置
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //布防时间
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //假日布防时间
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;    //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    DWORD   dwRoiFixNum; //固定区域总数，确定后续再次获取的组号
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC现在支持4个，球机现在支持24个
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//固定ROI区域名称
    DWORD   dwRoiTrackNum; //自动跟踪区域总数，确定后续再次获取的组号
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC现在支持4个，球机现在支持24个
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;

typedef  enum  _DETECT_ROI_TYPE_
{
    DETECT_FIX_ROI  =  0, //检测ROI固定区域
        DETECT_TRACK_ROI = 1 //检测ROI 自动跟踪区域
}DETECT_ROI_TYPE;
//条件参数
typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //区域检测号 一个PTZ支持4个 
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //多码流配置
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE 的值
    BYTE    byRoiDetectTrackType;//固定区域时，该字段无效；跟踪区域时，1～人脸侦测（IPC）,2～移动物体跟踪,3-车牌跟踪
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND,*LPNET_DVR_ROI_DETECT_COND;

//配置参数
//ROI固定区域模式 区域编码功能
typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI固定区域模式 是否启用 0～不启用， 1～启用
    BYTE  byImageQualityLevel; //图像质量提升等级 1～6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;  //ROI区域
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;

//ROI自动跟踪模式 区域编码功能  
typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI自动跟踪模式 是否启用 0～不启用， 1～启用
    BYTE  byImageQualityLevel; //图像质量提升等级 1～6
    BYTE  byModeType;// 0 ~ 无, 1～人脸模式(移动和静止的物体), 2~移动物体跟踪(移动的物体), 3-车牌跟踪
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;

typedef union tagNET_DVR_ROI_DETECT_UNION
{
    DWORD                        uLen[128];   
    NET_DVR_ROI_FIX_RECT_CFG    strRoiFixRectCfg;//固定区域模式
    NET_DVR_ROI_TRACK_RECT_CFG  strRoiTrackRectCfg;//自动跟踪模式
}NET_DVR_ROI_DETECT_UNION,*LPNET_DVR_ROI_DETECT_UNION;

typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;  //560
    DWORD       dwStreamType;    //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE 的值 
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo; //ROI检测区域
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

//虚焦侦测
typedef struct tagNET_VCA_DEFOCUSPARAM
{    
    DWORD dwSize;
    BYTE byEnable;//使能
    BYTE  bySensitiveLevel;// 1-100，默认50，灵敏度越高，越容易报警
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM,*LPNET_VCA_DEFOCUSPARAM;

//IPC5.1.0  
typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD wPresetNum; //预置点编号
    BYTE byRes1[2]; //字节对齐 
    char byName[NAME_LEN];
    BYTE byRes[64];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;

typedef struct
{
    NET_DVR_SCHEDTIME struSchedTime; //时间
    WORD  wAction;  ///< 定时动作具体动作
    WORD  wActionNum; ///< 特殊动作子编号，如预置点，巡航，花样，报警输出，日夜切换，
    BYTE byres[12];
}NET_DVR_SCHEDTASK,* LPNET_DVR_SCHEDTASK;

//定时任务
typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///< 使能 1-开，0-关
    BYTE byRes[3];    ///< 字节对齐
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];    ///< 7天，每天10时间段
    DWORD dwParkTime;   ///< 守望时间 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK,*LPNET_DVR_TIME_TASK;

//条件结构体
typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;                 // 结构体大小
    DWORD dwChannel ;           //通道号
    DWORD dwIndex ;             //索引号
    BYTE  byRes[64] ;        
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;                 // 结构体大小
    char  cName[NAME_LEN] ;          //名称
    BYTE  byRes[64];          
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

//登录设备参数
typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{    
    DWORD  dwSize;       //结构体大小
    BYTE   byMobileDev;  //设备种类, 0- 非移动设备, 1 - 移动设备
    BYTE   byRes[63];    //保留                    
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;

typedef enum RECV_DATA_TYPE
{ 
    ENUM_RECV_ERRCODE = 0x0, //返回错误码
} RECV_DATA_TYPE;

//码流输出模式
typedef enum tagFISHEYE_STREAM_OUTPUT_MODE_
{
    FISHEYE_STREAM_MODE_FISHEYE    = 1,   //鱼眼模式
        FISHEYE_STREAM_MODE_PTZ        = 2,   //PTZ模式
        FISHEYE_STREAM_MODE_PANORAMA   = 3    //全景模式
}FISHEYE_STREAM_OUTPUT_MODE;

//回调数据类型枚举
typedef enum _CALLBACK_TYPE_DATA_ENUM_
{
    ENUM_FISHEYE_STREAM_STATUS   = 1,  //鱼眼码流输出状态
        ENUM_FISHEYE_PTZPOS          = 2,  //ptz通道当前所处鱼眼模式下的坐标
        ENUM_FISHEYE_REALTIME_OUTPUT = 3   //实时输出模式
}CALLBACK_TYPE_DATA_ENUM;

//鱼眼码流状态
typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{   
    DWORD  dwSize;        //结构体大小 
    BYTE   byStreamMode;  //码流输出模式，参见FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //保留
}NET_DVR_FISHEYE_STREAM_STATUS,*LPNET_DVR_FISHEYE_STREAM_STATUS;

//长连接回调数据结构体
typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{   
    DWORD  dwChannel;      //通道号
    DWORD  dwDataType;     //参见CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //数据长度
    BYTE*  pData;          //数据，当dwTypeData为 ENUM_FISHEYE_STREAM_STATUS，其对应为NET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //保留    
}NET_DVR_CALLBACK_TYPE_DATA,*LPNET_DVR_CALLBACK_TYPE_DATA;

//鱼眼ptz拖动参数
typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD          dwChannel;      //通道号
    DWORD          dwPtzChannel;   //当dwChannel所指通道模式为FISHEYE_STREAM_MODE_FISHEYE（鱼眼模式时），此值为其拖动所联动的ptz通道。当dwChannel通道模式为非鱼眼时，置为0即可
    NET_VCA_POINT  struToPoint;    //拖动画面要跳转到的目标点，目标点位置相对于预览画面的左上角
    NET_VCA_POINT  struOriPoint;   //拖动操作起始点,此点为当次拖动操作开始时，鼠标指针相对于预览画面左上角的位置
    BYTE           byRes[56];      //保留
}NET_DVR_DRAG_POS_PARAM,*LPNET_DVR_DRAG_POS_PARAM;

//平台查询诊断服务器的状态
typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad;       //CPU资源占用情况, 取值范围：0-100
    BYTE       byMemLoad;      //Memory资源占用情况，取值范围：0-100
    WORD       wAbility;      //诊断服务器能力集，大于0
    WORD       wRemainAbility;//诊断服务器剩余能力，取值范围：大于 0  剩余监控点的个数
    WORD       wTotalPlanNum; //最多64个计划>
    WORD       wCurPlanNum;   //当前计划数  最多64个计划>
    BYTE       byRes[62];     //保留
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;            //是否启用     
    BYTE   byDevType;             //设备类型：0-非云台设备，1-带云台设备
    BYTE   bySignalPoint;       //信号丢失阀值，0-100
    BYTE   byBlurPoint;         //图像模糊阀值，0-100
    BYTE   byLumaPoint;         //图像过亮阀值，0-100
    BYTE   byChromaPoint;       //图像偏色阀值，0-100
    BYTE   bySnowPoint;         //噪声干扰阀值，0-100
    BYTE   byStreakPoint;       //条纹干扰阀值，0-100
    BYTE   byFreezePoint;       //画面冻结阀值，0-100
    BYTE   byPTZPoint;          //云台失控阀值，0-100
    BYTE   byMonitorDel;        //监控点删除 0-不删除， 1-删除
    BYTE   byContrastThreshold; //对比度异常阈值，0-100
    BYTE   byMonoThreshold;     //黑白图像阈值，0-100
    BYTE   byShakeThreshold;    //视频抖动阈值，0-100
    BYTE   byFlashThreshold;    //视频剧变阈值，0-100
    BYTE   byCoverThreshold;    //视频遮挡阈值，0-100
    BYTE   bySceneThreshold;    //场景变更阈值，0-100
    BYTE   byDarkThreshold;     //图像过暗阈值，0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

//诊断结果
typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];    ///< 流ID，长度小于32个字节
       char  sMonitorIP[64];  ///< 监控点ip
       DWORD  dwChanIndex;  ///< 监控点通道号  
    DWORD  dwWidth;  ///< 图像宽度
    DWORD  dwHeight;  ///< 图像高度
    NET_DVR_TIME  struCheckTime;  ///< 检测时间(合并日期和时间字段)，格式：2012-08-06 13:00:00
    BYTE  byResult;  ///0-未检测 1-正常 2-异常 3-登录失败 4-取流异常
    BYTE  bySignalResult; ///< 视频丢失检测结果 0-未检测 1-正常 2-异常
       BYTE  byBlurResult;  ///< 图像模糊检测结果，0-未检测 1-正常 2-异常
       BYTE  byLumaResult;  ///< 图像过亮检测结果，0-未检测 1-正常 2-异常
       BYTE  byChromaResult;  ///< 偏色检测结果，0-未检测 1-正常 2-异常
       BYTE  bySnowResult;  ///< 噪声干扰检测结果，0-未检测 1-正常 2-异常
    BYTE  byStreakResult;  ///< 条纹干扰检测结果，0-未检测 1-正常 2-异常
       BYTE  byFreezeResult;  ///< 画面冻结检测结果，0-未检测 1-正常 2-异常
       BYTE  byPTZResult;  ///< 云台检测结果，0-未检测 1-正常 2-异常
    BYTE  byContrastResult;     //对比度异常检测结果，0-未检测，1-正常，2-异常
    BYTE  byMonoResult;         //黑白图像检测结果，0-未检测，1-正常，2-异常
    BYTE  byShakeResult;        //视频抖动检测结果，0-未检测，1-正常，2-异常
    char  sSNapShotURL[256];    ///<图片URL地址
    BYTE  byFlashResult;        //视频剧变检测结果，0-未检测，1-正常，2-异常
    BYTE  byCoverResult;        //视频遮挡检测结果，0-未检测，1-正常，2-异常
    BYTE  bySceneResult;        //场景变更检测结果，0-未检测，1-正常，2-异常
    BYTE  byDarkResult;         //图像过暗检测结果，0-未检测，1-正常，2-异常
    BYTE  byStreamType;        //码流类型，0-无效，1-未知，2-国标类型，3-非国标类型
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST   ///< 这个数据结构是平台发送到诊断服务器的
{
    NET_DVR_STREAM_INFO  struStreamInfo;
       char   sSnapShotURL[256];  ///< 诊断抓图URL，长度小于256个字节    
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO  ///< 这个数据结构是诊断服务器返回给平台的
{
    DWORD  dwSize;
    char   sStreamID[32];     ///<流ID(监控点ID)，长度小于32个字节
    DWORD  dwPicLength;  ///图片长度
    BYTE   byStatus;     ///< 设置结果:0-成功,1-数据有误，2-图片不存在，3-获取图片失败
    BYTE   byRes[31];
       char   *pSnapShot;      ///< 诊断抓图，是一块图片缓存数据(700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];    ///< 计划id，长度小于32个字节
       NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];    ///< 检测时间 
    BYTE    byPlanMode;  ///0:即时计划，1:周期计划
    BYTE    byRes1;//     
    BYTE    byCheckFlag;  ///< 是否检测，0-不检测，1-检测
    BYTE    bySignal;  ///<视频丢失 是否检测，0-不检测，1-检测
       BYTE    byBlur;  ///< 图像模糊 是否检测，0-不检测，1-检测
       BYTE    byLuma;  ///< 图像过亮是否检测，0-不检测，1-检测
       BYTE    byChroma;  ///< 偏色检测 是否检测，0-不检测，1-检测
       BYTE    bySnow;  ///<噪声干扰 是否检测，0-不检测，1-检测
    BYTE    byStreak;  ///<条纹干扰 是否检测，0-不检测，1-检测
       BYTE    byFreeze;  ///<画面冻结是否检测，0-不检测，1-检测
       BYTE    byPTZ;  ///<云台是否检测，0-不检测，1-检测
    BYTE    byEnablePlanRound;  ///计划循环是否开启
    BYTE    byContrast;  //对比度异常是否检测，0-不检测，1-检测
    BYTE    byMono;      //黑白图像是否检测，0-不检测，1-检测
    BYTE    byShake;     //视频抖动是否检测，0-不检测，1-检测
    BYTE    byFlash;     //视频剧变是否检测，0-不检测，1-检测
    BYTE    byCover;     //视频遮挡是否检测，0-不检测，1-检测
    BYTE    byScene;     //场景变更是否检测，0-不检测，1-检测
    BYTE    byDark;      //图像过暗是否检测，0-不检测，1-检测
    BYTE    byRes[13];     
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;


typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;                //总步数
    BYTE  byStepIndex;                //当前第几步
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;

//第三方IPC列表
typedef enum tagNET_DVR_IPC_ENUM
{
    ENUM_BUSINESS_INVALID = -1,
        
        ENUM_BUSINESS_HIKVISION = 0,
        ENUM_BUSINESS_PANASONIC,
        ENUM_BUSINESS_SONY,
        ENUM_BUSINESS_AXIS,
        ENUM_BUSINESS_SANYO,
        ENUM_BUSINESS_BOSCH,
        ENUM_BUSINESS_ZAVIO,
        ENUM_BUSINESS_GRANDEYE,
        ENUM_BUSINESS_PROVIDEO,
        ENUM_BUSINESS_ARECONT, // 9 
        ENUM_BUSINESS_ACTI,
        ENUM_BUSINESS_PELCO,
        ENUM_BUSINESS_VIVOTEK,
        ENUM_BUSINESS_INFINOVA,  
        ENUM_BUSINESS_DAHUA,    //14
        
        ENUM_BUSINESS_HIK_STD_H264 = 0x20,
        ENUM_BUSINESS_HIK_STD_MPEG4,
        ENUM_BUSINESS_SUNELL ,    //景阳
        ENUM_BUSINESS_ATEME ,    
        ENUM_BUSINESS_LAUNCH,    //朗驰
        ENUM_BUSINESS_YAAN,    //雅安
        ENUM_BUSINESS_BLUESKY,    //蓝色星际
        ENUM_BUSINESS_BLUESKYLIMIT,//蓝色星际LIMIT
        ENUM_BUSINESS_TDWY,            //天地伟业
        ENUM_BUSINESS_HBGK,            //汉邦高科
        ENUM_BUSINESS_SANTACHI,        //金三立
        ENUM_BUSINESS_HIGHEASY,        //恒忆
        ENUM_BUSINESS_SAMSUNG,          
        
        ENUM_BUSINESS_URL_RTSP = 0x40,    /* url类型取流 */
        ENUM_BUSINESS_ONVIF,            
        
        ENUM_MAX_BUSINESS_TYPE,    //最大厂商类型
} NET_DVR_IPC_ENUM, *LPNET_DVR_IPC_ENUM;

//后端传显统一后第三方IPC列表
typedef enum tagNET_DVR_IPC_ENUM_UNIFY
{
    ENUM_IPC_PROTOCOL_INVALID = -1,
        ENUM_IPC_PROTOCOL_HIKVISION = 0,  //海康威视
        ENUM_IPC_PROTOCOL_PANASONIC ,     //松下
        ENUM_IPC_PROTOCOL_SONY ,          //索尼
        
        ENUM_IPC_PROTOCOL_AXIS = 4,       //安讯士
        ENUM_IPC_PROTOCOL_SANYO ,         //三洋
        ENUM_IPC_PROTOCOL_BOSCH ,         //博世  
        ENUM_IPC_PROTOCOL_ZAVIO ,         //ZAVIO  
        ENUM_IPC_PROTOCOL_GRANDEYE ,      //GRANDEYE
        ENUM_IPC_PROTOCOL_PROVIDEO ,      //创视
        ENUM_IPC_PROTOCOL_ARECONT ,       //爱锐康特
        ENUM_IPC_PROTOCOL_ACTI ,          //大卫通
        ENUM_IPC_PROTOCOL_PELCO ,         //帕尔高 
        ENUM_IPC_PROTOCOL_VIVOTEK ,       //晶睿通讯
        ENUM_IPC_PROTOCOL_DAHUA ,         //大华
        ENUM_IPC_PROTOCOL_SAMSUNG ,       //三星
        
        ENUM_IPC_PROTOCOL_PSIA = 17,      //PSIA
        ENUM_IPC_PROTOCOL_ONVIF ,         //ONVIF
        ENUM_IPC_PROTOCOL_BRICKCOM ,      //金砖通信
        ENUM_IPC_PROTOCOL_GB28181 ,       //GB28181
        
        ENUM_IPC_PROTOCOL_CANON = 23 ,    //佳能
        
        ENUM_IPC_PROTOCOL_HUINT = 32,      //HUINT
        ENUM_IPC_PROTOCOL_INFINOVA ,       //英飞拓
        ENUM_IPC_PROTOCOL_HIK_STD_H264,    //海康标准264
        ENUM_IPC_PROTOCOL_HIK_STD_MPEG4 ,  //海康标准MPEG4
        ENUM_IPC_PROTOCOL_SUNELL ,         //景阳
        ENUM_IPC_PROTOCOL_ATEME ,          //安特姆
        ENUM_IPC_PROTOCOL_LAUNCH ,         //郎驰
        ENUM_IPC_PROTOCOL_YAAN,                //亚安
        ENUM_IPC_PROTOCOL_BLUESKY ,            //蓝色星际
        ENUM_IPC_PROTOCOL_BLUESKYLIMIT ,    //蓝色星际LIMIT
        ENUM_IPC_PROTOCOL_TDWY ,           //天地伟业
        ENUM_IPC_PROTOCOL_HBGK ,            //汉邦高科
        ENUM_IPC_PROTOCOL_SANTACHI,            //金三立
        ENUM_IPC_PROTOCOL_HIGHEASY,            //恒亿
        ENUM_IPC_PROTOCOL_HANBANG ,         //汉邦高科
        ENUM_IPC_PROTOCOL_SAMSUNG_3120 ,    //三星3120
        ENUM_IPC_PROTOCOL_SAMSUNG_3080 ,    //三星3080
        ENUM_IPC_PROTOCOL_SAMSUNG_2000,     //三星2000
        ENUM_IPC_PROTOCOL_SAMSUNG_5200 ,    //三星5200
        ENUM_IPC_PROTOCOL_JINGYUAN ,        //警院
        ENUM_IPC_PROTOCOL_VIDEOTREC ,       //动力盈科
        ENUM_IPC_PROTOCOL_CHENOVA ,            //上海诚丰
        ENUM_IPC_PROTOCOL_FENGHUO ,         //烽火
        ENUM_IPC_PROTOCOL_ZB_5301 ,         //浙江贝尔5301
        ENUM_IPC_PROTOCOL_ZB_5401 ,         //浙江贝尔5401
        ENUM_IPC_PROTOCOL_HAIXIN,            //海信
        ENUM_IPC_PROTOCOL_ZHONGYINGXIN ,    //中瀛鑫
        ENUM_IPC_PROTOCOL_AVUN ,            //信诺安达
        ENUM_IPC_PROTOCOL_GOVTY ,           //广州吉田
        ENUM_IPC_PROTOCOL_SAE ,                //艾里克
        ENUM_IPC_PROTOCOL_DONGFANGWANGLI,   //东方网力
        ENUM_IPC_PROTOCOL_CHANGHONG,        //长虹
        ENUM_IPC_PROTOCOL_H3C ,                //华三
        ENUM_IPC_PROTOCOL_BAIAN ,           //百安
        ENUM_IPC_PROTOCOL_HAT ,                //华安泰
        ENUM_IPC_PROTOCOL_YUANYE,            //远业
        ENUM_IPC_PROTOCOL_HIKCARD ,            //海康板卡
        ENUM_IPC_PROTOCOL_HAIXINCAP ,       //海信抓拍机
        ENUM_IPC_PROTOCOL_WENANCAP ,        //文安抓拍机
        ENUM_IPC_PROTOCOL_XUNMEI ,            //讯美
        ENUM_IPC_PROTOCOL_BAIWO ,            //佰沃
        ENUM_IPC_PROTOCOL_APD ,                //安普达
        ENUM_IPC_PROTOCOL_REACHDEV ,        //锐取
        ENUM_IPC_PROTOCOL_XUNMEI_DAHUA ,    //讯美大华OEM
        ENUM_IPC_PROTOCOL_HUANGHE,            //黄河设备
        ENUM_IPC_PROTOCOL_LIANCHEN ,        //联宸
        ENUM_IPC_PROTOCOL_CHENGYE,            //诚业
        ENUM_IPC_PROTOCOL_VISIONDIGI ,      //威乾
        ENUM_IPC_PROTOCOL_HENGHE ,          //恒河
        ENUM_IPC_PROTOCOL_KODAK ,           //科达
        ENUM_IPC_PROTOCOL_AIRONIX,          //奥尼克斯
        ENUM_IPC_PROTOCOL_LG,               //乐金
        ENUM_IPC_PROTOCOL_HASEE ,          //神州
        ENUM_IPC_PROTOCOL_8000ME ,          //8000ME
        ENUM_IPC_PROTOCOL_POVITEL ,         //普天博威
        ENUM_IPC_PROTOCOL_YIVIEW,           //亿维
        ENUM_IPC_PROTOCOL_TIANYUE ,         //天跃
        ENUM_IPC_PROTOCOL_HOWELL ,          //浩维
        ENUM_IPC_PROTOCOL_WAPA,             //波粒
        ENUM_IPC_PROTOCOL_SANLE ,           //三乐
        ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION,      //加密海康板卡
        ENUM_IPC_PROTOCOL_JUNSDA ,          //宙视达
        ENUM_IPC_PROTOCOL_LIYUAN ,          //立元
        ENUM_IPC_PROTOCOL_XINCHAN ,         //信产
        ENUM_IPC_PROTOCOL_BITE ,            //比特
        ENUM_IPC_PROTOCOL_MEIAN,            //美安
        ENUM_IPC_PROTOCOL_ROSEEK,           //锐势
        ENUM_IPC_PROTOCOL_AEBELL ,          //美电贝尔
        ENUM_IPC_PROTOCOL_JSL_ST ,          //金三立ST
        ENUM_IPC_PROTOCOL_VIMICRO,          //中星微电子
        
        ENUM_IPC_PROTOCOL_TYPE,    //最大厂商类型
}NET_DVR_IPC_ENUM_UNIFY, *LPNET_DVR_IPC_ENUM_UNIFY;



typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD                dwSize;            // 结构体大小
    NET_DVR_STREAM_INFO    struStreamInfo;    // 监控点
    WORD                 wYear;              // 年 
    BYTE                 byMonth;            // 月
    BYTE                byDrawFrame;    // 0-不抽帧 1-抽帧
    BYTE                byStreamType;   //0-主码流 1-子码流
    BYTE                byRes[31];  
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{    
    DWORD            dwSize;            // 结构体大小
    BYTE            byRecordDistribution[LEN_32];   // 录像分布，byRecordDistribution[0]=1表示1日存在录像，byRecordDistribution[0]=0表示没有录像，
    //byRecordDistribution[1]表示2日，以此类推
    BYTE            byHasEventRecode[LEN_31];            //事件录像 0-无事件录像，1-有事件录像
    BYTE            byRes;                        //保留
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;


typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD    dwSize;                        // 结构体大小
    BYTE     byGroup;                    // 组号，每组可获取 64个通道，从0开始, 0表示第1组，以此类推
    BYTE    byProType;                    //协议类型，0-私有协议，1-松下协议，2-索尼
    BYTE    byAccessMode;                //接入模式，0-IP地址，1-域名
    BYTE    byRes1;                        //保留字段，置0
    char    szUserName[NAME_LEN];        //用户名
    char    szPassword[PASSWD_LEN];        //密码
    char    szDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR struIP;                //IP地址
    WORD    wPort;                         // 端口号
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181协议接入时的设备服务器ID
    BYTE    byRes2[2];                    //保留字段，置0
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD    dwSize;    // 结构体大小
    DWORD    dwTotalChannelNum;      //设备总通道个数，设备不在线时返回0，byChannel无效
    BYTE     byChannel[MAX_CHANNUM_V30];    /*byChannel[i]为0表示第（byGroup+1）*（i-1）通道未接入到NVR，
                                    为1表示该通道已接入到NVR byGroup在NET_DVR_ACCESS_DEVICE_INFO中*/
    BYTE  byRes[32];           //保留
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD    dwSize; //组号
    BYTE    byGroup; //组号，每组可配置64个画面
    BYTE    byVideoOutType; /*视频输出接口类型,0-主CVBS,1-HDMI 2-VGA 3-辅助输出一
                     4-辅助输出二 5-辅助输出三 6-辅助输出四, 7-辅助HDMI, 8-扩展HDMI1,
                     9-扩展HDMI2, 10-扩展HDMI3, 11-扩展HDMI4, 12-非同源VGA1，
                     13-非同源VGA2，14-非同源VGA3，15-非同源VGA4，16-同源VGA, 17-主LCD,18-辅助VGA,19-辅助LCD*/
    BYTE    byRes[2];
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD    dwSize;    // 版本管理及结构体大小
                    WORD    wSwitchSeq[MAX_WINDOW_V40];/*bySwitchSeq [i]=6，表示第（组号*64+i+1）个窗口
                    显示第六通道，为0xff表示该窗口不显示*/
                    BYTE    byPreviewNumber;/*预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面，6-25画面,7-32画面, 8-36画面, 9-64画面
                    0xff:最大画面*/
                    BYTE    byEnableAudio;//是否声音预览,0-不预览,1-预览
                    BYTE    bySwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
                    BYTE    bySameSource ; //是否同源，当视频输出口类型为非同源VGA1-非同源VGA4时有效 
                    BYTE    byRes[32];        //保留
}NET_DVR_PREVIEW_SWITCH_CFG,* LPNET_DVR_PREVIEW_SWITCH_CFG;

typedef struct tagNET_DVR_USER_COND
{    
    char        szUserName[NAME_LEN];
    BYTE        byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{    
    DWORD            dwSize;
    BYTE            byAddMonitoringPointRight; // 添加监控点（前端设备）权限0-无 1-有
    BYTE            byModMonitoringPointRight; // 修改监控点（前端设备）权限0-无 1-有
    BYTE            byDelMonitoringPointRight; // 添加监控点（前端设备）权限0-无 1-有
    BYTE            bySetRecordPlanRight; // 制定录像策略权限0-无 1-有
    BYTE            byDelRecordPlanRight; // 删除录像策略权限0-无 1-有
    BYTE            byEnableOrDisableRecordPlanRight; // 启用和禁用录像计划权限0-无 1-有
    BYTE            byManualRecordRight; // 启动和停止手动录像权限0-无 1-有
    BYTE            bySetAlarmRecordRight; // 报警录像设定权限0-无 1-有
    BYTE            byRecordBackupRight; // 录像存档权限0-无 1-有
    BYTE            byRecordDownloadRight; // 录像下载权限0-无 1-有
    BYTE            byRecordDeleteRight; // 录像删除权限0-无 1-有（保留）
    BYTE            byDelBackupRecordRight; // 删除存档录像权限0-无 1-有（保留）
    BYTE            bySetBackupVolumeRight; // 设置存档卷权限0-无 1-有
    BYTE            byRecordPlayBackRight; // 录像回放权限0-无 1-有
    BYTE            byLogDeleteRight; // 日志清空权限0-无 1-有（保留）
    BYTE            byLogDownloadRight; // 日志下载权限0-无 1-有（保留）
    BYTE            byAddUserRight; // 添加用户权限0-无 1-有
    BYTE            byDelUserRight; // 删除用户权限0-无 1-有
    BYTE            byModUserRight; // 修改用户权限0-无 1-有
    BYTE            byAllocUserRight; // 用户权限分配权限0-无 1-有
    BYTE            byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD                dwSize;
    DWORD               dwMaxNum;         // 最大备机数目
    BYTE                   byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;

//配置N+1设备工作机模式，NVR需要这步，CVR不需要
typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD    dwSize ;
    BYTE    byWorkMode;        //0-工作机 1-备机
    BYTE    byRes[127];       //保留
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR    struIP;        // 设备IP
    char            szPassword[PASSWD_LEN];    //备机密码，需简易加密
    BYTE             byAddType;         // 0-（工作机上）添加备机，1-（备机上）添加工作机
    BYTE             byDisableBackup; //备份功能使能开关 0-开启1-关闭 CVR默认开启
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR    struIP;        // 设备IP
    BYTE             byDelType;     // 0-删除指定的机器（备机或工作机）1-全删
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;

typedef union tagNET_DVR_NPO_PARAM_UNION
{
    NET_DVR_ADD_PARAM    struAddParam;        //添加信息
    NET_DVR_DEL_PARAM     struDelParam;        //删除信息
}NET_DVR_NPO_PARAM_UNION, *LPNET_DVR_NPO_PARAM_UNION;

// N+1模式设备参数
typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD                    dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam;
    BYTE                     byType;     /* 0-添加，对应unionParam中的struAddParam 1-删除，对应unionParam中的struDelParam */
    BYTE                      byRes2[255];          // 保留
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

// 数据回迁
typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD                dwSize;
    BYTE                   byEnable;     // 0-不启用数据回迁 1-启用数据回迁
    BYTE                   byDelData;     // 当byEnable为1是有效 0-不删除备机录像数据 1-删除备机录像数据
    BYTE                   byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD     dwSize;
    BYTE     bySleepStatus;/*休眠状态0-不休眠 1-休眠*/
    BYTE      byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD     dwSize;
    BYTE     bySpeed;    /*0-高速 1-中速 2-低速*/
    BYTE      byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD                dwSize;
    DWORD                dwSrcLunID;        // 源LUN ID
    DWORD               dwDstLunID;     // 目的LUN ID
    BYTE                   byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD                dwSize;
    DWORD                dwLunID;                    // LUN ID
    DWORD                dwHSize;                    // 扩展的大小高32位
    DWORD                dwLSize;                    // 扩展的大小低32位
    char                szArrayIDGroup[NAME_LEN];    // 使用的阵列ID组，以逗号隔开，为空则为默认
    char                   szNewLunName[MAX_NAMELEN];     // 新LUN名
    BYTE                   byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;


typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD                dwSize;
    char                szOldDvrNetDiskName[MAX_NAMELEN];        // 原DVR网盘共享名
    char                   szNewDvrNetDiskName[MAX_NAMELEN];     // 新DVR网盘共享名
    NET_DVR_IPADDR        struWarrantIP;                        // 新授权的DVR网盘IP
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;


typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD                dwSize;
    DWORD                dwLunID;        // LUN ID
    BYTE                   byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD                dwSize;
    DWORD                dwTargetID;        // iSCSI服务的Target ID
    DWORD                dwLunID;        // LUN ID
    DWORD                dwAccessMode;    //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    NET_DVR_IPADDR        struClientIP;        // 客户端IP，0.0.0.0为所以IP
    BYTE                   byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD                dwSize;
    DWORD                dwStoreLunID;                    // 存储LUN ID
    DWORD                dwLogicLunID;                    // 逻辑LUN ID，-1表示自动生成
    DWORD                dwHbaID;                        // 光纤通道号
    DWORD                dwAccessMode;                    //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    char                szClientWWWPN[NAME_LEN];         // 客户光纤卡
    BYTE                   byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;


// 逻辑卷 60字节
typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD        dwHCapacity;    // 逻辑卷大小高32位
    DWORD        dwLCapacity;    // 逻辑卷大小低32位
    char        szName[MAX_NAMELEN];     // 逻辑卷名称
    DWORD        dwBlockSize;        // 逻辑卷的最小存储单元块大小
    char        szArrayIDGroup[NAME_LEN];     //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;

typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD            dwHCapacity;    // DVR网盘大小高32位
    DWORD            dwLCapacity;    // DVR网盘大小低32位
    char                szName[MAX_NAMELEN];     // DVR网盘名称
    DWORD            dwBlockSize;        // 逻辑卷的最小存储单元块大小
    NET_DVR_IPADDR    struWarrantIP;        // 授权的DVR网盘IP
    char            szArrayIDGroup[NAME_LEN];     //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;

typedef union tagNET_DVR_VD_UNION
{
    BYTE                        byUnionLen[256];      // 联合体大小
    NET_DVR_OPERATE_VD_PARAM    struHikVDParam;        // 虚拟磁盘
    NET_DVR_LUN_PARAM            struLunParam;            // 逻辑卷
    NET_DVR_DVR_PARAM            struDvrParam;            // DVR网盘
}NET_DVR_VD_UNION, *LPNET_DVR_VD_UNION;

typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE                byVDType;    //虚拟磁盘类型：0-私有虚拟磁盘 1-逻辑卷 2-DVR网盘
    BYTE                byRes1[3];
    NET_DVR_VD_UNION     uVDParam;
    BYTE                byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;

typedef struct tagNET_DVR_CVR_ALARM
{
    char            szFirstType[NAME_LEN];  //主类型，不能为空
    char            szFirstIndex[NAME_LEN];    //主类型编号
    char            szSecondType[NAME_LEN];    //次类型，可以为空
    NET_DVR_TIME    struTime;        //报警时间
    BYTE             byStatus;       //状态 0-正常 非0-不正常，不同类型值表示意义不同，见下表
    BYTE            byAlarmLevel;         //报警级别
    BYTE            byRes1[2];
    char               szSecondIndex[NAME_LEN];  //次类型编号，可以为空
    char            szThirdType[NAME_LEN];  //第三类型，可以为空
    char            szThirdIndex[NAME_LEN];    //第三类型编号
    char            szFourthType[NAME_LEN];  //第四类型，可以为空
    char            szFourthIndex[NAME_LEN];    //第四类型编号
    BYTE              byRes2[92];  //保留
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM; 

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //设备IP
    BYTE             byLinkStatus; //连接状态 0-连接失败1-连接成功
    BYTE             byWorkStatus; //工作状态 0-正常1-异常
    BYTE             byBacupStatus; //备份状态0-不在备份1-正在备份
    BYTE             bySyncProgress; //录像同步进度，0表示未开始，100表示同步完成
    NET_DVR_TIME_EX    struSyncBeginTime;    //同步开始时间
    NET_DVR_TIME_EX    struSyncEndTime;        //同步结束时
    char            szSerialNumber[SERIALNO_LEN] ; //设备序列号
    DWORD            dwSoftwareVersion ;        //设备软件版本
    BYTE              byWorkingDeviceGUID[GUID_LEN]; //工作机GUID，非字符串，用于备机上搜索工作机录像
    char            szDevTypeName[DEV_TYPE_NAME_LEN];        //设备类型名称
    WORD            wDevType;        //设备类型值
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //设备IP
    BYTE             byWorkStatus;     //工作状态 0-正常1-异常
    BYTE             byBackupStatus; //备份状态0-不在监控 1-正在监控2-正在备份中2-正在同步
    WORD            wBackupPort;    //备份端口
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef union tagNET_DVR_NPO_DEV_INFO_UNION
{
    BYTE                             byUnionLen[512];            //联合体长度
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;        //工作机信息
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;     //备机信息
}NET_DVR_NPO_DEV_INFO_UNION, *LPNET_DVR_NPO_DEV_INFO_UNION;


typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD                        dwSize;
    NET_DVR_NPO_DEV_INFO_UNION    unionDevInfo;
    BYTE                        byType;    /*类型 0-工作机，对应unionDevInfo中的struWorkingDeviceInfo     1-备机，对应unionDevInfo中的struRedundantDeviceInfo*/
    BYTE                           byRes[127];    
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;

//ipc升级参数
typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO    struStreamInfo[MAX_CHANNUM_V30];    // 64个监控点
    char                  szFileName[260];                    // 升级文件名
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;


typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO    struStreamInfo;     //监控点
    WORD                wErrCode;            //对应错误码
    BYTE                byRes[30];          //保留
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

//IPC配置文件导入
typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char          szFileName[260];                    // 配置文件名
    BYTE        byRes[32];                        
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD     wRow;       //出错的行，0表示没出错，1表示第1行出错，以此类推
    WORD    wErrCode;    //错误码
    BYTE    byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE     struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize; 
    DWORD dwChannel; //通道号
    DWORD dwPatternCmd; //云台轨迹操作命令码,详见下面定义
    DWORD dwPatternID; //云台轨迹ID（删除所有轨迹时无效）
    BYTE  byRes[64]; 
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byOneTouchSwitch;//一键开关, 0-不启用，1-启用 (和wActionType组合使用)
    BYTE  byRes1[2];
    DWORD dwParkTime; //守望等待时间，单位s 
    WORD  wActionType; //守望动作类型，0-自动扫描，1-帧扫描，2-随机扫描，3-巡航扫描，4-花样扫描，5-预置点，6-全景扫描，7-垂直扫描
    WORD  wID; //ID号（巡航扫描、预置点、花样扫描的ID）
    BYTE  byRes[128]; 
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD  dwSize; 
    DWORD  dwChannel; //通道号
    NET_VCA_POINT struPoint; //定位坐标
    BYTE byTrackType; //跟踪类型0、非自动取证(普通取证) 1、高速道路跟踪 2、城市道路跟踪（手动跟踪取证）3、静态取证
    BYTE byLinkageType;//联动动作: 0-手动跟踪 1-联动不跟踪
    BYTE byRes[2];
    NET_VCA_POINT struPointEnd;/*定位坐标终点*/
    NET_DVR_TIME_V30 struTime;//手动跟踪定位，当前时间。
    DWORD  dwSerialNo;//序号；
    BYTE   byRes1[36];  
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;

typedef enum tagVQD_TYPE
{
    VQD_BLUR_FLAG     = 0x00000001,    //图像模糊
        VQD_LUMA_FLAG     = 0x00000002,//亮度异常
        VQD_CHROMA_FLAG   = 0x00000004,//图像偏色
        VQD_SNOW_FLAG     = 0x00000008,//雪花干扰
        VQD_STREAK_FLAG   = 0x00000010,//条纹干扰
        VQD_FREEZE_FLAG   = 0x00000020,//画面冻结
        VQD_SIGLOSE_FLAG  = 0x00000040,//信号丢失
        VQD_PTZ_FLAG      = 0x00000080//云台失控
}VQD_TYPE;

typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD  dwSize ;        //结构体大小
    BYTE    byEnable;        // 诊断使能 0 :关闭，开启 1:开启
    BYTE     byRes1[3] ;     //保留
    BYTE    byVQDTypeEnable[32];     //VQD诊断模式，0 --不启用 1--启用  每种诊断类型对应有灵敏度，灵敏度的下标与诊断类型的下标一致
    /*数组0 图像模糊     数组1 亮度异常 数组2 图像偏色*/
    /*数组3 雪花干扰     数组4 条纹干扰 数组5 画面冻结*/
    /*数组6 信号丢失     数组7 云台失控*/    
    BYTE byThresholdValue[32] ;       //阈值0~100，不同诊断模式有各自对应的阈值
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //报警处理方式
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //假日布防时间段 
    BYTE    byRes[324];      //保留
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;


typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;   //通道号
    DWORD  dwVQDType;     // VQD诊断类型    
    NET_DVR_TIME struDiagnoseTime;    //诊断时间
    BYTE     byScoreValue;       //分数值 ，百分制
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO,*LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize ;        //结构体大小
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo ; //诊断异常信息结构体
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/]; 
    //解码资源状态列表，byDecStatus[i]表示槽位号i的子系统状态，0-无效，1-空闲，2-普通解码(包括普通解码上墙和大屏主从屏)，3-智能解码
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST,*LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource; /*申请的解码资源，以分辨率衡量，0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,
                         6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,
                         19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 
                         31-2448*2048,32-2448*1200,33-2448*800,34-XGA（1024*768），35-SXGA（1280*1024）,36-WD1(960*576/960*480),
    37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)*/
    DWORD  dwChannel; //智能通道号
    NET_DVR_IPADDR  struIP;   //申请者IP
    WORD  wPort;         //申请者端口号(智能分析仪通讯端口)
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO,*LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;  //槽位号，此参数做释放解码资源和登陆解码子系统校验用
    NET_DVR_IPADDR struIP; //解码子系统IP地址
    WORD  wPort;      //端口号
    BYTE  byRes1[2];
    DWORD dwDecChan;  //解码通道号
    BYTE  sUserName[NAME_LEN];    /* 解码子系统登陆帐号 */
    BYTE  sPassword[PASSWD_LEN];    /* 解码子系统登陆密码 */
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO,*LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum; //槽位号,填申请解码资源时返回的槽位号
    DWORD dwDecChan; //解码通道号
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND,*LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;     //关联使能，0-无关联，1-关联
    BYTE  byRes1[3];
    //byEnable = 1时以下参数有效
    DWORD dwYUVAddress[3]; //YUV输出地址
    WORD  wWidth;       //YUV输出宽
    WORD  wHeight;      //YUV输出高
    BYTE  byEnableAudio;  //使能音频，0-不启用，1-启用
    BYTE  byRes2[3];
    DWORD dwAudioAddr;  //音频输出地址
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG,*LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD        dwSize;
    BYTE        byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //通道号
    DWORD        dwSubChanNo;    //槽位号
    DWORD        dwVariableNo;    //变量编号
    BYTE        byRes2[60];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD        dwSize; 
    WORD        wVariableIndex;        //变量编号，只能获取
    WORD        wVariableType;        //变量类型 1-模拟量 2-开关量，只能获取
    BYTE        sDescribe[NAME_LEN];//变量描述
    BYTE        byLimitLineType;    //报警限值配置类型，0-不支持报警限值配置，1-两限值配置（即上限、下限），2-四限值配置
    BYTE        byRes[31];            //保留
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;


//模拟量点号相关参数
typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int           nMeasureHigh;            // 量程上限 外部值*1000传入 可以为负数
    int           nMeasureLow;            // 量程下限 外部值*1000传入
    BYTE        byAlarmMode;            // 报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL，
    // 即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    BYTE         byRes1[3];
    int            nAlarmValue[4];            // 报警限
    DWORD          dwOsdCfg;                // 模拟量字符叠加，按位表示0-15对应视频通道1-16
    DWORD        dwSensitive;            // 灵敏度范围10~1000。外部 float*1000。 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化，需要上传。如果为1，则表示变化超过1时上报。
    DWORD        dwIPChanOsd;            // 数字通道叠加模拟量字符，按位表示，0~31对应数字通道1-32
    BYTE        byRes[24];
}NET_DVR_ALARM_SENSOR_POINT_CFG,*LPNET_DVR_ALARM_SENSOR_POINT_CFG;

typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
    BYTE        byRes[64];
}NET_DVR_ALARM_SWITCH_POINT_CFG,*LPNET_DVR_ALARM_SWITCH_POINT_CFG;

typedef union tagNET_DVR_ALARM_POINT_PARAM_UNION
{
    BYTE    byLength[64]; //联合体长度为64
    NET_DVR_ALARM_SENSOR_POINT_CFG struSensor;    //模拟量相关参数
    NET_DVR_ALARM_SWITCH_POINT_CFG struSwitch;    //开关量相关参数
}NET_DVR_ALARM_POINT_PARAM_UNION,*LPNET_DVR_ALARM_POINT_PARAM_UNION;

//点号信息
typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD        dwSize;
    DWORD        dwPointNo;            //点号
    BYTE        sPointDescribe[NAME_LEN];        //点号描述
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam; //当变量类型为模拟量时，使用结构体struSensor，当变量类型为开关量时，使用结构体struSwitch
    BYTE        byPointType;        //点号类型，1-模拟量，2-开关量
    BYTE        byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE        byRes1[2];
    DWORD        dwChanNo;        //通道号
    DWORD        dwSubChanNo;    //槽位号
    DWORD        dwVariableNo;    //变量编号
    BYTE        byRes[16];            //保留
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

//历史数据查询
typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD        dwSize;
    BYTE        byMajorType;    //查询方式，1-全部，2-按时间， 3-按类型，4-时间+类型
    BYTE        byMinorType;    //1-点号，2-通道+槽位+变量号
    BYTE        byRes1[2];
    NET_DVR_TIME struStartTime;    //起始时间
    NET_DVR_TIME struStopTime;    //结束时间
    BYTE        byChanType;        //通道类型，1-模拟量，2-开关量，3-485通道，0xff表示无效
    BYTE        byRes2[3];
    DWORD        dwChanNo;        //通道号，从1开始，0xffffffff表示无效
    DWORD        dwSubChanNo;    //槽位号，从1开始，0xffffffff表示无效
    DWORD        dwVariableNo;    //变量号，从1开始，0xffffffff表示无效
    DWORD        dwPointNo;    //点号，0xffffffff表示无效
    BYTE          byRes3[32];        //保留
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD        dwSize;
    NET_DVR_TIME struTime;    //时间点
    BYTE        byChanType;        //通道类型，1-模拟量，2-开关量，3-485通道，0xff表示无效
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //通道号，从1开始，0xffffffff表示无效
    DWORD        dwSubChanNo;    //槽位号，从1开始，0xffffffff表示无效
    DWORD        dwVariableNo;    //变量号，从1开始，0xffffffff表示无效
    DWORD        dwPointNo;        //点号，0xffffffff表示无效
    int            iData;            //历史数据
    BYTE        byDataType;        //0-正常数据，1-越上限数据，2-越下限数据
    BYTE        byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD    dwSize;
    BYTE    byDataUploadMode;    //1-按通道上传，2-按监测点上传
    BYTE    byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG,*LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;


typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE    byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE    byPointType;    //点类型，1-遥测（模拟量），2-遥信（开关量）
    BYTE    byRes1[2];        //保留
    DWORD     dwChanNo;        //485通道号，0xffffffff表示无效，通道类型为1时：表示本地模拟量通道号，通道类型为2时表示本地开关量通道号，通道类型为3时表示485通道号。
    DWORD    dwSubChanNo;    //槽位号， 0xffffffff表示无效，通道类型为3时使用
    DWORD    dwVariableNo;    //变量编号，0xffffffff表示无效
    DWORD     dwPointNo;        //104点号，0xffffffff表示无效
    int        iValue;            //监测点的值
    BYTE    byRes[16];
}NET_DVR_ALARMHOST_POINT_VALUE,*LPNET_DVR_ALARMHOST_POINT_VALUE;

typedef union tagNET_DVR_ALARMHOST_DATA_UNION
{
    BYTE    byLength[40];
    NET_DVR_ALARMHOST_POINT_VALUE struPointValue;    //监测点实时数据
}NET_DVR_ALARMHOST_DATA_UNION,*LPNET_DVR_ALARMHOST_DATA_UNION;

typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD        dwSize;
    BYTE        byDataType;        //数据类型，1-监测点实时数据上传
    BYTE        byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE        byRes2[32];
}NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;     /*结构长度*/
    BYTE   byAudioInputChan;//音频输入通道号 
    BYTE   byRes[63];        // 保留字节
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE byAudioOutVolume;// 输出音量等级：归一化为0-100；
    BYTE byRes[63];
}NET_DVR_AUDIOOUT_VOLUME,*LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE,*LPNET_DVR_FUZZY_UPGRADE;

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //工作模式，0-控制台，1-私有透明通道，2-透明通道
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //使能透明通道，0-不使能，1-使能
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //远程设备IP地址
    WORD wPort; //远程设备端口
    BYTE byRes2[18];    
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //使能透明通道，0-不使能，1-使能
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //允许接入的远程设备IP    
    BYTE byRes2[16];    
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //本地监听的端口号，和RS485口一一对应
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];    
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;

typedef union tagNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION
{
    BYTE byRes[512];
    NET_DVR_TRANSPARENT_CLIENT_MODE struClientMode;  //客户端模式参数
    NET_DVR_TRANSPARENT_SERVER_MODE struServerMode; //服务器模式参数
}NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION, *LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;    
    BYTE  byWorkMode; //工作模式，1-客户端模式，2-服务器模式
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;

typedef enum tagNAKED_DATA_TYPE
{
    NAKED_DATA_TYPE_NOT_DEFINED = 0, //未定义
        NAKED_DATA_TYPE_POS_INFO    //接收的是Pos信息
}NAKED_DATA_TYPE;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP端口号，对于Pos信息接收，该值为0，则使用默认端口7050
    BYTE  byRes[130];      //保留字节
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

#define UPLOAD_POS_INFO     1001  //上传Pos信息

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD     struVerHead;  //版本头
    DWORD dwChannelNum;          //通道号
    BYTE  byRes[60]; 
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;


#define MAX_IGNORE_STRING_NUM        4
#define FILTERRULE_NUM              4
#define MAX_POS_FILTER_DATA_LEN     128

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //起点坐标
    NET_VCA_POINT   struEnd;    //终点坐标
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;


typedef struct 
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*交易开始标志，目前最大为32，只有anyCharacter为否时才生效*/
    BYTE byExclusive;    //是否包含标志本身 0-包含 1-不包含
    BYTE byFlagType;    //标志类型：0-字符串；1-十六进制
    BYTE byRes[2];        /*保留*/
}NET_DVR_GENERIC_START, *LPNET_DVR_GENERIC_START;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*交易结束标志，目前最大为32*/
    BYTE  byExclusive;    //是否包含标志本身 0-包含 1-不包含
    BYTE  byFlagType;    //标志类型：0-字符串；1-十六进制
    BYTE  byRes[6];
} NET_DVR_GENERIC_END, *LPNET_DVR_GENERIC_END;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*数据标志，目前最大为32*/
    BYTE  byFlagType;    //标志类型：0-字符串；1-十六进制
    BYTE  byRes[3];
}NET_DVR_GENERIC_DATA_CFG, *LPNET_DVR_GENERIC_DATA_CFG;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*忽略的字符，目前最大为32*/
}NET_DVR_IGNORE_STRING, *LPNET_DVR_IGNORE_STRING;

typedef struct
{
    BYTE  byCaseSensitive;/*是否区分大小写，0->不区分，1->区分*/
    BYTE  byRes1[7];   
    NET_DVR_GENERIC_START struTransactionStart;/*交易开始*/
    NET_DVR_GENERIC_END struTransactionEnd;/*交易结束*/
    NET_DVR_GENERIC_DATA_CFG struLineDeli;/*行间隔符*/
    NET_DVR_IGNORE_STRING struIgnoreString[MAX_IGNORE_STRING_NUM];/*忽略字符串，目前为4个*/
    BYTE byRes[40];    //保留
}NET_DVR_POS_GENERIC, *LPNET_DVR_GENERIC;

typedef struct
{
    DWORD    dwPosAddr;        //pos地址编号
    BYTE    byRes[948];
}NET_DVR_POS_AVE, *LPNET_DVR_AVE;

#define SERIAL_NUM_LEN 8
typedef struct tagNET_DVR_POS_NUCLEUS/*size 952byte*/
{
    char   szEmployeeNo[SERIAL_NUM_LEN];//员工编号，如1（备注：标题e<employee#>）
    char   szTerminalNo[SERIAL_NUM_LEN];// Pos机编号，如1（备注：标题t<terminal#>）
    char   szShiftNo[SERIAL_NUM_LEN]; //轮班（备注：标题s<shift#>）
    BYTE      byRes[928];
}NET_DVR_POS_NUCLEUS, *LPNET_DVR_POS_NUCLEUS;
typedef  union _NET_DVR_POS_PROTOCOL_UNION
{
    BYTE byLenth[952];   //用于表示联合体长度，无实际意义
    NET_DVR_POS_GENERIC struGeneric;
    NET_DVR_POS_AVE struAve;
    NET_DVR_POS_NUCLEUS struNUCLEUS;
}NET_DVR_POS_PROTOCOL_UNION,*LPNET_DVR_POS_PROTOCOL_UNION;

typedef enum tagNET_DVR_CHARSET_ENUM  //编码方式
{
    ENUM_UTF8 =0,
        ENUM_GB2312,
        ENUM_LATIN1,
        ENUM_LATIN2,
        ENUM_LATIN3,
        ENUM_LATIN4,
        ENUM_CYRILLIC,
        ENUM_ARABIC,
        ENUM_GREEK,
        ENUM_HEBREW,
        ENUM_TURKISH,
        ENUM_NORDIC,
        ENUM_THAI,
        ENUM_LATIN7,
        ENUM_LATIN8,
        ENUM_LATIN9,
        ENUM_LATIN10,
        ENUM_CENTRAL_EUROPEAN,
        ENUM_CYRILLIC_SCRIPT,
        ENUM_HEBREW_DOS862
}NET_DVR_CHARSET_ENUM, *LPNET_DVR_CHARSET_ENUM;


typedef struct
{
    DWORD   dwSize;
    BYTE     byEnable;            //规则使能
    BYTE     byCharSetType;      //编码方式0-UTF-8,1-GB2312
    BYTE    byRes1;   //保留
    BYTE    byProtocolType;//协议类型，1->generic text协议(universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON(该类型无需处理pos协议参数), 5-NUCLEUS
    NET_DVR_POS_PROTOCOL_UNION uPosProtocol;   //POS协议 
    BYTE    byRes[32];    //保留
}NET_DVR_POS_FILTER_CFG, *LPNET_DVR_POS_FILTER_CFG;

typedef struct  tagNET_DVR_NET_SNIFF /*网络侦听结构体 312byte*/
{
    BYTE       byEnableSourcePort;       //是否启用对数据源端口过滤  0-不启用，1-启用
    BYTE       byEnableDestAddr;        //是否启用对目标IP地址进行过滤 0-不启用，1-启用
    BYTE       byEnableDestPort;         //是否启用对目标地址的端口号进行过滤
    BYTE       byRes1;                 //保留
    BYTE       bySourceIpAddr[MAX_DOMAIN_NAME];                //数据源地址 
    BYTE       byDestinationIpAddr[MAX_DOMAIN_NAME];        //数据发送目标地址 
    WORD          wSourcePort;               //数据源端口号
    WORD          wDestinationPort;           //数据发送目标端口号
    BYTE       byRes[16];                 //保留
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;

typedef struct
{
    WORD  wNetPort;  /*device net port*/
    BYTE  byRes[2];
}NET_DVR_NET_RECEIVE, *LPNET_DVR_NET_RECEIVE;

typedef struct tagNET_DVR_MONITOR_INFO  /*监听*/
{
    WORD  wPort;       //监听端口号
    BYTE   byRes1[2];
    NET_DVR_IPADDR  struRestrictRemoteIP;//保留限制远程访问IP
    BYTE   byRes[164];     
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;

typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP; //IP地址
    WORD wPort;    //端口号
    BYTE byRes[2];
}NET_DVR_ADDRESS,*LPNET_DVR_ADDRESS;

typedef union tagNET_DVR_POS_CONNECTMODE_UNION
{
    BYTE                       byLen[312];      //联合体长度，无实际意义
    NET_DVR_NET_RECEIVE     struNetRecv;     //网络接受模式
    NET_DVR_MONITOR_INFO     struTcpMonitor;    //网络监听模式
    NET_DVR_SINGLE_RS232     struRS232;        //串口方式
    NET_DVR_MONITOR_INFO     struUdpMonitor;     //网络监听-UDP模式
    NET_DVR_NET_SNIFF          struSniff;          //网络侦听模式
    NET_DVR_ADDRESS            struMcast;          //多播模式
    NET_DVR_USB_RS232         struUSBRS232;    //USB转串口方式
}NET_DVR_POS_CONNECTMODE_UNION, *LPNET_DVR_POS_CONNECTMODE_UNION;


//DVR与POS连接方式配置结构体
typedef struct tagNET_DVR_CONNECT_POS_CFG
{
    DWORD   dwSize;               //结构体大小
    BYTE     byConnectMode;    //连接模式:0->网络监听(TCP),1->网络接受,2->串口接收3-网络监听（UDP）,4-网络侦听,5-多播
    BYTE     byRes1[3];         //保留
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;    //连接模式配置
    BYTE  byRes[64];
}NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD                  dwSize;              //结构体大小
    BYTE                  byFilterID;           //POS过滤规则ID
    BYTE                 byFontSize;         //字号大小，0-- 8*16  1--16*32  2--32*64 
    BYTE                  byShowPosInfo;        //码流中是否叠加pos信息
    BYTE                byOverlayMode;      //叠加方式，0-滚屏，1-翻页
    DWORD                 dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR        struOsdColor;           //OSD颜色
    NET_DVR_SCHEDTIME        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    DWORD                  dwMaxRelRecordChanNum ;  //报警触发的录象通道数（只读）最大支持数量
    DWORD                  dwRelRecordChanNum ;     //本组内关联的录象通道数 
    DWORD                  dwRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组内后续的关联通道号无效
    DWORD                 dwTimeOut;        /*time Out(5-3600s)*/ //数据超时指在多长时间接收不到POS数据即判定一次数据包的结束。
    BYTE              byRes[60];    //保留
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG; 

#define        MAX_LAN_ENCODE_LEN        32    //语言编码格式最大长度
typedef struct    tagNET_DVR_DEVICE_LAN_ENCODE
{    
    DWORD        dwSize;        
    BYTE        byLanEncode[MAX_LAN_ENCODE_LEN];    //设备语言编码格式
    BYTE        byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byEnable; //使能，是否开启 0~不开启,1~开启
    BYTE    bySensitiveLevel;// 1-100，默认50，灵敏度越高，越容易报警
    BYTE    byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD    dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    //报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION,*LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD            dwSize;          // 结构大小
    NET_VCA_DEV_INFO struDevInfo;    //前端设备信息
    BYTE             byRes[128];      // 保留字节
}NET_DVR_SCENECHANGE_DETECTION_RESULT,*LPNET_DVR_SCENECHANGE_DETECTION_RESULT;
typedef enum
{
    PREVIEW_MOD = 0,
        ALARM_MOD,
        PLAYBACK_MOD,
        MAX_TYPE
}MODULE_TYPE;

//车位信息
typedef struct tagNET_DVR_PARK_INFO
{ 
    char          sPlateNo[MAX_PlATE_NO_LEN];             //车牌号码 
    char          sParkIndex[MAX_PlATE_NO_LEN];        //车位编号
    BYTE          byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;


typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD                 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*触发时间*/
    NET_DVR_PARK_INFO    struParkInfo; //车位信息
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //流信息
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //流源信息
}NET_DVR_STREAM_SRC_CFG,*LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP, 9-RTP+PS（国标：GB28181），0xff-无效
    BYTE  byVideoEncType;//视频编码类型，0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，0xff-无效
    WORD  wWidth; //图像宽度
    WORD  wHeight; //图像高度
    BYTE  byRes1[2];
    DWORD dwVideoBitrate;     //视频码率,单位Kbps
    DWORD dwVideoFrameRate;    //帧率，200起表示小于1帧/秒的状态，其余值表示实际帧率值,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//音频编码类型，0-G722，1-G711_U，2-G711_A，5-MPEG2,6-G726，7-AAC,0xff-无效    
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;


typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//流ID、转码通道信息    
    BYTE  byMode;//转码模式，1-主动转码，2-被动转码
    BYTE  byLinkNums;//连接数
    BYTE  byPassiveTransMode; //被动转码模式，0-无效，1-实时流，2-文件流
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//目标转码ip地址
    BYTE  byTransResource;//所使用的转码资源数，按D1计算
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//源编码信息
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//目标编码信息
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//全部转码资源，以D1为单位计算
    DWORD dwIdleResource;//剩余转码资源，以D1为单位计算
    BYTE  byCpuLoad;//CPU利用率
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-通道模式，2-流ID模式
    BYTE  byDisplayMode; //0-普通，1-畅显
    BYTE  byEnableVcaDec; //是否启用智能解码，0-不启用，非0-启用
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE,*LPNET_DVR_DEV_WORK_MODE;


typedef struct tagNET_DVR_PASSIVETRANSINFO 
{
    DWORD dwSize;
    BYTE byStreamType;// 码流类型，0-主码流，1-子码流
    BYTE byLinkMode;// 0：TCP方式,1：UDP方式（保留）
    BYTE byPassiveTransMode; //被动转码模式，1-实时流，2-文件流
    BYTE byRes1[5];    
    BYTE byDataType;//缓冲区类型，1-SDP，2-码流头
    BYTE byRes2;
    WORD wDataLength;//数据长度
    char *pBuffer;//缓冲区
    BYTE byRes3[32]; // 保留
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;        //是否显示，1-显示，0-隐藏    
    BYTE  byBaseMapType;    //底图类型，1-图片底图，2-超高清输入底图
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG,*LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //分辨率，MAKE_RESOLUTION宏定义的值，从电视墙能力获取支持的分辨率值
    BYTE  byRes2[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    NET_DVR_RECTCFG_EX struWinPosition;//目的窗口(相对显示墙),底图窗口的起始坐标和大小必须是基准坐标的整数倍
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//图片名称
    BYTE   byUsed; //是否已存在，0-不存在，1-存在
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO,*LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO大小，包括BMP的文件头，图片大小超限，限100K，高和宽须是32的倍数
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO,*LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo是否存在，0-不存在，1-存在（此参数只能获取）
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO大小，包括BMP的文件头(此参数只能获取)
    BYTE   byLogoName[NAME_LEN];  //logo名称
    DWORD  dwLogoNo;    //logo编号（获取所有logo信息时有效）
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG,*LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo号
    BYTE   byEnable; //logo是否显示，1-显示，0-隐藏
    BYTE   byRes1[3];    
    DWORD  dwCoordinateX;    //图片显示区域X坐标
    DWORD  dwCoordinateY;    //图片显示区域Y坐标    
    BYTE   byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE   byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE   byRes2[34];                //保留    
}NET_DVR_WIN_LOGO_CFG,*LPNET_DVR_WIN_LOGO_CFG;    


typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //窗口号，从1开始，0表示底图
    BYTE  byEnable; //是否打开音频，1-打开音频，0-关闭音频
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //0-正常状态，1-放大状态
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //放大区域，当byZoomStatus为1时有效
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS,NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;          // 结构大小
    DWORD           dwChannel;;     // 通道号
    BYTE            byRes[16];      // 保留字节
}NET_DVR_RESUME_INITRACKPOS_CFG,*LPNET_DVR_RESUME_INITRACKPOS_CFG;

typedef  struct tagNet_DVR_TEST_SELFCHECK_RESULT   
{
    DWORD   dwSize;     
    DWORD   dwChannel;      //通道号            
    BYTE    bySelfCheckStatus;   //自检状态值 0-未开始，1-成功，2-失败，3-自检中
    BYTE    byRes[23];   //保留字节
}NET_DVR_TEST_SELFCHECK_RESULT, *LPNET_DVR_TEST_SELECHECK_RESULT;


typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;     
    DWORD   dwChannel;       //通道号
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM]; 
    //0-表示不开启测试， 1-表示开启测试
    //数组下标0 开启老化测试程序                               
    //数组下标1 红外灯进入测试模式
    //数组下标2 ICR老化测试，0表示关闭，1表示开启，可以与bit0 组合，如0000_0001(只开启巡航老化)、0000_0101（同时开启巡航和ICR老化）、0000_0100（只开启ICR老化） 
    //数组下标3 -球机pt自矫正功能状态，0表示球机自矫正功能未清除，1表示球机自矫正功能已清除
    //数组下标4 花样扫描测试程序，0表示关闭，1表示开启
    //数组下标5 电子罗盘校正程序，0表示关闭，1表示开启
    WORD    wICRIntervalTime;//icr间隔时间（byTestCommand 数组下表2内的值为1时，ICR开关间隔时间，单位秒）
    BYTE      byElectronicCompassState;//罗盘状态返回， 0-正常， 1-不正常
    BYTE    byRes[17];      //保留字节
}NET_DVR_TEST_COMMAND, *LPNET_DVR_TEST_COMMAND;

typedef struct  tagNET_DVR_AGING_TRICK_SCAN
{
    DWORD   dwSize;
    DWORD   dwChannel;       //通道号
    BYTE     byAging; // 表示设置的参数 为老化前工具还是老化后工具， 0-老化前、1-老化后 
    BYTE     byWriteReadEnalbe; //读写指令使能，0-设置读指令， 1-设置写指令
    BYTE     byRes[126];      //保留字节
}NET_DVR_AGING_TRICK_SCAN, *LPNET_DVR_AGING_TRICK_SCAN;

#define IPC_PARAM_AGING_TRICK_SCAN        0x00000001 //清除花样扫描参数设置
typedef struct tagNET_DVR_IPC_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //参数类型，按位表示    
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //清除花样扫描参数设置
    BYTE byRes[32];
}NET_DVR_IPC_PARAM_TYPE, *LPNET_DVR_IPC_PARAM_TYPE;

typedef struct  tagNET_DVR_ECCENTRIC_CORRECT_STATE
{
    DWORD   dwSize;
    DWORD   dwChannel;       //通道号
    BYTE     byEccentricCorrectState; // 偏心矫正状态，0-校正失败、1-校正成功、2-校正中
    BYTE     byRes[127];      //保留字节
}NET_DVR_ECCENTRIC_CORRECT_STATE, *LPNET_DVR_ECCENTRIC_CORRECT_STATE;



#define MAX_DEVMODULE_NUM 8
typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //通道号
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试风扇1
    // bit1-测试风扇2
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试加热器1
    // bit1-测试加热器2
    BYTE    byRes[22];      //保留字节
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;

//出入口条件
typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE  byLaneNo;//车道号（0-表示无效值(设备需要做有效值判断),1-车道1）
    BYTE  byRes[3];
}NET_DVR_BARRIERGATE_COND,*LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-无操作,1-开道闸
    BYTE   byRes1 ;
    WORD   wAlarmOperateType;//0-无操作,bit0-继电器输出报警 bit1-布防上传报警 bit3-告警主机上传（可复选）(0-表示关，1-表示开)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL,*LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-不接入设备，1-开道闸、2-关道闸、3-停道闸、4-报警信号、5-常亮灯
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM,*LPNET_DVR_RELAY_PARAM;

//出入口配置
typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable ;// 使能0-表示关闭，1-表示打开
    BYTE    byBarrierGateCtrlMode;//0-相机自动控制，1-平台外部控制
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//关联触发模式 参考ITC_TRIGGERMODE_TYPE
    /*0x00: 不做匹配*/
    /*0x01: 车牌匹配（带车牌颜色）*/
    /*0x02: 车牌匹配（不带车牌颜色）*/
    /*0x04: 卡号匹配*/
    DWORD  dwMatchContent;  //异常处理,异常处理方式的"或"结果
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//继电器关联配置信息(一个继电器只能控制一个接入设备) 数组0表示继电器1 数组1表示继电器2 依次类推 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //单个IO触发参数，单个IO触发参数，数组0表示IO1，数组1表示IO2，依次类推 ; 具体数组值的含义（0-无，1-道闸开到位，2-道闸关到位，3-消防报警）
    //车辆信息管控  
    //数组0表示临时车辆配置的模式
    //数组1-黑名单车辆的模式, 
    //数组2-白名单车辆的模式
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//车辆信息管控  
    BYTE    byRes2[64];
}NET_DVR_ENTRANCE_CFG,*LPNET_DVR_ENTRANCE_CFG;
////////////////////////////出入口参数配置 end///////////////////////////////

// 道闸控制
typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byLaneNo;  //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    BYTE  byBarrierGateCtrl;//0-关闭道闸,1-开启道闸,2-停止道闸 3-锁定道闸
    BYTE  byEntranceNo;//出入口编号 [1,8]
    BYTE  byRes[13];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;

//出入口黑白名单的数据同步
typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//通道号0xff - 全部通道（ITC 默认是1）
    DWORD  dwDataIndex;//数据流水号（平台维护的数据唯一值，客户端操作的时候，该值不会起效。该值主要用于数据增量同步）
    char   sLicense[MAX_LICENSE_LEN]; //车牌号码
    BYTE   byListType;//名单属性（黑白名单）0-白名单，1-黑名单
    BYTE   byPlateType;    //车牌类型
    BYTE   byPlateColor;    //车牌颜色
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // 卡号
    NET_DVR_TIME_V30  struStartTime;//有效开始时间
    NET_DVR_TIME_V30  struStopTime;//有效结束时间
    //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
    char        sOperateIndex[MAX_OPERATE_INDEX_LEN]; 
    BYTE  byRes1[224]; // 保留字节
} NET_DVR_VEHICLE_CONTROL_LIST_INFO,*LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;

//数据全部获取接口 （长连接获取）
typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//通道号0xffffffff - 全部通道（ITC 默认是1）
    DWORD  dwOperateType;//操作类型，参照VCA_OPERATE _TYPE。（可复选）
    char   sLicense[MAX_LICENSE_LEN];//车牌号码
    char   sCardNo[MAX_CARDNO_LEN]; // 卡号
    BYTE   byListType;//名单属性（黑白名单）0-白名单，1-黑名单，0xff-全部
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//数据流水号     
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND,*LPNET_DVR_VEHICLE_CONTROL_COND;

//黑白名单数据需要同步报警
typedef struct
{
    DWORD    dwSize; 
    DWORD    dwDataIndex;//数据流水号（这个值返回设备当前接收到的数据的最后一个数据流水号,平台同步的时候从下一个流水号开始同步）
    char     sOperateIndex[MAX_OPERATE_INDEX_LEN];  //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0） 2014-03-03
    BYTE     byRes[32];
}NET_DVR_VEHICLE_CONTROL_LIST_DSALARM, *LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM;

//车辆报警（黑白名单）
typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //名单属性（黑白名单）0-白名单，1-黑名单，2-临时名单
    BYTE  byPlateType;  //车牌类型
    BYTE  byPlateColor;    //车牌颜色
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//车牌号码
    char  sCardNo[MAX_CARDNO_LEN];  // 卡号
    NET_DVR_TIME_V30 struAlarmTime; //报警时间
    DWORD dwChannel;          //设备通道号，如果直连的是IPC，则为ipc通道号；如果连的DVR\nvr,则为DVR\NVR的通道号
    DWORD dwPicDataLen;   //图片数据大小，0表示无图片，不为0是表示后面带图片数据
    BYTE  byPicType;    //图片类型，0-JPEG
    BYTE  byRes3[3];
    char    *pPicData;
    BYTE  byRes2[48];
}NET_DVR_VEHICLE_CONTROL_ALARM,*LPNET_DVR_VEHICLE_CONTROL_ALARM;

//消防报警
typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//报警时间
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM,*LPNET_DVR_FIRE_ALARM;

//清除设备车牌黑名单数据库信息
typedef struct
{
    DWORD dwSize;
    DWORD dwDelType;//删除条件类型，删除条件类型，参照VCA_OPERATE _TYPE。（可复选）
    char  sLicense[16]; //车牌号码
    char  sCardNo[48]; // 卡号 
    BYTE  byPlateType;    //车牌类型
    BYTE  byPlateColor;    //车牌颜色
    BYTE  byOperateType;    //删除操作类型(0-条件删除,0xff-删除全部)
    //2014-02-25
    BYTE  byListType;//名单属性（黑白名单）0-白名单，1-黑名单 2014-03-03
    DWORD dwDataIndex;//数据流水号     
    //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
    char  sOperateIndex[MAX_OPERATE_INDEX_LEN]; 
    BYTE  byRes[24];        
} NET_DVR_VEHICLE_CONTROL_DELINFO, *LPNET_DVR_VEHICLE_CONTROL_DELINFO;

//常亮灯功能
typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byLaneNo; //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    BYTE  byBrightlampCtrl;//0-关闭常亮灯，1-开启常亮灯
    BYTE  byRes[14]; 
}NET_DVR_GATELAMP_INFO,*LPNET_DVR_GATELAMP_INFO;


//SDI矩阵1.0
#define  MATRIX_MAX_OUTPUT_NUM      256              //矩阵最大输出通道个数
typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize; 
    DWORD dwValidInputNum;     //有效的输入通道数
    DWORD dwValidOutputNum;    //有效的输出通道数
    BYTE  byRes[64]; 
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize; 
    DWORD   dwInputChan;        //输入通道号，为0表示取消和指定输出的关联关系
    DWORD   dwOutputChan;       //要切换到的输出通道号, (屏幕服务器为屏幕索引号(1字节设备号+1字节保留+2字节屏幕索引号)), 0xffffffff表示切换到所有输出
    DWORD   dwMatrixID; //矩阵ID号
    BYTE    byRes[28]; 
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize; 
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //输出通道关联的输入通道, dwIORelation[i] = j表示输出通道(i + 1)和输入通道j关联,
    //dwIORelation[i] = 0表示输出通道i + 1未关联输入通道                                                                
    BYTE    byRes[256]; 
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;


//批量接口配置
typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    BYTE   byRelativeIndex;//0-其他(保留)，索引(相对于接入类型) 范围 1~8 Led的相对索引范围是（1～255）   0xff-全部信息（长连接获取时使用）
    //    BYTE   byLaneID;// 逻辑车道号    
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND,*LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//0-其他，1-远距离读头设备，2-出入口控制机，3-led屏 
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE    byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//DEV IP地址 144
            WORD     wDevPort;//设备端口
            BYTE     byRes[510];
        }struRrReader;//远距离读头设备
        struct
        {
            BYTE byRs485No; //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
            BYTE byDevCtrlCode;//拨码地址，用于区分设备(1-255)
            BYTE byAutoIssuedData;//是否自动下发卡片数据 0-不自动下发，1-自动下发
            BYTE byOfflineDetEnable;//离线检测 0-关闭，1-开启
            BYTE byDetCycle;//检测周期（0～60 单位 s）
            BYTE byRes[651];
        }struGateway;//出入口控制机
        struct
        {
            BYTE byExternalMode;//0-RS485,1-网络
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP地址 144 (在byExternalMode == 1 时生效)
            WORD wDevPort;//设备端口(在byExternalMode == 1 时生效)
            BYTE byRs485No; //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
            BYTE byDevCtrlCode;//拨码地址，用于区分设备(1-255)
            //led屏通过控制卡控制显示的，不同的控制卡类型支持的显示方式不同
            BYTE byCtrlCardType;//控制卡类型 0-保留(无效值) 1- EQ2013
            BYTE byLedScreenType;//屏类型 0-单色屏 1-双色屏
            BYTE byLedScreenUse;//屏用途0-其它 1-区位屏 2-提示屏 3-收费屏
            BYTE byLedDisplayMode;//屏幕字体显示方式: 1 "立即显示",    2 "左移" ,3 "右移" ,4 "上移",     5 "下移"
            char sLedCustomInfo[MAX_LED_INFO];//屏幕字体显示信息
            //led屏是由控制卡控制的，led屏可以根据项目实际使用更换大小，此时需要终端通知控制卡目前使用的屏宽和屏高
            DWORD dwLedScreenH;//显示屏组成高度上需要的LED点数
            DWORD dwLedScreenW;//显示屏组成宽度上需要的LED点数
            BYTE byRes1[236];
        }struLed;//led屏
    }uExternalDevInfo; //由byExternalMode 值来决定哪个有效
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;

//长连接获取配置
typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS//远距离读头设备
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//设备名称
    BYTE   byExternalDevTpye;//0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    BYTE   byRelativeIndex;//0-其他(保留)，相对索引(相对于接入类型能) 范围 1~8  0xff-全部信息（长连接获取时使用）
    BYTE   byOnline;//0-不在线，1-在线
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS,*LPNET_DVR_EXTERNAL_DEVSTATUS;

//终端出入口检测配置
typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;        //结构长度
    //离线检测开启时，如果检测到设备在线，则由终端匹配卡片信息，并发送道闸控制指令给出入口控制机；否则由出入口控制机自身匹配控制道闸
    BYTE   byOfflineDetEnable;//离线检测 0-关闭，1-开启
    BYTE   byDetCycle;//检测周期（0～60 单位 s）
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG,*LPNET_DVR_ENTRANCEDET_CFG;

//终端出入口控制(控制接口 下发卡片信息)
typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD  dwSize; //结构长度
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byManualIssuedData;//手动数据下发 0-关闭，1-开启 
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND,*LPNET_DVR_ENTRANCEDEV_COMMAND;

//终端出入口控制(控制接口 清空下发卡片信息)
typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize; //结构长度
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL,*LPNET_DVR_ENISSUED_DATADEL;

//出入口过车收费明细（监听方式）
typedef  struct  _tagNET_ITS_PASSVEHICLE_COST_ITEM
{
    DWORD   dwSize;        //结构长度
    DWORD   dwPassVehicleID; //过车序号与出入口数据的过车序号相关联
    BYTE    byIntime[MAX_TIME_LEN]; //入场时间格式为yyyymmddhh24missfff
    BYTE    byOuttime[MAX_TIME_LEN]; //出场时间格式为yyyymmddhh24missfff
    BYTE    byCardNo[MAX_CARD_LEN];   //卡号
    BYTE    byPlateInfo[MAX_LICENSE_LEN]; //车牌号码
    float   fPayCost;       //收费金额(单位元)
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //操作人员名称
    BYTE    byVehicleType; //车辆类型  0-小型车 2 大型车
    BYTE    byRes1[3]; //预留字段1
    DWORD   dwPayRuleID; // 收费规则流水号
    DWORD   dwFreeRuleID; // 减免规则流水号
    BYTE    byRes2[256]; // 预留字段2
}NET_ITS_PASSVEHICLE_COST_ITEM, *LPNET_ITS_PASSVEHICLE_COST_ITEM;

//出入口交接班数据（监听方式）
typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;        //结构长度
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //操作人员名称
    BYTE    byOperatorCard[MAX_CARD_LEN]; //操作人员卡号
    BYTE    byStartTime[MAX_TIME_LEN];//上班时间格式形如yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //下班时间格式形如yyyymmddhh24miss
    float   fTotal_Pay;    //本次上班期间总的收费金额(单位元)
    DWORD   dwTotal_Records;   //本次上班期间总的过车收费的记录条数
    BYTE    byRes[64]; //预留
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;


typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //触发类型，详见ITC_TRIGGERMODE_TYPE 
    BYTE   byRes[24]; 
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;



typedef struct tagNET_DVR_TEMP_HUMI
{ 
    DWORD    dwSize;            // 内容长度 && 版本（用于后期扩展）
    DWORD       dwChannel;         // 通道号，默认1
    int      iHumidity;         // 湿度，整数部分：val/1000，小数部分：val%1000
    int      iTemp;             // 温度，整数部分：val/1000，小数部分：val%100
    BYTE     byRes[8];          // 保留字节    
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;


typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;      // 内容长度 && 版本（用于后期扩展）
    DWORD    dwChannel;     // 通道号，默认1
    DWORD    dwSoundMode;   // 报警模式: 0提醒模式；1警报模式；2静音模式
    BYTE     byRes[12];     // 保留字节
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{ 
       DWORD    dwSize;// 内容长度 && 版本（用于后期扩展）
    DWORD    dwChannel;         // 通道号，默认1
    DWORD    dwMode;        // 安全模式: 1启用，码流加密；2不启用，码流不加密
    char     szRandCode[6];   //设备出厂的"随机验证码"
    BYTE     byRes[6];         // 保留字节
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD dwSize;
    BYTE  byPreviewFpsAdjMode;   /* 预览帧率调节模式:0-不调节，标准帧率预览,1-标准低帧率预览,2-根据GPS速度进行帧率调节 */
    BYTE  bySelPeccType;           /* 是否选择违章类型 */    
    BYTE  byOptHabit;             /* 取证操作习惯, 0:长按取证;1:短按两次取证 */    
    BYTE  byEnablePeccRec;      /* 1: 使能违章录像抓取, 0: 禁止违章录像抓取 */
    BYTE  byPicSize;                /*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA，7-XVGA，8-HD900p，9-HD1080，10-2560*1920，11-1600*304，12-2048*1536，13-2448*2048,14-2448*1200，15-2448*800，16-XGA(1024*768)，17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;            /* 图片质量系数 0-最好 1-较好 2-一般 */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG,*LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD         dwSize;
    NET_DVR_IPADDR    struAddr;                    // 平台服务器IP
    WORD            wServerPort;                   // 平台服务器侦听端口，
    BYTE         bySeverProtocolType;            //平台协议类型 1-私有，2-Ehome
    BYTE            byStatus;                         //设备注册到该平台的状态，1-未注册，2-已注册
    BYTE         sDeviceId[NAME_LEN/*32*/];     //设备ID
    char         sPassWord[PASSWD_LEN];
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    BYTE         sPlatformEhomeVersion[NAME_LEN];//平台EHOME协议版本
    /********* IPC5.1.7 新增参数 end 2014-03-21***********/
    BYTE         byNetWork;                //0- 无意义，1-自动，2-有线网络优先，3-有线网络，4-3G网络
    BYTE         byAddressType;            //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE            byRes1[2];
    BYTE         sDomainName[MAX_DOMAIN_NAME/*64*/]; //域名
    BYTE            byRes[140];          // 保留字节
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;

//条件结构
typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    BYTE    byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE    byRes[63]; 
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//目标跟踪：0-关闭，1-开启，默认0-关闭
    BYTE bySensitivity;  //灵敏度参数，范围1-100，默认50
    BYTE byBackgroundUpdateRate;//背景更新速度：范围1-100，默认50
    BYTE bySceneChangeLevel;//场景变化等级：范围1-100，默认50
    BYTE byMinTargetSize;//最小目标尺寸：范围1-100，默认50
    BYTE byRes[15];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

#define MAX_HEATMAPREGION_NUM 8

//热度图检测配置结构
typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //使能，是否开启
    BYTE  byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//区域范围
    NET_DVR_HEATMAP_PARAM  struHeatMap ; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    //布防时间
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

//热度图报警上传
typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*设备信息*/
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    DWORD  dwMaxHeatMapValue;//最大热度值
    DWORD  dwMinHeatMapValue;//最小热度值
    DWORD  dwTimeHeatMapValue;// (时间热度值)平均热度值
    WORD   wArrayLine;//图片像素点行值 
    WORD   wArrayColumn;//图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
    BYTE*  pBuffer;  //热度图片像素点数据信息
    BYTE   byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE   byRes[127];
}NET_DVR_HEATMAP_RESULT,*LPNET_DVR_HEATMAP_RESULT;

//热度图报警查找 条件结构体
typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//通道号
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    BYTE    byReportType;//0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    BYTE    byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE    byRes[126];
}NET_DVR_HEATMAP_QUERY_COND,*LPNET_DVR_HEATMAP_QUERY_COND;

//热度图报警查找 
typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*间隔开始时间*/
    NET_DVR_TIME_EX   struEndTime;  /*间隔结束时间*/
    DWORD  dwHeatMapPicLen;         /*空间热度图片长度(当含有图片的时候，该字段为非0，没有图片的时候，该字段为0)*/
    BYTE*  pBuffer;                 //热度图片数据信息
    DWORD  dwTimeHeatMapValue ;     //时间热度值(含有空热度图的时候,该字段不需要传值)
    DWORD  dwHeatMapMaxValue;//检测区域最高热度点人员活动时间(s)(空间热度图时有效)
    DWORD  dwHeatMapMinValue;//检测区域最低热度点人员活动时间(s) (空间热度图时有效)
    BYTE    byRes[116];
}NET_DVR_HEATMAP_INFO,*LPNET_DVR_HEATMAP_INFO;

typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    NET_DVR_TIME_EX   struStartTime; //开始时间
    NET_DVR_TIME_EX   struEndTime; //结束时间
    BYTE    byReportType; //0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    BYTE    byEnableProgramStatistics; //是否按节目统计，0-否，1-是
    BYTE    byRes1[2];
    DWORD   dwPlayScheduleNo; //按节目统计时关联的日程号
    BYTE    byRes[120];
}NET_DVR_PDC_QUERY_COND,*LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PROGRAM_INFO
{
    DWORD   dwProgramNo; //节目编号
    BYTE    sProgramName[NAME_LEN]; //节目名称
    BYTE    byRes[16];
}NET_DVR_PROGRAM_INFO, *LPNET_DVR_PROGRAM_INFO;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    DWORD   dwEnterNum;   //进入人数
    DWORD   dwLeaveNum;  //离开人数
    NET_DVR_PROGRAM_INFO struProgramInfo;        //节目信息
    BYTE    byRes[204];    //保留字节
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;


typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写  3 */ 
    BYTE  byTimeOsd;// 时间信息叠加 0 - 不叠加， 1- 叠加
    BYTE  byRecogResultOsd;//识别结果叠加  0 - 不叠加， 1- 叠加
    BYTE  byRecogHint;//识别成功提示 0 - 不提示， 1- 提示
    BYTE  byRecogDir;//识别方向 0: 正向, 1: 背向
    BYTE  byRecogEnv;//识别环境 0: 白天, 1: 晚上
    BYTE  byRecogPlateType;//0-小车牌识别，1-大车牌识别
    BYTE  byUploadPlate;//是否上传车牌 0 -不上传， 1-上传
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG,*LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{    
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:不开启雷达  1:开启雷达 */    
    BYTE   byEnableAlarm;   /* 0:不开启报警  1:开启报警 */    
    WORD   wOverSpeed;    /* 范围为20~250 */    
    BYTE   bySpeedUnits;  /* 0:公里/小时   1:英里/小时 */    
    BYTE   bydirection;     /* 0:反向（雷达与车相向） 1:正向（雷达与车反向） */    
    BYTE   byMeasureMode;   /* 0:静态 (雷达状态)       1:动态 (雷达状态)*/    
    BYTE   byTargetType;    /* 0:最快(雷达测速车辆最快)  1:最近(雷达测速车辆最近)*/    
    BYTE   bySensitivity;  /* 灵敏度[0,100] */                          
    BYTE   byCaptureNum;   /* 抓拍张数[0,255] */                                
    BYTE   byUploadPlate;  /*是否上传超速抓拍图片 0-不上传，1-上传*/    
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG,*LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* 稽查任务是否进行黑名单稽查 0-稽查，1-不稽查*/    
    BYTE  byCheckAlarm;/* 稽查成功报警 0-不报警，1-报警*/    
    BYTE  byCheckHint; /* 稽查成功提示 (软件提示) 0-不提示，1-提示*/    
    BYTE  byUploadBlackCar; /*是否上传黑车信息 0-不上传，1-上传*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG,*LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//通道号0xff - 全部通道（默认是1,代表一个通道）
    NET_DVR_PLATE_INFO  struPlateInfo; //车牌信息
    WORD  wIllegalType; //违章类型采用国标定义 （参考附件）
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// 违规类型信息（128）
    NET_DVR_TIME_V30  struIllegalTime;//违规时间
    BYTE  byIllegalVehicleNum;//车辆违法次数
    BYTE  byRes1[3];
    char sCustomInfo[64];//自定义信息
    BYTE  byRes2[128]; // 保留字节
}NET_DVR_VEHICLE_CHECK,*LPNET_DVR_VEHICLE_CHECK;

typedef enum _LONG_CFG_SEND_DATA_TYPE_ENUM_
{
    ENUM_DVR_VEHICLE_CHECK = 1, //黑名单车辆数据稽查类型
    ENUM_MSC_SEND_DATA = 2, //屏幕控制器数据类型
    ENUM_ACS_SEND_DATA = 3, //门禁主机数据类型
    ENUM_TME_CARD_SEND_DATA = 4, //停车场(出入口控制机)卡片数据类型
    ENUM_TME_VEHICLE_SEND_DATA = 5, //停车场(出入口控制机)车辆数据类型
    ENUM_DVR_DEBUG_CMD = 6, //调试命令信息
    ENUM_DVR_SCREEN_CTRL_CMD =7 //屏幕互动命令类型
}LONG_CFG_SEND_DATA_TYPE_ENUM;

typedef enum _LONG_CFG_RECV_DATA_TYPE_ENUM_
{
    ENUM_DVR_ERROR_CODE = 1, //错误码
    ENUM_MSC_RECV_DATA=2, //屏幕控制器数据类型
    ENUM_ACS_RECV_DATA=3 //门禁主机数据类型
}LONG_CFG_RECV_DATA_TYPE_ENUM;

typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//工作时间间隔（单位：秒）[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//持续工作时间（单位：秒）[2min~24h]界面显示按分钟单位
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM,*LPNET_DVR_WIPER_CONTINUEWORK_PARAM;

typedef union tagNET_DVR_WIPERMODE_PARAM_UNION
{
    BYTE uLen[16];
    //当byWiperWorkMode = 1时生效
    NET_DVR_WIPER_CONTINUEWORK_PARAM struWiperContinueWorkParam; 
}NET_DVR_WIPERMODE_PARAM_UNION,*LPNET_DVR_WIPERMODE_PARAM_UNION;

typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //雨刷工作模式
    //0-单次模式，1-持续模式（针对配置结构NET_DVR_ROTATE_OPERATE_PARAM）
    BYTE  byWiperWorkMode;
    BYTE  byRes[23];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG,*LPNET_DVR_WIPERINFO_CFG;

//保存自动对焦参数 
typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{ 
       DWORD     dwSize;
    DWORD     dwChannel;            //通道号
    BYTE      byRes[24];            // 保留字节
}NET_DVR_AUTOFOCUS_TESTCFG,*LPNET_DVR_AUTOFOCUS_TESTCFG;


typedef struct tagNET_DVR_VIDEO_OUT_CFG
{    
    BYTE    byDisplayMode;        //显示模式，1-标准，2-冷色，3-暖色，0xff-自定义
    BYTE     byBrightnessLevel;     // 亮度值0-100
    BYTE    byContrastLevel;     // 对比度0-100
    BYTE     bySharpnessLevel;     // 锐度0-100
    BYTE     bySaturationLevel;     // 饱和度0-100
    BYTE     byHueLevel;         // 色调0-100
    BYTE    byImageMode;        // 图像模式，0-正常模式，1-夜模式1，2-夜模式2，3-夜模式3，4-日照模式1，5-日照模式2，6-日照模式3
    BYTE    byRes[5];            // 保留
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;
//色温
typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{    
    BYTE    byRed;                //红色， 0-100
    BYTE    byGreen;            //绿色， 0-100
    BYTE    byBlue;                //蓝色，0-100
    BYTE    byRedOffset;        //红色偏移，0-100
    BYTE    byGreenOffset;        //绿色偏移，0-100
    BYTE    byBlueOffset;        //蓝色偏移，0-100
    BYTE    byRes[6];        
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{    
    BYTE    byGainR;            //增益R， 0-100
    BYTE    byGainG;            //增益G，0-100
    BYTE    byGainB;            //增益B，0-100
    BYTE    byOffsetR;            //偏移量R，0-100
    BYTE    byOffsetG;            //偏移量G，0-100
    BYTE    byOffsetB;            //偏移量B，0-100
    BYTE    byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{        
    BYTE    byEnable;            //是否启用屏幕边缘 0-不启用 1-启用
    BYTE    byLeftEdge;            //左边缘，0-100
    BYTE    byRightEdge;        //右边缘，0-100
    BYTE    byTopEdge;            //上边缘，0-100
    BYTE    byLowerEdge;        //下边缘，0-100
    BYTE    byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;    
    BYTE    byCfgType;       /*设置的参数类型，获取时此参数无效，0-无效，1-背光参数，2-视频参数，3-色温参数，4-ADC参数，5-屏幕边缘参数*/
    BYTE    byBackLight;    //背光 0~100
    BYTE    byRes1[2];
    NET_DVR_VIDEO_OUT_CFG           struVideoOutCfg;     //视频参数（画面模式）
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //色温参数
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC参数
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //屏幕边缘参数
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;
//模拟遥控类型
typedef enum tagNET_DVR_SCREEN_REMOTE_CTRL_TYPE
{
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,//1-电源开
        REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,//2-电源关
        REMOTE_CTRL_SIGNALSOURCE,//3-信号源
        REMOTE_CTRL_MENU,//4-菜单
        REMOTE_CTRL_DETERMINATION,//5-确定
        REMOTE_CTRL_ON,//6-上
        REMOTE_CTRL_UNDER,//7-下
        REMOTE_CTRL_LEFT,//8-左
        REMOTE_CTRL_RIGHT,//9-右
        REMOTE_CTRL_INFO,//10-INFO
        REMOTE_CTRL_RETURN,// 11-返回上一层    
        REMOTE_CTRL_NUM, //12-数字键盘
}SCREEN_REMOTE_CTRL_TYPE;

//模拟遥控按键
typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;    
    BYTE        byControlType;    //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键,13-开关一体按键
    BYTE       byControlParam; //操作参数，操作类型为12时，表示按键值（0-9），其他操作时此参数无效
    BYTE        byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL,*LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//屏幕信号源配置
typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;    
    BYTE     bySignalSourceType;    //输入源索引，见枚举 NET_DVR_CAM_MODE
    BYTE     byNoSignalPic;            //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    BYTE     byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

//屏幕拼接配置
typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;    
    BYTE    bySpliceIndex;            //自拼接屏号，0就是没有拼接，其他值表示自拼接屏的屏号。例如拼接0101~0202这4块屏，则这4块屏的bySpliceIndex必须相同，且非0.
    BYTE    bySpliceX;                //屏幕在自拼接屏中的行位置
    BYTE    bySpliceY;                //屏幕在自拼接屏中的列位置
    BYTE    byWidth;                //拼接规模宽，以屏幕为单位
    BYTE    byHeight;               //拼接规模高，以屏幕为单位
    BYTE    byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

//风扇工作方式配置
typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;    
    BYTE        byWorkMode;                 //1-常开，2-自动
    BYTE        byTemperatureLimitValue; //风扇开启的温度阀值，工作模式为自动时该参数有效。
    BYTE        byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA信号配置
typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;    
    BYTE        byEnableAutoAdjust;      //是否自动调整，0-否，1-是，当自动调整启用时以下参数无效
    BYTE        byHorizontalPosition;   //水平位置 0-100
    BYTE        byVerticalPosition;      //垂直位置 0-100
    BYTE        byClock;                //时钟 ，0-100
    BYTE        byPhase;                //相位，0-100
    BYTE        byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

//屏幕菜单配置
typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;    
    BYTE        byMenuLanguage; //语言，1-中文，2-英文
    BYTE        byTransparency; //透明度 0-不透明，1-低，2-中，3-高
    BYTE        byDuration;        //持续时间，0-常开，1-5秒，2-15秒，3-30秒
    BYTE        byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

//画中画
typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;    
    BYTE    byEnable;    //是否启用画中画 0-不启用 1-启用
    BYTE    bySubWindowSource;    //子画面信号源，参考枚举NET_DVR_CAM_MODE
    BYTE    bySubWindowBorderColor;    //子画面边框颜色， 1-蓝色，2-黑色
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;    //子画面位置，屏幕总大小为100*100
    BYTE    byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

//透雾配置
typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;    
    BYTE    byDefogEnable;    //开启透雾开关，0~关闭，1~开启
    BYTE    byDefogModel;     //透雾模式，0~自动去雾，1~手动去雾
    BYTE    byDefogLevel;     //透雾强度等级，1-7个等级，默认等级为4。等级1为0.5；等级2为0.55；等级3为0.60；等级4为0.65；等级5为0.70；等级6为0.75；等级7为0.80。（去雾模式为手动去雾时，可配置去雾强度等级）
    BYTE    byRes[33];
}NET_DVR_DEFOG_LCD,*LPNET_DVR_DEFOG_LCD;

//屏幕维墙
typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD    dwSize;
    BYTE    byEnable; //状态开关。0-为关闭；1-为开启
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

//屏幕位置
typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD     dwSize;
    BYTE     byScreenRowNum;//屏幕行号。
    BYTE     byScreenColNum;//屏幕列号。
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;

typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize;     //结构体的长度
    DWORD     dwChanNo;   //视音频通道号， 绑定且启用后，被绑定的语音对讲通道则作为该通道的音频源
    BYTE      byEnable;   //是否启用语音对讲作为音频输入源 0-不启用 1-启用
    BYTE      byRes[31];          //保留
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{    
    DWORD   dwSize; 
    BYTE    byEnable;//使能
    BYTE    byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD    dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30/*64*/];//触发录像通道号
    BYTE    byEnablePreset[MAX_CHANNUM_V30];
    BYTE    byPresetNo[MAX_CHANNUM_V30];
    BYTE    byEnableCruise[MAX_CHANNUM_V30];
    BYTE    byCruiseNo[MAX_CHANNUM_V30];
    BYTE    byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE    byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //假日布防时间
    BYTE  byRes[224];;
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{    
    DWORD dwSize;  //结构体大小
    BYTE    byEnable;//使能
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/]; //* 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff则后续无效*/ 
    /*触发的录像通道*/
    DWORD     dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff,则后续无效*/ 
    DWORD dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/]; //启用的预置点信息，当dwEnablePresetChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用预置点
    BYTE byRes2[516];                    /*保留*/
    DWORD dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/]; //启用巡航功能通道的信息，当dwEnableCruiseChanNum不为0时，数组下标0-( dwEnableCruiseChanNum -1)有效，当为0时，表示未启用巡航
    DWORD dwEnablePtzTrackChanNum;  //当前已启云台轨迹通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/]; //调用云台轨迹的通道信息，当dwEnablePtzTrackChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用云台轨迹
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;  //结构体大小;
    BYTE     byEnableCS;  //开启云存储服务  0-关闭 1-开启
    BYTE     byRes[511];     //保留
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;


typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize ; //结构体大小
    BYTE    byValid;       //是否有效
                           /*(只读)录像类型，0: 不在录像；1：在录像 2-空闲 
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中 
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中*/
    BYTE    byRecord;     
    DWORD   dwRelatedHD;  //关联磁盘
    BYTE    byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE     byRes[63];        //保留字节
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

#define  MAX_CAMERAID_LEN    64
typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;   
    DWORD             dwRecordType; //录像类型  0- 定时录像，1- 移动侦测录像，2- 报警录像，3- 报警或移动侦测录像，4- 报警和移动侦测录像， 5- 命令触发，6- 手动录像，7- 震动报警，8- 环境触发报警，9- 智能报警，10- 回传录像
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //录像开始时间
    NET_DVR_TIME_EX   struStopTime;  //录像结束时间 
    DWORD             dwStoragePoolID; //存储池ID
    BYTE              byFormatType ;     //封装类型：1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP，9-RTP+PS（国标：GB28181），0xff-无效
    BYTE              byVideoEncType ;       //视频编码类型：0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，0xfe- 自动（和源一致），0xff-无效 
    BYTE              byAudioEncType;  //音频编码类型：0-G722，1-G711_U，2-G711_A，5-MP2L2，6-G726，7-AAC，0xfe- 自动（和源一致），0xff-无效 
    BYTE               byRes[125];
}NET_DVR_UPLOAD_RECORD_INFO,*LPNET_DVR_UPLOAD_RECORD_INFO;

//补光灯参数配置  条件结构体
typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//同步输出号(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND,*LPNET_DVR_IOOUT_COND;

//补光灯参数配置
typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD  dwSize;
    BYTE   byWorkMode;// 0-报警输出,1-频闪灯(默认)
    BYTE   byRes1[3];
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//默认状态 0-低电平(默认)，1-高电平
            BYTE   byWorkState;//生效状态 0-低电平(默认),1-高电平,2-脉冲
            BYTE   byFreqMulti;//倍频，数值范围[1,15]
            BYTE   byDutyRatio;//占空比，[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
            NET_DVR_SCHEDTIME  struFlashLightTime;//启用闪光灯时间
            BYTE   byRes1[116];
        }struStrobeLamp;    // 频闪灯 时有效
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG,*LPNET_DVR_IOOUT_CFG;

//信号灯同步参数
typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//相位(0~360)
    BYTE   byLineLock;//电源同步 0-否，1-是
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG,*LPNET_DVR_SIGNAL_SYNCCFG;

// 萤石EZVIZ接入参数结构体
typedef struct
{
    DWORD    dwSize; 
    BYTE    byEnable;// 启用EZVIZ接入 0～禁用，1～启用
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    BYTE    byDeviceStatus; //设备是否在线状态，0-保留，1-在线，2-离线
    BYTE    byAllowRedirect;    //是否允许重定向,0-保留,1-是,2-否,0表示保持不变,兼容老SDK接新设备的情况
    BYTE    byDomainName[MAX_DOMAIN_NAME];    //域名服务器地址
    BYTE    byRes [445];
}NET_DVR_EZVIZ_ACCESS_CFG,*LPNET_DVR_EZVIZ_ACCESS_CFG;

typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0表示移动侦测， 
    1表示视频遮挡， 
    2表示视频丢失， 
    3表示PIR报警， 
    4表示无线报警， 
    5表示呼救报警， 
    6表示智能抓图， 
    7表示人脸侦测， 
    8表示越界侦测侦测， 
    9表示区域入侵侦测， 
    10表示场景变更侦测，
    11 表示异常侦测，
    0xff 表示报警输入
    */
    BYTE  byAlarmType; 
    //联动动作 0-无效,1-抓图上传FTP,2-Jpeg抓图上传Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    //报警输入号或者通道号或者无线编号
    //(当byAlarmType ==0xff时,dwChannel表示的是报警输入号)
    //(当byAlarmType ==4时,dwChannel表示的是无线编号)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND,*LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum ; //触发的报警关联通道数（只读）最大支持数量
    //dwRelateChan的初始值是0xffffffff;数组内填写是实际的通道号;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG,*LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //启用比例变倍配置 0-否，1-是
    BYTE   byPresetFreezing; //启用预置点视频冻结 0-否，1-是
    BYTE   byPresetSpeed;//预置点速度等级 1--8，默认4
    BYTE   byKeyboardCtrlSpeed;//手控速度等级0-低,1-中,2-高
    BYTE   byAutoScanSpeed;//扫描速度等级：1--40，默认28
    BYTE   byZoomingSpeed;//变倍速度：1--3，默认3
    BYTE   byManualControlSpeed;//手控速度模式：0-兼容，1-行人，2-非机动车，3-机动车，4-自适应
    BYTE   byPTZMotionTrack;//启用运动跟踪（锁定云台操作） 0-默认（开启），1-关闭
    BYTE   byRes[124]; 
}NET_DVR_PTZ_BASICPARAMCFG,*LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //镜头倍数显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPtStatus;    //方位角显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPresetStatus;//预置点标题显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPositionDisplayFormat;//方位角显示格式 0-按照PT显示(例 P179|T-02)，1-按照方位显示(SE123|T-02)
    BYTE   byRes[124]; 
}NET_DVR_PTZ_OSDCFG,*LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //掉电记忆模式：Oxff-禁用、1-30秒、2-60秒、3-300秒、4-600秒，默认30秒
    BYTE   byRes[127]; 
}NET_DVR_PTZ_POWEROFFMEMCFG,*LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan; //通道号
    BYTE   byLimitMode; //限位模式 0-保留，1-键控限位，2-扫描限位
    BYTE   byRes[63]; 
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//启用使能，0-否，1-是
    BYTE   byLimitStatus; //限位状态 0-未限位，1-已限位（不可编辑） 
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCFG,*LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byLimitMode; //限位模式 0-保留，1-键控限位，2-扫描限位
    BYTE   byWorkMode ;//0-设置，1-清除
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCTRL,*LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode ;//云台锁定控制 0-解锁，1-锁定
    BYTE   byRes[123]; 
}NET_DVR_PTZ_LOCKCFG,*LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//通道号
    BYTE    byRes[64];
}NET_DVR_PTZLOCKINFO_COND,*LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec ;//剩余秒数
    BYTE    byRes[128];    //保留字节
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    WORD   wRouteNo;//巡航路径号
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND,*LPNET_DVR_CRUISEPOINT_COND;

typedef struct
{
    WORD    wPresetNo;    //预置点
    WORD    wDwell;    //停留时间
    BYTE    bySpeed;    //速度
    BYTE    bySupport256PresetNo;//兼容之前的 第256号预置点是否生效
    BYTE    byRes[6];
}NET_DVR_CRUISEPOINT_PARAM,*LPNET_DVR_CRUISEPOINT_PARAM;

typedef struct
{
    DWORD  dwSize;
    // 最大支持128个巡航点
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISE_POINT_NUM];
    BYTE     Res[64]; //保留
}NET_DVR_CRUISEPOINT_V40, *LPNET_DVR_CRUISEPOINT_V40;

typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;

#define MAX_DISPLAY_NUM         512  //最大显示输出个数
#define MAX_LEDCONTENT_NUM      512  //虚拟LED字符串最大长度
#define MAX_PPT_CHAN            128     //PPT长度

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//使能
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//坐标范围，依据基准坐标计算出支持的拼控模式
    BYTE  sName[NAME_LEN]; //电视墙名称
    BYTE  byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//显示输出号
    BYTE  byDispChanType;/*输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI,11-VGA/DVI自适应，12-HDBaseT, 0xff-无效*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM,*LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/] ;
    BYTE  byRes[128];
}NET_DVR_DISPLAYCFG,*LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byRes1[3]; 
    //墙号,1字节墙号+3字节保留
    DWORD    dwVideoWallNo; 
    DWORD   dwDisplayNo;//显示输出号
    //坐标须为基准坐标的整数倍（1920*1920），宽度和高度值不用设置，即为基准值
    NET_DVR_RECTCFG_EX struRectCfg;
    BYTE    byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION,*LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

/*窗口信息*/
typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //窗口使能,0-不使能，1-使能 
    BYTE  byWndOperateMode;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    BYTE  byRes1[6];
    DWORD dwWindowNo;//窗口号
    DWORD dwLayerIndex;//窗口相对应的图层号，图层号到最大即置顶，置顶操作
    NET_DVR_RECTCFG_EX struRect; //目的窗口统一坐标(相对显示墙)，获取或按统一坐标设置时有效
    NET_DVR_RECTCFG_EX struResolution; //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
   DWORD dwXCoordinate; //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
   DWORD dwYCoordinate; //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
   BYTE  byRes2[36];
}NET_DVR_VIDEOWALLWINDOWPOSITION,*LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    //窗口号：1字节墙号+1字节保留+2字节窗口号
    DWORD    dwWindowNo; 
    DWORD   dwSceneNo;//场景号
    BYTE    byRes[20];
}NET_DVR_VIDEO_WALL_INFO,*LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM 
{
    DWORD   dwSize;
    BYTE    byEnable; //使能
    BYTE    byDispMode;//显示模式，1-透明，2-半透明，3-覆盖
    BYTE    byRes1[6];
    NET_DVR_RGB_COLOR struContentColor;//字体颜色
    NET_DVR_RGB_COLOR struBackColor;//背景颜色
    NET_DVR_RECTCFG_EX struRect;
    DWORD   dwContentNum;/*字符的个数*/
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; /*虚拟LED字符内容*/
    BYTE    byMoveMode; //字符移动模式，1-普通；2-平滑，3-静止
    BYTE    byFontSize; //字体大小，1-1倍，2-2倍，3-4倍
    BYTE    byMoveDirection; //移动方向，0-默认（从左到右），1-从左到右，2-从右到左，3-从上到下，4-从下到上
    BYTE    byMoveSpeed; //移动速度，1-速度1,2-速度2
    BYTE    byRes2[124];
}NET_DVR_VIRTUALLED_PARAM,*LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //图像切割模式，1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE,*LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{ 
    DWORD  dwSize ;
    DWORD  dwSerialPort; //当前使用串口号
    BYTE byProtocolType; //串口协议类型，1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 ， 4-LCD-DLP， 5-LCD-S3 , 6-LCD-D20，7-LCD-L2,8-LCD-Z1，9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+ 
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT,*LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//场景名称
    BYTE  byEnable;//场景是否有效 1-有效，0-无效
    BYTE  bySceneIndex;     //场景号，只能获取。获取所有场景时使用该参数
    BYTE  byRes [78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //电视墙信息
    DWORD dwCmd; //场景控制命令，1-场景模式切换（如果要切换的是当前场景，则不进行切换），2-初始化场景（将此场景的配置清空，如果是当前场景，则同时对当前场景进行清屏操作），3-强制切换（无论是否是当前场景，强制切换），4-保存当前模式到某场景 5-删除场景 
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{
    DWORD dwSize;
    DWORD dwDisplayNo;  //显示输出口号，0xffffffff表示对所用输出口进行操作
    BYTE  byEnable;     //使能显示，0-不显示，1-显示
    BYTE  byChanType;   //显示的通道类型，1-显示通道号，2-虚拟屏号
    BYTE  byRes1[2];
    DWORD dwWallNo; //墙号，1字节墙号（高位）+3字节保留，显示屏幕序号时有效
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO,*LPNET_DVR_SHOW_CONTROL_INFO;

typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;    //缓冲区指针
    DWORD   nLen;    //缓冲区长度
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //条件缓冲区
    NET_DVR_BUF_INFO struInParamBuf;         //参数缓冲区
    DWORD  dwRecvTimeout;      //接收数据超时时间，单位：ms,置0采用接口默认超时
    BYTE   byRes[32];
}NET_DVR_IN_PARAM,LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf;            //输出参数缓冲区
    void*  lpStatusList;       //状态缓冲区    
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM,LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;    
    DWORD dwChannel;   //音频通道号组合（1字节设备号+1字节子板号+2字节音频通道号）
    BYTE  byRes[48];   
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO; 

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //音频通道名称
    BYTE          byEnable; //音频是否开启， 0-关， 1-开
    BYTE          byAudioSwitchType; //音频切换方式，1-按前端源方式，2-按窗口解码源方式 
    BYTE          byRes[2]; 
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //音频源信息 byAudioSwitchType为1时有效
    DWORD         dwWindowNo; //子窗口号（1字节墙号+1字节子窗口号+2字节窗口号），byAudioSwitchType为2时有效
    BYTE          byRes2[28]; 
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

#define MAX_SUBBOARD_NUM        42        //集中式大屏设备板数目
#define MAX_SINGLE_BOARD_EXCEPTION_NUM 16 //单板最大并发异常数
typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //串口工作模式，1-RS484,2-RS232
    BYTE byFunType; //串口功能，1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    DWORD dwBaudRate;//波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    WORD wProtocol;//串口协议，不同串口功能对应串口协议不一样
    BYTE byVariable ;  //串口是否可变，1-不可变  2-可变 （只获取）
    BYTE byRes[31];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;   
    BYTE       byBoardType;    //类型 0-主板  1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入 0xff-未知类型
    BYTE       byInterfaceNum;  //接口数
    BYTE       byStatus;        //状态，0-异常， 1-正常
    BYTE       byRes[1]; 
    DWORD      dwSlotNo;       //所在槽位号 
    BYTE       byRes2[32];  
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //背板类型， 1-4U， 2-8U， 3-13U, 0xff-未知类型
    BYTE      bySoltNum;        //槽位数目
    BYTE      byBoardNum;   //有效数目
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //前byBoardNum项有效 
    BYTE       byRes2[32]; 
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE         byExceptNum;         //异常项数
    BYTE        byRes1[3];               
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //主类型
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //次类型
    BYTE        byRes2[32]; 
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;


typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //通道号
    BYTE    byLinearScanType; //限位类型，0-保留,1-左边界设置,2-右边界设置
    BYTE    byRes[63]; 
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

//码流附加信息
typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //结构体大小
    BYTE  byStreamWithVca; //码流中叠加智能信息，可供进行后检索。0-不叠加,1-叠加
    BYTE  byRes[127];      //保留
}NET_DVR_STREAM_ATTACHINFO_CFG,*LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;    
    BYTE   byDefaultRoute;  //默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
    BYTE   byNetworkCardNum;      //设备实际可配置的网卡数目
    BYTE   byRes1[2]; //保留
    NET_DVR_ETHERNET_MULTI struEtherNet [MAX_NETWORK_CARD]; //以太网口
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

//配置清除
typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byAllPreset; //清除所有的预置点：0-否,1-是
    BYTE   byAllPatrols; //清除所有的巡航路径：0-否,1-是
    BYTE   byAllPatterms; //清除所有的花样扫描：0-否,1-是
    BYTE   byAllPrivacyMasks; //清除所有的隐私块：0-否,1-是
    BYTE   byAllPTZLimited; //清除所有的限位设置：0-否,1-是
    BYTE   byAllScheduledTasks; //清除所有的定时任务：0-否,1-是
    BYTE   byAllParkAction; //清除所有的守望：0-否,1-是
    BYTE   byRes[125]; 
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

//云台优先配置信息
typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //云台优先：0-Rs485，1-网络，默认网络
    BYTE   byRes[3];
    DWORD   dwDelay; //延时：2---200秒
    BYTE   byRes1[124]; 
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

//零方位角控制
typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byWorkMode ;//0-设置，1-清除
    BYTE   byRes[127]; 
}NET_DVR_INITIALPOSITIONCTRL,*LPNET_DVR_INITIALPOSITIONCTRL;

//隐私遮蔽参数
typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan; //通道号
    BYTE   byRegionalID; //区域ID号 1～24
    //删除当前ID对应的隐私遮蔽信息 0-保留，1-删除 （WriteOnly）
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62]; 
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//是否启用 0-否，1-是
    //隐私遮蔽区域配置参数是否显示  0-否，1-是 （ReadOnly）
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0-保留,1-灰、2-红、3-绿、4-蓝、5-橙、6-黄、0xff-马赛克
    BYTE   byActiveZoomRatio;//屏蔽倍率：1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];//遮挡区域名称，只使用16个字节
    NET_VCA_POLYGON  struRegion;//区域范围
    //当前区域坐标是否有效 0-否，1-是 （针对单个区域设置区域坐标信息，和单场景下的多区域设置区域坐标信息）
    BYTE   byCurrentRegionEnable;
    //当前倍率使用字段 0- byActiveZoomRatio ;1- fActiveZoomRatio(支持能力节点curActiveZoomRatioType)
    BYTE   byCurZoomRatio ;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //屏蔽倍率(精确到小数点1位)：[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

//全局使能    
typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//启用使能，0-否，1-是
    BYTE   byRes[127]; 
}NET_DVR_PRIVACY_MASKS_ENABLECFG,*LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

//智能运动跟踪配置信息
typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//启动使能 0-否，1-是
    BYTE  byRes[3];
    DWORD dwDuration;//持续时间：0--300秒，默认300秒
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG,*LPNET_DVR_SMARTTRACKCFG;

//跟踪倍率
typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byRes[128]; 
}NET_DVR_ZOOMRATIOCTRL,*LPNET_DVR_ZOOMRATIOCTRL;


//拨码开关信息
typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//拨号开关状态
    BYTE   byRes[28]; 
}NET_DVR_DIAL_SWITCH_CFG,*LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS //录像丢失报警子结构 
{
    NET_DVR_TIME_EX struInspectStart; //巡检开始时间
    NET_DVR_TIME_EX struInspectEnd;   //巡检结束时间
    NET_DVR_IPADDR  struIP;           //录像丢失对应通道的IP地址 
    DWORD  dwChanNo;                //通道号
    DWORD  dwIDIndex;                //编码器ID
    BYTE   sName[STREAM_ID_LEN];       //编码器名称 
    NET_DVR_TIME_EX struLossStartTime; //录像丢失开始时间
    NET_DVR_TIME_EX struLossEndTime;   //录像丢失结束时间
    DWORD  dwLostNum;                 //录像丢失个数 0xffffffff表示全部丢失
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION //取流异常报警  子结构 
{
    NET_DVR_IPADDR  struIP;           //发生视频异常通道的IP地址 
    DWORD  dwChanNo;                //通道号
    DWORD  dwIDIndex;                //编码器ID
    BYTE   sName[STREAM_ID_LEN];       //编码器名称 
    BYTE   byExceptionCase;           //异常原因，0-数据写入异常 1-网络接收异常
    BYTE   byRes[307];                //保留
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;


typedef struct tagNET_ALARM_RESOURCE_USAGE  //资源使用报警 子结构
{ 
    BYTE   byLevel;    //使用情况，严重程度递增： 0-正常，1-一级告警上限 2-二级告警上限 3-三级告警上限  
    BYTE   byRes[491]; //保留
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION //录像异常报警 子结构
{ 
    BYTE    byReason;    //异常原因 0-录像卷满 1-录像卷异常 2-无可用lun卷
    BYTE    byRes1[3];   //保留
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //录像卷ID（硬盘号）
    BYTE    byRes[452];  //保留
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;

typedef union tagNET_ALARM_CVR_SUBINFO_UNION  //CVR报警子结构
{
    BYTE byLen[492];   //联合体长度
    NET_ALARM_RECORDFILE_LOSS     struRecordLost; //录像丢失
    NET_ALARM_STREAM_EXCEPTION     struStreamException; //取流异常
    NET_ALARM_RESOURCE_USAGE     struResourceUsage;  //资源使用
    NET_ALARM_RECORD_EXCEPTION   struRecordException; //录像异常
}NET_ALARM_CVR_SUBINFO_UNION, *LPNET_ALARM_CVR_SUBINFO_UNION;

#define  MAX_VARIABLE_DATA_NUM    65535  //最大可变数据个数

typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //报警子类型 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；6-编码器(通道)移动侦测报警；
    //7-编码器(通道)遮挡报警; 8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //报警信息子结构 报警类型为8,9,10,11,12时该联合体有效
    BYTE             byRes[256];
    DWORD            dwNumber; //可变数据个数
    WORD             *pNO; //当类型为0、3、6、7时，可能会有通道号；当类型为5时，可能会有磁盘号。可表示的值范围为0~65535    
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

typedef struct tagNET_DVR_CONTROL_START_CFG //一键开始控制信息
{
    BYTE    byUseDefine; //使用自定义， 0-使用默认，1-使用自定义
    BYTE    byRes1;
    WORD    wCourseIndex; //课程索引
    BYTE    byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//一键延长录像控制信息
{
    BYTE    byUseDefine; //使用自定义， 0-使用默认，1-使用自定义
    BYTE    byRes1;
    WORD    wDelayTime; //录像延长时间<继续录像时间以此为准>，单位s
    BYTE    byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;

typedef union tagNET_DVR_CONTROL_INFO_UNION  //控制信息联合体
{
    BYTE    byLen[132]; //联合体长度
    NET_DVR_CONTROL_START_CFG  struStartCfg;   //一键开始
    NET_DVR_CONTROL_DELAY_CFG  struDelayCfg;  //一键延迟
}NET_DVR_CONTROL_INFO_UNION, *LPNET_DVR_CONTROL_INFO_UNION;

typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD    dwSize;        //结构体大小
    WORD    wCmdType;    //控制命令类型，0-一键开始，1-一键结束，2-一键暂停，3-一键恢复，4-一键延长,5-一键开始屏蔽 6-一键停止屏蔽
    BYTE    byRes1 [2]; //保留
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //控制信息，具体使用结合控制命令类型
    BYTE    byRes[256]; //保留
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD     dwSize;  //结构体大小
    DWORD    dwOneKeyDelayTime; //一键本地延迟时间  录像继续录的时间 单位 S
    BYTE     byDirectedMode; //导播模式，0-自动导播，1手动导播
    BYTE     byClassroomType;    //教室类型，0-无效，1-主教室，2-从教室
    BYTE     byCourseDataStorageEnabled;//课堂数据统计是否存储在硬盘, 0-不存储，1-存储
    BYTE     byRes[125];     //保留
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_STATISTIC_DATA_COND
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //统计对象类型，详见TARGET_TYPE
    NET_DVR_TIME   struStartTime;//开始统计时间
    NET_DVR_TIME   struStopTime;//结束统计时间
    BYTE        byRes[280];
}NET_DVR_STATISTIC_DATA_COND, *LPNET_DVR_STATISTIC_DATA_COND;

typedef struct tagNET_DVR_STATISTIC_DATA_CFG
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //统计对象类型，详见TARGET_TYPE
    NET_DVR_TIME   struStartTime;//事件开始时间
    NET_DVR_TIME   struStopTime;//事件结束时间
    BYTE        byRes[300];
}NET_DVR_STATISTIC_DATA_CFG, *LPNET_DVR_STATISTIC_DATA_CFG;

//typedef enum
//{
//    NET_SDK_ALL_TARGET = 0,          //统计所有对象
//    NET_SDK_PPT_TARGET_ALARM,     //PPT报警
//    NET_SDK_PPT_TARGET_VIEW,       //PPT视图
//    NET_SDK_STU_SINGLE_ALARM,     //单个学生报警
//    NET_SDK_STU_SINGLE_VIEW,       //单个学生视图
//    NET_SDK_SUT_MULT_ALARM,       //多个学生报警
//    NET_SDK_STU_MULT_VIEW,         //多个学生视图
//    NET_SDK_STU_TEACHER_VIEW,     //师生互动视图
//    NET_SDK_TEA_UP_DOWN_ALARM,  //教师上下讲台
//    NET_SDK_TEA_START_VIEW,        //教师授课视图
//    NET_SDK_BLA_WRITE_ALARM,      //书写板书报警
//    NET_SDK_BLA_WRITE_VIEW,       //书写板书视图
//    NET_SDK_TEA_FULL_VIEW,         //教师全景视图
//    NET_SDK_TEA_START_ALARM,      //教师开始授课报警
//    NET_SDK_TEA_WALK_ALARM,      //教师走动报警
//    NET_SDK_TEA_LEFT_ALARM,       //教师离开报警
//    NET_SDK_TEA_RUN_ALARM,        //教师奔跑报警
//    NET_SDK_TEA_MULT_ALARM       //教师多人报警
//}TARGET_TYPE;

typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;   //结构体大小
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30] ; 
    //SDI通道，设备端实际的流返回形式是模拟通道，而控制前端使用IP通道。
    BYTE   byCameraType[MAX_CHANNUM_V30];     //通道接入的相机类型，值为 0-无意义，1-老师跟踪，2-学生跟踪，3-老师全景，4-学生全景，5-多媒体，0xff-未接入
    BYTE   byRes[64];     //保留
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG; 

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE                byProtocolType;    //协议类型 0-FTP，1-SFTP
    BYTE                byRes1;     //保留
    WORD                wFTPPort;  //端口
    BYTE                   byAddress[MAX_DOMAIN_NAME];  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    BYTE                szUserName[NAME_LEN/*32*/];        //用户名<加密>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //密码<加密>
    BYTE                szCustomDir[128];    //发布目录,支持目录结构
    BYTE                byRes[12]; //保留
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //发布的URL地址信息
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE                byProtocolType;    //协议类型 0-FTP，1-SFTP
    BYTE                byRes1;     //保留
    WORD                wFTPPort;  //端口
    BYTE               byAddress[MAX_DOMAIN_NAME];  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    BYTE                szUserName[NAME_LEN/*32*/];        //用户名<加密>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //密码<加密>
    BYTE                  byDirLevel;                     /*0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录*/
    BYTE                byTopDirMode;         /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址                     0xff=使用自定义*/
    BYTE                bySubDirMode;         /*二级目录，0x1=使用通道名称,0x2=使用通道号，0x3=使用课程名称，0x4-使用授课日期，0xff-使用自定义*/
    BYTE              byRes2;
    BYTE               byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*自定义一级目录*/
    BYTE               bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*自定义二级目录*/   
    BYTE                byRes[72]; //保留
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;


typedef  union tagNET_DVR_PUBLISH_ADD_UNION
{
    BYTE    byLen[256]; //联合体长度
    NET_DVR_PUBLISH_HTTP_CFG struHttpCfg; //http地址信息
    NET_DVR_PUBLISH_FTP_CFG  struFtpCfg;  //ftp地址信息
    NET_DVR_PUBLISH_FTP_CFG_DIR struDirFtpCfg;  //按目录方式的FTP
}NET_DVR_PUBLISH_ADD_UNION, *LPNET_DVR_PUBLISH_ADD_UNION;

typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO //通道录像发布信息
{
    BYTE    byPublish; //是否发布，0-不发布， 1-发布
    BYTE    byRes1[3];
    DWORD  dwStreamType;   //一键发布码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    BYTE    byRes[12];     //保留
}NET_DVR_RECORD_PUBLISH_INFO,*LPNET_DVR_RECORD_PUBLISH_INFO;


typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;  //结构体大小
    BYTE   byPublishType;    //发布方式，0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3]; //保留
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //一键发布地址信息
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30]; //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //导播通道录像发布信息
    BYTE                  byUploadTime;      //是否启动定时ftp上传功能 0-无意义，1-不启动，2-启用
    BYTE                byTimerMode;      //0-无意义，1-按课表定时上传最近一节课的录像，2-按时间点方式上传前24小时录像
    BYTE                  byUploadStartHour;    //按时间定时上传起始时间  时
    BYTE                byUoploadStartMin;    //按时间定时上传 开始时间 分
    BYTE                byRes[1020]; //保留
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;  //结构体大小
    BYTE  byUseDefine;  //使用自定义  0-使用默认发布配置信息，1-使用自定义发布配置信息
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //导播通道录像发布信息
    NET_DVR_TIME_EX  struStartTime;  //课程开始时间
    NET_DVR_TIME_EX  struEndTime;   //课程结束时间
    BYTE    bySchedulePublish;  //是否按课表发布，0不按课表发布1按课表发布
    BYTE    sFileName[COURSE_NAME_LEN/*32*/];  //发布文件名称
    BYTE    byRes[31];
}NET_DVR_ONEKEY_PUBLISH_CFG,*LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD    dwSize;  
    char    sCourseName[COURSE_NAME_LEN/*32*/];  
    char    sInstructorName[INSTRUCTOR_NAME_LEN/*16*/]; 
    char    sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE    byIndex;        //课程索引
    BYTE    byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime ;   //课程起止时间
    WORD  wCourseIndex ;        //课程索引
    WORD  wSessionIndex ;        //节次
    BYTE   byRes[4] ;            //保留
}NET_DVR_EACH_LESSON_INFO,*LPNET_DVR_EACH_LESSON_INFO ;
// 流录像状态
typedef struct tagNET_DVR_CURRICULUM_CFG  //课表计划 按年月日配置
{ 
    DWORD  dwSize ;         //结构体大小
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/] ; //每节课信息
    BYTE   byRes[256] ; //保留
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;

typedef  struct  tagNET_DVR_DATE_
{
    WORD         wYear;        //年
    BYTE        byMonth;        //月    
    BYTE         byDay;        //日                        
}NET_DVR_DATE,*LPNET_DVR_DATE;

typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD    dwSize ;
    BYTE    byEnablePPTDetect; //是否启用PPT检测
    BYTE    byPptDetLevel; //灵敏度
    BYTE    byEnablePartScreen; //是否配置部分区域
    BYTE    byRes1;
    WORD    wX; //区域坐标
    WORD    wY;
    WORD    wWidth;
    WORD    wHeight;
    BYTE    byRes[32];
}NET_DVR_PPT_DETECT_CFG,*LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD    dwSize ;
    BYTE    byChan[MAX_PPT_CHAN]; 
    BYTE    byRes[32];
}NET_DVR_PPT_CHANNEL_CFG,*LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;   //是否启用
    BYTE   byRes[11];
    //备份码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    DWORD  dwStreamType;  
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD     dwSize ;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];  //需要备份的通道,数组下标对应相应的通道号
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //导播通道备份信息
    BYTE    byRes[256];      // 保留字节 
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

//室内机编号
typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //层号
    WORD  wRoomNumber;    //房间号
    WORD  wDevIndex;      //室内机编号，0-10
    BYTE  byRes[122];     //保留
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

//门口机编号
typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wBuildingNumber; //楼号
    WORD wUnitNumber;  //单元号
    SHORT wFloorNumber;  //层号
    WORD wDevIndex;  //门口机序号，每一层中门口机的序号唯一，从0开始
    BYTE byRes[118]; //保留
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

//围墙机编号
typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wDevIndex;  //围墙机序号，每一层中门口机的序号唯一，从0开始
    BYTE byRes[124]; //保留
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

//管理机编号
typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //期号，范围[0,9]
    WORD wDevIndex;  //管理机序号，每一期中管理机的序号唯一,从0开始
    BYTE byRes[124]; //保留
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;

//可视对讲设备编号联合体
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION
{   
    BYTE byLen[128] ; //联合体大小
    NET_DVR_INDOOR_UNIT_DEVICEID struIndoorUnit;   //室内机
    NET_DVR_OUTDOOR_UNIT_DEVICEID struOutdoorUnit; //门口机
    NET_DVR_MANAGE_UNIT_DEVICEID struManageUnit; //管理机
    NET_DVR_OUTDOOR_FENCE_DEVICEID struFenceUnit; //围墙机
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struVillaOutdoorUnit;  //别墅门口机
}NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;

//设备编号参数结构体
typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType;   //设备类型，1-门口机，2-管理机 4-围墙机,5-别墅门口机，6-二次确认机
    BYTE byIsAutoReg;  //是否自动注册，0-否，1-是
    BYTE byRes1[2];  //保留
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;

//权限密码类型
typedef enum tagPRIVILEGE_PASSWORD_TYPE_ENUM
{    
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1, //工程密码
        ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2, //布/撤防密码
        ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK  = 3, //户主开锁密码
        ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING  = 4, //防劫持密码
}PRIVILEGE_PASSWORD_TYPE_ENUM;

//权限密码信息
typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{   
    DWORD  dwSize; //结构体大小
    BYTE   byPwdType; //密码类型，参考PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];  //保留
    BYTE   byOldPassword[PASSWD_LEN];  //旧密码
    BYTE   byNewPassword[PASSWD_LEN]; //新密码
    BYTE   byRes2[128]; //保留
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;


//室内机操作时间配置
typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime; //最大监视时间，范围[10,60]秒
    DWORD dwMaxRingTime; //最大振铃时间，范围[15,60]秒
    DWORD dwCallForwardingTime; //呼叫转移超时时间，范围[0,20]秒
    BYTE  byRes[116];//保留
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

//室外机操作时间配置
typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime; //最大留言时间，范围[30,60]秒
    DWORD dwMaxTalkTime; //最大通话时间，范围[90,120]秒
    BYTE   byRes[120]; //保留
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;

//管理机操作时间配置
typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //最大监视时间，范围[10,60]秒
    DWORD dwMaxRingTime;        //最大振铃时间，范围[15,60]秒
    DWORD dwMaxTalkTime;        //最大通话时间，单位s
    BYTE  byRes[116];           //保留
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;

//可视对讲操作时间联合体
typedef union tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION
{   
    BYTE byLen[128]; //联合体大小
    NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG struIndoorUnit; //室内机
    NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG struOutdoorUnit; //门口机/围墙机/别墅门口机/二次确认机
    NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG struManageUnit; //管理机
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;

//可视对讲操作时间配置
typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType; //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机
    BYTE byRes1[3];  //保留
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;

//室内机关联的网络设备
typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit; //主门口机IP
    NET_DVR_IPADDR struManageUnit;  //管理机IP
    NET_DVR_IPADDR struSIPServer;    //SIP服务器IP
    NET_DVR_IPADDR struAgainUnit;   //二次确认机IP
    BYTE             byOutDoorType;  //主门口机类型，0保留，1-主单元门口机，2-主别墅门口机
    BYTE             byOutInConnectMode;  //门口机与室内分机组网模式：1-门口机与室内分机同一局域网,2-门口机与室内分机不同局域网；
    BYTE             byIndoorConnectMode;  //室内主机与室内分机组网模式：1-通过无线网卡、2-通过有线网卡；
    BYTE           byRes1;
    NET_DVR_IPADDR struIndoorUnit; //室内主机IP
    BYTE           byRes[300];       //保留
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;

//门口机相关联的网络设备
typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{   
    NET_DVR_IPADDR struMainOutdoorUnit; //主门口机IP，副门口机时有效
    NET_DVR_IPADDR struManageUnit;   //管理机IP
    NET_DVR_IPADDR struSIPServer;     //SIP服务器IP，副门口机时无效
    BYTE           byRes[592];       //保留
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;

//二次确认机相关联的网络设备
typedef struct tagNET_DVR_AGAIN_RELATEDEV
{   
    NET_DVR_IPADDR   struSIPServer;       //SIP服务器IP
    NET_DVR_IPADDR   struCenterAddr;      //中心平台IP
    WORD             wCenterPort;         //中心平台端口
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //室内主机IP
    BYTE             byRes[588];//保留
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;


//管理机相关联的网络设备
typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP服务器IP
    BYTE   byRes[880];       //保留
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;


//可视对讲关联网络设备参数结构体
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION
{   
    DWORD dwRes[256] ; //联合体大小
    NET_DVR_INDOOR_UNIT_RELATEDEV struIndoorUnit;   //室内机
    NET_DVR_OUTDOOR_UNIT_RELATEDEV struMainOutdoorUnit; //门口机/围墙机
    NET_DVR_MANAGE_UNIT_RELATEDEV struManageUnit; //管理机
    NET_DVR_OUTDOOR_UNIT_RELATEDEV  struVillaUnit;      //别墅门口机
    NET_DVR_AGAIN_RELATEDEV           struAgainUnit;      //二次确认机
}NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;

//关联网络设备参数结构体
typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType; //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机
    BYTE byRes1[3];  //保留
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize; //结构体大小
    DWORD dwGatewayIndex; //门禁序号，从1开始
    BYTE   byCommand; //操作命令，0-关闭，1-打开
    BYTE   byLockType; //锁类型，0-普通（以前默认都为0）,1-智能锁
    BYTE   byRes1[2]; //保留
    BYTE   byControlSrc[NAME_LEN]; //操作发起源信息
    BYTE   byControlType; //开锁类型，1-监视，2-通话
    BYTE  byRes3[3];
    BYTE  byPassword[PASSWD_LEN];       //锁密码，当byLockType为智能锁时有效
    BYTE  byRes2[108]; //保留
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;


//公告图片信息结构体
typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData; //图片指针
    DWORD dwPicDataLen; //图片数据长度
    BYTE   byRes[32]; //保留
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;

//公告数据
typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize; //结构体大小
    NET_DVR_TIME_EX struTime; //公告时间
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //公告编号
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];//公告主题
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN]; //公告详情
    BYTE   byLevel; //公告等级，1-广告类信息；2-物业信息；3-报警类信息;4-通知类信息
    BYTE   byPicNum; //公告图片数量
    BYTE   byRes1[2]; //保留    
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM]; //公告图片
    BYTE   byRes2[128]; //保留
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;

//操作权限验证参数
typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize; //结构体大小
    BYTE   byPassword[PASSWD_LEN]; //验证密码
    BYTE   byRes[128]; //保留
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;

//开锁类型
typedef enum tagUNLOCK_TYPE_ENUM
{    
    ENUM_UNLOCK_PASSWORD = 1, //密码开锁
        ENUM_UNLOCK_HIJACKING  = 2, //劫持开锁
        ENUM_UNLOCK_CARD = 3, //刷卡开锁
        ENUM_UNLOCK_HOUSEHOLDER  = 4, //户主开锁
        ENUM_UNLOCK_CENTER_PLATFORM = 5 //中心平台开锁
}UNLOCK_TYPE_ENUM;


//防区类型，和产品线确认，此定义没有使用，使用的是DETECTOR_TYPE
// typedef enum tagALARM_ZONE_TYPE_ENUM
// {    
//     ENUM_ALARM_ZONE_SMOKE = 1, //烟感
//         ENUM_ALARM_ZONE_GAS  = 2,  //煤气
//         ENUM_ALARM_ZONE_INFRARED = 3, //红外
//         ENUM_ALARM_ZONE_MAGNETIC  = 4, //门磁
//         ENUM_ALARM_ZONE_MANUAL = 5 //手动
// }ALARM_ZONE_TYPE_ENUM;

//开锁记录
typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType; //开锁方式，参考UNLOCK_TYPE_ENUM
    BYTE   byRes1[3]; //保留
    BYTE   byControlSrc[NAME_LEN]; //操作发起源信息，刷卡开锁时为卡号，其余情况下为设备编号
    DWORD  dwPicDataLen; //图片数据长度
    BYTE*  pImage; //图片指针
    BYTE   byRes[212];  //保留
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;

//公告信息阅读回执
typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //公告编号
    BYTE   byRes[224];  //保留
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;


//可视对讲事件记录信息联合体
typedef union tagNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
{
    BYTE byLen[256]; //联合体大小
    NET_DVR_UNLOCK_RECORD_INFO struUnlockRecord; //开锁记录
    NET_DVR_NOTICEDATA_RECEIPT_INFO struNoticedataReceipt; //公告信息阅读回执
}NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON,*LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;


//可视对讲事件记录
typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize; //结构体大小
    NET_DVR_TIME_EX struTime; //时间
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //设备编号
    BYTE   byEventType; //事件信息类型，1-开锁记录，2-公告信息阅读回执
    BYTE   byRes1[3]; //保留
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo; //事件信息，具体内容参考byEventType取值
    BYTE  byRes2[256]; //保留
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;


//防区报警信息
typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN]; //防区名称
    DWORD  dwZonendex; //防区号
    BYTE   byZoneType; //防区类型，参考DETECTOR_TYPE
    BYTE   byRes[219];  //保留
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

typedef union tagNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION
{
    BYTE byLen[256]; //联合体大小
    NET_DVR_ZONE_ALARM_INFO struZoneAlarm; //防区报警
}NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION,*LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;


//可视对讲报警信息联合体
typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;  //结构体大小
    NET_DVR_TIME_EX struTime; //报警时间
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN]; //设备编号
    BYTE  byAlarmType; //报警类型，1-防区报警，2-防拆报警，3-劫持报警，4-多次密码开锁失败报警,5-门没开，6-门没关 7-SOS 、8-通话对讲
    BYTE  byRes1[3]; //保留
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo; //报警信息，具体内容参考字段byAlarmType取值
    BYTE  byRes2[256]; //保留
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;

typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;//区域ID
    BYTE byNumber;//区域中的人员数量 0-表示区域中没有人员
    BYTE byDressType;//着装类型 0-未知，1-法袍、2-徽章、3-制服
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;//检测图片长度 (0表示没有长度)
    char*  pPicBuffer;//具体的图片数据
    BYTE byRes1[24];//保留(预留后期扩展区域属性)
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD     dwSize;
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;//前端设备信息
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    /*人员检测报警类型
    （0-    未知，
    （1-    审讯室内打架斗殴报警
    （2-    审讯人员瞌睡检测报警
    （3-    被审讯人员起身检测报警
    （4-    审判人员检测）
    */
    BYTE  byPeopleAlarmType; 
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;

typedef    struct tagNET_DVR_SUPPLEMENTLIGHT
{
    BYTE        byEnable;//使能 0-关，1-开
    BYTE          byMode;//补光灯模式 0-自动，1-定时
    BYTE        byHighBeamBrightness;//远光灯亮度[0,10]
    BYTE        byLowBeamBrightness;//近光灯亮度[0,10]
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//定时时间段    
    WORD        wFilteringTime;//过滤时间(s)[0,120]
    BYTE        byRes[62];
}NET_DVR_SUPPLEMENTLIGHT,*LPNET_DVR_SUPPLEMENTLIGHT;

typedef    struct tagNET_DVR_EXTERNALDEVICE
{
    DWORD        dwSize;//结构体大小
    NET_DVR_SUPPLEMENTLIGHT struSupplementLight;//补光灯结构信息        
    BYTE        byRes[512];
}NET_DVR_EXTERNALDEVICE,*LPNET_DVR_EXTERNALDEVICE;

//(球机支持，软件实现，补光灯是设计在设备内部的)
typedef    struct tagNET_DVR_BUILTIN_SUPPLEMENTLIGHT
{
    DWORD        dwSize;//结构体大小
    BYTE          byMode;//补光灯模式 0-定时，1-开启，2-关闭，3-自动（非光敏，算法画面识别）
    BYTE        byBrightnessLimit;//亮度限制[0,100]
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//定时时间段    
    BYTE        byRes1[256];
}NET_DVR_BUILTIN_SUPPLEMENTLIGHT,*LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT;

typedef    struct tagNET_DVR_OSD_BATTERY_POWER_CFG
{
    DWORD dwSize;
    NET_VCA_POINT  struOSDBatteryPower;//客流统计显示OSD显示左上角坐标
    BYTE   byOSDBatteryPower;//电池电量OSD叠加显示使能,  0-否，1-是
    BYTE    byRes[63];
}NET_DVR_OSD_BATTERY_POWER_CFG, *LPNET_DVR_OSD_BATTERY_POWER_CFG;

#define CARD_PARAM_CARD_VALID       0x00000001  //卡是否有效参数
#define CARD_PARAM_VALID            0x00000002  //有效期参数
#define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
#define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
#define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
#define CARD_PARAM_GROUP            0x00000040  //所属群组参数
#define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
#define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数

typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //使能有效期，0-不使能，1使能
    BYTE byRes1[3];
    NET_DVR_TIME_EX struBeginTime; //有效期起始时间
    NET_DVR_TIME_EX struEndTime; //有效期结束时间
    BYTE byRes2[32];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType; 
    // 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
    // #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
    // #define CARD_PARAM_VALID            0x00000002  //有效期参数
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
    // #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
    // #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byCardValid; //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    BYTE byCardType; //卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，默认普通卡
    BYTE byLeaderCard; //是否为首卡，1-是，0-否
    BYTE byRes1;
    DWORD dwDoorRight; //门权限，按位表示，1为有权限，0为无权限，从低位到高位表示对门1-N是否有权限
    NET_DVR_VALID_PERIOD_CFG struValid; //有效期参数
    DWORD dwBelongGroup; //所属群组，按位表示，1-属于，0-不属于，从低位到高位表示是否从属群组1-N
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //卡密码
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //卡权限计划，取值为计划模板编号，同个门不同计划模板采用权限或的方式处理
    DWORD dwMaxSwipeTime; //最大刷卡次数，0为无次数限制
    DWORD dwSwipeTime; //已刷卡次数
    WORD wRoomNumber;  //房间号
    SHORT wFloorNumber;   //层号
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    BYTE  byCheckCardNo; //设备是否进行卡号校验，0-不校验，1-校验
    BYTE  byRes[31];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byRes[16];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;

typedef struct tagNET_DVR_CARD_USER_INFO_CFG  /*对应配置结构体*/
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN];                /* 用户名*/
    BYTE byRes2[256];
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //门状态周计划参数
#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //读卡器周计划参数
#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //卡权限周计划参数
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //门状态假日计划参数
#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //读卡器假日计划参数
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //卡权限假日计划参数
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //门状态假日组参数
#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //读卡器验证方式假日组参数
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //卡权限假日组参数
#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //门状态计划模板参数
#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //读卡器验证方式计划模板参数
#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //卡权限计划模板参数
#define ACS_PARAM_CARD                         0x00001000 //卡参数
#define ACS_PARAM_GROUP                        0x00002000 //群组参数
#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //反潜回参数
#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //事件及卡号联动参数
#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //密码开门使能参数
#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //人数统计参数

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //参数类型，按位表示    
    //#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //门状态周计划参数
    //#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //读卡器周计划参数
    //#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //卡权限周计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //门状态假日计划参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //读卡器假日计划参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //卡权限假日计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //门状态假日组参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //读卡器验证方式假日组参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //卡权限假日组参数
    //#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //门状态计划模板参数
    //#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //读卡器验证方式计划模板参数
    //#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //卡权限计划模板参数
    //#define ACS_PARAM_CARD                         0x00001000 //卡参数
    //#define ACS_PARAM_GROUP                        0x00002000 //群组参数
    //#define ACS_PARAM_ANTI_SNEAK_CFG                 0x00004000 //反潜回参数
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //事件及卡号联动参数
    //#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //密码开门使能参数
    //#define ACS_PARAM_PERSON_STATISTICS_CFG           0x00020000 //人数统计参数
    BYTE byRes[32];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byIOUseType;     //用途，0-禁用，1-开门按钮，2-门状态，0xff-自定义
    BYTE    byRes[63];              // 保留字节
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byIOUseType;     //用途，0-禁用，1-电锁，0xff-自定义
    BYTE    byRes[63];              // 保留字节
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byEnable;   //是否启用梯控，0-否，1-是
    BYTE    byRes1;     //保留
    BYTE    byInterfaceType; //接口类型，0-无，1-RS485,2-网口
    BYTE    byRS485Protocol; //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    BYTE    byNetworkType;  //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    BYTE    byRes[63];              // 保留字节
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byEnable;               //是否启用梯控，0-否，1-是
    BYTE    byRes1;                 //保留
    BYTE    byInterfaceType;        //接口类型，0-无，1-RS485,2-网口
    BYTE    byRS485Protocol;        //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    BYTE    byNetworkType;          //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    BYTE    byRes2;                 //保留
    WORD    wServerPort;            //梯控服务器端口号，当网卡协议类型为1-私有 时有效
    NET_DVR_IPADDR    struServerIP; //梯控服务器IP，当网卡协议类型为1-私有 时有效
    BYTE    byRes[256];              // 保留字节
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN]; // 可视对讲设备编号，即长号，设备类型为IPC时全部为0
    BYTE  byDeviceName[NAME_LEN];  //设备名称
    BYTE  bySourceType;            //视频源类型，0无意义，1-IPC、2-DVR/DVS/NVR、3-门口机、4-围墙机、5-二次确认机
    BYTE  byRes[255];              //保留
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;

#define UNLOCK_PASSWORD_LEN                        8 //解除密码长度
typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //门名称
    BYTE byMagneticType; //门磁类型，0-常闭，1-常开
    BYTE byOpenButtonType; //开门按钮类型，0-常闭，1-常开
    BYTE byOpenDuration; //开门持续时间，1-255s
    BYTE byDisabledOpenDuration; //残疾人卡开门持续时间，1-255s
    BYTE byMagneticAlarmTimeout; //门磁检测超时报警时间，0-255s，0表示不报警
    BYTE byEnableDoorLock; //是否启用闭门回锁，0-否，1-是
    BYTE byEnableLeaderCard; //是否启用首卡常开功能，0-否，1-是
    BYTE byRes1;
    DWORD dwLeaderCardOpenDuration; //首卡常开持续时间，1-1440min
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //胁迫密码
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //超级密码
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN];         //解除码
    BYTE byRes2[56];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];    //设备编号
    BYTE    byRes[64];                          //保留
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;                                  //ID
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //设备编号
    BYTE        byMACAddr[MACADDR_LEN];             //mac地址
    BYTE        byRes1[2];                           //保留
    BYTE        sSerialNumber[SERIALNO_LEN];        //设备序列号
    NET_DVR_IPADDR   struDevIP;                     //设备IP地址
    NET_DVR_TIME_EX struRegisterTime;                 //注册时间
    BYTE        byRegisterType;                     //注册类型，0-保留、1-门口机，2-管理机、3-室内机、4-围墙机、5-别墅门口机、6-二次确认机、7-8700客户端、8-4200客户端
    BYTE        byRes[127];                         //保留
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;

typedef struct tagNET_DVR_CALLER_INFO
{
    DWORD dwSize;          //结构体大小
    WORD   wBuildingNo;    //楼号
    SHORT   wFloorNo;    //层号
    BYTE   byZoneNo;        //期号
    BYTE   byUnitNo;    //单元号
    BYTE   byDevNo;    //设备编号
    BYTE    byDevType;   //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP
    BYTE    byRes[100];        //保留
}NET_DVR_CALLER_INFO,*LPNET_DVR_CALLER_INFO;

typedef struct tagNET_DVR_CALL_STATUS
{
    DWORD dwSize;          //结构体大小
    BYTE   byCallStatus; //获取通话状态，1-无呼叫、2-响铃、3-正在通话
    BYTE   byRes[127];
}NET_DVR_CALL_STATUS, *LPNET_DVR_CALL_STATUS;

#define MAX_SERVER_DEVICE_NUMBER                  16  //最大设备数量

typedef struct tagNET_DVR_SERVER_DEVICE_CFG
{
    BYTE    byDeviceName[NAME_LEN];   //设备名称
    BYTE       byDeviceType; ////设备类型，1-门口机，2-管理机，3-室内机
    BYTE       byDeviceID; //门口机编号
    BYTE    byRes[6];        //保留
}NET_DVR_SERVER_DEVICE_CFG,*LPNET_DVR_SERVER_DEVICE_CFG;

typedef struct tagNET_DVR_SERVER_DEVICE_INFO
{
    DWORD   dwSize;  //结构体大小
    DWORD     dwDeviceNum; //设备数
    NET_DVR_SERVER_DEVICE_CFG    struDeviceCfg[MAX_SERVER_DEVICE_NUMBER];   //设备信息
    BYTE    byRes[200];        //保留
}NET_DVR_SERVER_DEVICE_INFO,*LPNET_DVR_SERVER_DEVICE_INFO;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD    dwSize;
    DWORD   dwCmdType;      //信令类型  0-请求呼叫，1-取消本次呼叫，2-接听本次呼叫 3-拒绝本地来电呼叫 4-被叫响铃超时 5-结束本次通话，6-设备正在通话中，7-客户端正在通话中，8室内机不在线
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wBuildingNumber; //楼号
    WORD wUnitNumber;  //单元号
    SHORT wFloorNumber;  //层号
    WORD  wRoomNumber;    //房间号
    BYTE    byRes[118];     //保留
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;

#define MAX_SCREEN_ADDRESS_LEN 16 //特征码最大长度
#define MAX_DAY_TIME_POINT 8   //每天最大时间点个数
#define MAX_TIME_POINT     16  //每年最大时间点个数

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //用户名
    BYTE byPassWord[PASSWD_LEN]; //密码
    NET_DVR_IPADDR struIPAddr; //IP地址
    WORD wPort; //端口号
    BYTE byRes[24];    
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;

typedef union tagNET_DVR_SCREEN_BASE_INFO
{
    BYTE byScreenAddress[MAX_SCREEN_ADDRESS_LEN]; //屏幕特征码，设备添加方式为0时有效
    NET_DVR_DEV_IP_INFO struIPInfo; //屏幕ip地址信息
    BYTE byRes[100];
}NET_DVR_SCREEN_BASE_INFO,*LPNET_DVR_SCREEN_BASE_INFO;

typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //使能，0-不使能，1-使能
    BYTE byDevAddType; //设备添加方式，0-按特征码(服务器和屏幕使用串口通信)，1-按IP地址(服务器和屏幕使用网络通信)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //屏幕设备基本信息
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG,*LPNET_DVR_SCREEN_INDEX_CFG;

//模拟遥控器参数
typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE        byControlType;    //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键
    BYTE        byControlParam; //操作参数，操作类型为12时，表示按键值(0-9)，其他操作时此参数无效
    BYTE        byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

//屏幕维墙参数
typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //状态开关。0-为关闭；1-为开启
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

//区域放大还原参数
typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;    //区域放大还原指令，1-放大，2-还原
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //需要放大的区域，以1920*1920作为屏幕总大小，还原时此参数无效
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;

typedef  union tagNET_DVR_SCREEN_CONTROL_PARAM
{
    NET_DVR_INPUT_INTERFACE_CTRL    struInputCtrl;
    NET_DVR_DISPLAY_COLOR_CTRL         struDisplayCtrl;
    NET_DVR_DISPLAY_POSITION_CTRL     struPositionCtrl;
    NET_DVR_SIMULATE_REMOTE_CTRL struSimulateRemoteCrtl; //模拟遥控按键
    NET_DVR_SCREEN_WALL_CTRL struScreenWallCtrl; //屏幕维墙参数  
    NET_DVR_AREA_ZOOM_CFG struZoomArea;  //区域放大还原参数
    BYTE        byRes[16];
}NET_DVR_SCREEN_CONTROL_PARAM, *LPNET_DVR_SCREEN_CONTROL_PARAM;

typedef struct tagNET_DVR_SCREEN_CONTROL
{     
    DWORD     dwSize;             
    DWORD      dwCommand ;      /* 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制*/
    BYTE       byProtocol;      //串口协议类型,1:LCD-S1,2:LCD-S2
    BYTE    byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE       byRes2[52];    
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{     
    DWORD   dwSize;
    BYTE    bySerialNo;        //串口号
    BYTE    byRes[2];
    BYTE       byProtocol;    // 串口协议类型 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20，7-LCD-L2,8-LCD-Z1，
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-无效，使用预先绑定的协议类型 
    DWORD      dwCommand ;      /* 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制，6-模拟遥控按键,7-显示屏幕状态,
    8-显示屏幕特征码（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）, 9-屏幕维墙,10-恢复屏幕默认参数，11-显示IP（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）,12-屏幕USB升级 13-区域放大还原*/
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE    byWallNo;        // 电视墙号
    BYTE   byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//根据坐标进行计算，基准坐标
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo; //拼接屏号
    BYTE byWallNo; //电视墙号
    BYTE byEnable; //是否使能，0-否，1-是
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //需要进行拼接的区域，获取的时候此参数填0
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG,*LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;    //输入源索引，见枚举 INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;        //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    BYTE  byRes[30];       
}NET_DVR_MSC_SCREEN_INTERFACE_CFG,*LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

//背光参数
typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //背光，0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG,*LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//画中画参数
typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE    byEnable;    //是否启用画中画 0-不启用 1-启用
    BYTE    bySubWindowSource;    //子画面信号源，参考枚举INPUT_INTERFACE_TYPE
    BYTE    bySubWindowBorderColor;    //子画面边框颜色， 1-蓝色，2-黑色
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //子画面位置，屏幕总大小为1920*1920
    BYTE    byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG,*LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//风扇状态，0-关，1-开
    BYTE           byFanExceptionStatus;    //风扇异常状态，0-不支持，1-正常，2-异常
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //累积工作时长，单位：小时
    BYTE           byVersion[VERSION_LEN];//软件版本号
    int            iTemperature; //板卡温度，精确到个位，单位：摄氏度
    BYTE             byTempState;     //板卡温度状态，0-不支持，1-正常，2-异常
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE,*LPNET_DVR_SCREEN_WORK_STATE;

//开机logo参数
typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //开机是否显示logo,0-不显示，1-显示
    BYTE byRes[31];    
}NET_DVR_BOOT_LOGO_CFG,*LPNET_DVR_BOOT_LOGO_CFG;
//音频参数
typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //是否静音，0-否，1-是
    BYTE    byVolume; //音量大小，0-100
    char    byBalance; //声道平衡，-50-+50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;

//屏幕参数联合体
typedef union tagNET_DVR_MSC_SCREEN_PARAM
{
    NET_DVR_MSC_SCREEN_INTERFACE_CFG struInterfaceCfg; //输入源参数
    NET_DVR_SCREEN_FAN_WORK_MODE_CFG struFanWorkMode; //风扇工作模式参数
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA信号参数
    NET_DVR_SCREEN_MENU_CFG struMenuCfg; //屏幕菜单参数
    NET_DVR_VIDEO_OUT_CFG struOutEffectCfg; //显示效果参数
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemperatureCfg; //色温参数
    NET_DVR_ADC_CFG struAdcCfg; //ADC参数
    NET_DVR_SCREEN_EDGE_CFG struScreenEdgeCfg; //屏幕边缘参数
    NET_DVR_MSC_SCREEN_BACKLIGHT_CFG struBacklight; //背光参数
    NET_DVR_MSC_SCREEN_PIP_CFG struPicInPicCfg; //画中画参数
    NET_DVR_DEFOG_LCD struDefog; //去雾参数
    NET_DVR_SCREEN_WORK_STATE struWorkState; //屏幕工作状态
    NET_DVR_BOOT_LOGO_CFG struBootLogoCfg; //开始显示logo参数
    NET_DVR_LCD_AUDIO_CFG struAudioCfg; //音频参数
    BYTE byRes[256];
}NET_DVR_MSC_SCREEN_PARAM,*LPNET_DVR_MSC_SCREEN_PARAM;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数  14-音频参数
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //屏幕参数
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG,*LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //屏幕区域
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //配置的屏幕参数
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG,*LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byParamType; //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数 14-音频参数
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //屏幕区域
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND,*LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //是否启用该时间点,0-不启用，1-启用
    BYTE bySwitchType; //开关机类型，0-关机，1-开机
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //开关机时间点
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME,*LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //是否启用该时间点,0-不启用，1-启用
    BYTE bySwitchType; //开关机类型，0-关机，1-开机
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //开关机时间点
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT,*LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //周开关机计划
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //按时间点开关机参数
    BYTE byRes[64];
}NET_DVR_TIME_SWITCH_CFG,*LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //屏幕范围
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //延时时间，0-3000，单位：ms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME,*LPNET_DVR_DELAY_TIME;

//双目标定类型
typedef enum _BV_CALIBRATION_TYPE_ENUM_
{
    ENUM_BV_CALIBRATION_NONE    = 0, //未标定
        ENUM_BV_CALIBRATION_DIRECT  = 1, //双目直接标定
        ENUM_BV_CALIBRATION_SAMPLE = 2, //双目样本标定
} BV_CALIBRATION_TYPE_ENUM;


//样本标定点
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{   
    BYTE  byCalibPtID;   //标定点ID，范围[1,5]。表示此点在双目标定过程中的序号
    BYTE  byRes1[3];     //保留
    NET_VCA_POINT struPoint;  //标定点坐标
    BYTE  byRes2[16];    //保留
}NET_DVR_BV_SAMPLE_CALIB_POINT,*LPET_DVR_BV_SAMPLE_CALIB_POINT;

//开始样本标定输入参数
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //摄像机高度，单位cm
    DWORD  dwHumanHeight;  //人体身高，单位cm
    BYTE    byRes[248];      //保留
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//设置样本标定输入参数
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //标定点。即当人员保持直立行走，人脸出现在特定画面区域中时，此点表示对象两眼连线的中点。
    BYTE byRes[228]; //保留
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//结束样本标定输入参数
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256]; //保留
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//样本标定输入参数联合体
typedef union tagNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION
{   
    BYTE byRes[256]; //保留
    NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM struCalibBegin; //开始标定输入参数
    NET_DVR_BV_SAMPLE_CALIB_SET_PARAM struCalibSet; //设置标定输入参数
    NET_DVR_BV_SAMPLE_CALIB_END_PARAM struCalibEnd; //结束标定输入参数
}NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION,*LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//样本标定命令枚举
typedef enum _BV_SAMPLE_CALIB_CMD_ENUM
{
    ENUM_BV_SAMPLE_CALIB_BEGIN    = 1,   //开始标定
        ENUM_BV_SAMPLE_CALIB_SETTING  = 2,   //设置参数
        ENUM_BV_SAMPLE_CALIB_END      = 3    //结束标定
}BV_SAMPLE_CALIB_CMD_ENUM;

//样本标定结构体
typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{   
    DWORD   dwSize;     //结构体大小
    DWORD   dwChannel;  //通道号
    BYTE    byCommand; //标定命令，参见BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];    //保留
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //标定输入参数，取值依赖于字段byCommand
    BYTE    byRes2[256] ;  //保留
}NET_DVR_BV_SAMPLE_CALIBRATION,*LPNET_DVR_BV_SAMPLE_CALIBRATION;


//双目样本标定信息
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;             //结构体大小
    DWORD  dwCameraHeight;    //摄像机高度，单位cm
    float  fPitchAngle;   //摄像机俯视角度[0°, 60°],
    float  fInclineAngle; //摄像机倾斜角度[-20°,20°]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //标定点组
    BYTE  byRes[256]; //保留
}NET_DVR_BV_SAMPLE_CALIB_CFG,*LPNET_DVR_BV_SAMPLE_CALIB_CFG;

//双目图像校正参数结构体
typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{   
    float   fCamInternalMatrix[3][3];  //相机内参矩阵，包括焦距及主点坐标
    float   fDistCoeffs[8];            //镜头畸变系数
    float   fRotateMatrix[3][3];       //校正后的旋转矩阵
    float   fProjectMatrix[3][4];      //校正后的投影矩阵
    BYTE    byRes[64];              //保留
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

//左右相机校正参数
typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;                       //结构大小
    float      fReprojectMatrix[4][4];   //重投影矩阵
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //左相机校正参数
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //右相机校正参数
    BYTE    byLensType;             //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE    byRes[255];             //保留
} NET_DVR_BV_CORRECT_PARAM,*LPNET_DVR_BV_CORRECT_PARAM;

//输出视频类型
typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;     //结构大小
    BYTE   byType;     //输出视频类型，1-拼接图，2-深度图
    BYTE   byRes[63];  //保留
}NET_DVR_OUTPUT_VIDEO_TYPE,*LPNET_DVR_OUTPUT_VIDEO_TYPE;

#define MAX_CHECK_485CHAN        64    //485自检设备通道号个数

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD        dwSize;  
    DWORD        dwRS485Chan[MAX_CHECK_485CHAN];//RS485通断情况有问题的通道号，值表示通道号，位表示槽位号
    DWORD        dwSensorChan[4];//模拟量无效的通道号，按位表示
       BYTE         byRes[32];      // 保留字节 
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

//设置完全获取出厂值
typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize ; //结构体长度
    DWORD   dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;   
    DWORD        dwChannel;   //图片对应的通道号
    BYTE        byPictureType;//图片格式,0-bmp，1-jpeg，2-PNG 3-SWF 4-GIF 
    BYTE         byRes1[3];  //保留
    NET_DVR_TIME_V30 struTime;  //图片生成时间
    char*        sPictureBuffer;//图片缓冲区
    DWORD        dwPictureLength;//图片长度
    DWORD        dwPicMangeNo;  //图片管理号
    BYTE        sPicName[NAME_LEN];  //图片名称
    BYTE        byRes[92];
}NET_DVR_UPLOAD_PICTURE_INFO,*LPNET_DVR_UPLOAD_PICTURE_INFO;

#define  MAX_UPLOADFILE_URL_LEN      240

typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN] ;   //url
    BYTE byRes[260];
} NET_DVR_UPLOAD_FILE_RET,*LPNET_DVR_UPLOAD_FILE_RET;

typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];  //人脸子图坐标信息
    BYTE     byRes[64];        
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;
typedef union tagNET_DVR_PIC_EXTRA_INFO_UNION
{
    BYTE   byUnionLen[544];   //联合体长度，无实际意义
    NET_DVR_FACE_EXTRA_INFO struFaceExtraInfo;   //人脸侦测信息
}NET_DVR_PIC_EXTRA_INFO_UNION, *LPNET_DVR_PIC_EXTRA_INFO_UNION;

typedef struct    tagNET_DVR_FIND_PICTURE_V40   //查找结果结构体
{
    char    sFileName[PICTURE_NAME_LEN];//图片名
    NET_DVR_TIME struTime;//图片的时间
    DWORD dwFileSize;//图片的大小
    char    sCardNum[CARDNUM_LEN_V30];    //卡号
    BYTE   byPlateColor ;//参考结构 VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//参考结构 VLR_VEHICLE_CLASS
    BYTE   byFileType ;  //文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测
    BYTE   byRecogResult ;//识别结果参考结构VTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE   byEventSearchStatus; //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    BYTE   byRes[75];        //  保留字节
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //图片附件信息
}NET_DVR_FIND_PICTURE_V40,*LPNET_DVR_FIND_PICTURE_V40;

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byDetectionTarget;//检测目标:0-所有目标，1-人，2-车
    BYTE byRes[62];             //保留
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;

typedef    struct tagNET_DVR_REGION_ENTRANCE_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_REGIONENTRANCE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_ENTRANCE_DETECTION,*LPNET_DVR_REGION_ENTRANCE_DETECTION;

typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //通道号 
    DWORD dwRegion;         //区域ID号
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byRes[63];             //保留
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef    struct tagNET_DVR_EVENT_TRIGGER
{
    DWORD        dwSize;//结构体大小
    NET_DVR_HANDLEEXCEPTION_V41 struHandleException;     //异常处理方式
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40]; //实际触发录像通道，按值表示，采用紧凑型排列，从下标0开始顺序读取，中间遇到0xffffffff则后续无效。 
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //启用的预置点信息
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //启用巡航功能通道的信息
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //调用云台轨迹的通道信息
    BYTE        byRes2[256];
}NET_DVR_EVENT_TRIGGER,*LPNET_DVR_EVENT_TRIGGER;

typedef    struct tagNET_DVR_EVENT_SCHEDULE
{
    DWORD        dwSize;//结构体大小
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    NET_DVR_SCHEDTIME struHolidayAlarmTime[MAX_TIMESEGMENT_V30]; /*假日布防时间*/
    BYTE        byRes[128];
}NET_DVR_EVENT_SCHEDULE,*LPNET_DVR_EVENT_SCHEDULE;

typedef struct  tagNET_DVR_ANR_ARMING_HOST
{
    DWORD   dwSize;//sizeof(NET_DVR_ANR_ ARMING_HOST)
    NET_DVR_IPADDR struANRArmingHostIpAddr; //断网续传的主机IP地址
    WORD    wANRAlarmHostPort; //断网续传的主机布防端口号
    BYTE     byANRAlarmType;//断网续传连接类型， 0-SDK私有断网续传连接，1-ehome断网续传连接
    BYTE     byRes[513];      //保留字节
}NET_DVR_ANR_ARMING_HOST, *LPNET_DVR_ANR_ARMING_HOST;

typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byDetectionTarget;//检测目标:0-所有目标，1-人，2-车
    BYTE byRes[62];             //保留
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;

typedef    struct tagNET_DVR_REGION_EXITING_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_REGIONEXITING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_EXITING_DETECTION,*LPNET_DVR_REGION_EXITING_DETECTION;

typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    BYTE byRes[62];             //保留
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;

typedef    struct tagNET_DVR_LOITERING_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_LOITERING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_LOITERING_DETECTION,*LPNET_DVR_LOITERING_DETECTION;

typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE byObjectOccup; //占比，范围[1-100]
    BYTE byRes[63];             //保留
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;
typedef struct tagNET_DVR_POS_HIDDEN_INFORMATION
{
    char szKeyWord[KEY_WORD_NUM/*3*/][KEY_WORD_LEN/*128*/];
    BYTE    byRes[128];
}NET_DVR_POS_HIDDEN_INFORMATION, *LPNET_DVR_POS_HIDDEN_INFORMATION;

typedef struct tagNET_DVR_HIDDEN_INFORMATION_CFG
{
    DWORD  dwSize;
    BYTE   byFuncType;//0-Pos功能
    BYTE   Res1[3];
    NET_DVR_POS_HIDDEN_INFORMATION struPosInfo;
    BYTE    byRes[1024];
}NET_DVR_HIDDEN_INFORMATION_CFG, *LPNET_DVR_HIDDEN_INFORMATION_CFG;

typedef    struct tagNET_DVR_GROUP_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_GROUPDETECTION_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_GROUP_DETECTION,*LPNET_DVR_GROUP_DETECTION;

typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byDetectionTarget;//检测目标:0-所有目标，1-人，2-车
    BYTE byRes[62];             //保留
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;

typedef    struct tagNET_DVR_RAPIDMOVE_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_RAPIDMOVE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_RAPIDMOVE_DETECTION,*LPNET_DVR_RAPIDMOVE_DETECTION;

typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    BYTE byRes[62];             //保留
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;

typedef    struct tagNET_DVR_PARKING_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_PARKING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_PARKING_DETECTION,*LPNET_DVR_PARKING_DETECTION;

typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    WORD wTimeThreshold;//时间阈值，范围[5-3600], 单位：s
    BYTE byTimeThresholdMode;//(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    BYTE byRes[59];             //保留留
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_UNATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_UNATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_UNATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    WORD wTimeThreshold;//时间阈值，范围[5-3600], 单位：s
    BYTE byTimeThresholdMode;//(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    BYTE byRes[59];             //保留
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_ATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    NET_DVR_ATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_ATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_ATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //通道号 
    DWORD dwStreamType;     //码流类型：0- 主码流，1- 子码流，2- 第三码流
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    WORD      wResolutionWidth; //分辨率的长
    WORD      wResolutionHeight; //分辨率的宽
    NET_VCA_POLYGON    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

#define MAX_DIALNUM_LENGTH  32
typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否启用无线拨号：0-否，1- 是
    BYTE       byDialMode; // 0-自动（Auto）、1-手动（Manual），默认自动，手动模式下可设置拨号计划、下线时间、手动拨号
    BYTE       byNetworkMode; //0-自动，1-4G优先，2-3G优先，3-手动切换2G，4-手动切换3G，5-手动切换4G，6-有线优先
    BYTE        byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //拨号号码
    BYTE       byUserName[NAME_LEN]; //用户名
    BYTE       byPassword[NAME_LEN]; //密码
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //手机号码
    BYTE       byVerifProtocol;  // 0-自动（Auto），1-CHAP，2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //下线时间，30-65535，单位秒，手动模式下有效
    BYTE        byRes3[64];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;

typedef    struct tagNET_DVR_WIRELESSDIAL_SCHEDULE
{
    DWORD        dwSize;//结构体大小
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE        byRes[160];
}NET_DVR_WIRELESSDIAL_SCHEDULE,*LPNET_DVR_WIRELESSDIAL_SCHEDULE;

#define MAX_LENGTH_32   32
typedef    struct tagNET_DVR_WIRELESSDIAL_STATUS
{
    DWORD        dwSize;//结构体大小
    BYTE        byRealtimeMode[MAX_LENGTH_32]; //实时模式(CDMA 1x、EVDO、HYBRID、GSM、GPRS、EDGE、WCDMA、HSDPA、HSUPA、HSPA、TDSCDMA、TD-LTE、FDD-LTE)
    BYTE        byUIMStatus[MAX_LENGTH_32]; //UIM状态(UNKNOWN,VALID,NOVALID,ROAM,NOEXIST)
    DWORD       dwSignalQuality; //信号质量，1-100
    BYTE        byDialStatus[MAX_LENGTH_32]; //拨号状态码
    NET_DVR_IPADDR    struIpAddr;  //IP地址
    NET_DVR_IPADDR    struIPMask;  //掩码地址
    NET_DVR_IPADDR    struGatewayIPMask;  //网关地址
    NET_DVR_IPADDR    struDnsServerIpAddr; //DNS地址
    BYTE        byRes[256];    
}NET_DVR_WIRELESSDIAL_STATUS,*LPNET_DVR_WIRELESSDIAL_STATUS;

typedef    struct tagNET_DVR_WIRELESSDIAL_CONNECT
{
    DWORD        dwSize;//结构体大小
    DWORD       dwInterface; //网卡编号，1,2……
    BYTE        byEnableConnect; //是否连网，0-断网，1-连网
    BYTE        byRes[255];
}NET_DVR_WIRELESSDIAL_CONNECT_PARAM,*LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM;


typedef    struct tagNET_DVR_LITESTORAGE
{
    DWORD        dwSize;//结构体大小
    BYTE       byEnable; /*使能 0-不启用,1-启用*/
    BYTE       byStorageTime;/*存储时间 1-30 默认7天*/
    BYTE       byLevel; //等级参数，0-无效值（保留），1-低，2-中(默认)，3-高；
    BYTE        byRes;
    float           fCapacity;//可用SD卡录像空间，只读
    BYTE        byDefLowStorageTime;// 低模式下推荐天数 只读
    BYTE        byDefMediumStorageTime; // 中模式下推荐天数 只读
    BYTE        byDefHighStorageTime; // 高模式下推荐天数 只读
    BYTE       byRes1[61];
}NET_DVR_LITESTORAGE,*LPNET_DVR_LITESTORAGE;

typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;//结构体大小
    NET_VCA_POLYGON  struRegion;//标定区域
    BYTE        byRes[64];
}NET_DVR_CALIBRATION,*LPNET_DVR_CALIBRATION;

typedef    struct    tagNET_DVR_STD_CONFIG
{
    void*        lpCondBuffer;        //[in]条件参数(结构体格式),例如通道号等.可以为NULL
    DWORD        dwCondSize;            //[in] lpCondBuffer指向的内存大小
    void*        lpInBuffer;            //[in]输入参数(结构体格式),设置时不为NULL，获取时为NULL
    DWORD        dwInSize;            //[in] lpInBuffer指向的内存大小
    void*        lpOutBuffer;        //[out]输出参数(结构体格式),获取时不为NULL,设置时为NULL
    DWORD        dwOutSize;            //[in] lpOutBuffer指向的内存大小
    void*        lpStatusBuffer;        //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    DWORD        dwStatusSize;        //[in] lpStatusBuffer指向的内存大小
    void*       lpXmlBuffer;    //[in/out]byDataType = 1时有效,xml格式数据
    DWORD       dwXmlSize;      //[in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
    BYTE        byDataType;     //[in]输入/输出参数类型,0-使用结构体类型lpInBuffer/lpOutBuffer有效,1-使用XML类型lpXmlBuffer有效
    BYTE        byRes[23];
}NET_DVR_STD_CONFIG,*LPNET_DVR_STD_CONFIG;

typedef    struct    DWORDtagNET_DVR_STD_ABILITY
{
    void*        lpCondBuffer;    //[in]条件参数(码字格式),例如通道号等.可以为NULL
    DWORD        dwCondSize;        //[in] dwCondSize指向的内存大小
    void*        lpOutBuffer;    //[out]输出参数(XML格式),不为NULL
    DWORD        dwOutSize;        //[in] lpOutBuffer指向的内存大小
    void*        lpStatusBuffer;    //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    DWORD        dwStatusSize;    //[in] lpStatusBuffer指向的内存大小
    DWORD        dwRetSize;        //[out]获取到的数据长度(lpOutBuffer或者lpStatusBuffer指向的实际数据长度)
    BYTE        byRes[32];        //保留字节
}NET_DVR_STD_ABILITY,*LPNET_DVR_STD_ABILITY;

typedef struct tagNET_DVR_STD_CONTROL
{
    void*        lpCondBuffer;    //[in]条件参数(码字格式),例如通道号等.可以为NULL
    DWORD        dwCondSize;        //[in] dwCondSize指向的内存大小
    void*        lpStatusBuffer;    //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    DWORD        dwStatusSize;    //[in] lpStatusBuffer指向的内存大小
    void*       lpXmlBuffer;    //[in/out]byDataType = 1时有效,xml格式数据
    DWORD       dwXmlSize;      //[in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
    BYTE        byDataType;     //[in]输入/输出参数类型,0-使用结构体类型lpCondBuffer有效,1-使用XML类型lpXmlBuffer有效
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;

typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
    DWORD   dwSize;                        //结构体大小
    void*    lpRequestUrl;                //请求信令，字符串格式
    DWORD    dwRequestUrlLen;            //请求信令长度，字符串长度
    void*    lpInBuffer;                    //输入参数缓冲区，XML格式
    DWORD    dwInBufferSize;                //输入参数缓冲区大小
    DWORD   dwRecvTimeOut;                //接收超时时间，单位：ms，填0则使用默认超时5s
    BYTE    byRes[32];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
    DWORD   dwSize;                        //结构体大小
    void*    lpOutBuffer;                //输出参数缓冲区，XML格式
    DWORD    dwOutBufferSize;            //输出参数缓冲区大小(内存大小)
    DWORD   dwReturnedXMLSize;            //实际输出的XML内容大小
    void*    lpStatusBuffer;                //返回的状态参数(XML格式),获取命令成功时不会赋值,如果不需要,可以置NULL
    DWORD    dwStatusSize;                //状态缓冲区大小(内存大小)
    BYTE    byRes[32];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;

typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //时
    BYTE byMinute; //分
    BYTE bySecond; //秒
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //开始时间点
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //结束时间点
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byDoorStatus; //门状态模式，0-无效，1-常开状态，2-常闭状态，3-普通状态（门状态计划使用）
    BYTE byVerifyMode; //验证方式，0-无效，1-刷卡，2-刷卡+密码(读卡器验证方式计划使用)，3-刷卡,4-刷卡或密码(读卡器验证方式计划使用), 5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码（无先后顺序）
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //时间段参数
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //是否使能，1-使能，0-不使能
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //周计划参数
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byRes1[3];    
    NET_DVR_DATE struBeginDate; //假日开始日期
    NET_DVR_DATE struEndDate; //假日结束日期
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //时间段参数
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，1-启用，0-不启用
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //假日组名称
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //假日计划编号，就前填充，遇0无效
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，1-启用，0-不启用
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //模板名称
    DWORD dwWeekPlanNo; //周计划编号，0为无效
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //假日组编号，就前填充，遇0无效
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;


typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //计划模板编号，为0表示取消关联，恢复默认状态（普通状态）
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //计划模板编号，为0表示取消关联，恢复默认状态（刷卡开门）
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，0-不启用，1-启用    
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //群组有效期参数
    BYTE byGroupName[GROUP_NAME_LEN]; //群组名称
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //是否启用该群组组合    
    BYTE byMemberNum; //刷卡成员数量
    BYTE bySequenceNo; //群组刷卡次序号
    BYTE byRes;
    DWORD dwGroupNo;  //群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //是否启用该多重卡组参数，0-不启用，1-启用
    BYTE byEnableOfflineVerifyMode; //是否启用主机离线时验证方式（超级密码代替远程开门）
    BYTE byRes1[2];
    DWORD dwTemplateNo; //启用多重卡功能的计划模板编号
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //群组组合参数
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用多重卡功能，0-不启用，1-启用
    BYTE bySwipeIntervalTimeout; //刷卡间隔超时时间，1-255s，默认10s    
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //群组刷卡参数
    BYTE byRes2[32];    
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

//2014-12-03  T1测试状态结构体
typedef struct 
{
    DWORD  dwSize;//结构体大小
    WORD   wPort;  //端口号
    //(设备通过端口控制（端口号设备端固定，上层不做配置），开始单独socket连接，单独交互T1测试内容，走XML格式)
    //0- 关闭(关闭设备的连接线程，释放端口)，1- 开启(设备内部单独起连接线程)
    BYTE   byPortState;  
    BYTE   byRes[61];     //保留
}NET_DVR_T1TEST_PARAMCFG,*LPNET_DVR_T1TEST_PARAMCFG;

#define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
#define CARD_PARAM_VALID            0x00000002  //有效期参数
#define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
#define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
#define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
#define CARD_PARAM_GROUP            0x00000040  //所属群组参数
#define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
#define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //使能反潜回功能，1-使能，0-不使能
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //反潜回起始读卡器编号    
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //是否加入反潜回路径，1-加入，0-不加入
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //后续读卡器编号，为0表示不关注起始读卡器编号
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //按数组表示,是否有开门权限，-无权限，-有权限
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //按数组表示,是否有关门权限，-无权限，-有权限
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //按数组表示,是否有常开权限，-无权限，-有权限
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //按数组表示,是否有常闭权限，-无权限，-有权限
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM]; //按数组表示,是否有布防权限，-无权限，-有权限
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];  //按数组表示,是否有撤防权限，-无权限，-有权限
    BYTE    byRes[256];                              //保留
}NET_DVR_PHONE_DOOR_RIGHT_CFG,*LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用多门互锁功能，1-启用，0-不启用
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //多门互锁组参数，取值为门编号
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byCardReaderType; //读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线,8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A
                            //11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，
                            //21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP
                            //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C
    BYTE byOkLedPolarity; //OK LED极性，0-阴极，1-阳极
    BYTE byErrorLedPolarity; //Error LED极性，0-阴极，1-阳极
    BYTE byBuzzerPolarity; //蜂鸣器极性，0-阴极，1-阳极
    BYTE bySwipeInterval; //重复刷卡间隔时间，单位：秒
    BYTE byPressTimeout;  //按键超时时间，单位：秒
    BYTE byEnableFailAlarm; //是否启用读卡失败超次报警，0-不启用，1-启用
    BYTE byMaxReadCardFailNum; //最大读卡失败次数
    BYTE byEnableTamperCheck;  //是否支持防拆检测，0-disable ，1-enable
    BYTE byOfflineCheckTime;  //掉线检测时间 单位秒
    BYTE byFingerPrintCheckLevel;   //指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byRes[24]; 
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //门锁状态，0-关，1-开
    BYTE byDoorStatus[MAX_DOOR_NUM]; //门状态，1-休眠，2-常开状态，3-常闭状态，4-普通状态
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //门磁状态，0-闭合，1-开启
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; ////事件触发器状态，0-无输入，1-有输入
    WORD wBatteryVoltage; //蓄电池电压值，实际值乘10，单位：伏特
    BYTE byBatteryLowVoltage; //蓄电池是否处于低压状态，0-否，1-是
    BYTE byPowerSupplyStatus; //设备供电状态，1-交流电供电，2-蓄电池供电
    BYTE byMultiDoorInterlockStatus; //多门互锁状态，0-关闭，1-开启
    BYTE byAntiSneakStatus; //反潜回状态，0-关闭，1-开启
    BYTE byHostAntiDismantleStatus; //主机防拆状态，0-关闭，1-开启
    BYTE byIndicatorLightStatus; //指示灯状态，0-掉线，1-在线
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //读卡器在线状态，0-不在线，1-在线
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //读卡器防拆状态，0-关闭，1-开启
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //读卡器当前验证方式，1-刷卡，2-刷卡+密码，3-刷卡，4-刷卡或密码
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
    DWORD dwCardNum; //已添加的卡数量
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //触发主机蜂鸣器，0-不触发，1-触发
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //触发读卡器蜂鸣器，1-触发，0-不触发
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //关联触发的报警输出，1-关联，0-不关联
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //对门1-N关联门打开，0-不关联，1-关联（即打开）
    BYTE  byDoorClose[MAX_DOOR_NUM]; //对门1-N关联门关闭，0-不关联，1-关联（即关闭）
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;

typedef enum _ENUM_UPGRADE_TYPE
{
    ENUM_UPGRADE_DVR = 0, //普通设备升级
        ENUM_UPGRADE_ADAPTER = 1, //DVR适配器升级
        ENUM_UPGRADE_VCALIB = 2,  //智能库升级
        ENUM_UPGRADE_OPTICAL = 3, //光端机升级
        ENUM_UPGRADE_ACS = 4, //门禁系统升级
        ENUM_UPGRADE_AUXILIARY_DEV = 5,//辅助设备升级
        ENUM_UPGRADE_LED = 6 //LED发送卡和接收卡升级
}ENUM_UPGRADE_TYPE;

typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号，为0无效
    BYTE byCardType; //卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，为0无效
    BYTE byWhiteListNo; //白名单单号,1-8，为0无效
    BYTE byReportChannel; //报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
    BYTE byCardReaderKind; //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    DWORD dwDoorNo; //门编号，为0无效
    DWORD dwVerifyNo; //多重卡认证序号，为0无效
    DWORD dwAlarmInNo;  //报警输入号，为0无效
    DWORD dwAlarmOutNo; //报警输出号，为0无效
    DWORD dwCaseSensorNo; //事件触发器编号
    DWORD dwRs485No;    //RS485通道号，为0无效
    DWORD dwMultiCardGroupNo; //群组编号
    WORD wAccessChannel;    //人员通道号
    BYTE  byRes[30];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME struTime; //时间
    BYTE    sNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo; //详细参数
    DWORD dwPicDataLen;   //图片数据大小，不为0是表示后面带数据
    char    *pPicData;
    BYTE byRes[24];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;

#define JUDGE_MAX_VIDEOOUT_NUM 9

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG 
{
    DWORD   dwSize;
    BYTE    byEnable;    //是否启用
    BYTE    byRes1[3];
    DWORD   dwChanNo;    //语音激励的视频通道号 
    BYTE    bySensitivity; //灵敏度 1-100，灵敏度越高，表示较低的音量就能使能该音频输入激励功能；灵敏度越低，表示需要较高的音量才能使能该音频输入的激励功能
    BYTE    byPriority;     //优先级  0-优先级0，1-优先级1， 值越大级别越高
    WORD    wDelayTime;  //语音激励结束画面切换延迟时间，单位s, 超时后自动回到预置点1对应的画面
    BYTE    byRes2;      //保留
    BYTE    byEnablePreset; //是否启用预置点
    WORD    wPreset;    //预置点
    WORD    wBase;           /*基准点编号*/
    BYTE    byRes3[2];
       BYTE    byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];          //语音激励是否输出到视频输出口。值0表示不输出，1-表示输出。下标表示通道顺序如下：0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
    BYTE    byRes[255]; //保留
}NET_DVR_AUDIO_ACTIVATION_CFG,*LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;       //结构体大小
    BYTE   byIROutPort;   //红外输出索引，1-红外输出口1，2-红外输出口2
    BYTE   byIRCmdIndex; //红外学码命令对应的索引；
    BYTE   byRes[254]; //保留
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

#define  MAX_IR_CMD_NAME_LEN    32   //红外输出命令名称长度
#define  MAX_IR_CMD_NUM         32   //红外命令个数

typedef struct tagNET_DVR_INFRARED_CMD_INFO   //红外命令名称信息
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];  //红外命令名称
    BYTE   byRes[8];         //保留
} NET_DVR_INFRARED_CMD_INFO,*LPNET_DVR_INFRARED_CMD_INFO;


typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;  //结构体大小
    BYTE      sIROutName[MAX_IR_CMD_NAME_LEN];  //红外输出口名称
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];  //红外命令子信息
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG,*LPNET_DVR_INFRARED_CMD_NAME_CFG;

typedef enum tagIR_LEARN_SEND_DATA_TYPE_ENUM
{ 
    ENUM_SENDDATA = 0x0, //发送数据
        ENUM_SEND_LEARN_IR_CMD_START,  //发送红外学码
        ENUM_SEND_LEARN_IR_CMD_END   = 0x2  //红外学码结束 
}IR_LEARN_SEND_DATA_TYPE_ENUM;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;       //结构体大小
    BYTE  byIROutPort;  //红外输出索引，1-红外输出口1，2-红外输出口2
    BYTE  byIRCmdIndex; //红外学码命令对应的索引 
    BYTE  byRes[30];    //保留   
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;       //结构体大小
    BYTE   bySaveLearnInfo;      //保存学码信息，0-保存，1-不保存
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END,*LPNET_DVR_INFRARED_LEARN_END;

#define MAX_VIDEOIN_TYPE_NUM  10    //最大支持的视频输入源类型

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;   //输入源类型  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
    WORD  wInNum;  //支持的输入个数
    WORD  wStartNo;  //输入对应的起始号 
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;

typedef  struct tagNET_DVR_TRIAL_SYSTEM_INFO
{
    DWORD dwSize ;    //结构体大小
    BYTE   byVideoInTypeNum ;   //视频输入源类型个数
    BYTE   byRes1[3];
    NET_DVR_VIDEOIN_TYPE_INFO struVideoIn[MAX_VIDEOIN_TYPE_NUM] ;  //视频输入源
    BYTE   byRes[512 ] ;  //保留
} NET_DVR_TRIAL_SYSTEM_INFO, *LPNET_DVR_TRIAL_SYSTEM_INFO;

typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;       //结构体大小
    BYTE    byCaseNo[CASE_NO_LEN];  //案件编号
    BYTE    byCaseName[CASE_NAME_LEN]; //案件名称；
    BYTE    byLitigant1[LITIGANT_LEN]; //当事人1；
    BYTE    byLitigant2[LITIGANT_LEN]; //当事人2；
    BYTE    byChiefJudge[CHIEF_JUDGE_LEN];//审判长
    BYTE    byCaseType; //案件类型；1-刑事案件、2-民事案件
    BYTE    byShowCaseInfoTime; /* 案件信息显示时间,单位秒, 取值范围1~30*/ 
    BYTE    byRes[254]; //保留
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;

#define     MICROPHONE_NUM            16
#define     FAN_NUM                8
#define     FPGA_NUM                8
#define     MAIN_BOARD                8
#define  LOCAL_INPUT_NUM        24
#define  LAMP_STATE_NAME        32
#define  LAMP_NAME                32
#define FILE_NAME_LEN            32
typedef  struct _NET_DVR_REMOTE_PLAY_
{
    DWORD    dwSize;            
    BYTE    byFileName[FILE_NAME_LEN];   //需要播放的文件名称
    BYTE    byVideoOut[7];    //播放输出口
    BYTE    byRes1[5];
    BYTE    byType;  // 0-无意义，1-开始播放，2-停止播放
    BYTE      byRes[31];  //保留
}NET_DVR_REMOTE_PLAY, *LPNET_DVR_REMOTE_PLAY;

typedef  struct _NET_DVR_TRIAL_MICROPHONE_STATUS
{
    DWORD     dwSize ;
    BYTE    byMicrophoneStatus [MICROPHONE_NUM];//麦克风状态下标表示麦克风号0-供电，1-不供电
    BYTE    byRes[32] ;  //保留
}NET_DVR_TRIAL_MICROPHONE_STATUS, *LPNET_DVR_TRIAL_MICROPHONE_STATUS;

typedef  struct _NET_DVR_TRIAL_HOST_STATUS
{
    DWORD  dwSize ;
    DWORD  dwFanSpeed [FAN_NUM];//风扇转速
    WORD   wMainBoardTemp[MAIN_BOARD]; //主板温度
    BYTE   byFpgaTempWarn [FPGA_NUM];     //数组0-主板温度暂无报警状态，数组1-FPGA温度报警状态位，1-处于报警状态   0-处于无报警状态
    BYTE   byRes[32] ;  //保留
}NET_DVR_TRIAL_HOST_STATUS, *LPNET_DVR_TRIAL_HOST_STATUS;

typedef  struct _NET_DVR_LOCAL_INPUT_INFO_
{
    DWORD      dwSize;
    BYTE      byChannelName[NAME_LEN] ;        //通道名称
    BYTE      byRes[32] ;  //保留
}NET_DVR_LOCAL_INPUT_INFO, *LPNET_DVR_LOCAL_INPUT_INFO;

typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE     byEnable;  //是否启用
    BYTE     byRes1[3];
    BYTE     byLampName[LAMP_NAME];   //Lamp 名称，报警输出3、4口为Lamp1。报警5、6输出口为lamp2。
    BYTE     byLampState1[LAMP_STATE_NAME];   //状态1对应名称， 
    BYTE     byLampState2[LAMP_STATE_NAME];   //状态2对应名称
    BYTE     byLampState3[LAMP_STATE_NAME];   //状态3对应名称
    BYTE     byRes[32];
}NET_DVR_LAMP_STATUS,*LPNET_DVR_LAMP_STATUS;

typedef  struct _NET_DVR_LAMP_OUT
{
    DWORD        dwSize;
    NET_DVR_LAMP_STATUS  struLampInfo[2]; //数组0-表示lamp1,数组1表述lamp2
    BYTE  byRes[256];  //保留
}NET_DVR_LAMP_OUT, *LPNET_DVR_LAMP_OUT;

typedef  struct _NET_DVR_LAMP_CONTROL
{
    DWORD     dwSize ;
    BYTE  byLampNo ; //Lamp编号，对应配置Lamp数组下标
    BYTE  byLampStateNo ; //Lamp状态编号 0-无意义，1-状态1, 2-状态2， 3-状态3  对应LAMP输出口配置状态
    BYTE  byRes[14] ;  //保留
}NET_DVR_LAMP_CONTROL, *LPNET_DVR_LAMP_CONTROL;


//实时信息
typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE                byStart;          // 开始码
    BYTE                byCMD;         // 命令号，01-进入指令，02-离开指令，03-拥堵状态指令(为03时，只有byLaneState和byQueueLen有效)
    BYTE                byRes[2];        // 预留字节
    WORD                wDeviceID;      // 设备ID
    WORD                wDataLen;       // 数据长度
    BYTE                byLane;         // 对应车道号
    BYTE                bySpeed;        // 对应车速（KM/H）
    BYTE                  byLaneState;     // 车道状态；0-无状态，1-畅通，2-拥挤，3-堵塞
    BYTE                  byQueueLen;       // 堵塞状态下排队长度（比如50米）
    BYTE                byRes1[24];        //保留
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

//TPS实时过车数据上传
typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwChan ;//通道号
    NET_DVR_TIME_V30      struTime;    //检测时间
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// 交通参数统计信息
    BYTE                  byRes[24];      // 保留
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

//统计信息
typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE                  byLane;             // 对应车道号
    BYTE                  bySpeed;             // 车道过车平均速度
    BYTE                  byRes[2];             // 保留
    DWORD               dwLightVehicle;      // 小型车数量
    DWORD               dwMidVehicle;        // 中型车数量
    DWORD               dwHeavyVehicle;      // 重型车数量
    DWORD               dwTimeHeadway;      // 车头时距，以秒计算
    DWORD               dwSpaceHeadway;     // 车头间距，以米来计算
    float               fSpaceOccupyRation; // 空间占有率，百分比计算,浮点数*1000
    float               fTimeOccupyRation;  // 时间占有率，百分比计算,浮点数*1000
    BYTE                byRes1[16];               // 保留
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

// 交通参数统计信息
typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE                byStart;          // 开始码
    BYTE                byCMD;         // 命令号， 08-定时成组数据指令
    BYTE                byRes[2];        // 预留字节
    WORD                wDeviceID;      // 设备ID
    WORD                wDataLen;       // 数据长度
    BYTE                byTotalLaneNum;  // 有效车道总数
    BYTE                byRes1[15];
    NET_DVR_TIME_V30    struStartTime;    //统计开始时间
    DWORD                dwSamplePeriod;    //统计时间,单位秒
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

//TPS统计过车数据上传
typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwChan ;//通道号
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// 交通参数统计信息
    BYTE                  byRes[128];      // 保留
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;

#define     DPC_CORRECT                1    //校正
#define     DPC_CORRECT_CANCEL         2    //取消校正
#define     DPC_CROSS_DISPALY_OPEN     3    //坏点检测十字叉显示开启
#define     DPC_CROSS_DISPALY_CLOSE    4    //坏点检测十字叉显示关闭
#define     DPC_POINT                  5    //坏点校正坐标
#define     DPC_UP                     6    //坏点校正坐标点向上偏移
#define     DPC_DOWN                   7    //坏点校正坐标点向下偏移
#define     DPC_RIGHT                  8    //坏点校正坐标点向右偏移
#define     DPC_LEFT                   9    //坏点校正坐标点向左偏移
#define     DPC_ALL_CORRECT            10   //所有坏点校正
#define     DPC_SAVE                   11   //坏点保存

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    WORD    wCtrlType ;//参考宏定义
    BYTE    byRes[2];
    NET_VCA_POINT struPoint; /*输入的图像平面坐标，归一化到0-1*/
    BYTE    byRes1[64]; 
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

//非均匀性校正(FFC)手动模式
typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE   byRes[64]; 
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

//非均匀性校正(FFC)背景补偿
typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE   byRes[64]; 
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

//存储服务器开关状态
typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    /*存储图片开关；按位表示，0-关闭，1-开启
    数组0-移动侦测抓图(暂不支持)
    数组1-报警抓图(暂不支持)
    ……
    */
    BYTE  byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER]; 
    /*存储附加信息开关；按位表示，0-关闭，1-开启
    数组0-热度图(暂不支持)
    数组1-客流量(暂不支持)
    ……
    */       
    BYTE  byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER]; 
    BYTE  byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,
*LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;

//强制停止取证
typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //产生智能报警的显示通道号
    BYTE  bySubWinNo;  //产生智能报警的子窗口号
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //产生报警时间
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //码流源信息
    BYTE  *byAlarmPic; //报警图片缓冲区
    DWORD dwAlarmPicSize; //报警图片大小，单位：字节
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //是否叠加智能报警logo，0-不叠加，非0-叠加
    BYTE byFlash;   //是否闪烁，0-不闪烁，非0-闪烁
    WORD wFlashTime; //闪烁时间，单位：秒，取值范围从解码器能力集获取 
    DWORD dwLogoX;  //logo X坐标，解码窗口总大小：1920*1920
    DWORD dwLogoY;  //logo Y坐标
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //智能报警时是否上传报警图片，0-不上传，非0-上传
    BYTE byOverlayTargetInfo; //报警图片是否叠加目标信息，0-不叠加，非0-叠加
    BYTE byOverlayRuleInfo; //报警图片是否叠加智能规则信息，0-不叠加，非0-叠加
    BYTE byPicQuality;            //图片质量系数 0-最好 1-较好 2-一般
    /*图片大小 可以通过能力集获取
    0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
    6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
    11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，     
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(使用当前码流分辨率)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //智能报警logo叠加参数    
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //智能报警图片参数
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

#define MAX_OSD_LEN                 64   //输出口OSD长度
typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//图片名称
    BYTE   byUsed; //是否已存在，0-不存在，1-存在
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO,*LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD dwSize;
    DWORD  dwOutputPicNo;  //图片序号
    BYTE   byEnable; //logo是否显示，1-显示，0-隐藏
    BYTE   byRes1[3];    
    NET_DVR_RECTCFG_EX struRect;//logo位置，输出口范围总大小为1920*1920
    BYTE   byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE   byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE   byRes2[2];                //保留
    DWORD  dwOutputPicWinNo; //输出口图片窗口号（1字节设备号+1字节输出口号+2字节输出口图片窗口号）,获取全部时有效
    BYTE   byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG,*LPNET_DVR_OUTPUT_PIC_CFG;

typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //OSD是否显示，0-不显示，1-显示
    BYTE     byFontSize; //字体大小，1-大，2-中，3-小
    BYTE     byOSDColor; //OSD颜色配置，0-默认， 1-黑，2-白，3-红，4-绿，5-蓝
    BYTE     byRes1[1];    
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD内容
    NET_DVR_RECTCFG_EX struRect;//OSD位置，输出口范围总大小为1920*1920
    DWORD dwOsdWinNo; //输出口OSD窗口号（1字节设备号+1字节输出口号+2字节OSD窗口号），获取所有时有效
    BYTE     byRes2[32];                //保留
}NET_DVR_OUTPUT_OSD_CFG,*LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //显示通道号（1字节设备号+1字节保留+2字节显示通道号）
    BYTE  byRelateAudio; //是否关联子窗口音频
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //关联音频的子窗口号（1字节电视墙号+1字节子窗口号+2字节窗口号）
    DWORD dwChannel; //编码通道号，获取全部时有效
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD    dwSize;
    BYTE    bySensorChan[64];//模拟量通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byAlarmInChan[64];//报警输入通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byAlarmOutChan[64];//报警输出通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    by485Chan[64];//485通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;

typedef struct
{
    DWORD    dwSize;
    BYTE    byOutScale[8];//下标表示主辅口号，0-表示不支持，1-表示12V，2-表示24V
    BYTE    byRes[16];
}NET_DVR_OUT_SCALE_CFG, *LPNET_DVR_OUT_SCALE_CFG;

typedef    struct     tagNET_DVR_MONITOR_LOCATION_COND
{
    DWORD   dwSize; 
    DWORD   dwChan;
    /*
    0 表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
    1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    */
    BYTE    byRelateType;
    BYTE    byRes[63];        //保留
}NET_DVR_MONITOR_LOCATION_COND, *LPNET_DVR_MONITOR_LOCATION_COND;

typedef    struct     tagNET_DVR_MONITOR_LOCATION_CFG
{
    DWORD   dwSize; 
    BYTE    byMonitoringSiteID[MAX_ID_LEN/*48*/];        //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN/*48*/];                //设备编号
    BYTE    byDirectionNo;        //监测方向编号,0-无,1-上行,2-下行,3-双向,4-由东向西,5-由南向北,6-由西向东,7-由北向南,8-其他
    BYTE    byRes1[3];        //保留
    BYTE    byMonitorInfo[MONITORSITE_ID_LEN/*48*/];      //监测点信息描述
    BYTE    byRes[128];        //保留
}NET_DVR_MONITOR_LOCATION_CFG, *LPNET_DVR_MONITOR_LOCATION_CFG;

typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;    //结构大小
    DWORD   dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;               //结构大小
    BYTE    byAlarmStatus;//布防状态，0-保留,1-撤防,2-布防
    BYTE    byRes[3]; 
    WORD    wAlarmDealyTime;//布防延迟时间，单位s
    WORD    wDisAlarmDealyTime;//撤防延迟时间，单位s
    BYTE    byRes1[64]; 
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{ 
    DWORD    dwSize;
    BYTE    byCommuMode;//私有协议通信模式，0-兼容模式，1-安全模式
    BYTE    byRes1[2];
    BYTE    byWebAuthentication;    //web认证配置 0-digest、1-basic;默认basic认证
    BYTE    byRtspAuthentication;   //rtsp认证配置 0-disable、1-basic;默认basic认证
    BYTE    byTelnetServer;         //telnet设置 0～禁用，1～启用
    BYTE    bySSHServer;            //SSH设置 0～禁用(默认)，1～启用
    BYTE    byIllegalLoginLock;     //开启登陆锁定, 0-启用（默认），1-禁用
    BYTE    byStreamEncryption;     //码流加密 0-不加密，1-加密
    BYTE    byRes[27];    
}NET_DVR_SECURITY_CFG,*LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD    dwSize;
    BYTE     byRes[3];
    BYTE     byLockCount;      //对应用户名或IP被几次连续的错误密码登录后，对该用户进行锁定，0-不锁定，其他值为锁定的次数。 默认为0，例如1表示错误登录1次以后就锁定该用户名。
    DWORD  dwLockTime;       //锁定时间，表示错误后锁定的时间，单位：秒。不能为0，byLockCount不为0时，dwLockTime才有效
    BYTE     byRes1[128];        //4字节对齐
} NET_DVR_PASSWORD_MANAGE_CFG,*LPNET_DVR_PASSWORD_MANAGE_CFG;


typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD    dwSize;
    BYTE    byUnlockType;    //0-无效， 1-按IP解锁，2-解锁所有IP
    BYTE    byIPVersion;    //1-IPV4，2-IPV6，当byUnlockType为1时，该参数有效
    BYTE    byRes1[2];
    NET_DVR_IPADDR struIPAddr;        //IP地址
    BYTE     byRes[64];
} NET_DVR_UNLOCK_INFO,*LPNET_DVR_UNLOCK_INFO;

typedef  struct  tagNET_DVR_LOCKED_INFO
{
    DWORD    dwSize;
    BYTE    byIPType;    //IP类型 0-无效，1-IPV4，2-IPV6
    BYTE    byRes1[3];
    NET_DVR_IPADDR struIPAddress;
    BYTE    byRes[20];    
} NET_DVR_LOCKED_INFO,*LPNET_DVR_LOCKED_INFO;


typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];
                            /*国家索引值
                            0-算法库不支持牌识国家，1-捷克共和国(CZ - Czech Republic)，2-法国(FRA - France)，
                            3-德国(DE - Germany),4-西班牙(E - Spain), 5-意大利(IT - Italy)，6-荷兰(NL - Netherlands)，7-波兰(PL - Poland)，8-斯洛伐克(SVK - Slovakia), 9-白俄罗斯(BY - Belorussia), 10-摩尔多瓦(MDA - Moldova)，11-俄罗斯(RU - Russia)，12-乌克兰(UA - Ukraine), 0xfe-无法识别    
    */
    BYTE  byCountry;                   // 国家索引值

    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;   //图片大小
    NET_VCA_RECT       struVcaRect;  //子图在大图中的坐标位置，归一化坐标
    DWORD              dwFaceScore;  //相似度，取值范围0-100
    BYTE                byRes[228];
    BYTE               *pImage;  //其中图片要求为jpg格式
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD dwSearchType;   //搜索类型
    //&0x1 - 穿越警戒线
    //&0x2 - 区域入侵
    //&0x4 - 物品遗留
    //&0x8 - 物品拿取
    //&0x10 - 进入区域
    //&0x20 - 离开区域
    //&0x40 - 非法停车
    //&0x80 - 徘徊
    //&0x100 -人员聚集
    //&0x200 - 快速移动        
    BYTE byRes[252];  //保留
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef union tagNET_DVR_SMARTSEARCH_PIC_UNION
{  
    BYTE                byLen[256];  //联合体长度
    NET_DVR_VEHICLE_PARA     struVehiclePara; //车辆检测信息
    NET_VCA_HUMAN_FEATURE    struHumaFeature; //人脸属性
    NET_DVR_FACE_PIC_DATA_INFO   struHumaPic;     //根据人脸子图信息查询（用于远程图片的以图索图功能）  
    NET_DVR_BEHAVIOUR_COND   struBehaviourCond;  //行为分析搜索条件      
}NET_DVR_SMARTSEARCH_PIC_UNION,*LPNET_DVR_SMARTSEARCH_PIC_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA  //智能图片搜索结构体 size 344
{
    DWORD                dwChanNo;               //通道号
    DWORD                byStreamID[STREAM_ID_LEN] ;   //流ID信息，与dwChanNo相比，优先级较高，即当byStreamID不为空时，则使用流ID，为空的情况下使用dwChanNo字段
    NET_DVR_TIME_EX         struStartTime;               //录像开始的时间
    NET_DVR_TIME_EX         struEndTime;            //录像停止的时间
    WORD                wSearchType;            //智能查找类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-行为分析
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;  //智能查找条件
    BYTE               byRes[64];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

//人体特征识别结果
typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;   //相似度 0-100
    NET_VCA_RECT   struVcaRect;    //人脸区域，归一化坐标
    BYTE           byRes2[236];   //保留
}NET_DVR_FACE_SUB_PIC_INFO ,*LPNET_DVR_FACE_SUB_PIC_INFO;


typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT struVcaRect;
    BYTE         byRes2[240];   //保留
}NET_DVR_BEHAVIOR_INFO ,*LPNET_DVR_BEHAVIOR_INFO;

typedef union tagNET_DVR_PIC_FEATURE_UNION
{  
    BYTE                         byLen[256];         //联合体长度
    NET_DVR_PLATE_INFO              struPlateInfo;      //车辆检索信息
    NET_DVR_FACE_SUB_PIC_INFO       struFaceSubInfo;    //人脸子图信息
    NET_DVR_BEHAVIOR_INFO           struBehavior;       //行为分析对应的子图信息
}NET_DVR_PIC_FEATURE_UNION,*LPNET_DVR_PIC_FEATURE_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];//文件名
    NET_DVR_TIME_EX     struTime;                      //图片的抓图时间
    DWORD   dwFileSize;                 //文件的大小
    WORD    wPicType;                  //图片类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-穿越警戒线，4-区域入侵， 5-物品遗留， 6-物品拿取， 7-进入区域， 8-离开区域， 9-非法停车，10-徘徊，11-人员聚集，12-快速移动
    BYTE    byRes1[2];                  //保留
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;  //图片属性
    BYTE    byRes[32];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET; 

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;   //是否听到声音 0-未听到，1-听到
    BYTE  byRes[31];     //保留
}NET_DVR_T1TEST_SEND_DATA_BUZZER,*LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef union NET_DVR_T1TEST_DATA_UNION
{
    BYTE  byUnionLen[32];
    NET_DVR_T1TEST_SEND_DATA_BUZZER struBuzzer;  //蜂鸣器
    NET_DVR_TIME_V30  struCurTime;   //当前PC机时间
}NET_DVR_T1TEST_DATA_UNION,*LPNET_DVR_T1TEST_DATA_UNION;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;     //结构体大小
    BYTE  byDataType;  //数据类型 0-蜂鸣器，1-pc本地时间
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;  //发送的数据内容
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA,*LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG  //图像建模参数配置
{
    DWORD       dwSize;    //结构体大小
    BYTE         byEnable;     //是否启用
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM  //鼠标信息配置
{
    DWORD           dwSize;   //结构体大小
    BYTE            byMouseEvent;  //鼠标事件类型， 0-鼠标左键单击，1-鼠标左键双击，2-鼠标右键，3-滚轮上滚，4-滚轮下滚
    BYTE            byRes1[3];    //保留
    NET_VCA_POINT   struPoint;    //鼠标点位置坐标，归一化处理
    BYTE            byRes[64];    //保留
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC开关 0-不开启，1-开启
    BYTE  byMode;              //模式, 0-快速, 1-普通,2-慢速
    BYTE  byFilterQValue;      //自适应滤波器Q值，单位Oct, 0-1/40,1-1/10, 默认值为1/40 Oct
    BYTE  byStaticFilterNum;   //静态滤波器数量，取值范围0-12  
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG,*LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;  //结构体大小
    DWORD  dwHighPassFilter;         //高通滤波器 取值范围 0-127, 具体索引代表含义以能力集为准
    DWORD  dwNoiseMargin;            //噪声门限，取值范围 0-127, 具体索引代表含义以能力集为准
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //自动限波控制参数，当音频输入源为macIn时有效
    BYTE   byRes[64];
}NET_DVR_MIX_AUDIOIN_CFG,*LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;  //结构体大小
    BYTE    byModulatorEnbale;  //是否启用相位调制器
    BYTE    byPostFilter;       //Post Filter开关，0-关闭，1-开启，默认开启
    BYTE    byLimitPressure;    //输出压限开关 0-关闭，1-开启，默认开启
    BYTE    byRes1;             //保留 
    WORD    wModulatorValue;    //相位调制量 取值范围 0-127, 具体索引代表含义以能力集为准，默认10
    WORD    wTriggerTime;       //压限触发时间，取值范围 0-127, 具体索引代表含义以能力集为准
    WORD    wFreeTime;          //压限释放时间，取值范围 0-127, 具体索引代表含义以能力集为准
    BYTE    byCompressThreshold; //压缩门限 0-1X,1-2X,2-4X,3-8X  X表示倍，比如2X表示2倍
    BYTE    byCompressMode;     //压缩方式，0-硬压缩，1-软压缩，默认为硬压缩
    BYTE    byCompressRate;    //压缩率 
    BYTE    byRecoveryGain;    //回复增益 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //输出增益 0 ~100（负值）
    BYTE    byRes[61];
}NET_DVR_MIX_AUDIOOUT_CFG,*LPNET_DVR_MIX_AUDIOOUT_CFG;

#define MAX_AUDIOOUT_PRO_TYPE                8    //音频输出处理方式
typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD    dwSize;  //结构体大小
    WORD    wVolume[MAX_AUDIOOUT_PRO_TYPE];      //音量大小 取值范围 0-127, 具体索引代表含义以能力集为准
    BYTE    byPhantomPowerSupply;    //是否使用幻象电源供电(音频输入通道为MIC时有效)，0-无意义，1-不供电，2-供电
    BYTE    byEnableAEC;    //是否启用全局的回声消除,0-不启用，1-启用
    BYTE    byRes1[2];
    BYTE    byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];    //是否启用FBC(啸叫抑制),0-不启用，1-启用
    BYTE    byRes[20];     //保留
}NET_DVR_VOLUME_CFG,*LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG  //视频输出口分辨率配置
{
    DWORD       dwSize;    //结构体大小
    BYTE         byResolution;     //分辨率 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];  /* 主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有'.'则认为是域名,否则为IP地址  */
    WORD   wPort;
    BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO,*LPNET_DVR_ADDR_DOMAIN_INFO;

#define MAX_CENTERNUM_V40     6    //报警中心地址个数

//报警中心网络配置
typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD    dwSize;
    BYTE    byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];  /* 辅报警主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有’.’则认为是域名,否则为IP地址 */
    WORD    wAuxiliaryAlarmPort;     /* 辅报警主机端口号 */
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40]; //报警中心地址信息
    BYTE    byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

//雷达调试报警上传 抓拍机4.0新增
typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD             dwSize;
    DWORD             dwRadarTriggerTimeSecond;//雷达触发时间，秒
    DWORD             dwRadarTriggerTimeMSecond;//雷达触发时间，毫秒
    DWORD             dwVedioTriggerTimeSecond;//视频触发时间，秒
    DWORD             dwVedioTriggerTimeMSecond;//视频触发时间，毫秒
    DWORD             dwVedioRadarDiffTimeMSecond;//雷达视频触发时间差，毫秒
    DWORD             dwRadarSpeed;//雷达速度
    BYTE              byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

#define MAX_FINGER_PRINT_LEN            768  //最大指纹长度
typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    DWORD dwFingerPrintLen;     //指纹数据长度
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //需要下发指纹的读卡器，按数组表示，0-不下发该读卡器，1-下发到该读卡器
    BYTE  byFingerPrintID;     //指纹编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //指纹数据内容
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG,*LPNET_DVR_FINGER_PRINT_CFG;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
    BYTE  byFingerPrintID;     //指纹编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byTotalStatus;  //下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    BYTE  byRes1;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    DWORD dwCardReaderNo;  //纹读卡器编号，可用于下发错误返回
    BYTE  byRes[24];
}NET_DVR_FINGER_PRINT_STATUS,*LPNET_DVR_FINGER_PRINT_STATUS;


typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器信息，按数组表示
    DWORD dwFingerPrintNum; //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    BYTE  byFingerPrintID;     //指纹编号，有效值范围为-10   0xff表示该卡所有指纹
    BYTE  byCallbackMode;     //设备回调方式，0-设备所有读卡器下完了范围，1-在时间段内下了部分也返回
    BYTE  byRes1[26];          //保留
}NET_DVR_FINGER_PRINT_INFO_COND,*LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器信息，按数组表示
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];        //需要获取的指纹信息，按数组下标，值表示0-不删除，1-删除该指纹
    BYTE  byRes1[34];          //保留
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;  //按值表示，指纹读卡器编号
    BYTE  byClearAllCard;  //是否删除所有卡的指纹信息，0-按卡号删除指纹信息，1-删除所有卡的指纹信息
    BYTE  byRes1[3];       //保留
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byRes[548];          //保留
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE
{
    BYTE   uLen[588];   //联合体长度
    NET_DVR_FINGER_PRINT_BYCARD       struByCard;     //按卡号的方式删除
    NET_DVR_FINGER_PRINT_BYREADER     struByReader;   //按读卡器的方式删除
}NET_DVR_DEL_FINGER_PRINT_MODE,*LPNET_DVR_DEL_FINGER_PRINT_MODE;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //删除方式，0-按卡号方式删除，1-按读卡器删除
    BYTE  byRes1[3];       //保留
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //处理方式
    BYTE  byRes[64];          //保留
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef enum _ACS_DEV_SUBEVENT_ENUM_
{
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,      //主机防拆报警
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,    //离线事件满90%报警
    EVENT_ACS_NET_BROKEN,                   //网络断开
    EVENT_ACS_NET_RESUME ,                  //网络恢复
    EVENT_ACS_LOW_BATTERY,                  //蓄电池电压低
    EVENT_ACS_BATTERY_RESUME,               //蓄电池电压恢复正常
    EVENT_ACS_AC_OFF,                       //交流电断电
    EVENT_ACS_AC_RESUME,                    //交流电恢复
    EVENT_ACS_SD_CARD_FULL,                 //SD卡存储满报警
    EVENT_ACS_LINKAGE_CAPTURE_PIC           //联动抓拍事件报警
}ACS_DEV_SUBEVENT_ENUM;

typedef enum _ACS_ALARM_SUBEVENT_ENUM_
{
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,    //防区短路报警
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,       //防区断路报警
    EVENT_ACS_ALARMIN_EXCEPTION,            //防区异常报警
    EVENT_ACS_ALARMIN_RESUME,               //防区报警恢复
    EVENT_ACS_CASE_SENSOR_ALARM,            //事件输入报警
    EVENT_ACS_CASE_SENSOR_RESUME            //事件输入恢复
}ACS_ALARM_SUBEVENT_ENUM;

typedef enum _ACS_DOOR_SUBEVENT_ENUM_
{
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN  = 0,        //首卡开门开始
    EVENT_ACS_LEADER_CARD_OPEN_END,             //首卡开门结束
    EVENT_ACS_ALWAYS_OPEN_BEGIN ,               //常开状态开始
    EVENT_ACS_ALWAYS_OPEN_END,                  //常开状态结束
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,               //常关状态开始
    EVENT_ACS_ALWAYS_CLOSE_END,                 //常关状态结束
    EVENT_ACS_LOCK_OPEN,                        //门锁打开
    EVENT_ACS_LOCK_CLOSE,                       //门锁关闭
    EVENT_ACS_DOOR_BUTTON_PRESS,                //开门按钮按下
    EVENT_ACS_DOOR_BUTTON_RELEASE,              //开门按钮放开
    EVENT_ACS_DOOR_OPEN_NORMAL,                 //正常开门（门磁）
    EVENT_ACS_DOOR_CLOSE_NORMAL ,               //正常关门（门磁）
    EVENT_ACS_DOOR_OPEN_ABNORMAL,               //门异常打开（门磁）
    EVENT_ACS_DOOR_OPEN_TIMEOUT,                //门打开超时（门磁）
    EVENT_ACS_REMOTE_OPEN_DOOR,                 //远程开门
    EVENT_ACS_REMOTE_CLOSE_DOOR,                //远程关门
    EVENT_ACS_REMOTE_ALWAYS_OPEN,               //远程常开
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,              //远程常关
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,                   //卡不属于多重认证群组
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,              //卡不在多重认证时间段内
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,            //多重认证模式超级密码认证失败
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,           //多重认证模式远程认证失败
    EVENT_ACS_MULTI_VERIFY_SUCCESS,                     //多重认证成功
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,            //多重多重认证需要远程开门
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,  //多重认证超级密码认证成功事件
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,          //多重认证重复认证失败
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,                     //多重认证超时失败
    EVENT_ACS_REMOTE_CAPTURE_PIC,                       //远程抓拍
    EVENT_ACS_DOORBELL_RINGING,                          //门铃响
    EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM       //门控安全模块防拆报警
}ACS_DOOR_SUBEVENT_ENUM;

typedef enum _ACS_CARD_READER_SUBEVENT_ENUM_
{
    EVENT_ACS_STRESS_ALARM = 0,                            //胁迫报警
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,              //读卡器防拆报警
    EVENT_ACS_LEGAL_CARD_PASS,                          //合法卡认证通过
    EVENT_ACS_CARD_AND_PSW_PASS,                        //刷卡加密码认证通过
    EVENT_ACS_CARD_AND_PSW_FAIL,                        //刷卡加密码认证失败
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,                     //刷卡加密码认证超时
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,               //读卡器认证失败超次
    EVENT_ACS_CARD_NO_RIGHT,                            //卡未分配权限
    EVENT_ACS_CARD_INVALID_PERIOD,                      //卡当前时段无效
    EVENT_ACS_CARD_OUT_OF_DATE,                         //卡号过期
    EVENT_ACS_INVALID_CARD,                             //无此卡号
    EVENT_ACS_ANTI_SNEAK_FAIL,                          //反潜回认证失败
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,                 //互锁门未关闭
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,                 //指纹比对通过
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,                 //指纹比对失败
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,             //刷卡加指纹认证通过
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,             //刷卡加指纹认证失败
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,          //刷卡加指纹认证超时
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,      //刷卡加指纹加密码认证通过
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,      //刷卡加指纹加密码认证失败
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,   //刷卡加指纹加密码认证超时
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,           //指纹加密码认证通过
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,           //指纹加密码认证失败
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,        //指纹加密码认证超时
    EVENT_ACS_FINGERPRINT_INEXISTENCE                   //指纹不存在
}ACS_CARD_READER_SUBEVENT_ENUM;

typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //事件主类型，0-设备事件，1-报警输入事件，2-门事件，3-读卡器事件
    WORD          wSubEventType;                      //事件次类型
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;

typedef  union tagNET_DVR_EVETN_CARD_LINKAGE_UNION
{
    BYTE                           byCardNo[ACS_CARD_NO_LEN];          //卡号
    NET_DVR_EVENT_LINKAGE_INFO  struEventLinkage;                   //事件联动时参数
}NET_DVR_EVETN_CARD_LINKAGE_UNION,*LPNET_DVR_EVETN_CARD_LINKAGE_UNION;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD            dwSize;    //结构体大小
    BYTE              byProMode;                          //联动方式，0-事件，1-卡号   
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //联动方式参数
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //关联的报警输出号，按数组表示，为0表示不关联，为1表示关联
    BYTE           byRes2[32];                         //保留
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //按数组表示,是否联动开门，0-不联动，1-联动
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //按数组表示,是否联动关门，0-不联动，1-联动
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //按数组表示,是否联动常开，0-不联动，1-联动
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //按数组表示,是否联动常关，0-不联动，1-联动
    BYTE           byMainDevBuzzer;                    //主机蜂鸣器   0-不联动，1-联动输出
    BYTE           byCapturePic;                           //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    BYTE           byRes3[30];                         //保留
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //联动读卡器蜂鸣器，按数组表示，0-不联动，1-联动
    BYTE           byRes[128];                           //保留
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;     //主机IP地址
    BYTE   byIsStartAddr; //是否为开始地址，0-否，1-是
    BYTE   byHostNo;      //主机编号，1-8，主要用于读卡器顺序设置
    BYTE   byRes[34];     //保留
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;   //反潜回主机编号
    BYTE  byRes[5];           //保留
    WORD wFollowUpCardReader; //该反潜回主机下的读卡器编号
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //是否加入反潜回路径，1-加入，0-不加入
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //后续主机地址信息
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //起始读卡器编号 当该内容全为0时，表示不关注从哪个读卡器开始
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE         byEnable;             //是否加入反潜回路径，1-加入，0-不加入
    BYTE          byAntiSnealHostNo;   //反潜回主机编号
    WORD         wReaderID;              //读卡器ID
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //后续主机读卡器编号
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD           dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];  //读卡器信息
    BYTE            byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD           dwSize;            //结构体大小
    BYTE            byRS485Backup;  //是否启用下行RS485通信备份功能，0-不启用，1-启用
    BYTE            byShowCapPic;    //是否显示抓拍图片， 0-不显示，1-显示
    BYTE            byShowCardNo;    //是否显示卡号，0-不显示，1-显示
    BYTE            byShowUserInfo;  //是否显示用户信息，0-不显示，1-显示
    BYTE            byOverlayUserInfo;//是否叠加用户信息，0-不叠加，1-叠加
    BYTE            byVoicePrompt;  //是否启用语音提示，0-不启用，1-启用
    BYTE             byUploadCapPic;     //联动抓拍是否上传图片，0-不上传，1-上传
    BYTE             bySaveCapPic;    //是否保存抓拍图片，0-不保存，1-保存
    BYTE            byInputCardNo;  //是否是否允许按键输入卡号，0-不允许，1-允许
    BYTE byRes[503];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_PLATFORM_VERIFY_CFG
{
    DWORD       dwSize;
    DWORD        dwDoorNo; //门编号
    BYTE        byResultType; //认证结果类型，0：非法，1：合法
    BYTE        byRes1[3];
    BYTE        byScreenDisplay[MAX_SCREEN_DISPLAY_LEN]; //LED屏幕显示，用于显示认证相关信息
    BYTE        byRes[300];                  // 保留字节
}NET_DVR_PLATFORM_VERIFY_CFG, *LPNET_DVR_PLATFORM_VERIFY_CFG;

typedef struct tagNET_DVR_PERSON_STATISTICS_CFG
{
    DWORD dwSize;
    BYTE byEnableStatistics;  //是否开启人数统计，0：不开启；1：开启；
    BYTE byEnableOfflineStatistics;  //是否开启离线人数统计，0：不开启；1：开启；
    BYTE byRes[606];
}NET_DVR_PERSON_STATISTICS_CFG, *LPNET_DVR_PERSON_STATISTICS_CFG;

typedef struct tagNET_DVR_ACS_SCREEN_DISPLAY_CFG
{
    DWORD dwSize;
    DWORD dwFontSize;  //字体大小，[1,10]；
    DWORD dwRowSpacing;  //行间距，单位：像素点；
    DWORD dwColumnSpacing;  //列间距，单位：像素点；
    DWORD dwFirstRowPosition;  //起始行位置在屏幕哪一个分块，0：0、 1：1/8:、 2：2/8、 3：3/8、 4：4/8、 5：5/8、 6：6/8:、 7：7/8；
    BYTE byDegree;  //字符显示方向角度，0-0度（正常），1-90度（侧着）；
    BYTE byScreenType;  //屏幕类型，0-DC48270RS043_01T，1-DC80480B070_03T；
    BYTE byRes[306];
}NET_DVR_ACS_SCREEN_DISPLAY_CFG, *LPNET_DVR_ACS_SCREEN_DISPLAY_CFG;

typedef struct tagNET_DVR_GATE_TIME_CFG
{
    DWORD dwSize;
    DWORD dwHoldOnALarmTime;  //延续报警器蜂鸣时间，单位ms
    DWORD dwHoldOnGateOpenTime;  //闸门收到关闭命令前继续保持打开状态时间，单位ms
    DWORD dwPostponeIntrusionAlarmTime;  //推迟触发闯入欺骗行为报警时间，单位ms
    DWORD dwNoLaneAccessTimeLimitTime;  //通道收到有效通行认证信号，但无人通行超时报警时间，单位s
    DWORD dwSafetyZoneStayTime;  //通道收到有效通行认证信号，乘客到达安全区后滞留通道超时报警时间，单位s
    BYTE byRes[300];
}NET_DVR_GATE_TIME_CFG, *LPNET_DVR_GATE_TIME_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //卡密码
    DWORD dwErrorCode; //获取卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
    BYTE byCardValid; //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    DWORD dwErrorCode; //发送卡密码开门使能配置返回的错误码，成功为0，失败返回错误码 
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;

//条件结构
typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

//参数结构
typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    //数据流水号 和（上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段sDataIndex对应）
    char   sDataIndex[DATA_INDEX_LEN];
    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应)
    WORD  wTaskNo;
    BYTE  byRes1[2];
    NET_VCA_RECT  struPlateRect;//车牌位置
    char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    /*
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别； 
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    */
    DWORD  dwRecogOperate;
    /*
    车辆图片数据上传
    bit0-车牌图片：0-不上传，1-上传； 
    bit1-车辆图片：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带子图(主驾驶)：0-不上传，1-上传；
    bit5-安全带子图(副驾驶)：0-不上传，1-上传；
    */
    DWORD  dwDataUploadType;
    BYTE   byRes[131];
    BYTE   byPicDataType;//图片数据类型，0-图片数据，1-URL
    //图片数据
    //当byPicDataType == 0的时候，该字段内的数据无效，图片数据在结构体后面
    //当byPicDataType == 1的时候，是指定的图片的URL信息
    char  sPicDataPath[256];
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;

//条件结构
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    char   sDataIndex[DATA_INDEX_LEN];//数据流水号    全0的时候表示获取全部 
    WORD  wTaskNo;//任务处理号         值为0的时候表示全部任务
                  /*
                  任务状态
                  bit0-完成状态的任务：0-不查询，1-查询；
                  bit1-执行中的任务：0-不查询，1-查询；
                  bit2-等待中的任务：0-不查询，1-查询；
    */
    BYTE   byTask;
    BYTE   byRes[125];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

//参数结构
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    char   sDataIndex[DATA_INDEX_LEN];//数据流水号
    WORD  wTaskNo;//任务处理号
    WORD  wTaskProgress;//任务执行进度（实际进度*1000）
    BYTE   byTaskState;//任务状态，0-等待中，1-执行中，2-完成
    BYTE   byRes1[3];
    /*
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别； 
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    
    */
    DWORD  dwRecogOperate;
    BYTE   byRes[128];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;

typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //结构
    //数据流水号 和（上传数据INTER_VEHICLE_RECOG_COND中的字段sDataIndex对应）
    char   sDataIndex[DATA_INDEX_LEN];
    //任务处理号 和 (上传数据INTER_DVR_SETUPALARM_PARAM中的字段dwTaskNo对应 同时 下发任务结构 INTER_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    WORD  wTaskNo; 
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;//车牌位置
    char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    BYTE  byVehicleType;    //车辆类型，参考VTR_RESULT
    BYTE  byColorDepth;     //车身颜色深浅，参考 0-深色，1-浅色
    BYTE  byColor;         //车身颜色,  参考VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //车辆主品牌
    BYTE  byVehicleSubLogoRecog; //车辆子品牌
    BYTE  byPilotSafebelt;//0-表示未知,1-不系安全带,2-系安全带
    BYTE  byCopilotSafebelt;//0-表示未知,1-不系安全带,2-系安全带
    BYTE  byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE  byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE  byVehicleModel;// 参考文档  车辆子品牌年款
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" 
    BYTE  byRes1[251];
    // 0-数据直接上传; 1-云存储服务器URL原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE  byDataType;
    /*
    上传图片类型信息:
    bit0-车辆图：0-不上传，1-上传； 
    bit1-车牌图：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带识别(主驾驶)：0-不上传，1-上传；
    bit5-安全带识别(副驾驶)：0-不上传，1-上传；
    */
    DWORD  dwPicType; //0:无图片信息;: 车辆图;:车牌图;
    BYTE    *pVehicleBuffer;    //车辆图片数据指针
    DWORD  dwVehicleBufferLen ;// 车辆图片数据长度
    BYTE    *pPlateBuffer;    //车牌图片数据指针
    DWORD  dwPlateBufferLen ;// 车牌图片数据长度
    BYTE    *pPilotFaceBuffer;    //人脸子图(主驾驶)图片数据指针
    DWORD  dwPilotFaceBufferLen ;// 人脸子图(主驾驶)图片数据长度
    BYTE    *pCopilotFaceBuffer;    //人脸子图(副驾驶)图片数据指针
    DWORD  dwCopilotFaceBufferLen ;// 人脸子图(副驾驶)图片数据长度
    BYTE    *pPilotSafebeltBuffer;    //安全带识别(主驾驶)图片数据指针
    DWORD  dwPilotSafebeltBufferLen ;// 安全带识别(主驾驶)图片数据长度
    BYTE    *pCopilotSafebeltBuffer;// 安全带识别(副驾驶)图片数据指针
    DWORD  dwCopilotSafebeltBufferLen ;// 安全带识别(副驾驶)图片数据长度
    NET_VCA_RECT  struVehicleRect ;//车身矩形坐标
    NET_VCA_RECT  struPilotRect ;//主驾驶矩形坐标
    NET_VCA_RECT  struCopilotRect ;//副驾驶矩形坐标
    BYTE   Res2[80] ;
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

#define MAX_ZONE_LINKAGE_CHAN_NUM    4    /* 防区关联最大通道数*/

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD                    dwSize;
    BYTE    byAddressType;    //0 - ipv4/ipv6地址，1 - 域名
    BYTE    byRes1;
    WORD    wServerPort;                //服务器端口
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                    //服务器域名
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                    //IP地址
    }unionServer;//使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    WORD                    wInterval;    //报警间隔时间,0-30s
    BYTE                    byRes3[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE    byDDNSType;        //域名服务器类型：0 - 无效，1 - IPServer(私有DNS)，2 - hiDDNS
    BYTE    byRes1;
    WORD    wDDNSPort;                        //域名服务器端口号
    BYTE    byServerAddr[MAX_DOMAIN_NAME];    //域名服务器地址
    BYTE    byDevName[MAX_DOMAIN_NAME];            //设备名称
    BYTE    byDevSerialNum[SERIALNO_LEN];    //设备序列号
    BYTE    byAddressType;    //0 - ipv4/ipv6地址，1 - 域名
    BYTE    byRes2;
    WORD    wDevPort;        //设备端口号    
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                                    //域名
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                                    //IP地址
    }unionDevAddr;//使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    BYTE    sUserName[NAME_LEN/*32*/];    //用户名
    BYTE    sPassword[PASSWD_LEN/*16*/];//密码
    DWORD    dwChannel;                    //联动通道号
    BYTE    byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD    dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];    // 每个防区可以关联四个视频通道
    BYTE    byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;    //屏幕索引号
    BYTE byOnOffLine;    //屏幕是否在线，0-离线，1-在线，当屏幕离线时，本结构后续参数无效
    BYTE byTempState;    //板卡温度状态，0-正常，1-异常
    BYTE byFanState;        //风扇状态，0-关，1-开
    BYTE byFanException;    //风扇异常状态，0-不支持 1-正常，2-异常
    BYTE byTemperature;    //屏幕板卡温度，单位：摄氏度
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

//传感器上传信息
typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD   dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //传感器名称
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //传感器通道
    BYTE    byReboot; //之前是否重启过（一般是重启的后的第一条数据带有这个标志）0-表示没有重启，1-有过重启
    BYTE    byPowerSupply;//是否正常供电 0-不在供电，1-正在供电
    BYTE    byStatusType;//设备状态:0:正常、1：异常、2、报警
    BYTE    bySensorType;//参考传感器枚举类型SENSOR_TYPE
    float      fVoltageValue;//电压值； 精确到0.001
    float    fCurrentValue;//电流值；精确到0.001
    float   fActualValue;//模拟信号转换后的数值；精确到0.001
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //描述信息;当设备状态（byStatusType）为非0时生效。
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

//抓拍图片上传
typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize; 
    NET_DVR_TIME_V30  struTime;
    DWORD    dwChannel;//通道号
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//图片长度
    BYTE    *pBuffer;    //图片数据指针
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;

#define MAX_MASK_AREA_NUM                   8   //马赛克区域个数

typedef struct tagNET_DVR_AREA_MASK_CFG  //区域马赛克
{
    DWORD  dwSize;  //结构体大小
    BYTE   byEnable;//是否启用马赛克   0-否，1-是
    BYTE   byMaskThick;  //马赛克厚度 0-薄码，1-中码，2-厚码，薄码的区块大小为8*8，中码16*16，厚码32*32。默认为中码
    BYTE   byRes1[2];
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM];//马赛克区域范围
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG  //音频变音
{
    DWORD  dwSize;  //结构体大小
    BYTE   byEnable;  //是否启用变音 0-不启用，1-启用
    char    byBassValue;   //高低音值，范围为-12-12 值越大声音越细，反之越小，0-表示不变音
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //wifi模式下DHCP范围配置
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;   //开始IP地址
    NET_DVR_IPADDR   struEndAddr;     //结束IP地址
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;


typedef struct tagNET_DVR_WIFI_CLIENT_INFO  //音频变音
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;  //IP地址
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //连接速度 单位KB
    BYTE        byRSSIValue;         //接收到的信号强度，取值为负值，传输时不带赋值，范围为0~-110dbm,值越大，代表信号越强
    BYTE        byRes1;         //保留
    WORD        wBandwidth;     //网络带宽  单位KB 
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG  //多码流关联通道
{
    DWORD       dwSize;              //结构体大小
    DWORD       dwChannel;           //关联的编码通道号
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;

typedef struct  
{
    BYTE byPort;   //端口
    BYTE byMasterSlaveProperty;   //端口主从属性  1-主  2-从
    BYTE byPortEthernetType;  //端口类型，1-百兆端口，2-千兆端口
    BYTE byRes[9]; 
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;
typedef struct  
{
    DWORD   dwSize; 
    BYTE     byEnable;     //是否启用， 0-不启用， !0-启用
    BYTE     byProtoType;  //协议类型， 1-光端机组网协议(私有)，2-综合平台组网协议（私有），3-G8032协议（公有）
    BYTE   byBandWidth;   //环网带宽类型，1-百兆，2-千兆
    BYTE     byRes1;        //保留字段
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //环网端口
    BYTE      byRes2[60];    //保留字段
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;
typedef struct  //
{
    DWORD   dwSize;   //结构体大小
    BYTE     byStatus;              //环网状态，1-正常 2-断开
    BYTE     byMasterSlaveProperty ; //光纤板主从属性 1-主  2-从
    BYTE     byRes[62];            //保留字段
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

//火点检测报警
typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize; //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byRes1[2];
    DWORD   dwPicDataLen;//报警抓拍图片长度
    BYTE    *pBuffer;    //数据指针
    NET_VCA_RECT struRect;//火点框 
    NET_VCA_POINT struPoint ;//火点框内最高温度点坐标
    WORD    wFireMaxTemperature ;//火点最高温度[300℃~4000℃]
    WORD    wTargetDistance ;//目标距离[100m ~ 10000m]
    BYTE    byRes[96];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

//火点检测配置
typedef    struct tagNET_DVR_FIREDETECTION_CFG
{
    DWORD    dwSize;//结构体大小
    BYTE    byEnabled;  //是否使能：0- 否，1- 是
    BYTE    bySensitivity; //检测灵敏度: 1~100默认5s
    BYTE    byFireComfirmTime;//发现火点等待时间: 0-120秒 默认5s
    BYTE    byFireRegionOverlay;//码流叠加火点框: 0- 否，1- 是
    BYTE    byRes[128];
}NET_DVR_FIREDETECTION_CFG,*LPNET_DVR_FIREDETECTION_CFG;

#define MAX_PLAYLIST_NUM        50          //最大播放列表数目 
#define MAX_PLAYPLAN_NUM        50          //最大播放计划数目 

#define MAX_LEN_256                     256 
#define MAX_GROUP_RECORD_NUM            10      //最大记录个数
typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize; 
    DWORD  dwAreaID;   //区域ID
    DWORD  dwMonitorID;  //当前开始获取的监控点编号，从1开始
    BYTE   byIsNeedGroup;  //是否查询关联分组信息
    BYTE   byRes [127];
}NET_DVR_AREA_MONITOR_COND,*LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;  
    BYTE  byDelType;     //删除类型，0-删除指定区域的所有监控点，1-删除指定区域的指定监控点
    DWORD  dwAreaID;   //区域ID
    DWORD  dwMonitorID;   //监控点ID（当byDelType为0时无效，当byDelType为1时有效），从1开始
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND,*LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_COND
{
    DWORD       dwSize;         //结构体大小
    BYTE        byType;         //黑白名单标志：- 全部，- 白名单，- 黑名单
    BYTE        byRes1[3];      //保留
    DWORD       dwFaceID;       //人脸名单ID
    DWORD       dwMaxSnapNum;   //最大抓拍张数，0-表示不限制
    BYTE        byRes[256];
}NET_DVR_BLACKLIST_ALARM_COND, *LPNET_DVR_BLACKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;         //结构体大小
    DWORD        dwStorageID;    //从当前编号开始获取剩余资源，从1开始
    BYTE        byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_RECORD
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwSnapFacePicID;    //抓拍人脸ID
    DWORD            dwRegisterID;        //名单注册ID号（只读）
    DWORD            dwGroupNo;            //分组号
    BYTE            byRes[128];
}NET_DVR_BLACKLIST_ALARM_RECORD, *LPNET_DVR_BLACKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_INFO  //名单分组信息
{
    DWORD          dwSize;   //结构体大小
    DWORD          dwGroupID; //分组编号（获取时有效，添加时无效），从1开始
    DWORD            dwGroupNo;            //名单分组号
    BYTE            byGroupType;        //分组类型，0-黑名单分组，1-白名单分组
    BYTE            byRes1;
    WORD            wThreshold;            //报警阈值，取值范围为0-1000
    DWORD            dwListNum;            //分组名单数
    BYTE            szGroupName[NAME_LEN];  //分组名称
    BYTE            szRemark[MAX_LEN_256];
    BYTE            byStorageAddr[MAX_DOMAIN_NAME];  //存储IP地址信息
    WORD            wStoragePort;            //存储IP对应的端口号
    BYTE            byRes[126];
}NET_DVR_BLACKLIST_GROUP_INFO, *LPNET_DVR_BLACKLIST_GROUP_INFO;


typedef struct tagNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD  
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwGroupRecordID;            //分组记录ID，修改和查询时有效，增加时无效，从1开始
    DWORD            dwGroupNo;            //名单分组号
    DWORD            dwFaceDBID;            //人脸库ID
    DWORD            dwFaceRecordID;        //人脸记录ID
    BYTE            byAlarmLevel;        //报警等级，0-high,1-medium,2-low
    BYTE            byRes1[3];            //保留
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;   //存储IP地址信息
    BYTE            byRes[256];
}NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD,*LPNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwRecordID;                //从当前编号开始获取，从1开始
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLACKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_CFG  //名单分组记录信息
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwRecordNum;            //记录总个数
    NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM]; //记录参数
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_RECORD_CFG,*LPNET_DVR_BLACKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_CFG  //名单分组记录信息
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwGroupNum;            //分组总个数
    NET_DVR_BLACKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM]; //记录参数
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_CFG,*LPNET_DVR_BLACKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_COND
{
    DWORD        dwSize;   //结构体大小
    DWORD            dwGroupID;                //从当前编号开始获取，从1开始
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_COND, *LPNET_DVR_BLACKLIST_GROUP_COND;



typedef  struct  tagNET_DVR_SENSOR_VALUE
{
    float   fMinValue; //最小值；精确到0.001，若为0xfffffffff表示查询所有
    float   fMaxValue; //最大值；精确到0.001，若为0xfffffffff表示查询所有
    BYTE    byRes[8];
}NET_DVR_SENSOR_VALUE, *LPNET_DVR_SENSOR_VALUE;

typedef  struct  tagNET_DVR_HISTORICAL_QUERY_PARAM //历史数据查询条件子结构
{
    NET_DVR_TIME_V30 struStartTime;//开始时间  
    NET_DVR_TIME_V30 struEndTime;//结束时间
    NET_DVR_SENSOR_VALUE struVoltageValue; //电压参数; 单位伏特 
    NET_DVR_SENSOR_VALUE struCurrentValue; //电流参数; 单位毫安
    NET_DVR_SENSOR_VALUE struTemperatureValue;//温度参数，单位摄氏度
    NET_DVR_SENSOR_VALUE struHumidityValue;//湿度参数
    BYTE   bySwitchStatus;//通电状态， 0~未通电，1~通电，0xff查询所有
    BYTE   bySensorStatus; //传感器状态； 0-正常、1-异常、2-报警；0xff查询所有
    BYTE   byRes[66];
}NET_DVR_HISTORICAL_QUERY_PARAM, *LPNET_DVR_HISTORICAL_QUERY_PARAM;

typedef  struct  tagNET_DVR_SENSOR_COND //条件结构
{
    DWORD  dwSize; 
    BYTE   byQueryType; //查询方式；0~实时数据查询，1~历史数据查询
    BYTE   byDeviceType; //设备类型;0~未知,1~模拟量传感器, 2~上电端子,3~上电插座，0xff表示查询所有
    BYTE   byDeviceID; //设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2，0xff表示查询所有
    BYTE   byRes1;
    // INTER_HISTORICAL_QUERY_PARAM子结构，在byQueryType为1时生效
    NET_DVR_HISTORICAL_QUERY_PARAM struHistoricalQueryParam; //历史数据查询参数
    BYTE   byRes[64];
}NET_DVR_SENSOR_COND,*LPNET_DVR_SENSOR_COND;

typedef  struct  tagNET_DVR_SENSOR_CFG//配置结构
{
    DWORD  dwSize; 
    BYTE   byEnable; //当前查询的传感器是否使能，0-不使能，1-使能；
    BYTE   byDeviceType; //设备类型;0~未知,1~模拟量传感器, 2~上电端子,3~上电插座
    BYTE   byDeviceID; //设备ID；Analog(模拟量传感器)范围：1-8、Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
    BYTE   byRes1;
    NET_DVR_TIME_V30 struTime;//时间 
    BYTE   byIsFirst; //是否是启动后第一条数据(检测是否有重启)，0-否, 1-是；
    BYTE   byIsSwitchOn; //是否通电，0-否, 1-是；
    BYTE   bySensorStatus; //传感器状态； 0-正常、1-异常、2-报警；
    BYTE   bySensorType; //传感器类型； 0-未知、1-温度、2-湿度；
    float  fVoltage; //电压；单位伏特，精确到0.001。若为0xff表示无效值
    float  fCurrent; //电流；单位毫安，精确到0.001。若为0xff表示无效值
    float  fTemperatureValue;//温度值；单位摄氏度，精确到0.001。若为0xff表示无效值
    float  fHumidityValue;//湿度值，精确到0.001。若为0xff表示无效值
    BYTE   bySensorName[SENSORNAME_LEN/*32*/]; //传感器名称
    BYTE   byDescription[MAX_SENSORDESCR_LEN/*64*/]; //传感器数据的描述信息，statusType为正常时，description可以为空
    BYTE   byRes[256];
}NET_DVR_SENSOR_CFG,*LPNET_DVR_SENSOR_CFG;

typedef    struct tagNET_DVR_SENSOR_SWITCH_COND
{
    DWORD     dwSize;//结构体大小
    BYTE     byDeviceType; //设备类型;0~未知, 1~上电端子Terminal,2~上电插座Socket
    BYTE     byDeviceID; //设备ID；Terminal(上电端子)范围：1-4、Socket(上电插座)范围：1-2
    BYTE     bySwitch; //开关，0-断电, 1-上电，2-重启
    BYTE     byRes[125];
}NET_DVR_SENSOR_SWITCH_COND,*LPNET_DVR_SENSOR_SWITCH_COND;

typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;     //结构体大小
    BYTE   byServerID[DEV_ID_LEN];  //SIP服务器ID；
    WORD   wPort;      //SIP服务器端口号
    BYTE   byRes1[2];  //保留
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;           //存活期周期，单位：秒，默认：3600 
    BYTE   byMaxHeartbeatTimeOut;    //最大心跳超时次数，默认：3次
    BYTE   byAutoAddIpc;            //是否启用自动添加ipc,0-不启用，1-启用
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];   //密码扩展为64位，设置时，byAuthPasswdEx为非空，此参数有效，byAuthPasswd无效，获取时，byAuthPasswdEx和byAuthPasswd都返回
    BYTE   byRes[190];                //保留
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;
typedef    struct    tagNET_DVR_ACTIVATECFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    sPassword[PASSWD_LEN];    //初始密码
    BYTE    byRes[108];
}NET_DVR_ACTIVATECFG,*LPNET_DVR_ACTIVATECFG;

typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;    //结构体大小
    BYTE        byMode;    //0-按通道激活，1-按地址激活
    BYTE        bySelfDefinePassword;//是否自定义密码,0-否,1-是
    BYTE        sPassword[PASSWD_LEN];//自定义密码
    BYTE        sUserName[NAME_LEN];//用户名
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union大小
        struct
        {
            DWORD       dwChannelNo;//通道号
            BYTE        byRes[508];
        }struChannelInfo;//通道信息
        struct
        {
            NET_DVR_IPADDR   struIp;//IP地址
            WORD    wPort;//端口号
            BYTE    sProtocolDesc[DESC_LEN];//协议类型
            BYTE    byMacAddr[MACADDR_LEN];//mac地址
            BYTE    byRes[344];
        }struAddrInfo;//IP地址，来自NET_DVR_SADPINFO
    }unActivateDeviceInfo;//使用联合体结构，通过byMode字段表示是按通道还是按地址
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-保留,1-IPC未激活，2-风险密码，3-密码强度弱，4-密码强度中，5-密码强度强;byDigitalChanPasswordStatus[0]表示第一个数字通道
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_CAMERACHAN_SERIALCFG
{  
    DWORD    dwSize;
    DWORD   dwBaudRate;  //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
    BYTE    byDataBit; //数据有几位：0-5位，1-6位，2-7位，3-8位
    BYTE    byStopBit;  //停止位：0-1位，1-2位
    BYTE    byParity;  //是否校验：0-无校验，1-奇校验，2-偶校验
    BYTE    byFlowcontrol;// 是否流控：0-无，1-软流控,2-硬流控
    WORD    wPTZProtocol;  //控球协议类型，索引值
    BYTE    byRes1[6];
    DWORD   dwSerialPort; //串口号,最高位为0，表示前面板串口，最高位为1，表示后面板串口
    BYTE    bySerialAddress; //串口地址0~255
    BYTE    byRes[15];
}NET_DVR_CAMERACHAN_SERIALCFG, *LPNET_DVR_CAMERACHAN_SERIALCFG;

#define MAX_MATRIX_SUBBOARD_NUM      16   //综合平台最大子板数
#define MAX_BOARD_SUBSYSTEM_NUM      12   //每个子板最大系统数
typedef  struct  tagNET_DVR_SUBSYSTEM_STATUS
{
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，
    11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板 ，15-多相机拼接子系统，16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统0-NULL*/
    BYTE    bySubSystemType;
    BYTE    bySubSystemNo;   //子系统号，即所在子板上的编号 
    BYTE    byOnlineStatus;  //网络连接状态， 1-在线 2-不在线
    BYTE    byRes[49]; 
}NET_DVR_SUBSYSTEM_STATUS, *LPNET_DVR_SUBSYSTEM_STATUS; 
typedef  struct  tagNET_DVR_MATRIX_SUBBOARD
{
    BYTE  byBoardNo;                //子板号
    BYTE  byPcieConnectStatus;        //pcie连接状态， 1-连接 2-断开
    BYTE  byRes[2]; 
    DWORD dwHardwareVersion;       //子板硬件版本
    DWORD dwPcieBandwidth ;        //pcie Link 带宽  
    DWORD dwTemperature ;          //子板温度  单位：摄氏度
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //子系统状态
    BYTE  byRes2[16]; 
}NET_DVR_MATRIX_SUBBOARD, *LPNET_DVR_MATRIX_SUBBOARD; 
typedef struct  tagNET_DVR_MATRIX_STATUS
{
    DWORD dwSize;
    BYTE  byMainFrameType;   //机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
    BYTE  bySoltNum;   //槽位数
    BYTE  byBoardNum;   //子板数
    BYTE  byRes;
    NET_DVR_MATRIX_SUBBOARD struMatrixSubboard [MAX_MATRIX_SUBBOARD_NUM]; 
    BYTE  byRes2[48];
}NET_DVR_MATRIX_STATUS,*LPNET_DVR_MATRIX_STATUS;
typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;  //图像融合宽(横向图像数目)
    WORD wHeight; //图像融合高(纵向图像数目)
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;  //是否融合，0-未融合或取消融合，非0-融合
    BYTE byUseHistoryMap; //是否使用历史融合映射表，0-不使用，非0-使用
    BYTE byRes[30]; 
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_MULTIFUNCTION_SERIALCFG
{
    DWORD dwSize ;
    BYTE  byVariable ;  //串口是否可变，1-不可变  2-可变 （只获取）
    BYTE  bySerialWorkMode;   //工作模式，1-RS485, 2-RS232（只在可变情况下，修改工作模式）
    BYTE  byFunType;   //串口功能， 1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    BYTE byDataBit;// 数据位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    BYTE byRes1 ;   
    DWORD dwBaudRate;//波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;   
    WORD wProtocol;   //串口协议  不同串口功能对应串口协议不一样
    BYTE byRes[34];
}NET_DVR_MULTIFUNCTION_SERIALCFG, *LPNET_DVR_MULTIFUNCTION_SERIALCFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //通道号
    BYTE    byPSpeed;  // X轴控制速度  （取值1－64）
    BYTE    byTSpeed;  // Y轴控制速度   （取值1－64）
    BYTE    byZSpeed;  // Z速度
    BYTE    byPDirect; // P方向， 1-左， 2-右
    BYTE    byTDirect; // T方向， 1-上， 2-下
    BYTE    byZDirect;  //Z方向，  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];  //保留字节
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL; 

//Sensor信息
typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE        bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//水平宽度 精确到小数点后两位 *10000
    float       fVerWidth;//垂直宽度 精确到小数点后两位 *10000
    float       fFold;//zoom=1没变时的焦距 精确到小数点后两位 *100
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//秒[0.000000,60.000000]
    BYTE byDegree;//度:纬度[0,90] 经度[0,180]
    BYTE byMinute;//分[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

//球机位置信息
typedef struct
{
    float   fPanPos;//水平参数，精确到小数点后1位
    float   fTiltPos;//垂直参数，精确到小数点后1位
    float   fZoomPos;//变倍参数，精确到小数点后1位
    BYTE    byRes[16] ;
}NET_DVR_PTZPOS_PARAM, *LPNET_DVR_PTZPOS_PARAM;

//GIS信息上传
typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;//结构体大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO    struDevInfo;//前端设备
    float   fAzimuth;//电子罗盘的方位信息；方位角[0.00°,360.00°)
    BYTE    byLatitudeType ;//纬度类型，0-北纬，1-南纬
    BYTE    byLongitudeType ;// 经度类型，0-东度，1-西度
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM    struLatitude;     /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude;   /*经度*/
    float   fHorizontalValue;//水平视场角，精确到小数点后面两位
    float   fVerticalValue;//垂直视场角，精确到小数点后面两位
    float   fVisibleRadius;//当前可视半径，精确到小数点后面两位
    float   fMaxViewRadius;//最大可视半径，精确到小数点后面0位（预留处理）
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor信息
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz坐标
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

//防破坏报警信息上传
typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD        dwSize;//结构体大小
    DWORD         dwRelativeTime; //相对时标
    DWORD        dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO    struDevInfo;//前端设备
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;

//集中布控参数配置
typedef    struct tagNET_DVR_CENTRALIZEDCTRL_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnable;//0-结束，1-开始
    BYTE        byLatitudeType ;//纬度类型，0-北纬，1-南纬
    BYTE        byLongitudeType ;// 经度类型，0-东经，1-西经
    BYTE        byRes1;
    NET_DVR_LLI_PARAM    struLatitude;     /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude; /*经度*/
    DWORD       dwTimeOut;//超时时间 [60s, 6*60*60s]
    BYTE        byControlType;//集中布控方式 0-强制布控，1-非强制布控
    BYTE        byRes[127];
}NET_DVR_CENTRALIZEDCTRL_CFG,*LPNET_DVR_CENTRALIZEDCTRL_CFG;

//球机的GIS信息数据
typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;//结构体大小
    float  fAzimuth;//电子罗盘的方位信息；方位角[0.00°,360.00°)
    float  fHorizontalValue;//水平视场角，精确到小数点后面两位
    float  fVerticalValue;//垂直视场角，精确到小数点后面两位
    float  fVisibleRadius;//当前可视半径，精确到小数点后面两位
    float  fMaxViewRadius;//最大可视半径，精确到小数点后面0位（预留处理）
    BYTE   byLatitudeType ;//纬度类型，0-北纬，1-南纬
    BYTE   byLongitudeType ;// 经度类型，0-东经，1-西经
    BYTE   byRes1[2] ;
    NET_DVR_LLI_PARAM     struLatitude;     /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude; /*经度*/
    NET_DVR_PTZPOS_PARAM struPtzPos; //ptz坐标
    NET_DVR_SENSOR_PARAM struSensorParam;//Sensor信息
    BYTE  byRes[256];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;

//子罗盘关联防破坏参数
typedef    struct tagNET_DVR_VANDALPROOFALARM_CFG
{
    DWORD    dwSize;//结构体大小
    BYTE    bySensitivity;//灵敏度[1,100] (支持灵敏度配置，灵敏度值大，越容易触发，值越小，越难触发)
    BYTE    byUploadEnabled;//启用防破坏报警上传使能 0-不启用，1-启用
    BYTE    byVoiceWarningEnabled;//启用防破坏报警语音提示使能 0-不启用，1-启用 
    BYTE    byEnable;// 启用检测防破坏报警 0-关闭，1-开始
    BYTE    byRes[124];
}NET_DVR_VANDALPROOFALARM_CFG,*LPNET_DVR_VANDALPROOFALARM_CFG;

typedef    struct tagNET_DVR_AZIMUTHINFO
{
    DWORD        dwSize;//结构体大小
    float       fDegree;//方位角度数(精确到小数点后两位)
    BYTE        byAzimuth; //方位角信息 0-东北,1-西北,2-东南,3-西南,4-东,5-西,6-南,7-北
    BYTE        byRes[127];
}NET_DVR_AZIMUTHINFO,*LPNET_DVR_AZIMUTHINFO;

//电子罗盘矫正、指向正北控制条件结构
typedef    struct tagNET_DVR_COMPASS_COND
{
    DWORD        dwSize;//结构体大小
    DWORD        dwChannel;//通道号
    BYTE        byRes[128];
}NET_DVR_COMPASS_COND,*LPNET_DVR_COMPASS_COND;

typedef    struct tagNET_DVR_POSITION_CFG
{
    DWORD     dwSize;//结构体大小
    BYTE     bySoftWorkMode;//工作模式 0-自动，1-手动
    BYTE     byRes[127];
}NET_DVR_POSITION_CFG,*LPNET_DVR_POSITION_CFG;

typedef    struct tagNET_DVR_STREAMING_COND
{
    DWORD        dwSize;//结构体大小
    DWORD        dwChannel;//通道号
    BYTE        byStreamType;//码流类型0-主码流，1-子码流，2-码流3
    BYTE        byRes[127];
}NET_DVR_STREAMING_COND,*LPNET_DVR_STREAMING_COND;

//卫星定位参数配置
typedef    struct tagNET_DVR_SATELLITETIME_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnable;//卫星定位校时使能 0-不开启，1-开启
    BYTE        byRes;
    WORD        wTimeInterval;//校时时间间隔(s)
    BYTE        byRes1[124];
}NET_DVR_SATELLITETIME_CFG,*LPNET_DVR_SATELLITETIME_CFG;

#define MAX_SIGNAL_JOINT_NUM       64  //最大的拼接规模
typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
    DWORD    dwSize;
    BYTE  sCamName[NAME_LEN] ;  //拼接后信号源名称
    BYTE  byEnable;               //使能，0-不使能  !0-使能
    BYTE  byCamMode ;            //拼接后信号源类型，NET_DVR_CAM_JOINT
    BYTE  byRows ;               //拼接行数
    BYTE  byColumns ;            //拼接列数
    DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //信号源号,前byRows* byColumns项有效
    DWORD dwJointNo;           //拼接编号（获取有效）
    DWORD dwSignalNoJoint;      //拼接后的信号源号（获取有效）
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
    DWORD    dwSize;
    DWORD    dwSignalNo;     //信号源号 
    DWORD     dwCutTop;      //上方裁剪像素值,0代表还原
    DWORD      dwCutBottom;   //下方裁剪像素值,0代表还原
    DWORD      dwCutLeft;     //左边裁剪像素值,0代表还原
    DWORD      dwCutRight;    //右边裁剪像素值,0代表还原
    BYTE     byRes2[32];  
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM; 

typedef struct tagNET_DVR_WALL_RELATION_CFG 
{
    DWORD dwSize; 
    BYTE  byEnable;           //关联， 0-不关联 !0-关联
    BYTE  byRealWallNo ;      //物理墙号
    BYTE  byRes[14] ; 
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;


typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
    DWORD        dwSize ;
    BYTE        byValid ;     //
    BYTE        byCamMode ;//见NET_DVR_CAM_MODE
    WORD        wInputNo ; //信号源序号
    BYTE        sCamName[NAME_LEN] ;
    NET_DVR_VIDEOEFFECT     struVideoEffect ;//视频参数
    NET_DVR_PU_STREAM_CFG    struPuStream ;    //ip输入时使用
    WORD        wBoardNum ;      //信号源所在的板卡号，只能获取
    WORD        wInputIdxOnBoard ; //信号源在板卡上的位置，只能获取
    DWORD    dwResolution ;//分辨率
    BYTE    byVideoFormat ;//视频制式，见VIDEO_STANDARD
    BYTE    byStatus;    //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常 
    BYTE    sGroupName[NAME_LEN/*32*/];    //网络信号源分组 组名
    BYTE    byJointMatrix ;            //关联矩阵，0-不关联  1-关联，当输入信号源为NET_DVR_CAM_BNC，NET_DVR_CAM_VGA，NET_DVR_CAM_DVI，NET_DVR_CAM_HDMI,中的一种时，该参数有效。
    BYTE    byJointNo ;         //拼接信号源的拼接编号(只能获取)
    BYTE    byColorMode;      //色彩模式， 0-自定义 1-锐利 2-普通 3-柔和，当为自定义时，使用struVideoEffect设置
    BYTE    byScreenServer; //关联屏幕服务器，0-不联，1-关联
    BYTE    byRes[126];
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM 
{
    DWORD    dwSize;
    WORD     wPTZProtocol;  //控球协议类型，索引值 
    BYTE     byRes[34];    
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM; 

//车辆称重
typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //是否超限
    BYTE      byAxleNum;            //轴数
    BYTE      byRes[2];               //预留 
    float     fOverWeight;          //超限重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fWeight;              //车身重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fLimitWeight;         //限制重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fAxleLen;             //轴距(米)，实际值扩大100倍传输（实际值精确到小数点后两位）
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/]; //设备描述信息
    BYTE      byRes2[64];            //预留
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

// 车牌检测结果
typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    BYTE    byPicNo;        //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    BYTE    byFeaturePicNo; //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    BYTE    byDriveChan;        //触发车道号
    BYTE    byVehicleType;     //车辆类型，参考VTR_RESULT
    BYTE    byDetSceneID;//检测场景号[1,4], IPC默认是0
    BYTE    byVehicleAttribute;// 0-无附加属性,1-黄标车(横幅),2-危险品车辆
    WORD    wIllegalType;       //违章类型采用国标定义
    BYTE    byIllegalSubType[8];   //违章子类型
    BYTE    byPostPicNo;    //违章时取第几张图片作为卡口图,0xff-表示不取
    BYTE    byChanIndex;        //通道号（保留）
    WORD    wSpeedLimit;        //限速上限（超速时有效）
    BYTE    byRes2[2];
    NET_DVR_PLATE_INFO  struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //车辆信息
    BYTE    byMonitoringSiteID[48];        //监测点编号
    BYTE    byDeviceID[48];                //设备编号
    BYTE    byDir;            //监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    BYTE    byDetectType;    //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byRes3; //保留
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    DWORD   dwCustomIllegalType; //违章类型定义(用户自定义)
    BYTE    byRes4[9]; //保留
    BYTE    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据黑白名单匹配后，是否开闸成功的标志)
    BYTE    byBarrierGateCtrlType; 
    BYTE    byAlarmDataType;//0-实时数据，1-历史数据
    NET_DVR_TIME_V30  struSnapFirstPicTime;//端点时间(ms)（抓拍第一张图片的时间）
    DWORD   dwIllegalTime;//违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //图片信息,单张回调，最多6张图，由序号区分
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //车辆称重
    BYTE     byRes[256]; //预留
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;

typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-外出布防，1-留守布防，2-即时布防
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;

typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    //日常计划布防时间段
    BYTE byNormalSchedTimeOn; //日常计划是否启用
    BYTE byMandatoryAlarm;//0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;


#define MAX_WHITELIST_PHONE_NUM      16

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD    dwSize; 
    BYTE    byEnable;//是否启用 0-不启用，1-启用
    BYTE    byRes1[3];
    BYTE    byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD    dwArmRight; //布防权限，按位，bit0为1表示对子系统1有布防权限，依此类推
    DWORD    dwDisArmRight; //撤防权限，按位，bit0为1表示对子系统1有撤防权限，依此类推
    DWORD    dwClearAlarmRight; //消警权限，按位，bit0为1表示对子系统1有消警权限，依此类推
    BYTE    byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/]; //防区报告类型，0-不上传，1-上传 
    DWORD    dwNonZoneReport; //非防区报警报告 bit0-软防区报告 bit1-系统状态报告 bit2-取消报告 bit3-测试报告         bit4-布防报告 bit5-撤防报告 bit6-挟持报告 bit7-报警恢复报告 bit8-旁路报告 bit9-旁路恢复报告。
    BYTE    byIntervalTime; //0-0s,1-10s,2-30s,3-1min,4-5min,5-10min,6-自定义（1~5999s）
    BYTE    byRes2;
    WORD    wDefineIntervalTime; //当byIntervalTime为6时有效，自定义时间（1~5999s）
    BYTE    byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD    dwSize;
    BYTE    byModuleType;            //外接触发器类型，1-键盘，2-触发器，3-防区
    BYTE    byKeyBoardType;            //1-LCD,2-LED
    BYTE    byTriggerType;            // 1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，5-32路触发器
    BYTE    byZoneType;                //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器
    WORD    wModuleAddress;            //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byRes2[2];                //保留
    char    sModelInfo[32];            //模块信息
    char    sDeviceVersionInfo[32];    //版本信息
    BYTE    byRes[128];                //保留
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;// 0- 否，1- 是
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE                       byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];//下标表示触发器号，值0-不启用，1-启用
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;
//时控输出规则参数
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{   
    DWORD  dwSize; //结构体大小
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/]; //最多支持8个日期区段的规则配置，对于定时开/关触发器只需要使用一个日期区段就可以了
    BYTE   byRes[64];  //保留
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

//单个时控输出规则配置
typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD        dwSize; 
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE        byRes[256];  //保留
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD        dwSize;
    BYTE        byBeforeAlarmPic;    //对应分辨率下可设置报警前图片最大数4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    BYTE        byAfterAlarmPic;    //对应分辨率下可设置报警后图片最大数 4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    WORD          wInterval; //间隔时间 单位s
    BYTE        byResolution;    //图片分辨率1-CIF，2-2CIF，3-4CIF，4-QCIF，5-WD1，6-VGA,7-XVGA，8-720P，9-1080P
    BYTE           byRes[63];          // 保留字节
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

#define PRIOR_SCHEDTIME            30

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE    byEnable; //是否启用 0-不启用，1-启用
    BYTE byRes1[3];
    BYTE bySubSystem[32];//子系统，下标表示子系统号 0-不支持，1-支持
    BYTE byMandatoryAlarm;//0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    BYTE byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType;     // 0-无,1-常开，2-常闭
    BYTE    byUploadAlarmRecoveryReport;    //是否上传防区报警恢复报告，0-不上传，1-上传 
    BYTE    byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //防区关联触发器    BYTE            byAssociateSirenOut[8];        //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出 
    BYTE    byAssociateSirenOut[8];        //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出 
    BYTE    byTamperResistor;    //防拆电阻，单位千欧 ， 0-无效 1-2.2 ，2--3.3, 3-4.7 ，4-5.6 ， 5-8.2 ，0xff-自定义
    BYTE    byRes2[3];
    float    fTamperResistorManual;/*防拆手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byTamperResistor为0xff时有效*/
    BYTE    byRes3[36];            // 保留字节
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;


typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1;
    WORD    wRemoteCtrllerID;//遥控器号 从1开始
    BYTE    sDevSn[16];/*产品序列号*/
    BYTE    byArmRight;            /*0-无布防权限，1-有布防权限*/
    BYTE    byDisArmRight;        /*0-无撤防权限，1-有撤防权限*/
    BYTE    byArmReportRight;    /*0-无传布防报告权限，1-有传布防报告权限*/
    BYTE    byDisArmReportRight;/*0-无上传撤防报告权限，1-有上传撤防报告权限*/
    BYTE    byClearAlarmRight;    /*0-无消警权限，1-有消警权限*/
    BYTE    bySubSystemID;       /* 设备(遥控器)子系统号,1~8 */
    BYTE    byKeyboardAddr;      /* 接收键盘的地址,在配对时设置 */    
    BYTE    byRes2[65];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


typedef struct tagNET_DVR_KEYBOARD_CFG
{
    DWORD    dwSize;
    BYTE    byEnableLock;        //是否启用键盘锁定,0--不启用, 1--启用
    BYTE    byErrorTimes;        //输入键盘用户密码错误次数（锁定键盘）
    WORD    wLockTime;            //锁定键盘时间，单位秒
    BYTE    byRes[128];
}NET_DVR_KEYBOARD_CFG, *LPNET_DVR_KEYBOARD_CFG;


typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD    dwSize;
    BYTE    byCommOperatorNum[NAME_LEN/*32*/];//通信运营商号码
    BYTE    byQueryCode[16];//业务查询代码
    BYTE    byBusinessType;//业务类型 0-话费，1-流量
    BYTE    byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD    dwSize;
    BYTE    by3GBusiness[1024];//3G业务通过短信查询
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD    dwSize;
    WORD    wdelayTime;//延迟预览时间，单位：秒
    BYTE    byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD    dwSize;
    DWORD    dwDevNo;    //设备号
    BYTE    byDevType;    //升级设备类型 0-键盘,1-机芯
    BYTE    byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD    dwSize;
    SHORT   nFloorNumber;    //层号
    WORD    wRoomNumber;    //房间号
    BYTE    byManageCenter;    //是否呼叫管理中心
    BYTE    byRes[127];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD    dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

//审讯案件信息
typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD    dwSize;
    BYTE    sCaseNo[INQUEST_CASE_NO_LEN];        //案件编号
    BYTE    sCaseName[INQUEST_CASE_NAME_LEN];    //案件名称；
    BYTE    sCustomInfo1[CUSTOM_INFO_LEN];        //自定义信息1；
    BYTE    sCustomInfo2[CUSTOM_INFO_LEN];        //自定义信息2；
    BYTE    sCustomInfo3[CUSTOM_INFO_LEN];        //自定义信息3
    BYTE    byShowCaseInfoTime; /* 案件信息显示时间,单位秒, 取值范围1~60秒*/
    BYTE    byShowCaseInfo;    //案件开始是否显示案件信息，0-不显示，1-显示
    BYTE    byPosition;        //案件显示位置，0-左上，1-左下
    BYTE    byRes[257]; //保留
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD    dwSize;
    DWORD    dwChannel;//审讯通道号
    BYTE    byShowCaseInfoTime;    //显示持续时间
    BYTE    byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD    dwSize;
    /*数组0: 审讯记录删除权限*/
    BYTE    byLocalRight[MAX_RIGHT];    /* 本地权限 */
    /*数组0: 远程音频预览权限*/
    BYTE    byRemoteRight[MAX_RIGHT];/* 远程权限 */ 
    BYTE    byNetAudioRight[MAX_CHANNUM_V40];    /* 远程音频预览权限，数组下标表示通道，值表示有无权限，0-无权限，1-有权限*/
    BYTE    byRes[512*9];         //保留9种权限可扩展
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //是否启用混音，0-不启用，1-启用
    BYTE    byRes1[3];    //保留
    DWORD    dwMixCnt;  /*混音的通道数*/
    BYTE    bySrcChan[MAX_MIX_CHAN_NUM];    /*数组下标表示混音通道号（模拟通道、IP通道）,数值0表示不混，数值1表示混入*/
    BYTE    byLineIn[MAX_LINE_IN_CHAN_NUM];    /*数组下标表示混入Line In通道号,数值0表示不混，数值1表示混入*/
    BYTE    byMic[MAX_MIC_CHAN_NUM];        /*数组下标表示混入Mic通道号,数值0表示不混，数值1表示混入*/
    BYTE    byMixAudioDelay;    //混音延迟，单位：帧，范围0-63
    BYTE    byRes2[127];    //保留
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    NET_DVR_TIME_EX struStartTime; //开始时间
    BYTE   byReportType; //统计报表类型：1-日报表，2-周报表，3-月报表，4-年报表
    BYTE   byStatType; //数据类型统计：Bit0-年龄段，Bit1-性别，Bit2-人数
    BYTE   byEnableProgramStatistics; //是否按节目统计，0-否，1-是
    BYTE   byRes1;
    DWORD  dwPlayScheduleNo; //按节目统计时关联的日程号
    BYTE   byRes[120];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;//少年（人数）
    DWORD    dwYouth;//青年（人数）
    DWORD    dwMidLife;//中年（人数）
    DWORD    dwElderly;//老年（人数）
    BYTE   byRes[64];
}NET_DVR_AGEGROUP_PARAM,*LPNET_DVR_AGEGROUP_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;//男（人数）
    DWORD    dwFemale;//女（人数）
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;/*间隔开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*间隔结束时间*/
    BYTE   byStatType;//数据类型统计：Bit0-年龄段有效，Bit1-性别有效，Bit2-人数有效
    BYTE   byRes[7];
    DWORD  dwPeopleNum;//人数统计
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;//年龄段人数统计
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;//性别人数统计
    NET_DVR_PROGRAM_INFO struProgramInfo;        //节目信息
    BYTE   byRes1[76];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

//获取交通数据条件结构 
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
    DWORD  dwSize;
    /*
    Bit0-通道有效 
    Bit1-时间有效
    Bit2-车牌号有效
    Bit3-车牌类型有效
    Bit4-车牌颜色有效
    Bit5-车身颜色有效
    Bit6-车辆类型有效
    Bit7-车辆品牌有效
    Bit8-车道号有效
    Bit9-监测方向有效
    Bit10-最低速度有效
    Bit11-最高速度有效
    Bit12-数据类型有效
    Bit13-布控方式类型有效
    Bit14-违法取证有效
    Bit15-事件类型有效
    Bit16-取证类型有效
    */
    DWORD  dwQueryCond;//查询条件 0表示无效，1表示有效
    DWORD  dwChannel;//默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    char  sLicense[MAX_LICENSE_LEN/*16*/];//(设备支持模糊查询, GB2312编码)
    /*
    Bit0-未知（其他）
    Bit1-标准民用车与军车 
    Bit2-02式民用车牌     
    Bit3-武警车           
    Bit4-警车             
    Bit5-民用车双行尾牌   
    Bit6-使馆车牌         
    Bit7-农用车           
    Bit8-摩托车    
    */
    DWORD  dwPlateType;//车牌类型（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色    
    */
    DWORD  dwPlateColor;//车牌颜色（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色    
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色    
    Bit13-深灰色    
    */
    DWORD  dwVehicleColor;//车身颜色（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    Bit9-SUV/MPV
    Bit10-中型客车
    */
    DWORD  dwVehicleType;//车辆类型（支持按位表示，可以复选）
     /**
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带 
    */
    DWORD dwIllegalType;
    /**
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-黑名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞 
    */
    DWORD dwEventType;
    /**
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    */
    DWORD  dwForensiceType;
    WORD   wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" （仅单选）
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE   byDirection;//监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南    
    WORD   wMinSpeed;//最低速度（0~999）单位km/h
    WORD   wMaxSpeed;//最高速度（0~999）单位km/h
    BYTE   byDataType;//数据类型 0-卡口数据，1-违法数据，2-交通事件，3-取证数据 （仅单选）
    BYTE   byExecuteCtrl;//布控 0-白名单，1-黑名单，0xff-其他
    BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

//交通图片参数子结构
typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30     struRelativeTime; //抓拍相对时标
    NET_DVR_TIME_V30    struAbsTime;  //抓拍绝对时标
    char szPicName[PICTURE_NAME_LEN/*64*/];
    BYTE  byPicType;//图片类型 0-车牌图，1-抓拍原图，2-合成图，3-特写图
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

//交通数据结构体
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
    DWORD  dwSize;
    DWORD  dwChannel;//默认是1（[1~32]）
    char  sLicense[MAX_LICENSE_LEN/*16*/];
    /*
    Bit0-未知（其他）
    Bit1-标准民用车与军车 
    Bit2-02式民用车牌     
    Bit3-武警车           
    Bit4-警车             
    Bit5-民用车双行尾牌   
    Bit6-使馆车牌         
    Bit7-农用车           
    Bit8-摩托车    
    */
    DWORD  dwPlateType;//车牌类型
    /*
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色    
    */
    DWORD  dwPlateColor;//车牌颜色
    /*
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色    
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色    
    Bit13-深灰色    
    */
    DWORD  dwVehicleColor;//车身颜色
    /*
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    */
    DWORD  dwVehicleType;//车辆类型
    /**
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带 
    */
    DWORD dwIllegalType;
    /**
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-黑名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞 
    */
    DWORD dwEventType;
    /**
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    */
    DWORD dwForensiceType;
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" 
    BYTE  byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE  byDirection;//监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南    
    WORD  wSpeed;//速度（0~999）单位km/h
    BYTE  byDataType;//数据类型: 0-卡口 1-违法 2-事件 3-取证
    BYTE  byRes[253];
    NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//长连接获取交通流量条件结构
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
    DWORD  dwSize;
    /**
    Bit0-通道有效
    Bit1-时间有效
    Bit2-车道号有效
    */
    DWORD  dwQueryCond;//查询条件 0-无条件
    DWORD  dwChannel;//默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    DWORD  dwResChan[10];//预留可扩展的通道号
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

//长连接获取交通流量结构
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
    DWORD  dwSize;
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    DWORD  dwChannel;//默认是1（[1~32]）
    DWORD  dwFlow;//车流量
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）    
    BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

//图片参数
typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //图片类型，0-jpg
    BYTE   byRes1[3];        //保留
    DWORD  dwPicWidth;       //图片宽度
    DWORD  dwPicHeight;      //图片高度
    DWORD  dwPicDataLen;     //图片数据大小
    char*  byPicDataBuff;    //图片数据缓冲区
    BYTE   byRes2[32];       //保留
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD       dwSize;//结构体大小
    BYTE       byEnable;       //规则是否启用， 0-不启用，1-启用
    BYTE       byRuleID;       //关联的规则ID
    BYTE       byColorBlockNo;  //颜色块序号，从1开始
    BYTE       byRes1;      //保留
    NET_DVR_PIC_INFO  struPicInfo;  //图片颜色信息
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD        dwSize;//结构体大小
    DWORD     dwChannel;     //通道号
    BYTE        byRuleID;       //关联的规则ID  0表示不关联
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

//LLDP参数
typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //卡号
    BYTE byPortNo;      //端口号
    BYTE byEnabledTx;   //使能发送lldp包，0-不使能，1-使能
    BYTE byEnabledRx;   //使能接收lldp包，0-不使能，1-使能
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //使能LLDP功能，0-不使能，1-使能
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //保持时间，单位：秒
    DWORD dwReiniTime;  //重新初始化时间，单位：秒
    DWORD dwPacketTime; //打包时间，单位：秒
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //各端口LLDP参数
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

//光纤收发器基本信息
typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //端口号，0-无效
    BYTE  byPortName[NAME_LEN];  //端口名
    BYTE  byWorkMode;            //工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byBandWidth;           //带宽，1-100M，2-1G，3-10G
    BYTE  byPortType;            //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];      //型号名称
    BYTE  bySerialNo[SERIALNO_LEN];  //序列号
    BYTE  bySoftwareVersion[VERSION_LEN]; //软件版本
    NET_DVR_IPADDR struIPAddr;           //IP地址
    DWORD dwSlotNo;    //网管卡槽位号（主槽位）
    BYTE  byStructureType;           //结构类型，1-2U，2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //各网口信息
    BYTE  byRes2[32];    
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                 //卡号，从1开始
    BYTE  byTypeName[NAME_LEN];     //型号名称
    BYTE  bySerialNo[SERIALNO_LEN]; //序列号
    BYTE  bySoftwareVersion[VERSION_LEN]; //软件版本
    DWORD dwMainSlot;               //主槽位，从1开始
    BYTE  byStructureType;          //结构类型，1-2U，2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //各端口参数
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType;                                       //电源类型，1-单电源，2-双电源
    BYTE  byRes1[3];
    DWORD dwSlotNum;                                             //网管卡槽位号（主槽位）
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //网管卡信息
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //功能卡信息
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

//光纤收发器工作状态信息
typedef struct tagNET_DVR_CARD_PORT_STATE
{
    BYTE  byValid;                 //是否有效，0-无效，1-有效
    BYTE  byPortType;            //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byLinkState;           //连接状态，0-未连接，1-已连接
    BYTE  byRes1;
    DWORD dwSendBytes;           //发送的字节数
    DWORD dwRecvBytes;           //接收数据包数
    DWORD dwRecvLostPackets;     //接收丢包数
    DWORD dwRecvCrcErrPackets;   //接收CRC校验错误包数
    DWORD dwRecvFragmentPackets; //接收碎片、冲突及过短字节包数（包长度均小于64字节）
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
    NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];    //各端口状态    
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
    BYTE  byEnabled;    //此结构是否有效，0-无效，1-有效
    BYTE  byRes1[3];
    DWORD dwCardNo; //卡号
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];    
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //网管卡状态
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //功能卡状态
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

//光纤收发器拓扑信息
typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //端口号，0-无效，非0为功能卡端口号
    BYTE  byPortType;               //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byLocalWorkMode;          //本地工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byLocalBandWidth;         //本地带宽，1-100M，2-1G，3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //对端设备类型名称
    BYTE  byPeerMac[MACADDR_LEN];   //对端MAC地址
    DWORD dwPeerPortNo;             //对端端口号
    BYTE  byPeerWorkMode;           //对端工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byPeerBandWidth;          //对端带宽，1-100M，2-1G，3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;                    //此结构体是否有效，0-无效，非0-有效
    BYTE  byRes1[3];
    DWORD dwCardNo;                 //卡号，0-网管卡，大于0-功能卡
    DWORD dwSlotNum;                //卡占用的槽位数
    BYTE  byTypeName[NAME_LEN];        //卡类型名称
    BYTE  byLocalMac[MACADDR_LEN];  //本地MAC地址
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //各端口拓扑信息
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM]; //各卡拓扑信息
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

//光纤收发器端口注释信息
typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //槽位号
    DWORD dwPortNo; //端口号
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
    DWORD dwSize;
    BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //本地端口注释信息
    BYTE  byPeerRemarks[MAX_REMARKS_LEN]; //对端端口注释信息
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;

typedef enum _EN_FIBER_CONVERT_ALARM
{
    FC_OPTICAL_PORT_LOST = 1,
    FC_ELECTRICAL_PORT_LOST,
    FC_FUNC_CARD_LOST,
}EN_FIBER_CONVERT_ALARM;

typedef enum _EN_FIBER_CONVERT_NOTIFICATION
{
    FC_OPTICAL_PORT_CONNECTED = 1,
    FC_ELECTRICAL_PORT_CONNECTED,
    FC_FUNC_CARD_INSERT,
}EN_FIBER_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;  //事件类型，1-告警，2-通知
    DWORD dwEvent;      //具体事件,告警时参考枚举EN_FIBER_CONVERT_ALARM,通知时参考枚举EN_FIBER_CONVERT_NOTIFICATION
    BYTE bySlotNum;     //槽位号
    BYTE byCardType;    //卡类型，1-网络卡，2-功能卡
    BYTE byPortNo;      //接口索引，从1开始
    BYTE byRes1[33];    
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE       byEnable;       //规则是否启用， 0-不启用，1-启用
    BYTE       byTriggerMode; // 1-持续触发，2-单次触发
    BYTE       byUploadPic;   //0-不上传图片，1-上传图片
    BYTE       byRes1;        //保留
    DWORD      dwTimeInterval; //持续触发报警时间间隔，范围[0,3600]，单位：秒
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;//处理方式
    BYTE       byRelRecordChan[MAX_IVMS_IP_CHANNEL];    //报警触发的录象通道：1表示触发该通道；0表示不触发
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//检测时间
    BYTE       byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD        dwSize;//结构体大小
    NET_VCA_DEV_INFO    struDevInfo;        //设备信息
    NET_DVR_TIME_EX     struTime;           //报警时间
    BYTE                byLampStatus;       //开关灯状态，0-已关闭  1-已打开
    BYTE                byRes1[3];          //保留
    DWORD               dwPicDataLen;       //图片数据长度，非0表示有图片上传
    char*               pPicData;           //图片数据
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

//防护舱级联配置
typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
    DWORD    dwSize; 
    BYTE    byDevAddr;    //设备地址，0-主机，1-15为从机
    BYTE    byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

//私有关键信息上传配置
typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD          dwSize;   
    NET_DVR_IPADDR     struIP; //消息上传的IP地址
    WORD          wPort;//消息上传的端口号
    BYTE         byRes[2];
    DWORD        dwInterval;//消息上传间隔(0-无时间间隔限制，以设备为准; >=0,以秒为单位的时间间隔)
    BYTE         byServerType;//服务类型 0-无，1-公安
    BYTE         byEcryptedSMSEnable;//0-不加密，1-加密
    BYTE         byAlgorithm;//加密算法，0-无，1-RSA
    BYTE         byRes1[221];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//秘钥长度
    char         szSecretKey[MAX_SECRETKEY_LEN/*512*/];//秘钥
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

//调试命令
typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD     dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

//调试信息
typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD     dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;



#define MAX_SSID_LEN    32   //SSID号长度
#define MAX_WS_PASSWD_LEN    64   //密码长度
typedef    struct tagNET_DVR_WIRELESSSERVER
{
    DWORD        dwSize;//结构体大小
    BYTE        byWLanShare;//WLan热点使能 0-关闭，1-使能
    BYTE        byBroadcastSSID;//SSID广播使能 0-关闭，1-使能
    BYTE        bySecurityMode;//安全模式 0- not-encrypted，1-WPA，2-WPA2(暂时只支持2)
    BYTE        byAlgorithmType; //加密模式 1-TKIP，2-AES
    char        szSSID[MAX_SSID_LEN/*32*/];//SSID号信息
    char        szPassWord[MAX_WS_PASSWD_LEN/*64*/];
    BYTE        byDefaultPassword;//是否是默认密码 0-否，1-是
    BYTE        byRes[255];
}NET_DVR_WIRELESSSERVER,*LPNET_DVR_WIRELESSSERVER;

typedef    struct tagNET_DVR_CONNECTDEV_COND
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byRes[128];
}NET_DVR_CONNECTDEV_COND,*LPNET_DVR_CONNECTDEV_COND;

typedef    struct tagNET_DVR_CONNECTDEV_CFG
{
    DWORD       dwSize;
    BYTE        byID;//序列号
    BYTE        byRes[1];
    BYTE        byMACAddr[MACADDR_LEN/*6*/];    // 物理地址
    NET_DVR_IPADDR    struDVRIP;//设备IP
    NET_DVR_TIME  struConnectTime;//接入时间
    BYTE        byRes1[256];
}NET_DVR_CONNECTDEV_CFG,*LPNET_DVR_CONNECTDEV_CFG;

typedef struct tagNET_DVR_GIS_SERVER_INFO
{
    BYTE  byUserName[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struServerIP;     //GIS服务器IP地址
    WORD  wPort;    //GIS服务器端口
    BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
    DWORD dwSize;
    BYTE  byEnable;        //是否显示，1-显示，0-隐藏    
    BYTE  byBaseMapType;    //底图类型，1-图片底图，2-超高清输入底图，3-GIS底图
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    NET_DVR_GIS_SERVER_INFO struGisServer;    //GIS服务器信息,当底图类型为GIS底图时有效
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{    
    DWORD        dwSize;                   //NET_DVR_VIDEO_IMG_DB_CFG结构体大小
    INT64       i64Capacity;             //视图库总容量，低位，单位：MB
    INT64        i64UsedSpace;            //只读，已用空间，低位，单位：MB
    INT64        i64AvailableSpace;        //只读，可用空间，低位，单位：MB
    BYTE          byRes[256];                //保留
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{    
    DWORD        dwSize;                   //NET_DVR_FILE_QUERY_INFO结构体大小
    INT64       i64FileLen;             //文件大小
    BYTE          byRes[256];                //保留
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char        szFileID[MAX_FILE_ID_LEN];        //上传之后，设备分配的文件ID
    BYTE        byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD     dwType;            //类型, 0-数据信息,1-单个图片信息(云存储批量下载),2-图片总体信息(云存储批量下载)
    BYTE    *pData;            //数据指针
    DWORD   dwDataLen;        //数据长度
    void*   pFileInfo;        //文件信息结构体(云存储批量下载时有效)
    DWORD   dwFileInfoLen;    //文件信息结构体长度(云存储批量下载时有效)
    BYTE    byRes[120];        //保留
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef BOOL (*DOWNLOAD_DATA_CB)( LONG lHandle, NET_DOWNLOAD_CB_INFO *pCBInfo, void *pUserData);

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //下载数据回调函数
    void                 *pUserData;            //用户参数, 在fnPreviewDataCB回调出来
    INT64                i64Offset;        //下载文件的偏移量，用于断点续传
    BYTE                   byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64    i64FileLen;             //上传新文件，需要给出文件长度，文件续传可以不给
    BYTE    byContinueUpload;     //0-新文件上传，1-老文件续传，文件名必须给出
    BYTE       byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;


typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char    szFileID[MAX_FILE_ID_LEN];        //上传之后，设备分配的文件ID
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;

typedef struct tagNET_DVR_SEND_PARAM_IN
{
    BYTE    *pSendData;                //发送的缓冲区
    DWORD    dwSendDataLen;            //发送数据长度
    NET_DVR_TIME_V30    struTime;   //图片时间
    BYTE    byPicType;                //图片格式,1-jpg,2-bmp,3-png,4-SWF,5-GIF
    BYTE    byRes1[3];
    DWORD   dwPicMangeNo;           //图片管理号
    BYTE    sPicName[NAME_LEN];     //图片名称
    DWORD   dwPicDisplayTime;       //图片播放时长，单位秒
    BYTE    byRes[200];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;


typedef struct tagNET_DVR_DOWNLOAD_QOS
{
    DWORD    dwMaxSpeed;            //流控最大速度，单位kbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;



//电影模式参数
typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD    dwSize;          //结构体大小
    BYTE     byScreenType;     //画面类型，0-单画面，1-两画面，2-画中画
    BYTE     byRes[255];    //保留
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

//导播策略配置
typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;  //结构体大小
    BYTE     byDirectedStrategyType; //导播策略类型，0-常态导播策略，1-精品导播策略
    BYTE     byRes[255];     //保留
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

//边框子结构
typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; /*边框宽度合法取值范围为[0,14]，并且只能取偶数值*/
    BYTE     byRed;  /*边框颜色为RGB 模式，R，G，B，分别对应位于如下*/
    BYTE     byGreen;
    BYTE     byBlue;
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

//配置画面边框
typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;          //结构体大小
    NET_DVR_FRAME    struTopFrame;    //上边框
    NET_DVR_FRAME    struBottomFrame;//下边框
    NET_DVR_FRAME    struLeftFrame;    //左边框
    NET_DVR_FRAME    struRightFrame;    //右边框
    BYTE            byFrameEnable;  //叠加边框0-不叠加1-叠加边框
    BYTE            byRes[256];     //保留
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

//配置画面边框条件
typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//画面编号
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

//音频优化参数
typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;          //结构体大小
    DWORD       dwCheckDelay;    //检测时延，单位s，0表示不自动优化
    BYTE        byThreshold;     //阈值[0,100]
    BYTE        byVolumePercent;//音量 [0,100]
    BYTE        byPriority;     //等级，[0，100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

//录制视频参数
typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;              //结构体大小
    BYTE        byExportType;         //阈值0-MP4 1-AVI
    BYTE        byRes[255];          //保留字节 
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byStreamType;  //码流类型，1-主码流，2-子码流，3-码流三
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

//RTMP Cfg
typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD       dwSize;                          //结构体大小
    BYTE        byEnable;                        //是否启用RTMP，0-不启用，1-启用
    BYTE         byRes1[3];
    DWORD       dwPacketLen;                     //RTMP包长
    char        szURL[RTMP_URL_LEN];            //RTMP URL
    BYTE         byRes[256];                      //保留字节 
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;

//文件发布
typedef  struct  tagNET_DVR_RECORDING_PUBLISH_FILE_CFG
{
    DWORD   dwSize;                         //结构体大小
    BYTE    byFileID[MAX_ID_LEN_128/*128*/];  //发布文件ID
    NET_DVR_TIME_EX  struStartTime;  //课程开始时间
    NET_DVR_TIME_EX  struEndTime;   //课程结束时间
    BYTE    byCmdType;  //发布命令类型  1--开始发布 2--取消发布
    BYTE   byRes[255];
}NET_DVR_RECORDING_PUBLISH_FILE_CFG, *LPNET_DVR_RECORDING_PUBLISH_FILE_CFG;

//文件发布进度条件
typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //发布文件ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

//文件发布进度参数
typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;          //结构体大小
    BYTE     byPublishPercent;     //发布百分比 0-100
    BYTE     byPublishStatus;     //发布状态  0-发布成功 1--正在发布 2--等待发布 3-连不上FTP  4--没有找到此文件 5--发布失败（其他错误）
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;

//删除视图库中的文件
typedef  struct  tagNET_DVR_BACKGROUND_PIC_COND
{
    DWORD    dwSize;  
    char     szFileID[MAX_ID_LEN_128/*128*/];        //上传之后，设备分配的文件ID, 指背景图片名
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_COND, *LPNET_DVR_BACKGROUND_PIC_COND;

//查询背景图片文件
typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
    DWORD    dwSize;                         //结构体大小
    DWORD     dwPicSize;  //背景图片大小
    DWORD     dwPicType;   //图片类型，YUV:0 JPEG:1
    WORD     wPicWidth;   //图片宽
    WORD     wPicHeight;    //图片高
    BYTE          byPicName[MAX_PIC_NAME_LEN/*128*/];   //图片名称
    BYTE         byRes[128];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;                              //结构体大小
    BYTE    byEnable;             //是否启用背景图片叠加，0-否，1-是
    BYTE    byRes1[3];
    BYTE    byPicID[MAX_ID_LEN_128/*128*/];
    BYTE    byRes[300];         //保留
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;


//上传背景图片文件
typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
    DWORD       dwSize;
    DWORD        dwChannel; //导播通道
    DWORD        dwPicSize;  //背景图片大小
    WORD        wPicWidth;   //图片宽
    WORD           wPicHeight;    //图片高
    char          szPicName[MAX_PIC_NAME_LEN/*128*/];   //图片名称
    BYTE        byPicType;   //图片类型，YUV:0 JPEG:1
    BYTE        byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;

//低功耗配置
typedef    struct tagNET_DVR_LOWPOWER
{
    DWORD        dwSize;//结构体大小
    BYTE          byMode;//补光灯模式 0-手动，1-定时
    BYTE        byEnabled;//手动模式下的使能开关 0-关闭，1-开启
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//定时时间段    
    BYTE        byRes1[256];
}NET_DVR_LOWPOWER,*LPNET_DVR_LOWPOWER;

typedef struct tagNET_DVR_POINT
{
    DWORD dwX;    //X轴坐标
    DWORD dwY;    //Y坐标
}NET_DVR_POINT, *LPNET_DVR_POINT;

//变倍联动配置
typedef    struct tagNET_DVR_ZOOMLINKAGE
{
    DWORD        dwSize;//结构体大小
    BYTE          byEnable;//使能 0-关，1-开
    BYTE       byRes[255];
}NET_DVR_ZOOMLINKAGE,*LPNET_DVR_ZOOMLINKAGE;

typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-未开始升级,1-正在升级,2-升级成功,3-包语言不匹配,4-写falsh失败,5-包类型不匹配,6-包版本不匹配,7-网络不可达,8-升级服务器出错,
                            //9-读取升级包文件出错,10-没有找到升级文件,11-升级文件有错,12-设备内存不足,0xff-未知错误
    BYTE    byProgress; //升级进度,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;

typedef    struct tagNET_DVR_FIRMWARECODE_COND
{
    DWORD  dwSize;
    DWORD  dwStartIndex;    //起始索引号
    DWORD  dwMaxNum;    //单次最大个数，32
    BYTE   byRes[52];
}NET_DVR_FIRMWARECODE_COND,*LPNET_DVR_FIRMWARECODE_COND;

typedef    struct    tagNET_DVR_FIRMWARECODE
{
    WORD  wIndex;
    WORD  wCodeLen;    //识别码长度，上层应用开发的时候做一个判断，如果本字段大于128，请报错，提示用户更新工具/客户端版本
    BYTE  byCode[MAX_IDCODE_LEN];//识别码
    BYTE  byVersion[MAX_VERSIIN_LEN];//版本
    BYTE  byRes[12];
}NET_DVR_FIRMWARECODE,*LPNET_DVR_FIRMWARECODE;

typedef    struct    tagNET_DVR_FIRMWARECODE_LIST
{
    DWORD  dwSize;
    DWORD  dwValidCodeNum;    //有效个数
    NET_DVR_FIRMWARECODE  struCode[MAX_IDCODE_NUM];
    BYTE   byRes[64];
}NET_DVR_FIRMWARECODE_LIST,*LPNET_DVR_FIRMWARECODE_LIST;

typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER 
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-未连接,1-已连接
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //是否需要从服务器检测，0-不需要，仅返回设备周期性检查的结果;1-需要，设备会即时连接服务器检测是否有新版本
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //是否有新版本,0-否,1-是
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //新版本的版本号
    BYTE   byChangeLog[SDK_LEN_2048];  //新版本更新的内容
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN]; 
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //推荐升级,0-否,1-是
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;

//温湿度配置
typedef    struct tagNET_DVR_THSCREEN
{
    DWORD  dwSize;//结构体大小
    BYTE   byEnable;//启用定时使能
    BYTE   byTHOSDDisplay;//温湿度显示OSD显示是否启用,  0-否，1-是
    BYTE   byRes[2]; // 保留字节
    NET_VCA_POINT   struTHOSDPoint;//温湿度显示OSD显示左上角坐标
    BYTE   byTimingMode;//校时模式 0-手动，1-自动
    BYTE   byRes1;
    WORD   wInterval;//校时定时模式下，间隔时间设置[1,10080]m
    BYTE   byRes2[254];
}NET_DVR_THSCREEN,*LPNET_DVR_THSCREEN;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT
{
    DWORD        dwSize;//结构体大小
    BYTE     byType;//调整模式：0-上下，1-左右，2-旋转，3-图像视场角
    BYTE     bySensorNo;//Sensor 号[1,8]
    BYTE     byRes[2];
    int     iAdjustMentRange;//调整幅度 [-100,100] 旋转的时候[-30,30] 图像视场角[-10,10]
    BYTE     byRes1[128];
}NET_DVR_SENSOR_ADJUSTMENT,*LPNET_DVR_SENSOR_ADJUSTMENT;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT_INFO
{
    DWORD        dwSize;//结构体大小
    int      iPan;//左右值
    int      iTilt;//上下值
    int      iRotation;//旋转值
    int      iFieldAngle;//图像视场角值
    BYTE     byRes[128];
}NET_DVR_SENSOR_ADJUSTMENT_INFO,*LPNET_DVR_SENSOR_ADJUSTMENT_INFO;

typedef    struct tagNET_DVR_SENSOR_RESET
{
    DWORD        dwSize;//结构体大小
    BYTE     bySensorNo;//Sensor号[1,8];当Sensor No为0的时候，表示全部清除；其他情况下表示单个清除
    BYTE     byRes[127];
}NET_DVR_SENSOR_RESET,*LPNET_DVR_SENSOR_RESET;

typedef    struct tagNET_DVR_PANORAMAIMAGE
{
    DWORD        dwSize;//结构体大小
    BYTE     byFusionMode;//模式：0-原始图像，1-全景图像
    BYTE     byRes[127];
}NET_DVR_PANORAMAIMAGE,*LPNET_DVR_PANORAMAIMAGE;

typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD        dwSize;//结构体大小
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];     //接管设备的地址 
    WORD        wPort ;                 //设备端口号
    BYTE        byRes[254] ;            //保留
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
    DWORD dwSize;
    BYTE byEnabled;        //是否启用会议区域，0-否，1-是
    BYTE byRes1[3];
    NET_DVR_POINT struRegion[RECT_POINT_NUM];    //会议区域，矩形，起始点为左下角，顺时针方向
    DWORD dwOutputWidth;    //单输出口基准宽，只能获取
    DWORD dwOutputHeight;    //单输出口基准高，只能获取
    BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
    DWORD dwSize;
    BYTE  byAnswerType; //会议呼叫响应方式，1-自动接听，2-自动拒接，3-手动接听
    BYTE  byProtocolType;    //使用的协议类型，1-SIP，2-H232
    BYTE  byRes[30];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    BYTE byRes[128];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;     //是否静音，0-否，1-是
    BYTE byVolume;   //音量，非静音时有效，1-100
    BYTE byAudioInputDisabled;  //禁止音频输入，0-允许音频输入，1-禁止音频输入
    BYTE byAudioInputVolume;    //音频输入音量，允许音频输入时有效，1-100
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef union tagNET_DVR_TERMINAL_DETAIL_CTRL_PARAM
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struCallInfo;
    NET_DVR_TERMINAL_AUDIO_CTRL struAudioCtrl;
}NET_DVR_TERMINAL_DETAIL_CTRL_PARAM, *LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;    //操作类型，1-接听，2-拒接，3-呼叫，4-音频调节
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;   //具体控制参数
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //搜索标识符
    NET_DVR_TIME struStartTime; //搜索起始时间
    NET_DVR_TIME struEndTime;   //搜索结束时间
    BYTE byCallType;    //呼叫类型，1-已接，2-未接，3-已拨，4-所有类型
    BYTE byRes1[3];
    DWORD dwMaxResults; //本次查找最多返回个数
    DWORD dwSearchPos;  //查找起始索引
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;    //呼叫类型，1-已接，2-未接，3-已拨
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN]; //终端名
    BYTE byAddressURL[MAX_URL_LEN]; //对端URL地址
    NET_DVR_TIME struStartTime; //呼叫开始时间
    NET_DVR_TIME struEndTime;   //呼叫结束时间
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef enum tagCALL_QUERY_RESULT_STATUS
{
    CALL_QUERY_RESULT_OK = 0,     //成功查询所有
    CALL_QUERY_RESULT_FAIL,       //查询失败，未知错误
    CALL_QUERY_RESULT_MORE,     //成功查询 还有更多没有返回
    CALL_QUERY_RESULT_NOMATCH,  //没有查询到匹配的
    CALL_QUERY_RESULT_PARAMERROR,  //查询条件参数错误
    CALL_QUERY_RESULT_INVALIDTIME,   //查询条件时间无效
    CALL_QUERY_RESULT_TIMEOUT,   //查询超时
}CALL_QUERY_RESULT_STATUS;

typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //搜索标识符
    BYTE   byStatus;  //查询状态  参考CALL_QUERY_RESULT_STATUS结构体
    BYTE   byRes[3];  //保留 
    DWORD dwCount; //实际查询到的结果个数
    BYTE *pResults; //结果内容，dwCount个NET_DVR_CALL_QUERY_SINGLE,需要调用者预先分屏好内存
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN]; //会议ID
    BYTE byConferenceName[NAME_LEN];    //会议名称     
    NET_DVR_TIME struStartTime;        //会议开始时间
    NET_DVR_TIME struEndTime;        //会议结束时间
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;

typedef union tagNET_DVR_CALL_INFO
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struTerminalCallInfo;  //终端点对点呼叫信息
    NET_DVR_CONFERENCE_CALL_INFO struConferenceCallInfo;  //会议呼叫信息
}NET_DVR_CALL_INFO, *LPNET_DVR_CALL_INFO;

typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
    DWORD dwSize;
    BYTE  byAlarmType;              //报警类型，1-会议呼叫， 2-呼叫状态切换，3-终端提问
    BYTE  byCallType;               //呼叫类型，报警类型为1时有效，1-终端点对点呼叫，2-会议呼叫
    BYTE  byAutoAnswer;                //是否已自动接听，0-否，1-是
    BYTE  byCallStatusSwitch;       //呼叫状态切换类型，当报警类型为2时有效，1-开始呼叫，2-呼叫成功，3-呼叫结束，4-对端挂断
    NET_DVR_CALL_INFO struCallInfo; //呼叫信息
    BYTE  byRes2[32];    
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;    //作为视频会议输入的输入口编号
    BYTE  byRes[32];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;    //是否静音，0-否，1-是
    BYTE byVolume;  //会议音量，1-100，非静音时有效
    BYTE byAudioInputDisabled;  //禁用音频输入，0-否，1-是
    BYTE byAudioInputVolume; //音频输入音量，1-100，允许音频输入时有效
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState; //会议状态，0-空闲，1-忙碌（会议中），2-呼叫中，3-被呼叫中
    BYTE byConferenceType;  //会议类型，1-点对点，2-MCU发起会议
    BYTE byRes1[2];
    DWORD dwInputNo;   //使用的音频输入口号
    NET_DVR_CALL_INFO struCallInfo; //会议信息
    NET_DVR_AUDIO_STATUS struAudioStatus;   //音频相关状态
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

//终端注册GK信息
typedef struct tagNET_DVR_TERMINAL_GK_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用
    BYTE  byRegisterState;    //注册状态，0-未注册，1-已注册，只读
    BYTE  byRes1[2];
    NET_DVR_IPADDR struGKIP; //GK IP
    WORD wGKPort; //GK端口号
    BYTE byRes2[2];
    BYTE byRegisterName[REGISTER_NAME_LEN]; //终端注册到GK的名字
    BYTE byRes3[32];
}NET_DVR_TERMINAL_GK_CFG, *LPNET_DVR_TERMINAL_GK_CFG;

//解码器漫游开关参数
typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
    DWORD dwSize;
    BYTE  byEnableRoam;    //是否允许窗口漫游，0-否，非0-是
    BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE byEnableZoom;  //是否缩放，0-否，1-是
    BYTE byAutoCutBlackEdge;  //是否自动裁剪黑边，0-否，1-是
    BYTE byRes1[2];
    WORD wLEDWidth;     //分辨率宽
    WORD wLEDHeight;    //分辨率高
    DWORD dwRefreshRate;    //刷新频率
    DWORD dwInputNO;    //关联的输入通道号
    BYTE byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //是否使能，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwPortNum;    //包含的端口个数
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM];     //包含的端口号
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //行号
    WORD wColumn; //列号
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo;  //显示区域的起始位置(接收卡行列号)
    WORD    wWidth;     //横向接收卡数
    WORD    wHeight;    //竖向接收卡数
    WORD     wRecvCardWidth;   //接收卡宽度大小，为0则使用端口参数中接收卡大小参数
    WORD    wRecvCardHeigt;   //接收卡高度大小，为0则使用端口参数中接收卡大小参数
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //接收卡位置
    WORD wRecvCardWidth;   //接收卡宽度大小
    WORD wRecvCardHeigt;   //接收卡高度大小
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;    //是否启用端口备份，0-否，1-是
    BYTE byPortMode; //端口模式，1-主口，2-备份口
    BYTE byRes1[2];
    DWORD dwPairPort; //配对端口号，当端口为主口时，此参数为备份口端口号，当端口为备份口时，此参数为主口端口号
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //是否启用该端口，0-否，1-是
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup;    //端口备份参数
    DWORD dwRecvCardNum;   //本端口连接的接收卡数
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM];   //各接收卡的信息
    DWORD dwPortNo; //端口号，获取所有端口参数时有效
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp;    //色温参数
    NET_DVR_VIDEO_OUT_CFG struVoutCfg;        //显示效果参数
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;        //是否启用测试信号，0-不启用，1-启用
    BYTE bySignalType;    //测试信号类型，1-彩条，2-波纹，3-格状彩条，4-方格，5-水平和垂直灰阶联合体，6-棋盘，0xff-自定义颜色
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor;    //测试信号颜色，测试信号类型为0xff时有效
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode;    //无信号显示模式，1-黑屏，2-显示厂家LOGO，3-显示自定义图片
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;    //输入分辨率宽，只读
    DWORD dwResolutionHeight;    //输入分辨率高，只读
    DWORD dwRefreshRate;        //输入信号刷新频率，只读
    NET_DVR_SCREEN_VGA_CFG struVgaCfg;    //VGA信号调整参数，VGA输入时可调
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;    //输出编号
    NET_DVR_LINE_COLUMN_INFO struPosStart; //接收卡起始位置
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //接收卡结束位置
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];    //GAMMA表Y取值，每个元素取值0-65535
    BYTE byRes[128];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;    //传输时钟dclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    DWORD dwGclkRate;    //刷新时钟gclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    DWORD dwGclkCountNum;    //300ns gclk计数值
    BYTE  byDclkDutyRatio;    //dclk时钟占空比，取值：25，50，75
    BYTE  byDclkPhase;    //dclk相位，取值：0,1,2,3
    BYTE  byGclkNum;    //刷新1行需要的有效gclk个数，0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;    //时钟相关参数
    BYTE byGrayLevel;    //灰度等级，取值13，14
    BYTE byRefreshRate;    //刷新倍率，取值1-6
    BYTE byLineScanNum;    //行扫数，0-255
    BYTE byRefreshCompleteGrayNum; //刷新完整灰阶数，0-255
    DWORD dwHBlank;        //行消隐时间，单位：gclk时钟个数，取值1-65535
    DWORD dwAfterglowCtrl;    //余晖控制结束时间，单位：gclk时钟个数，取值1-65535
    DWORD dwLineFeedTime;    //换行时间，单位：gclk时钟个数，取值1-65535
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;        //芯片1高字节
    BYTE byChip1Low;        //芯片1低字节
    BYTE byChip2High;        //芯片2高字节
    BYTE byChip2Low;        //芯片2低字节
    BYTE byChip3High;        //芯片3高字节
    BYTE byChip3Low;        //芯片3低字节
    BYTE byRes[10];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;    //下鬼影消除等级，0-5
    BYTE byEliminateShadowy;            //第一扫偏暗消除等级，0-15
    BYTE byGrayEqualize1;                //低灰偏色补偿1，0-3
    BYTE byGrayEqualize2;                //低灰偏色补偿2，0-15
    BYTE byEnableGrayUniformity;        //低灰均匀性提升是否开启，0-关，1-开
    BYTE byDisableHGrayStripes;            //低灰横条纹消除是否开启，0-关，1-开
    BYTE byGhostShadowEnhancedMode1;    //下鬼影消除增强模式1是否开启，0-关，1-开
    BYTE byGhostShadowEnhancedMode2;    //下鬼影消除增强模式2是否开启，0-关，1-开
    BYTE byClearBadPoint;                //去除坏点使能，0-非使能，1-使能
    BYTE byEnableSelfDefineRegistor;    //是否启用自定义寄存器值，0-否，1-是
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue;    //自定义寄存器参数    
    BYTE byRes[32];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
    DWORD dwSize;
    NET_DVR_LED_RECV_REGISTOR struFirstRegistor;    //第一组接收卡高级参数，自定义寄存器值为红芯片寄存器值
    NET_DVR_LED_RECV_REGISTOR struSecondRegistor;    //第二组接收卡高级参数，自定义寄存器值为绿芯片寄存器值
    NET_DVR_LED_RECV_REGISTOR struThirdRegistor;    //第三组接收卡高级参数，自定义寄存器值为蓝芯片寄存器值
    BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

typedef struct tagNET_DVR_LED_CHECK_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;   //输入编号
    BYTE  byRes[32];
}NET_DVR_LED_CHECK_COND, *LPNET_DVR_LED_CHECK_COND;

//查询方式
enum  ADDR_QUERY_TYPE
{
    QUERYSVR_BY_COUNTRYID = 0,    //按国家编号查询服务器地址
    QUERYDEV_BY_NICKNAME_DDNS = 2, //按昵称从hiDDNS上查询设备信息
    QUERYDEV_BY_SERIAL_DDNS = 3,    //按序列号从hiDDNS上查询设备信息
    CHECKDEV_BY_NICKNAME_DDNS = 4,//按昵称从hiDDNS诊断设备信息
    CHECKDEV_BY_SERIAL_DDNS = 5,    //按序列号从hiDDNS诊断设备信息
    QUERYDEV_BY_NICKNAME_IPSERVER = 6, //按昵称从IPServer上查询设备信息
    QUERYDEV_BY_SERIAL_IPSERVER = 7    //按昵称从IPServer上查询设备信息
};
#define    CLIENT_VERSION_LEN    64
//按国家编号查询的条件结构体
typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD    wCountryID;    //国家编号,取值详见附件一
    char    szSvrAddr[MAX_DOMAIN_NAME];//服务器地址,表示去哪个服务器上查询目标服务器的信息
    char    szClientVersion[CLIENT_VERSION_LEN];//客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;

//按国家编号查询的返回结构体
typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址(即设备注册服务器)
    char    szAlarmSvrAddr[MAX_DOMAIN_NAME];//报警服务器地址
    BYTE    byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

//从hiDDNS上查询或诊断的条件结构体
typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址
    char    szDevNickName[MAX_DOMAIN_NAME];    //设备在解析服务器上的别名
    char    szDevSerial[SERIALNO_LEN];    //设备序列号
    char    szClientVersion[CLIENT_VERSION_LEN];//客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[272];        //保留
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;
#define SDK_MAX_IP_LEN 48
//从hiDDNS上查询返回的结构体
typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //设备IP地址
    WORD    wCmdPort;        //控制端口（SDK连接端口）
    WORD    wHttpPort;        //http端口
    BYTE    byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;

//从hiDDNS上诊断返回的结构体
typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE    byDevStatus;        //设备状态,0-正常,1-找不到,2-设备不在线,3-设备不在当前区域
    BYTE    byRes1;
    NET_DVR_QUERY_DDNS_RET    struQueryRet;    //地址信息
    WORD    wRegionID;        //当前设备注册区域编号[1美国,2南美,3亚太,4中国,5欧洲,6其它] 
    BYTE    byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

//从IPServer上查询的条件结构体
typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址
    WORD    wResolveSvrPort;    //解析服务器端口
    char    szDevNickName[MAX_DOMAIN_NAME];    //设备在解析服务器上的别名
    char    szDevSerial[SERIALNO_LEN];    //设备序列号
    BYTE    byRes[334];        //保留
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

//从IPServer上查询返回的结构体
typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //设备IP地址
    WORD    wCmdPort;        //控制端口（SDK连接端口）
    BYTE    byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //通道号
    BYTE   byres[32];                    //保留
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;

//码流加密条件结构
typedef    struct tagNET_DVR_STREAMENCRYPTION_COND
{
    DWORD    dwSize;  //结构体大小
    DWORD   dwChan;  //预览通道号
    BYTE    byRes[128];
}NET_DVR_STREAMENCRYPTION_COND, *LPNET_DVR_STREAMENCRYPTION_COND;

//码流加密信息结构
typedef    struct tagNET_DVR_STREAMENCRYPTION_CFG
{
    DWORD    dwSize;    //结构体大小
    BYTE    byEnable;  //启用码流加密，0~关闭，1~开启
    BYTE    byRes[255];
}NET_DVR_STREAMENCRYPTION_CFG, *LPNET_DVR_STREAMENCRYPTION_CFG;

//校准的GPS经纬度参数
typedef    struct tagNET_DVR_REVISE_GPS_CFG
{
     DWORD    dwSize;    //结构体大小
     BYTE   byLatitudeType ;//纬度类型，0-北纬，1-南纬
     BYTE   byLongitudeType ;// 经度类型，0-东度，1-西度
     BYTE   byMode ;//模式 0-默认，1-自动，2-手动
     BYTE    byRes;
     NET_DVR_LLI_PARAM    struLatitude;     /*纬度*/
     NET_DVR_LLI_PARAM    struLongitude; /*经度*/
     BYTE    byRes1[300];
}NET_DVR_REVISE_GPS_CFG, *LPNET_DVR_REVISE_GPS_CFG;

typedef    struct tagNET_DVR_PDC_RECOMMEND
{
    DWORD         dwSize;
    WORD        wWidth;//推荐宽度值[0, 1000]
    BYTE        byRes[126];
}NET_DVR_PDC_RECOMMEND,*LPNET_DVR_PDC_RECOMMEND;

typedef    struct tagNET_DVR_FLASHSTORAGE_REMOVE
{
    DWORD         dwSize;
    DWORD       dwChannel;
    BYTE        byPDCRemoveEnable;//清除客流数据使能 0-不清除，1-清除
    BYTE        byRes[127];
}NET_DVR_FLASHSTORAGE_REMOVE,*LPNET_DVR_FLASHSTORAGE_REMOVE;

/********************************DS-TME4XX控制机开发 Begin****************************/
typedef struct tagNET_DVR_PARKING_CARD
{
    DWORD  dwSize;
    DWORD  dwChannel;//默认是1（后续兼容多通道设备）
    char  szCardNo[MAX_CARDNO_LEN/*48*/];//卡号
    BYTE  byCardType;//卡片类型 0-临时卡，1-固定卡
    BYTE  byCardStatus;//卡片状态 0-正常，1-挂失，2-注销
    BYTE  byChargeRuleID;//收费规则ID
    BYTE  byDelete;//是否删除 0-不删除，1-删除
    NET_DVR_TIME_V30 struStartTime;//有效开始时间
    NET_DVR_TIME_V30 struEndTime;//有效结束时间
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

//出入口卡片信息上传
typedef struct tagNET_DVR_GATE_CARDINFO
{
    DWORD     dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //相对时标
    DWORD dwAbsTime; //绝对时标
    char    szCardNo[MAX_CARDNO_LEN/*48*/];//卡号
    char    szPassVehicleID[MAX_VEHICLE_ID_LEN];//唯一标识
    char    szInVehicleID[MAX_VEHICLE_ID_LEN];//出口时的入口唯一标识
    NET_DVR_TIME_V30  struSwipeTime;//刷卡时间
    NET_DVR_TIME_V30  struCardTime;//卡片存的时间，即入场时写入的时间，只对出口票箱有用，0表示无入场时间
    BYTE    byLetPass;//出入口放行方式 0-不放行(当CardType == 纸票)需要收费，1-放行，2-中心收费放行
    BYTE     byCardType;//卡类型 0-固定卡，1-临时卡，2-纸票
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

//出入口付费信息上传(COMM_GATE_CHARGEINFO_UPLOAD)
typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //相对时标
    DWORD dwAbsTime; //绝对时标
    char  sLicense[MAX_LICENSE_LEN];        //车牌
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //出场唯一过车标示
    char  szEntranceID[32];  //入场唯一过车标示
    DWORD dwTotalCost;   //实际收费金额*100
    char  szOperateName[32]; //脱机下为"offline"
    BYTE  byChargeRuleId; //收费规则centerId
    BYTE  byVehicleType;//车辆类型，0-其他车辆，1-小型车，2-大型车
    BYTE  byRes[127];//预留
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

//停车场停车卡控制结构体
typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE  byCardType;//卡片类型 0-临时卡
    BYTE  byDeleteALL;//是否全部删除 0-不删除，1-删除
    BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;

//TME车辆抓图上传
typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //车道号1～32（索引车道号，可以跳跃）
    BYTE    byCamLaneId; //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE    byRes1; //保留
    DWORD   dwChanIndex; //通道号
    NET_DVR_PLATE_INFO  struPlateInfo; //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    byMonitoringSiteID[48]; //监测点编号
    BYTE    byDeviceID[48]; //设备编号
    BYTE    byDir;     //监测方向，0-其它 1 入场，2 出场 
    BYTE    byRes2; 
    WORD    wBackList; //标记为是否报警数据 0 表示为正常过车数据  1 表示黑名单
    DWORD   dwPicNum; //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义 
    NET_ITS_PICTURE_INFO struPicInfo[4];  //图片信息,暂定最多4张图
    BYTE    byPassVehicleID[32];    //车辆唯一ID 
    BYTE    byCardNo[48]; // 卡号
    BYTE    bySwipeTime[32];//增加刷卡时间  时间格式为yyyymmddhh24missfff
    DWORD   dwCharge;      //收费金额 （分）
    BYTE    byHistory;     //是否是历史数据  0-否  1-是
    BYTE    byLetPass;     //是否已放行，0-未放行，1-放行  2-未知
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

//车辆信息同步
typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//默认是1（后续兼容多通道设备）
    char    szLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//关联卡号
    NET_DVR_TIME_V30 struStartTime;//有效开始时间
    NET_DVR_TIME_V30 struEndTime;//有效结束时间
    BYTE    byVehicleType;//车辆类型：0-其他车辆，1-小型车，2-大型车
    BYTE    byPlateColor;//车牌颜色，参考 VCA_PLATE_COLOR
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;

//缴费金额信息
typedef    struct tagNET_DVR_CHARGEACCOUNT_CFG
{
    DWORD   dwSize;//结构体大小
    float   fAccount;//实际收费金额
    BYTE    byRes[128];
}NET_DVR_CHARGEACCOUNT_CFG,*LPNET_DVR_CHARGEACCOUNT_CFG;

//停车场票箱从属设备多角度参数配置
typedef    struct tagNET_DVR_PXMULTICTRL_CFG
{
    DWORD        dwSize;//结构体大小
    DWORD        dwMultiChansWaitTime;//多角度抓拍匹配时间（1~300s）
    BYTE         byMultiChansCapEnabled;//是否启用多角度抓拍 0-否，1-是
    BYTE        byRes[127];
}NET_DVR_PXMULTICTRL_CFG,*LPNET_DVR_PXMULTICTRL_CFG;

//停车场票箱脱机下参数配置
typedef    struct tagNET_DVR_PXOFFLINE_CFG
{
    DWORD   dwSize;//结构体大小
    BYTE    byEnabled;//是否启用票箱脱机模式：0-不启用 1-启用
    BYTE    byChargeEnabled;//是否脱机收费 0-否，1-是
    BYTE    byAlarmEnabled;//是否启用脱机报警 0-否，1-是
    BYTE    byRecordSource;//记录产生依据 0-牌识 1-读卡
    DWORD   dwTimeWait;//票箱进入脱机模式前的等待时间（1-300秒）
    /**
     realeaseMode&(0x1<<0) 固定车放行
     realeaseMode&(0x1<<1) 固定卡放行
     realeaseMode&(0x1<<2) 临时车放行
     realeaseMode&(0x1<<3) 临时卡放行
     realeaseMode&(0x1<<4) 无车牌放行
     realeaseMode&(0x1<<5) 固定车若免费则自动放行
     realeaseMode&(0x1<<6) 临时车若免费则自动放行 
    */
    DWORD   dwRealeaseMode; //放行方式，按位表示
    BYTE    byVehCardmatch;//车卡一致  0-否，1-是
    BYTE    bySingleInSingleOut;//单进单出 0-否，1-是
    BYTE    byRes[126];
}NET_DVR_PXOFFLINE_CFG,*LPNET_DVR_PXOFFLINE_CFG;

typedef    struct tagNET_DVR_PARKINGSAPCE_CFG
{
    DWORD    dwSize;//结构体大小
    DWORD     dwTotalParkingLot;//总停车位数
    DWORD    dwCurrParkingLot;//当前剩余停车位数
    BYTE    byRes[128];
}NET_DVR_PARKINGSAPCE_CFG,*LPNET_DVR_PARKINGSAPCE_CFG;

typedef    struct tagNET_DVR_PAPERCHARGEINFO_CFG
{
    DWORD   dwSize;//结构体大小
    char    szBarCode[LEN_16];//条形码（16位字符串）
    char    szLicense[MAX_LICENSE_LEN]; //车牌号码
    char    szVehicleInTime[LEN_32];//入场时间（32位字符串 YYYY-MM-DD HH:MM:SS）
    char    szPaymentTime[LEN_32];//缴费时间（32位字符串 YYYY-MM-DD HH:MM:SS）
    float   fPaymentAmount;//缴费金额
    DWORD   dwPaymentOutFailureTime;//缴费出场失效时间（DWORD）
    BYTE    byVehicleOutEnabled; //是否出场: 0- 否，1- 是
    BYTE    byRes[128];
}NET_DVR_PAPERCHARGEINFO_CFG,*LPNET_DVR_PAPERCHARGEINFO_CFG;

//停车场票箱参数
typedef    struct tagNET_DVR_ILLEGALCARDFILTERING_CFG
{
    DWORD   dwSize;//结构体大小
    char    sLEDDefaultInfo[MAX_LED_INFO_LEN/*512*/]; // LED默认显示内容
    BYTE    byillegalCardFilteringEnabled;//启用非法卡过滤,0~不启用，1~启用
    BYTE    bySendCardSensingCoilEnabled;//发卡机是否关联地感线圈
    BYTE    byWiegendSensingCoilEnabled;//远距离卡是否关联地感线圈
    BYTE    byGateSwitchEnabled; //是否有道闸开关信息
    BYTE    byVerifyKeyWriteCardEnabled;//是否验证密钥和写卡
    BYTE    byNoplateTakeCardEnabled;// 是否启用无车牌取凭据放行
    BYTE    byRes[126];
}NET_DVR_ILLEGALCARDFILTERING_CFG,*LPNET_DVR_ILLEGALCARDFILTERING_CFG;


//停车场出入口车卡收费规则规则条件结构
typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize; 
    DWORD   dwChannel;  //通道号 
    char    szCardNo[32];//卡号
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;

//LED屏幕显示参数
typedef    struct tagNET_DVR_LEDDISPLAY_CFG
{
    DWORD   dwSize;//结构体大小
    char    sDisplayInfo[MAX_LED_INFO_LEN/*512*/]; // LED显示内容
    BYTE    byDisplayMode;//显示方式:0~左移,1~右移,2~立即显示
    BYTE    bySpeedType;//速度类型:0~快,1~中,2~慢
    BYTE    byRes1[2];
    DWORD   dwShowTime;//显示时长，1~60秒
    BYTE    byRes[128];
}NET_DVR_LEDDISPLAY_CFG,*LPNET_DVR_LEDDISPLAY_CFG;

//语音播报控制参数
typedef    struct tagNET_DVR_VOICEBROADCAST_CFG
{
    DWORD        dwSize;//结构体大小
    char        sInfo[MAX_VOICE_INFO_LEN/*128*/]; //语音播报内容
    BYTE        byRes[128];
}NET_DVR_VOICEBROADCAST_CFG,*LPNET_DVR_VOICEBROADCAST_CFG;

//纸票打印格式参数
typedef    struct tagNET_DVR_PAPERPRINTFORMAT_CFG
{
    DWORD        dwSize;//结构体大小
    char        sTitleInfo[MAX_LITLE_INFO_LEN/*64*/]; //纸票标题内容
    char        sCustomInfo[MAX_CUSTOM_INFO_LEN/*64*/]; //纸票自定义信息内容
    char        sPhoneNum[MAX_PHONE_NUM_LEN/*16*/];//联系电话
    BYTE        byPrintInTimeEnabled; //是否打印入场时间
    BYTE        byRes[127];
}NET_DVR_PAPERPRINTFORMAT_CFG,*LPNET_DVR_PAPERPRINTFORMAT_CFG;


//智能锁闸时间段
typedef    struct tagNET_DVR_LOCKGATE_TIME_CFG
{
    char        sBeginTime[LEN_32];//开始时间（32位字符串 HH:MM:SS）    
    char        sEndTime[LEN_32];//结束时间（32位字符串 HH:MM:SS）
    BYTE        byRes[64];
}NET_DVR_LOCKGATE_TIME_CFG,*LPNET_DVR_LOCKGATE_TIME_CFG;

//智能锁闸参数
typedef    struct tagNET_DVR_LOCKGATE_CFG
{
    DWORD        dwSize;//结构体大小
    NET_DVR_LOCKGATE_TIME_CFG struTime[LOCKGATE_TIME_NUM]; //智能锁闸时间段
    BYTE        byRes[128];
}NET_DVR_LOCKGATE_CFG,*LPNET_DVR_LOCKGATE_CFG;

//数据同步状态
typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//应用序列号, 代表当前所连接的应用
    DWORD   dwParkingNum; //当前停车场号
    DWORD   dwUpdataSerialNum; //更新序列号; 代表最后更新的序列号。
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;

//联动EPTZ参数
typedef    struct tagNET_DVR_EPTZ_CFG
{
    DWORD dwSize;
    BYTE    byEnableEPTZ;        //是否启用EPTZ, 0-不启用，1 -启用
    BYTE    byRes[503];
}NET_DVR_EPTZ_CFG, *LPNET_DVR_EPTZ_CFG;

//中心点参数
typedef    struct tagNET_DVR_CENTER_POINT_CFG
{
    DWORD dwSize;
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE    byRes[512];
}NET_DVR_CENTER_POINT_CFG, *LPNET_DVR_CENTER_POINT_CFG;

/********************************DS-TME4XX控制机开发 End****************************/

/********************************IPC FF车牌 Start****************************/
typedef struct tagNET_DVR_FTPUPLOAD_PARAM
{
    char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
    char szCameraName[MAX_CAMNAME_LEN/*32*/];
    BYTE byRes[64];
}NET_DVR_FTPUPLOAD_PARAM, *LPNET_DVR_FTPUPLOAD_PARAM;

//char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
//里面内容是固定字符串  capture_time,plate_No,alarm_type,camera_name
//数组下标表示先后顺序

//char szCameraName[MAX_CAMNAME_LEN/*32*/];
//依赖于szRuleTypeItem中字段表示内容为 camera_name 的情况

typedef struct tagNET_DVR_FTPUPLOADCFG
{
    DWORD dwSize;
    BYTE byEventType; //事件类型，0-默认，1-车辆检测
    BYTE byMode; //图片命名模式，0-默认，1-自定义
    BYTE byRes[62];
    NET_DVR_FTPUPLOAD_PARAM  struCustomVehicle[MAX_FTPNAME_NUM/*12*/];
    BYTE byRes1[1024] ;
}NET_DVR_FTPUPLOADCFG, *LPNET_DVR_FTPUPLOADCFG;

/********************************IPC FF车牌 End****************************/

//信息发布终端升级
typedef struct tagNET_DVR_PUBLISH_UPGRADE_COND
{
    DWORD dwSize;
    DWORD dwUpgradeType;    //升级类型，1-按终端升级，2-按终端组升级
    DWORD dwTerminalNum;    //升级的终端格式，按终端升级时有效
    DWORD *pTerminalNo;     //需要升级的终端号，按终端升级时有效
    DWORD dwGroupNo;        //终端组号，按终端组升级时有效
    BYTE  byRes[32];
}NET_DVR_PUBLISH_UPGRADE_COND, *LPNET_DVR_PUBLISH_UPGRADE_COND;
//WEP加密密钥
typedef struct tagNET_DVR_WEP_KEY_CFG
{
    char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//加密密钥， 
    BYTE    byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;

typedef struct tagNET_DVR_SUB_UPGRADE_PROGRESS
{
    DWORD dwTerminalNo; //终端号
    DWORD dwProgress;   //终端升级进度，0-100，101表示此终端升级出现异常
}NET_DVR_SUB_UPGRADE_PROGRESS, *LPNET_DVR_SUB_UPGRADE_PROGRESS;

typedef struct tagNET_DVR_UPGRADE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //主进度，0-100
    DWORD  dwSubProgressNum;    //子进度个数
    LPNET_DVR_SUB_UPGRADE_PROGRESS  lpStruSubProgress; //各终端升级的子进度，dwSubProgressNum个NET_DVR_SUB_UPGRADE_PROGRESS内容
    BYTE   byRes[32];
}NET_DVR_UPGRADE_PROGRESS_RESULT, *LPNET_DVR_UPGRADE_PROGRESS_RESULT;

//信息发布服务器日程发布进度
typedef struct tagNET_DVR_SCHEDULE_PROGRESS_COND
{
    DWORD dwSize;
    DWORD dwScheduleNo;     //日程号
    BYTE  byProgressType;   //获取的进度类型，1-按组获取进度，2-按终端获取进度
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //终端组号，进度类型为1时有效
    DWORD dwTerminalNo;     //终端号，进度类型为2时有效
    BYTE  byRes2[32];
}NET_DVR_SCHEDULE_PROGRESS_COND, *LPNET_DVR_SCHEDULE_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_SCHEDULE_PROGRESS
{
    DWORD dwTerminalNo; //终端号
    DWORD dwProgress;   //终端日程发布进度，0-100，101表示此终端日程发布出现异常,102表示此终端存储空间不足
}NET_DVR_SUB_SCHEDULE_PROGRESS, *LPNET_DVR_SUB_SCHEDULE_PROGRESS;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //主进度，0-100，按组获取进度时为整组日程发布进度，按终端获取进度时为单个终端日程发布进度
    DWORD  dwSubProgressNum;    //子进度个数，按组获取时有效，表示组下各终端进度个数
    LPNET_DVR_SUB_SCHEDULE_PROGRESS  lpStruSubProgress; //各终端日程发布的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_SCHEDULE_PROGRESS内容
    BYTE   byRes[32];
}NET_DVR_SCHEDULE_PROGRESS_RESULT, *LPNET_DVR_SCHEDULE_PROGRESS_RESULT;



//WEP参数
typedef struct tagNET_DVR_WEP_CFG
{
    BYTE   byAuthenticationType;//身份验证类型；0~开启验证；1~共享密钥；2~自动验证
    BYTE   byDefaultTransmitKeyIndex;//默认传输密钥个数，1~4个。对应到struEncryptionKeyCfg加密密钥的个数。
    /*
    当为64位密钥时，ASCII码密钥字符长度为5个。
    当为128位密钥时，ASCII码密钥字符长度为13个。
    */
    BYTE   byWepKeyLenType;//密钥类型；0~   64位密钥，1~  128位密钥。
    BYTE   byKeyType;// 密钥类型；0~   ASCII码，1~  16进制。
    NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP加密密钥，最大支持4个。
    BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

//WPA参数
typedef struct tagNET_DVR_WPA_CFG
{
    BYTE   byAlgorithmType; //算法类型；0~TKIP, 1~AES, 2~TKIP/AES
    BYTE   byWPAKeyLen;// WPA共享密钥长度，区间为8~63，对应到csSharedKey参数的字符长度
    BYTE   byDefaultPassword;//是否启用默认WPA密钥
    BYTE   byRes1;
    char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//WPA共享密钥,为8-63个ASCII字符
    BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;


typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
    BYTE   bySecurityMode; //安全模式；0~禁用,1~WEP,2~WPA-personal, 3~WPA2-personal
    NET_DVR_WEP_CFG  struWEPCfg; //当安全模式选择为WEP时生效。
    NET_DVR_WPA_CFG  struWPACfg; //当安全模式选择为WPA-personal、WPA2-personal时生效。
    BYTE    byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

//wifi热点参数配置(完整版)
typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD    dwSize;//结构体大小
    BYTE    byWifiAPEnabled;  //是否启用无线AP：0-否，1- 是
    BYTE    byBroadcastEnabled; // 是否启用广播，0-否，1-是
    BYTE    byWlanShareEnabled; //是否启用共享，0-否，1-是
    BYTE    byDHCPEnabled; //是否启用DHCP，0-否，1-是
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType; //IP地址类型，0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr;  //IP地址
    NET_DVR_IPADDR    struIPMask;  //掩码地址
    NET_DVR_IPADDR    struGatewayIPMask;  //网关地址
    NET_DVR_IPADDR    struStartIPAddrPool;  //IP段起始地址
    NET_DVR_IPADDR    struEndIPAddrPool;  // IP段结束地址
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS地址
    NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg;//无线安全加密参数
    BYTE    byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;    //通道号，0为无效
    BYTE byChannelName[NAME_LEN];
    BYTE bySignal;  //是否有信号，0-无，1-有，只读
    BYTE bySignalType;  //信号源类型，1-标清，2-高清，有信号时有效，只读
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;    //是否有效，0-无效，1-有效
    BYTE  byRes1[3];
    DWORD dwDevNo;    //光端机号
    BYTE  byDevName[NAME_LEN];   //节点光端机名称
    BYTE  byDevID[MAX_ID_LEN];   //光端机物理ID，设备唯一标识，只读
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM];
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

#define MAX_OPTICAL_DEV_NODE 32     //最多节点光端机数

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //是否有信号接入，0-无，1-有，只读
    BYTE  byLinkType;    //链路类型，1-环网，2-链网，只读
    BYTE  byPortWorkMode;    //端口工作模式，0-无效，1-主口，2-辅口，当链路类型为环网时有效，只读
    BYTE  byRes1[1];
    DWORD dwPairPort;    //配对光口号，链路类型为环网时有效，主口时此参数为辅口号，辅口时，此参数为主口号
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //节点光端机设备信息
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
    DWORD dwSize;
    BYTE  byEnable;    //是否关联光端机输入，0-否，非0-是
    BYTE  byRes1[3];
    DWORD dwDevNo;    //光端机号
    DWORD dwOpticalPort;  //光口号
    BYTE  byDevID[MAX_ID_LEN];   //光端机物理ID
    DWORD dwInputChanNo;  //光端机输入通道号
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;

typedef  struct tagNET_DVR_START_FILE_TO_CLOUD_COND
{
    DWORD    dwSize; 
    BYTE    aCameraID[MAX_CAMERAID_LEN];    //编码器ID
    DWORD      dwPoolID;    //存储池ID
    DWORD      dwRepPoolID;    //冗余池ID
    WORD      wReplication;    //冗余份数
    BYTE       byRes [178];
}NET_DVR_START_FILE_TO_CLOUD_COND,*LPNET_DVR_START_FILE_TO_CLOUD_COND;

typedef  struct     tagNET_DVR_START_PICTURE_FROM_CLOUD_COND
{
    DWORD       dwSize;
    BYTE        aCameraID[MAX_CAMERAID_LEN];    //编码器ID
    NET_DVR_TIME_V30    struBeginTime;    //开始时间
    NET_DVR_TIME_V30    struEndTime;        //结束时间
    DWORD   dwPicType;        //图片类型，按位表示
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    BYTE    byRes1[3];
    BYTE    byZoomType;    //0-不缩放,1-按比例,2-按大小,3-按分辨率
    union
    {
        BYTE    uLen[32];
        struct
        {
            BYTE        byScale;         //1~99
        }struScale;
        struct
        {
            BYTE        byQuality;    //1~99
        }struQuality;
        struct
        {
            DWORD       dwWidth;    
            DWORD       dwHeight;
        }struResolution; //目标分辨率
    }uZoomParam;
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //数据回调函数
    void*   pUser;    //用户数据指针
    BYTE    byRes [372];
}NET_DVR_START_PICTURE_FROM_CLOUD_COND,*LPNET_DVR_START_PICTURE_FROM_CLOUD_COND;

typedef     struct    tagNET_DVR_START_PICTURE_FROM_CLOUD_RET
{
    DWORD       dwSize;
    DWORD       dwFileCount;    //文件数量
    BYTE        byRes[120];
}NET_DVR_START_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_START_PICTURE_FROM_CLOUD_RET;

typedef  struct 
{
    DWORD       dwSize;
    NET_DVR_TIME_V30    struTime;    //图片时间
    DWORD       dwPicLen;    //图片长度
    BYTE        byPicType;    //图片格式,1-jpg,2-bmp,3-png
    BYTE        byRes[107];
}NET_DVR_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_PICTURE_FROM_CLOUD_RET;

typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //身份证信息上报，0：上传18位身份证号；1：上传全部信息
    BYTE byRes1;
    BYTE byCardVerifyMode; //刷卡认证模式，0：远程中心认证；1：客户端平台认证
    BYTE byACSDevType; //设备型号，1：身份证读卡器，2：IC读卡器，3：二维码读卡器，4：指纹读卡器，5：字符屏+二维码读卡器，6：收卡器，7：字符屏，8：指纹头，9：语音模块；
    BYTE byDoorMode; //门出入类型，0：进门，1：出门；
    BYTE byRes2;
    WORD wDevDetailType; //外设的具体设备型号，1-iDR210，2-IDM10；
    BYTE byRes[300];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;            //进门模式，0受控；1禁止；2自由；
    BYTE byOutMode;         //出门模式，0受控；1禁止；2自由；
    BYTE byWorkMode;        //工作模式，0紧急；1维护；2常闭；3常开； 
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

#define MAX_ID_NUM_LEN                  32  //最大身份证号长度
#define MAX_ID_NAME_LEN                 128   //最大姓名长度
#define MAX_ID_ADDR_LEN                 280   //最大住址长度
#define MAX_ID_ISSUING_AUTHORITY_LEN    128 //最大签发机关长度

//身份证信息
typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;        //结构长度
    BYTE  byName[MAX_ID_NAME_LEN];   //姓名
    NET_DVR_DATE struBirth; //出生日期
    BYTE byAddr[MAX_ID_ADDR_LEN];  //住址
    BYTE byIDNum[MAX_ID_NUM_LEN];   //身份证号码
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];  //签发机关
    NET_DVR_DATE struStartDate;  //有效开始日期
    NET_DVR_DATE struEndDate;  //有效截止日期
    BYTE byTermOfValidity;  //是否长期有效， 0-否，1-是（有效截止日期无效）
    BYTE   bySex;  //性别，1-男，2-女
    BYTE  byNation;    //民族，1-"汉"，2-"蒙古"，3-"回",4-"藏",5-"维吾尔",6-"苗",7-"彝",8-"壮",9-"布依",10-"朝鲜",
    //11-"满",12-"侗",13-"瑶",14-"白",15-"土家",16-"哈尼",17-"哈萨克",18-"傣",19-"黎",20-"傈僳",
    //21-"佤",22-"畲",23-"高山",24-"拉祜",25-"水",26-"东乡",27-"纳西",28-"景颇",29-"柯尔克孜",30-"土",
    //31-"达斡尔",32-"仫佬",33-"羌",34-"布朗",35-"撒拉",36-"毛南",37-"仡佬",38-"锡伯",39-"阿昌",40-"普米",
    //41-"塔吉克",42-"怒",43-"乌孜别克",44-"俄罗斯",45-"鄂温克",46-"德昂",47-"保安",48-"裕固",49-"京",50-"塔塔尔",
    //51-"独龙",52-"鄂伦春",53-"赫哲",54-"门巴",55-"珞巴",56-"基诺"
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

//身份证信息报警
typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;        //结构长度
    NET_DVR_ID_CARD_INFO    struIDCardCfg ;//身份证信息
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME_V30  struSwipeTime; //时间
    BYTE    byNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    DWORD dwDoorNo; //门编号，为0无效
    DWORD dwPicDataLen;   //图片数据大小，不为0是表示后面带数据
    char    *pPicData;
    BYTE byCardType; //卡类型，1-普通卡，2-残疾人卡，3-黑名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    BYTE byRes[207];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;        //结构长度
    DWORD  dwAccessChannel;    //人员通道号
    NET_DVR_TIME_V30  struSwipeTime; //时间
    BYTE    byNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    DWORD    dwEntryTimes;    //人员入次数；
    DWORD    dwExitTimes;        //人员出次数；
    DWORD    dwTotalTimes;        //人员出入总次数； 
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;
typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
    DWORD   dwSize;
    DWORD   dwVideoMangeNo;  //视频管理号
    BYTE    byVideoType;  //视频格式 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB 
    BYTE    byRes1[3];  //保留
    BYTE    sVideoName[NAME_LEN];  //视频名称 
    NET_DVR_TIME_V30 struTime;  //图片上传时间
    BYTE     byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
    DWORD   dwSize;
    BYTE    sFileName[NAME_LEN];  //文件名称
    DWORD    dwManageNo;     //(只能获取)
    NET_DVR_TIME_EX  struTime;    //文档上传时间 
    BYTE    byUsed;          //是否已存在，0-不存在，1-存在 （只能获取）
    BYTE    byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
    DWORD    dwSize;
    BYTE    byItemType;  //播放项类型，1-图片 2-视频 3-播放列表 
    BYTE    byRes[3];    //保留
    DWORD    dwPlayManageNo;   //播放管理号
    DWORD    dwPlayPicTime; //播放图片时间，单位秒, (类型为图片有效) 
    BYTE    byRes2[64]; 
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM; 

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
    DWORD    dwSize;
    BYTE    byEnable;  //是否有效， 0-无效  !0-有效
    BYTE    byPlayType;  //播放模式，1-循环播放
    BYTE    byVaildItemNum;    //有效播放项数量
    BYTE    byRes[1]; 
    NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM]; //播放项，前byVaildItemNum有效
    BYTE     byPlaylistName[PLAYLIST_NAME_LEN];  //播放列表名称   
    DWORD   dwPlaylistNo;    //播放列表号（获取有效）
    BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;
typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
    DWORD    dwSize;   
    BYTE    byCtrlType;  //操作类型， 1-添加播放项  2-删除播放项  3-移动播放项位置
    BYTE    byPlayIndex;  //播放序号， 从1开始
    NET_DVR_PLAY_ITEM struPlayItem;    //播放项
    BYTE   byNewPlayIndex;   //新播放序号，0无效
    BYTE   byRes[63]; 
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL; 
typedef struct tagNET_DVR_PLAN_ITEM
{
    NET_DVR_PLAY_ITEM struPlanPlayItem;       //播放项    
    NET_DVR_TIME_SEGMENT struTimeSegment;     //时间段参数
    BYTE  byRes[16]; 
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD    dwSize;   
    BYTE    byEnable;  //是否使能,  0-不使能 !0-使能
    BYTE    byPlanMode;   //计划模式，1-周计划  2-日计划
    BYTE    byRes[2];
    NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwPlayPlanNo;   //播放计划号（获取时有效）
    BYTE    byPlayPlanName[NAME_LEN]; //播放计划名称
    BYTE    byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;
typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;    //是否启用播放计划， 0-不启用 !0-启用
    BYTE byRes[3];
    DWORD dwPlayPlanNo;   //播放计划号
    BYTE byRes2[32]; 
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG; 
typedef struct tagNET_DVR_DEV_PLAYCTRL
{
    DWORD   dwSize;
    BYTE    byControlType;  //控制类型，1-音频开，2-音频关，3-停止播放，4-暂停播放，恢复播放 
    BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;

typedef union tagNET_DVR_PLAYITEM_INFO
{
    struct   //单独播放
    {
        DWORD  dwPlayItem;   //播放项
        BYTE    byPlayItemName[NAME_LEN]; //播放项名称
        BYTE    byRes2[8]; 
    } struPlayItem;    
    struct  //播放列表
    {
        DWORD  dwPlaylistNo;  //播放列表号
        BYTE    byPlaylistName[NAME_LEN]; //播放列表名称
        WORD   wPlayIndex;    //播放位置
        BYTE    byPlayType;    //播放列表中正在播放类型 1-图片 2-视频  
        BYTE    byRes[3];      
        DWORD  dwPlayItem;   //播放项    
        BYTE    byPlayItemName[NAME_LEN]; //播放项名称
        BYTE    byRes2[16];
    } struPlaylistItem;
    struct  //播放计划项
    {
        DWORD  dwPlayPlanNo;  //播放计划号 
        NET_DVR_TIME_SEGMENT struTime;      //正在播放时间段
        BYTE    byPlayType;  //播放计划正在播放类型  1-图片 2-视频 3-播放列表
        BYTE    byRes[3]; 
        DWORD  dwPlaylistNo;  //播放列表号
        BYTE    byPlaylistName[NAME_LEN]; //播放列表名称
        DWORD  dwPlayItem;   //播放项
        BYTE    byPlayItemName[NAME_LEN]; //播放项名称
        WORD   wPlayIndex;    //播放位置
        BYTE    byRes2[18];       
    } struPlayPlanItem;
}NET_DVR_PLAYITEM_INFO, *LPNET_DVR_PLAYITEM_INFO; 
typedef struct tagNET_DVR_PLAYING_INFO
{
    DWORD    dwSize;
    BYTE    byPlayWay;   //播放方式， 1-单项播放  2-播放列表  3-播放计划 4-动态解码 5-紧急插播
    BYTE    byCurPlayType; //正在播放素材类型， 1-图片 2-视频，动态解码和紧急插播时无效
    BYTE    byPlayState;    //播放状态，1-正在播放，2-播放停止，3-播放暂停
    BYTE    byAudioState;    //音频开关状态，0-关，1-开
    NET_DVR_PLAYITEM_INFO  struPlayItemInfo;  //播放项信息
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_ONLINEUSER_COND //条件结构
{
    DWORD   dwSize; 
    DWORD  dwChannel;//通道号（前端默认是1）
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG //配置结构
{
    DWORD   dwSize; 
    BYTE   byID;//用户序列号
    BYTE   byUserType;//用户类型 0-普通用户，1-操作员，2-超级用户
    BYTE   byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;//IP地址    
    NET_DVR_TIME_V30  struLoginTime;//登陆时间
    char   szUserName[NAME_LEN/*32*/];//用户名
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;

//存储健康状态
typedef    struct tagNET_DVR_STORAGE_DETECTION
{
    DWORD    dwSize;//结构体大小
    BYTE    byHealthState;//健康状态0-良好，1-差，2-损坏，3-未知
    BYTE    bySDCardState;//SDcard状态 0-掉线，1-上线,2-未知,3-已锁定
    WORD    wAbnormalPowerLoss;//异常掉电数
    WORD    wBadBlocks;//坏块数
    BYTE    byRemainingLife; //SD卡剩余寿命; 0~100%
    BYTE    byRes[125];
}NET_DVR_STORAGE_DETECTION,*LPNET_DVR_STORAGE_DETECTION;

//存储智能检测报警上传
typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    DWORD   dwCardID;   //卡ID
    WORD    wAbnormalPowerLoss;//异常掉电数
    WORD    wBadBlocks;//坏块数
    BYTE    byHealthState;//健康状态0-良好，1-差，2-损坏，3-未知
    BYTE    byRes1[3];
    float   fResidualLife; //SD卡 预计剩余寿命
    BYTE    byRes[118];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;


//存储侦测的读写锁配置
typedef    struct tagNET_DVR_STORAGE_RWLOCK
{
    DWORD   dwSize;//结构体大小
    BYTE    byEnabled;//使能 0-关闭，1-开启
    BYTE    byRes[3];
    char    szPassWD[PASSWD_LEN/*16*/]; //读写锁新密码
    char    szOriginalPassWD[PASSWD_LEN/*16*/]; //原始密码
    BYTE    byRes1[128];
}NET_DVR_STORAGE_RWLOCK,*LPNET_DVR_STORAGE_RWLOCK;

//存储侦测的解锁配置
typedef    struct tagNET_DVR_STORAGE_UNLOCK
{
    DWORD   dwSize;//结构体大小
    char    szPassWD[PASSWD_LEN/*16*/]; //密码
    BYTE    byRes1[128];
}NET_DVR_STORAGE_UNLOCK,*LPNET_DVR_STORAGE_UNLOCK;


typedef    struct tagNET_DVR_PTZTRACKSTATUS
{
    DWORD        dwSize;//结构体大小
    BYTE          byID;//联动设备的ID (字段byLinkageType非0的时候生效)
    BYTE      byLinkageType;//联动动作0-不联动，1-联动球机设备跟踪
    BYTE      byRes[254];
}NET_DVR_PTZTRACKSTATUS,*LPNET_DVR_PTZTRACKSTATUS;

#define MAX_PROXY_COUNT 32

typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129];  //代理服务器地址
    BYTE  byAuthType; //认证方式，暂时先不使用该字段 
    WORD  wPort;      //代理服务器端口
    BYTE  byRes2[64]; //如果要使用认证方式，必然需要一些保留字节，先留一些
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD                     dwLength;         //结构长度
    DWORD                    dwChannel;         //通道
    NET_DVR_TIME_V30        struTimePoint;    //时间点
    BYTE                      byRes[64];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen;     //图片长度
    char     *pPicBuf;     //图片数据
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;

//手动测距参数
typedef    struct tagNET_DVR_MANUALRANGING_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否开启手动测距：0- 否，1- 是
    BYTE        byRes[127];
}NET_DVR_MANUALRANGING_CFG,*LPNET_DVR_MANUALRANGING_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD           dwSize;            //结构体大小
    BYTE           byDoorNotCloseAlarm;   //是否上传门未关报警，0-不上传，1-上传
    BYTE            byRes[603];         //保留
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp 
    DWORD    dwYear;            //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate,当帧率小于0时，0x80000002:表示1/2帧率，同理可推0x80000010为1/16帧率
    DWORD    dwFlag;         //flag E帧标记
    DWORD    dwFilePos;      //file pos
    DWORD     dwPacketType;    //Packet type:0 -file head，1 -video I frame，2- video B frame， 3- video P frame， 10- audio packet， 11- private packet
    DWORD     dwPacketSize;   //packet size
    unsigned char*    pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   //打包方式:0-保留，1-FU_A打包方式
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] 表示私有数据类型 
    //reserved[1] 表示私有裸数据地址高位
    //reserved[2] 表示私有裸数据地址低位
    //reserved[3] 表示私有裸数据长度
    //reserved[4] 私有帧/包的时间间隔\时间戳
    //reserved[5].一bit位标记是否为深P帧，深P：1，不为深P：0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef BOOL (* DEV_WORK_STATE_CB)(void* pUserdata, int iUserID, LPNET_DVR_WORKSTATE_V40 lpWorkState);

typedef struct tagNetDVRCheckDevState
{
    DWORD                dwTimeout;      //定时检测设备工作状态，单位ms，为0时，表示使用默认值(30000)。最小值为1000
    DEV_WORK_STATE_CB    fnStateCB;
    void*                pUserData;
    BYTE                byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;

#define COURSE_NAME_LEN_128                128    //课程名称
#define INSTRUCTOR_NAME_LEN_64            64    //授课教师
#define MAX_UUID_LEN            64    //手动课程UUID

//获取条件结构体
typedef    struct tagNET_DVR_COURSE_LIST_COND
{
    DWORD                    dwSize;
    NET_DVR_TIME_V30        struStartTime;   //课程开始时间
    NET_DVR_TIME_V30        struEndTime;   //课程结束时间
    BYTE                       byCourseName[COURSE_NAME_LEN_128];  //课程名称
    BYTE                       byInstructorName[INSTRUCTOR_NAME_LEN_64]; //授课老师
    BYTE                   byCourseType; //课表类型，0-全部，1-手动
    BYTE                    byRes[603];
}NET_DVR_COURSE_LIST_COND,*LPNET_DVR_COURSE_LIST_COND;

typedef struct  tagNET_DVR_COURSE_CFG
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //课程开始时间
    NET_DVR_TIME_V30        struEndTime;   //课程开始时间
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE            byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE           byCourseType;//课表类型，0-全部，1-手动课表
    BYTE            byRes[303];
}NET_DVR_COURSE_CFG, *LPNET_DVR_COURSE_CFG;

typedef struct tagNET_DVR_RECORD_STATUS
{
    DWORD       dwSize;              //结构体大小
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE        byRecordStatus;         //录播状态，0-暂停，1-屏蔽,2-正在录像，3-空闲
    BYTE     byRes[603];              //保留字节 
}NET_DVR_RECORD_STATUS, *LPNET_DVR_RECORD_STATUS;

typedef struct tagNET_DVR_MANUAL_CURRICULUM_CFG
{
    DWORD       dwSize;              //结构体大小
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE           byCourseName[COURSE_NAME_LEN_128];  //课程名称
    BYTE           byInstructorName[INSTRUCTOR_NAME_LEN_64]; //授课老师
    BYTE        byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE        byCmdType;            //命令，0-开始录像 1-结束 2-暂停 3-继续,4-开始屏蔽，5-结束屏蔽
    BYTE         byRes[303];              //保留字节
}NET_DVR_MANUAL_CURRICULUM_CFG, *LPNET_DVR_MANUAL_CURRICULUM_CFG;

typedef struct tagNET_DVR_IMAGE_DIFF_DETECTION_CFG
{
    DWORD       dwSize;              //结构体大小
    NET_VCA_POLYGON struRegion;    //区域范围
    BYTE       byEnabled;    //是否启用，0-不启用，1-启用
    BYTE        byThreshold;             //阈值[0,100]
    BYTE         bySensitivity;        //灵敏度 [0,100]
    BYTE     byRes[301];              //保留字节 
}NET_DVR_IMAGE_DIFF_DETECTION_CFG, *LPNET_DVR_IMAGE_DIFF_DETECTION_CFG;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //发布文件ID
    BYTE             byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_COND, *LPNET_DVR_RECORDING_PUBLISH_FILE_COND;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_INFO
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //课程开始时间
    NET_DVR_TIME_V30        struEndTime;   //课程开始时间
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE     byRes[300];              //保留字节 
}NET_DVR_RECORDING_PUBLISH_FILE_INFO, *LPNET_DVR_RECORDING_PUBLISH_FILE_INFO;

//屏幕控制
typedef struct tagNET_DVR_SCREEN_POINT
{
    WORD wX; //X坐标
    WORD wY; //Y坐标
}NET_DVR_SCREEN_POINT,*LPNET_DVR_SCREEN_POINT;

typedef struct tagNET_DVR_MOUSE_PARAM
{
    BYTE byMouseEvent;                   //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                                         //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                                         //10-滚轮松开，11-滚轮向下，12-滚轮向上
    BYTE byRes1[3];
    NET_DVR_SCREEN_POINT struMousePoint; //鼠标坐标信息
    BYTE byRes2[8];
}NET_DVR_MOUSE_PARAM, *LPNET_DVR_MOUSE_PARAM;

typedef struct tagNET_DVR_MARK_PARAM
{
       BYTE byMarkEvent;           //标注事件，1-正常标注，2-标注结束
    BYTE byMarkTool;           //标注工具，0-无效，1-画笔，2-橡皮擦，标注事件为1时有效
    BYTE byLineWidth;          //线条粗细，0-无效，1-细，2-中，3-粗，标注事件为1时有效
    BYTE byMouseEvent;         //鼠标事件，标注事件为1时有效，0-无效，1-鼠标左键按下，2-鼠标左键松开，3-鼠标移动
    NET_DVR_RGB_COLOR struColor;    //标注颜色，标注工具为画笔时有效
    NET_DVR_SCREEN_POINT struPoint; //标注坐标信息
    BYTE byRes[4];
}NET_DVR_MARK_PARAM, *LPNET_DVR_MARK_PARAM;

typedef struct tagNET_DVR_KEYBOARD_PARM
{
    DWORD dwKeyValue; //符号使用ASCII表中的值，特殊按键待确定
    BYTE  byRes[12];
}NET_DVR_KEYBOARD_PARAM, *LPNET_DVR_KEYBOARD_PARAM;

typedef struct tagNET_DVR_PPT_PARAM
{
    BYTE  byPPTAction;              //PPT动作，1-打开放映，2-停止放映，3-上一个动画，4-下一个动画，
                                    //5-上一页，6-下一页，7-跳到X页，8-激光笔开，9-激光笔关，10-激光笔移动
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //激光笔坐标信息，PPT动作为10时有效
    DWORD dwPPTNo;                  //PPT页码数，PPT动作为7时有效
    BYTE  byRes2[4];
}NET_DVR_PPT_PARAM, *LPNET_DVR_PPT_PARAM;

typedef struct tagNET_DVR_REMOTE_CTRL_PARAM
{
    BYTE byRemoteCtrlCmd;   //远程控制命令，1-切换置顶窗口，2-关闭屏幕当前窗口，3-打开文件，4-关闭文件，5-删除文件，6-关机
    BYTE byRes1[3];
    DWORD dwCtrlParam;    //操作参数，打开关闭文件时为文件索引号
    BYTE byRes2[8];
}NET_DVR_REMOTE_CTRL_PARAM, *LPNET_DVR_REMOTE_CTRL_PARAM;

typedef struct tagNET_DVR_SPOTLIGHT_PARAM
{
    BYTE  byCmd;                    //聚光灯命令，0-关闭聚光灯，1-开启聚光灯，2-聚光灯位置移动
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //聚光灯中心点坐标，聚光灯位置移动时有效
    DWORD dwRadius;                 //聚光灯半径
    BYTE  byRes2[4];
} NET_DVR_SPOTLIGHT_PARAM, *LPNET_DVR_SPOTLIGHT_PARAM;

typedef struct tagNET_DVR_TOUCHPAD_PARAM
{
    BYTE byMouseEvent;  //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                        //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                        //10-滚轮松开，11-滚轮向下，12-滚轮向上
    BYTE byRes1[3];
    int iXDisplacement; //X轴位移，正数表示向右移动，负数表示向左移动，鼠标移动时有效
    int iYDisplacement; //Y轴位移，正数表示向上移动，负数表示向下移动，鼠标移动时有效
    BYTE byRes2[4];
}NET_DVR_TOUCHPAD_PARAM, *LPNET_DVR_TOUCHPAD_PARAM;

typedef struct tagNET_DVR_MEDIA_LIST_PARAM
{
    BYTE byOperateCmd;     //操作命令，1-显示图片素材，2-显示视频素材，3-显示ppt素材，4-关闭多媒体文件夹
    BYTE byRes[15];
}NET_DVR_MEDIA_LIST_PARAM, *LPNET_DVR_MEDIA_LIST_PARAM;

typedef union tagNET_DVR_SCREEN_CTRL_PARAM
{
    NET_DVR_MOUSE_PARAM struMouseParam;             //鼠标参数，命令类型为1时有效
    NET_DVR_MARK_PARAM struMarkParam;               //标注参数，命令类型为2时有效
    NET_DVR_KEYBOARD_PARAM struKeyboardInfo;        //键盘参数，命令类型为3时有效
    NET_DVR_PPT_PARAM struPPTParam;                 //PPT参数，命令类型为4时有效
    NET_DVR_REMOTE_CTRL_PARAM struRemoteCtrlParam;  //远程操作参数，命令类型为5时有效
    NET_DVR_SPOTLIGHT_PARAM struSpotLight;          //聚光灯参数，命令类型为6时有效
    NET_DVR_TOUCHPAD_PARAM struTouchPadParam;        //触摸板参数，命令参数为7时有效
    NET_DVR_MEDIA_LIST_PARAM struMediaListParam;    //多媒体参数，命令类型为8时有效
    BYTE byRes[16];
}NET_DVR_SCREEN_CTRL_PARAM, *LPNET_DVR_SCREEN_CTRL_PARAM;

typedef struct tagNET_DVR_SCREEN_CTRL_CMD
{
    DWORD dwSize;
    BYTE  byCmdType;                               //命令类型，1-鼠标，2-标注，3-键盘，4-PPT，5-远程操作，6-聚光灯，7-触控板，8-显示多媒体材料
    BYTE  byRes1[3];
    NET_DVR_SCREEN_CTRL_PARAM struScreenCtrlParam; //屏幕控制参数
}NET_DVR_SCREEN_CTRL_CMD, *LPNET_DVR_SCREEN_CTRL_CMD;

typedef struct tagNET_DVR_FILE_RESPONSE_PARAM
{
    BYTE byFileState;       //文件操作状态，1-文件索引不存在
    BYTE byRes1[3];
    DWORD dwErrorFileIndex; //文件操作的文件索引值
    BYTE byRes2[24];
} NET_DVR_FILE_RESPONSE_PARAM, *LPNET_DVR_FILE_RESPONSE_PARAM;

typedef struct tagNET_DVR_PPT_RESPONSE_PARAM
{
    BYTE  byCurrentState;   //当前PPT状态，1-正在放映，2-放映停止，3-PPT已关闭，4-ppt受保护或生产预览图失败，5-获取页码失败，6-ppt内容为空，7-缩略图生成失败，8-缩略图生成成功
    BYTE  byRes1[3];
    DWORD dwCurrentPage;    //PPT的页数，PPT状态为1,7,8时有效
    DWORD dwFileIndex;        //PPT文件索引值
    DWORD dwTotalPageNum;    //PPT总页数，PPT状态为5时有效
    BYTE  byRes2[16];
}NET_DVR_PPT_RESPONSE_PARAM, *LPNET_DVR_PPT_RESPONSE_PARAM;

typedef union tagNET_DVR_SCREEN_RESPONSE_PARAM
{
    BYTE byRes[32];
    NET_DVR_PPT_RESPONSE_PARAM  struPPTParam;  //PPT参数
    NET_DVR_FILE_RESPONSE_PARAM    struFileParam; //文件操作响应参数
}NET_DVR_SCREEN_RESPONSE_PARAM,*LPNET_DVR_SCREEN_RESPONSE_PARAM;

typedef struct tagNET_DVR_SCREEN_RESPONSE_CMD
{
    DWORD dwSize;
    BYTE  byResponseCmd; //屏幕响应命令类型，1-PPT，2-文件操作
    BYTE  byRes1[3];
    NET_DVR_SCREEN_RESPONSE_PARAM struResonseParam; //屏幕响应参数
    BYTE  byRes2[16];
}NET_DVR_SCREEN_RESPONSE_CMD, *LPNET_DVR_SCREEN_RESPONSE_CMD;

typedef struct tagNET_DVR_SCREEN_FILE_COND
{
    DWORD dwSize;
    BYTE  byFileType; //文件类型，1-图片，2-视频，3-ppt，0xff-所有文件类型
    BYTE  byRes[127];
}NET_DVR_SCREEN_FILE_COND, *LPNET_DVR_SCREEN_FILE_COND;

typedef struct tagNET_DVR_SCREEN_FILE_INFO
{
    DWORD dwSize;
    DWORD dwFileIndex;     //文件索引，全局唯一
    BYTE  byFileType;      //文件类型，1-图片，2-视频，3-ppt
    BYTE  byPictureFormat; //图片格式，文件类型为图片时有效，1-bmp,2-jpeg,3-png,4-swf,5-gif 
    BYTE  byVideoFormat;   //视频格式，文件类型为视频时有效，1-avi,2-wmv,3-mp4,4-flv,5-vod,6-mkv,7-rmvb
    BYTE  byRes1;
    BYTE  byFileName[MAX_FILE_PATH_LEN]; //屏幕文件名
    DWORD dwFileSize;     //文件大小，单位：字节
    DWORD dwPPTPage;      //ppt页码值，仅当获取已打开的PPT文件信息时有效
    BYTE  byRes2[64];
}NET_DVR_SCREEN_FILE_INFO, *LPNET_DVR_SCREEN_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_CONFIG
{
    DWORD dwSize;
    BYTE  byVolume;             //音量，0-100
    BYTE  byContrast;           //对比度，0-100
    BYTE  byBrightness;         //亮度，0-100
    BYTE  byScreenShowEnabled;  //开启屏幕显示，0-关，非0-开
    BYTE  byScreenLocked;       //锁定屏幕，0-解锁，非0-锁定
    BYTE  byBlackScreenEnabled; //屏幕黑屏，0-取消黑屏，非0-黑屏
    BYTE  byRes[30];
}NET_DVR_SCREEN_CONFIG, *LPNET_DVR_SCREEN_CONFIG;

typedef struct tagNET_DVR_SCREEM_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    BYTE  byFileType;      //文件类型，1-图片，2-视频，3-ppt
    BYTE  byPictureFormat; //图片格式，0-bmp 1-JPEG，2-PNG 3-SWF 4-GIF，文件类型为1时有效
    BYTE  byVideoFormat;   //视频格式，0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB，文件类型为2时有效
    BYTE  byRes1;
    BYTE  byFileName[MAX_FILE_PATH_LEN]; //文件名称
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_UPLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileIndex;  //文件索引
    DWORD dwPPTPageNo;  //下载PPT页面图片时有效，为0表示下载PPT本身，其他值表示PPT页码值
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;

typedef enum _EN_SWITCH_CONVERT_ALARM
{
    SC_OPTICAL_PORT_LOST = 1,
    SC_NETWORK_PORT_LOST,
}EN_SWITCH_CONVERT_ALARM;
//语音参数配置
typedef    struct tagNET_DVR_TMEVOICE_CFG
{
    DWORD      dwSize;//结构体大小
    BYTE       byVoiceSpeed;//语速 0~100
    BYTE       byVoicePitch; //语调 0~100
    BYTE       byVoiceVolum; //音量0~100
    BYTE       byRes1;
    /*声音种类；
    3  = Xiaoyan (female, Chinese) 
    51 = Jiu Xu (male, Chinese) 
    52 = Duo Xu (male, Chinese) 
    53 = Xiaoping (female, Chinese)
    54 = Donald Duck (male, Chinese)
    55 = Baby Xu (child, Chinese)
    */
    DWORD     dwVoiceRole; //声音种类
    char      sInfo[MAX_TMEVOICE_LEN/*64*/]; //语音播报内容（出入口压线圈播报的语音内容）
    BYTE      byRes[128];
}NET_DVR_TMEVOICE_CFG,*LPNET_DVR_TMEVOICE_CFG;

typedef enum _EN_SWICH_CONVERT_NOTIFICATION
{
    SC_OPTICAL_PORT_CONNECTED = 1,
    SC_NETWORK_PORT_CONNECTED,
}EN_SWITCH_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_SWITCH_CONVERT_ALARM
{
    DWORD dwSize;
    BYTE  byPortNo;    //接口索引，从1开始
    BYTE  byRes1[3];
    DWORD dwEventType; //事件类型，1-告警，2-通知
    DWORD dwEvent;     //具体事件，告警时参考枚举EN_SWITCH_CONVERT_ALARM，通知时参考枚举EN_SWITCH_CONVERT_NOTIFICATION
    BYTE  byRes2[32];    
}NET_DVR_SWITCH_CONVERT_ALARM, *LPNET_DVR_SWITCH_CONVERT_ALARM;

//输入板参数配置
typedef struct tagNET_DVR_INPUT_BOARD_CFG
{
    DWORD    dwSize;
    DWORD    dwSlotNo;           //输入板槽位号
    BYTE    byFullFrameEnable;  //是否开启全帧率畅显，0-不开启，1-开启
    BYTE    byRes[3];           //四字节对齐
    BYTE    byRes1[64];         //保留
}NET_DVR_INPUT_BOARD_CFG, *LPNET_DVR_INPUT_BOARD_CFG;

typedef struct tagNET_DVR_INPUT_BOARD_CFG_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_BOARD_CFG struBoardList[MAX_NUM_INPUT_BOARD]; //输入板配置信息列表
}NET_DVR_INPUT_BOARD_CFG_LIST, *LPNET_DVR_INPUT_BOARD_CFG_LIST;

/******************************安全防范视频监控联网信息安全 begin******************************************/
//获取加密设备信息条件结构体
typedef struct _NET_DVR_ENCRYPT_DEVICE_COND
{
    DWORD  dwSize;     //结构体大小
    DWORD  dwChannel;     //通道号
    BYTE   byAlgorithm; //加密算法，0-保留，1-RSA,2-SM2
    BYTE   byModelLen; //模长，0-保留，1-1024位,2-2048位,3-256位
    BYTE   byCERTSaveLocation; //证书保存位置，根据设备返回的能力集来选择，0-保留，1-加密芯片中(通过USB插入设备),2-设备中
    BYTE   byRes[29];
}NET_DVR_ENCRYPT_DEVICE_COND, *LPNET_DVR_ENCRYPT_DEVICE_COND;
//获取加密设备信息结构体
typedef struct _NET_DVR_ENCRYPT_DEVICE_INFO
{
    DWORD  dwSize;     //结构体大小
    BYTE   byAlgorithm; //加密算法，0-保留，1-RSA,2-SM2
    BYTE   byModelLen; //模长，0-保留，1-1024位,2-2048位,3-256位
    BYTE   byRes1[30];  //保留
    DWORD  dwPublicKeyLen;        //公钥长度
    char   szPublicKey[MAX_PUBLIC_KEY_LEN];       //公钥 
    char   szChipSerialNumber[CHIP_SERIALNO_LEN];   //芯片序列号
    char   szDeviceID[ENCRYPT_DEV_ID_LEN];     //设备ID
    BYTE   byRes2[128];
}NET_DVR_ENCRYPT_DEVICE_INFO, *LPNET_DVR_ENCRYPT_DEVICE_INFO;
//加密证书参数结构体
typedef struct _NET_DVR_ENCRYPT_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertType; //证书类型，0-CA根证书，1-签名证书,3-加密证书，4- SM2加密密钥对
    BYTE byRes1[2]; //保留
    DWORD dwCertLen; //证书长度
    BYTE  byRes2[32]; 
    char* pCertBuf;  //证书缓冲区
}NET_DVR_ENCRYPT_CERT_PARAM, *LPNET_DVR_ENCRYPT_CERT_PARAM;
/******************************安全防范视频监控联网信息安全 end******************************************/
#define MAX_RING_NAME_LEN_128                128    //铃音名称长度
typedef struct tagNET_DVR_RING_UPLOAD_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //铃音名称
    DWORD     dwRingSize;   //文件大小
    BYTE        byRingType;   //铃音类型，0-wav
    BYTE        byRes[363];
}NET_DVR_RING_UPLOAD_CFG,*LPNET_DVR_RING_UPLOAD_CFG;

typedef struct tagNET_DVR_RING_SEARCH_COND
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，傻瓜式查找，不设置此参数（设为0）表示无视序号查找
    BYTE        byRes[300];
}NET_DVR_RING_SEARCH_COND,*LPNET_DVR_RING_SEARCH_COND;

typedef struct tagNET_DVR_RING_SEARCH_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //铃音名称
    DWORD     dwRingSize;   //文件大小
    BYTE        byRingType;   //铃音类型，0-wav
    BYTE        byRes[303];
}NET_DVR_RING_SEARCH_CFG,*LPNET_DVR_RING_SEARCH_CFG;

//报警控制
typedef struct tagNET_DVR_ALARMCTRL_CFG
{
    DWORD   dwSize;
    BYTE    byListenPicUploadEnabled;//监听图片上传使能
    BYTE    byRes [259];
}NET_DVR_ALARMCTRL_CFG,*LPNET_DVR_ALARMCTRL_CFG;

//雷达测速配置
typedef struct tagNET_DVR_POSTRADARSPEED_CFG
{
    DWORD   dwSize;//结构体大小
    BYTE    byLaneType; //道路类型；0~未配置,1~高速公路,2~城市快速路,0xff~其他道路
    BYTE    byRes1[3];
    DWORD   dwInterval; //超速抓拍间隔，单位：ms
    DWORD   dwSignSpeed;//标志限速(小车)，单位km/h
    DWORD   dwSpeedLimit;//限速值(小车)，单位km/h
    DWORD   dwBigCarSignSpeed;//标志限速(大车)，单位km/h
    DWORD   dwBigCarSpeedLimit;//限速值（大车），单位km/h
    DWORD   dwLowSpeedLimit;// 小车限低速，单位km/h
    DWORD   dwBigCarLowSpeedLimit;// 大车限低速，单位km/h
    BYTE    byCheckPostEnabled; //启用卡口抓拍
    BYTE    byOverSpeedEnabled; //启用超速抓拍
    BYTE    byRes[246];
}NET_DVR_POSTRADARSPEED_CFG, *LPNET_DVR_POSTRADARSPEED_CFG;

//雷达参数配置
typedef struct tagNET_DVR_POSTRADARPARAM_CFG
{
    DWORD   dwSize;//结构体大小
    BYTE    bySoftWareVersion[32];//软件版本号 只读参数
    BYTE    byID; //串口号
    BYTE    byWorkMode; //工作模式，0~持续,1~触头,2~触尾,3~巡逻车触尾,4~双触,0xff~其他
    BYTE    bySpeedType; //速度格式，0~单字节,1~双字节,2~四字节,0xff~其他
    BYTE    byDirectionFilter; //方向过滤，0~不过滤,1~输出来向,2~输出去向
    DWORD   dwAngleCorrect;//角度修正[0,70]
    DWORD   dwSensitivity;// 灵敏度[11,240]
    DWORD   dwSpeedLowLimit;// 测速下限[1,150km/h]
    DWORD   dwTrigDistance;// 触发距离[0,40m]
    BYTE    byRes[256];
}NET_DVR_POSTRADARPARAM_CFG, *LPNET_DVR_POSTRADARPARAM_CFG;

typedef struct tagNET_DVR_CLOUD_URL_COND
{
    DWORD   dwSize;
    BYTE    byType;     //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byRes[63];
}NET_DVR_CLOUD_URL_COND, *LPNET_DVR_CLOUD_URL_COND;

typedef struct tagNET_DVR_CLOUD_URL
{
    DWORD   dwSize;
    char    szURL[256]; //云存储URL
    BYTE    byRes[256];
}NET_DVR_CLOUD_URL, *LPNET_DVR_CLOUD_URL;

typedef struct tagNET_DVR_CLOUD_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //0-不开启，1-开启
    BYTE    byType;        //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byStatus;    //状态，只读 0-保留 1-在线 2-不在线
    BYTE    byRes1;
    char    szAuthCode[CODE_LEN]; //授权码
    char    szAlias[ALIAS_LEN];    //别名，只读
    INT64    i64TotalCapability;            //总容量，只读，单位：MB
    INT64    i64UsedSpace;                //已用容量，只读，单位：MB
    BYTE    byRes2[256];
}NET_DVR_CLOUD_CFG, *LPNET_DVR_CLOUD_CFG;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;    //通道号
    BYTE    byRes[254];    //为将来使用流ID做保留
}NET_DVR_CLOUD_UPLOADSTRATEGY_COND, *LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY
{
    DWORD      dwSize;
    BYTE    byStrategyType;    //策略类型0-无意义，1-录像，2-图片
    BYTE    byRes1[3];
    DWORD    dwRecordType;    //策略类型byStrategyType 为1时有效，按位表示
    /*0x00: 无意义*/
    /*0x01: 全部事件*/
    /*0x02: 移动侦测*/
    /*0x04: 信号量报警类型*/
    /*0x08: 智能类型*/
    BYTE    byRes[256];
}NET_DVR_CLOUD_UPLOADSTRATEGY, *LPNET_DVR_CLOUD_UPLOADSTRATEGY;

//录像完整性检查条件参数
typedef  struct tagNET_DVR_RECORD_CHECK_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byCheckType;        //检测方式,0--录像是否完整,1--录像是否完整&缺失录像的起止时间
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //检测录像的开始时间
    NET_DVR_TIME_EX struEndTime;    //检测录像的结束时间
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_COND, *LPNET_DVR_RECORD_CHECK_COND;

//录像完整性检查结果
typedef  struct tagNET_DVR_RECORD_CHECK_RET
{
    DWORD    dwSize; 
    BYTE   byRecordNotComplete;    //录像是否完整，0--完整,1--不完整
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //缺失录像的开始时间，byCheckType、byRecordNotComplete值都为1时有效
    NET_DVR_TIME_EX struEndTime;    //缺失录像的结束时间，byCheckType、byRecordNotComplete值都为1时有效
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_RET, *LPNET_DVR_RECORD_CHECK_RET;

//添加手动回传任务条件
typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND;

//添加手动回传任务参数
typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    NET_DVR_TIME_EX struBeginTime;    //回传的录像开始时间
    NET_DVR_TIME_EX struEndTime;    //回传的录像结束时间
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG;

//获取所有手动回传任务条件参数
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byType;        //获取方式,0--获取全部剩余任务，1--根据流ID获取剩余任务, 2--获取全部任务，3--根据流ID获取任务
    BYTE   byRes1[3];                //保留
    NET_DVR_STREAM_INFO    struStreamInfo;    //流id信息（72字节），根据流ID获取剩余任务时有效
    BYTE    byRes[128];                //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_RECORD_PASSBACK_MANUAL_COND;

//获取所有手动回传任务参数
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;    //流id信息（72字节），根据流ID获取剩余任务时有效
    DWORD        dwTaskID;        //任务ID
    NET_DVR_TIME_EX    struStartTime;  //回传的录像开始时间
    NET_DVR_TIME_EX    struStopTime;   //回传的录像结束时间
    BYTE        byTaskStatus;    //任务状态，0--未执行，1--暂停中，2--已执行, 3--回传中
    BYTE        byRes1[3];
    NET_DVR_TIME_EX    struExecuteStartTime;//任务实际执行开始时间，byTaskStatus为1和2有效
    NET_DVR_TIME_EX    struExecuteStopTime;//任务实际执行结束时间，byTaskStatus为2有效
    BYTE        byRes[128];        //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET, *LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

//控制手动回传任务参数
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_CTRL
{
    DWORD    dwSize;
    BYTE    byControlType;    //控制方式,0--暂停所有手动任务，1--恢复所有手动任务
    BYTE    byRes[131];        //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_CTRL, *LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

//删除手动回传任务条件
typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byDelType;    //删除方式,0--根据任务ID删除，1--根据流ID删除任务，2--删除全部任务
    BYTE    byRes[131];    //保留
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

//删除手动回传任务参数
typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    DWORD    dwTaskID;    //手动回传任务ID，根据任务ID删除任务时有效
    NET_DVR_STREAM_INFO    struStreamInfo;    //流id信息（72字节），根据流ID删除任务时有效
    BYTE    byRes[128];    //保留
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

typedef struct tagNET_DVR_PASSBACK_DAY
{
    BYTE    byAllDay;    //是否启用全天回传
    BYTE    byRes[3];    //保留
}NET_DVR_PASSBACK_DAY, *LPNET_DVR_PASSBACK_DAY;

typedef struct tagNET_DVR_PASSBACK_SCHED
{
    NET_DVR_SCHEDTIME    struPassBackTime;    //回传任务时间段，开始时间-结束时间
    BYTE        byRes[4];        //保留
}NET_DVR_PASSBACK_SCHED, *LPNET_DVR_PASSBACK_SCHED;

//录像回传计划参数
typedef struct tagNET_DVR_RECORD_PASSBACK_SCH_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //是否启用，0--不启用，1--启用
    BYTE    byPassBackWeek;    //是否按周回传，0--否，1--是，值为1时struPassBackDay、struPassBackSched无效
    BYTE    byRes1[2];            //保留
    NET_DVR_PASSBACK_DAY    struPassBackDay[MAX_DAYS];  //全天回传计划
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //时间段回传计划
    BYTE   byRes[128];        //保留
}NET_DVR_RECORD_PASSBACK_SCH_CFG, *LPNET_DVR_RECORD_PASSBACK_SCH_CFG;

//录像卷参数
typedef struct tagNET_DVR_DEV_STORAGE_CFG
{
    DWORD    dwSize;
    DWORD    dwCapacityTotal;        //设备存储(CVR表示录像卷)总容量(只读)，单位MB
    DWORD    dwFreeSpaceTotal;        //设备存储(CVR表示录像卷)剩余总空间(只读)，单位MB
    DWORD    dwLockedRecordSpace;    //设备已加锁录像存储(CVR表示录像卷)总容量(只读)，单位MB
    DWORD    dwUnLockedSpace;        //设备未加锁存储(CVR表示录像卷)总容量(只读),包含未加锁录像和剩余存储空间，单位MB
    BYTE    byRes[512];                //保留
}NET_DVR_DEV_STORAGE_CFG, *LPNET_DVR_DEV_STORAGE_CFG;

//设备连接的用户参数
typedef struct tagNET_DVR_ONLINE_USER_INFO_
{
    DWORD    dwSize;
    WORD    wOnlineUserCount;    //登录设备的用户数
    BYTE   byRes[514];    //保留
}NET_DVR_ONLINE_USER_INFO, *LPNET_DVR_ONLINE_USER_INFO;

//查询录像总大小条件参数
typedef struct tagNET_DVR_RECORD_SEGMENT_COND_
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreanInfo;
    NET_DVR_TIME_EX    struStartTime;  //开始时间
    NET_DVR_TIME_EX    struStopTime;    //结束时间
    BYTE        byRes[256];        //保留
}NET_DVR_RECORD_SEGMENT_COND, *LPNET_DVR_RECORD_SEGMENT_COND;

//查询录像总大小返回参数
typedef struct tagNET_DVR_RECORD_SEGMENT_RET_
{
    DWORD    dwSize;
    DWORD    dwRecordTotalSize;    //录像总大小，单位MB
    BYTE    byRes[256];        //保留
}NET_DVR_RECORD_SEGMENT_RET, *LPNET_DVR_RECORD_SEGMENT_RET;

//船只检测单个区域配置
typedef struct tagNET_DVR_SHIPSDETECTION_REGION_CFG
{

    BYTE    byRuleID;
    BYTE    byEnable;     //使能
    BYTE    bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE    byFrameOverlayEnabled;//视频是否叠加检测框
    BYTE   byRes[36];
    NET_ITC_POLYGON struPolygon; //触发区域
    NET_VCA_LINE struTriggerLine;  //触发线
}NET_DVR_SHIPSDETECTION_REGION_CFG, *LPNET_DVR_SHIPSDETECTION_REGION_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//使能
    BYTE   byRes1[3];
    float    fLookDownUpAngle;//设备俯仰角度，精确到小数点后一位
    float    fHorizontalHeight;//设备水平高度，精确到小数点后一位
    NET_DVR_SHIPSDETECTION_REGION_CFG struShipsDetectionRegion[MAX_SHIPSDETE_REGION_NUM];//船只检测单个区域配置
    BYTE   byRes[256];
}NET_DVR_SHIPSDETECTION_CFG, *LPNET_DVR_SHIPSDETECTION_CFG;


typedef    struct tagNET_DVR_THERMOMETRY_BASICPARAM
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byStreamOverlay; //码流叠加温度信息：0- 否，1- 是
    BYTE         byPictureOverlay;//抓图叠加温度信息：0- 否，1- 是
    BYTE        byThermometryRange;//测温范围: 0-默认值,1-(-20~150),2-(0~550)（这里以摄氏度为单位计算）
    BYTE        byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)。
    BYTE        byRes[127];
}NET_DVR_THERMOMETRY_BASICPARAM, *LPNET_DVR_THERMOMETRY_BASICPARAM;

typedef    struct tagNET_DVR_THERMOMETRY_COND
{
    DWORD        dwSize;//结构体大小
    DWORD        dwChannel;
    WORD        wPresetNo;//0-保留
    BYTE        byRes[62];
}NET_DVR_THERMOMETRY_COND, *LPNET_DVR_THERMOMETRY_COND;

typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO_PARAM
{
    BYTE    byEnabled;  //是否使能：0- 否，1- 是
    BYTE    byRuleID;//规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
    WORD    wDistance;//距离(m)[0, 10000]
    float   fEmissivity;//发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
    BYTE    byRes[3];
    BYTE    byReflectiveEnabled;//反射温度使能：0- 否，1- 是
    float   fReflectiveTemperature;//反射温度 精确到小数后一位
    char    szRuleName[NAME_LEN/*32*/];//规则名称    
    BYTE    byRes1[63];
    BYTE    byRuleCalibType;//规则标定类型 0-点，1-框，2-线
    NET_VCA_POINT struPoint;//点测温坐标（当规则标定类型为"点"的时候生效）
    NET_VCA_POLYGON struRegion;//区域、线（当规则标定类型为"框"或者"线"的时候生效）
}NET_DVR_THERMOMETRY_PRESETINFO_PARAM, *LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM;


typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO
{
    DWORD        dwSize;//结构体大小
    WORD        wPresetNo;//0-保留
    BYTE        byRes[2];
    NET_DVR_THERMOMETRY_PRESETINFO_PARAM struPresetInfo[MAX_THERMOMETRY_REGION_NUM/*40*/];
}NET_DVR_THERMOMETRY_PRESETINFO, *LPNET_DVR_THERMOMETRY_PRESETINFO;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE_PARAM
{
    BYTE      byEnable;
    BYTE      byRuleID;//规则ID
    BYTE      byRule;//报警温度比较方式 0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于    
    BYTE      byRes;
    char      szRuleName[NAME_LEN];//规则名称
    float      fAlert;//预警温度
    float      fAlarm;//报警温度
    float      fThreshold;//门限温度
    BYTE      byRes1[64];
}NET_DVR_THERMOMETRY_ALARMRULE_PARAM, *LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE
{
    DWORD        dwSize;//结构体大小
    NET_DVR_THERMOMETRY_ALARMRULE_PARAM  struThermometryAlarmRuleParam[THERMOMETRY_ALARMRULE_NUM];
    BYTE        byRes[128];
}NET_DVR_THERMOMETRY_ALARMRULE, *LPNET_DVR_THERMOMETRY_ALARMRULE;


typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM
{
    BYTE       byEnable;
    BYTE       byRuleID;//规则ID,0-表示无效，范围值从1开始
    BYTE       byAlarmID1;
    BYTE       byAlarmID2;
    BYTE       byRule;//报警温度比较方式0-高温大于,1-高温小于,2-低温大于,3-低温小于,4-平均温大于,5-平均温小于,6-温差大于,7-温差小于
    BYTE       byRes[3];
    float      fTemperatureDiff;//温差值
    BYTE       byRes1[32];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON
{
    DWORD        dwSize;//结构体大小
    NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM  struDiffComparison[MAX_THERMOMETRY_DIFFCOMPARISON_NUM/*8*/];
    BYTE        byRes[64];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON;


//实时温度检测条件结构
typedef struct tagNET_DVR_REALTIME_THERMOMETRY_COND
{
    DWORD        dwSize;
    DWORD        dwChan;
    BYTE        byRes[64]; //保留
}NET_DVR_REALTIME_THERMOMETRY_COND, *LPNET_DVR_REALTIME_THERMOMETRY_COND;

typedef struct tagNET_DVR_POINT_THERM_CFG
{
    float        fTemperature;//当前温度
    NET_VCA_POINT struPoint;//点测温坐标（当规则标定类型为点的时候生效）
    BYTE    byRes[120];
}NET_DVR_POINT_THERM_CFG, *LPNET_DVR_POINT_THERM_CFG;

typedef struct tagNET_DVR_LINEPOLYGON_THERM_CFG
{
    float       fMaxTemperature;//最高温
    float        fMinTemperature;//最低温
    float       fAverageTemperature;//平均温
    float        fTemperatureDiff;//温差
    NET_VCA_POLYGON struRegion;//区域（当规则标定类型为框/线的时候生效）
    BYTE    byRes[32];
}NET_DVR_LINEPOLYGON_THERM_CFG, *LPNET_DVR_LINEPOLYGON_THERM_CFG;

typedef struct tagNET_DVR_THERMOMETRY_UPLOAD
{
    DWORD       dwSize;
    DWORD       dwRelativeTime;     // 相对时标
    DWORD       dwAbsTime;            // 绝对时标
    char        szRuleName[NAME_LEN/*32*/];//规则名称
    BYTE        byRuleID;//规则ID号
    BYTE        byRuleCalibType;//规则标定类型 0-点，1-框，2-线
    WORD        wPresetNo; //预置点号
    NET_DVR_POINT_THERM_CFG struPointThermCfg;
    NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
    BYTE        byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    BYTE        byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE        byRes[126];
}NET_DVR_THERMOMETRY_UPLOAD, *LPNET_DVR_THERMOMETRY_UPLOAD;

//温度报警（检测温度和配置温度比较报警）
typedef struct tagNET_DVR_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE    byRuleID;//规则ID
    BYTE    byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    WORD    wPresetNo; //预置点号
    NET_PTZ_INFO  struPtzInfo;//ptz坐标信息
    BYTE    byAlarmLevel;//0-预警 1-报警
    BYTE    byAlarmType;/*报警类型 0-最高温度 1-最低温度 2-平均温度 3-温差*/
    BYTE    byAlarmRule;//0-大于，1-小于
    BYTE    byRuleCalibType;//规则标定类型 0-点，1-框，2线
    NET_VCA_POINT struPoint;//点测温坐标（当规则标定类型为点的时候生效）
    NET_VCA_POLYGON struRegion;//区域（当规则标定类型为框的时候生效）
    float   fRuleTemperature;/*配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    float   fCurrTemperature;/*当前温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    DWORD   dwThermalInfoLen;//热成像附加信息长度
    char*   pPicBuff; ///可见光图片指针
    char*   pThermalPicBuff;// 热成像图片指针
    char*   pThermalInfoBuff; //热成像附加信息指针
    NET_VCA_POINT struHighestPoint;//线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
    BYTE    byRes[60];
}NET_DVR_THERMOMETRY_ALARM, *LPNET_DVR_THERMOMETRY_ALARM;


//温差报警
typedef struct tagNET_DVR_THERMOMETRY_DIFF_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE    byAlarmID1;//规则AlarmID1
    BYTE    byAlarmID2;//规则AlarmID2
    WORD    wPresetNo; //预置点号
    BYTE    byAlarmLevel;//0-预警 1-报警
    BYTE    byAlarmType;/*报警类型 0-最高温度 1-最低温度 2-平均温度*/
    BYTE    byAlarmRule;//0-大于，1-小于
    BYTE    byRuleCalibType;//规则标定类型 0-点，1-框，2线
    NET_VCA_POINT struPoint[2];//点测温坐标（当规则标定类型为点的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    NET_VCA_POLYGON struRegion[2];//区域（当规则标定类型为框的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    float   fRuleTemperatureDiff;/*配置规则温差,精确到小数点后一位(-40-1000),（浮点数+100）*/
    float   fCurTemperatureDiff;/*当前温差,精确到小数点后一位(-40-1000),（浮点数+100） */
    NET_PTZ_INFO  struPtzInfo;//ptz坐标信息
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    DWORD   dwThermalInfoLen;//热成像附加信息长度
    char*   pPicBuff; ///可见光图片指针
    char*   pThermalPicBuff;// 热成像图片指针
    char*   pThermalInfoBuff; //热成像附加信息指针
    BYTE    byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（H），2-开尔文(K)
    BYTE    byRes[63];
}NET_DVR_THERMOMETRY_DIFF_ALARM, *LPNET_DVR_THERMOMETRY_DIFF_ALARM;

typedef  struct  //条件结构
{
    DWORD   dwSize;
    DWORD  dwChannel;//通道号（前端默认是1）
    BYTE   byRes[128];
}NET_DVR_SHIPSCOUNT_COND, *LPNET_DVR_SHIPSCOUNT_COND;


//获取船只计数信息结构
typedef struct tagNET_DVR_SHIPSCOUNT_CFG
{
    DWORD dwSize;
    DWORD dwUpShipsCount; //上行船只数
    DWORD dwDownShipsCount; //下行船只数
    DWORD dwLeftShipsCount; //左行船只数
    DWORD dwRightShipsCount; //右行船只数
    DWORD dwTotalCount;//船只总计数
    DWORD dwRelativeTime; //设备侧计数开始计数的相对时标
    DWORD dwAbsTime; //设备侧计数开始计数的绝对时标
    BYTE   byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE   byRes[255];
}NET_DVR_SHIPSCOUNT_CFG, *LPNET_DVR_SHIPSCOUNT_CFG;

//船只信息
typedef struct tagNET_DVR_SHIPSINFO
{
    float     fShipsLength; //船只长度；1~1000.0m，精确到小数点后一位
    float     fShipsHeight; //船只高度；1~1000.0m，精确到小数点后一位
    float     fShipsWidth;  //船只宽度；1~1000.0m，精确到小数点后一位
    float     fShipsSpeed;  //船只速度；1~1000.0m/s，精确到小数点后一位
    BYTE      byShipsDirection;//船只方向；0~up,1~down,2~left,3~right
    BYTE      byShipsDetState;//船只检测状态；0~正跨越检测线，1~船头检测，2~船尾检测
    BYTE      byRes[62];
    NET_VCA_POLYGON  struShipsRect; //船只区域，归一化值，相对于大图（可见光图、热成像图)的分辨率
} NET_DVR_SHIPSINFO, *LPNET_DVR_SHIPSINFO;

//船只检测报警上传
typedef struct tagNET_DVR_SHIPSDETECTION_ALARM
{
    DWORD   dwSize;
    NET_VCA_DEV_INFO  struDevInfo;   //设备信息
    DWORD   dwRelativeTime; //相对时标
    DWORD   dwAbsTime; //绝对时标
    BYTE    byShipsNum; //船只数；(正跨越检测线的船只数)
    BYTE    byShipsNumHead;//船只数；(船头检测船只数)
    BYTE    byShipsNumEnd; //船只数；(船尾检测船只数)
    BYTE    byRes1;
    NET_DVR_SHIPSINFO struShipInfo[MAX_SHIPS_NUM/*20*/];//船只信息；最大支持20艘
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    BYTE*   pPicBuffer;    //可见光图片数据指针
    BYTE*   pThermalPicBuffer;    //热成像图片数据指针
    BYTE    byRes[256];
}NET_DVR_SHIPSDETECTION_ALARM, *LPNET_DVR_SHIPSDETECTION_ALARM;

typedef struct tagNET_DVR_BAREDATAOVERLAY_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//使能
    BYTE    byIntervalTime;// 上传的时间间隔可配置：1 2 3 4 5.单位为秒，默认为3秒
    BYTE    byRes[258];
}NET_DVR_BAREDATAOVERLAY_CFG, *LPNET_DVR_BAREDATAOVERLAY_CFG;

//测温联动条件结构
typedef    struct tagNET_DVR_THERMOMETRY_TRIGGER_COND
{
    DWORD    dwSize;//结构体大小
    DWORD    dwChan;//通道号
    DWORD    dwPreset;//预置点号
    BYTE     byRes[256];
}NET_DVR_THERMOMETRY_TRIGGER_COND, *LPNET_DVR_THERMOMETRY_TRIGGER_COND;

//手动除冰
typedef    struct tagNET_DVR_MANUALDEICING_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled; //是否启用手动除冰 ，0~关闭，1~启用
    BYTE        byRes[127];
}NET_DVR_MANUALDEICING_CFG, *LPNET_DVR_MANUALDEICING_CFG;

//小间距LED控制器
typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_COND
{
    DWORD    dwSize;
    DWORD    dwInputSourceNo;    //输入源编号
    DWORD    dwTextNo;        //文本编号
    BYTE    byRes[32];
}NET_DVR_INPUT_SOURCE_TEXT_COND, *LPNET_DVR_INPUT_SOURCE_TEXT_COND;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT
{
    DWORD        dwSize;
    DWORD        dwTextNo;            //文本编号
    BYTE        byEnable;            //是否使能，0-不使能，1-使能
    BYTE        byFontSize;            //字体大小
    BYTE        byBkGroudMode;        //背景模式，1-透明，2-覆盖
    BYTE        byRes[1];
    DWORD        dwXPosition;            //字符显示位置的左上角X坐标，输入源相对坐标
    DWORD        dwYPosition;            //字符显示位置的左上角Y坐标，输入源相对坐标
    NET_DVR_RGB_COLOR struForegroudColor;    //字符前景色
    NET_DVR_RGB_COLOR struBackgroudColor; //字符背景色
    BYTE        byTextContent[MAX_LEN_TEXT_CONTENT];    //字符内容
    BYTE        byRes1[64];
}NET_DVR_INPUT_SOURCE_TEXT, *LPNET_DVR_INPUT_SOURCE_TEXT;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_SOURCE_TEXT struTextList[MAX_NUM_INPUT_SOURCE_TEXT]; //文本列表
    BYTE    byRes[64];
}NET_DVR_INPUT_SOURCE_TEXT_LIST, *LPNET_DVR_INPUT_SOURCE_TEXT_LIST;

typedef struct  tagNET_DVR_INPUT_SOURCE_RESOLUTION
{
    DWORD  dwSize;
    DWORD  dwInputSignalNo;  //输入源编号
    BYTE  byEnabled;  //自定义分辨率是否使能
    BYTE  byRes;
    WORD  wImageWidth;     //图像宽度
    WORD  wImageHeight;  //图像高度
    WORD  wRefreshRate;     //刷新频率
    BYTE    byColorDepth;  //颜色深度，32位、16位、8位三种可选
    BYTE    byScanType;  //扫描类型，1-逐行扫描，2-间隔扫描
    BYTE    byRes1[62];
}NET_DVR_INPUT_SOURCE_RESOLUTION, *LPNET_DVR_INPUT_SOURCE_RESOLUTION;

typedef struct tagNET_DVR_INPUT_SOURCE_RESOLUTION_LIST
{
    DWORD dwSize;
    DWORD dwInputSignalCnt; //设备输入信号源数量
    LPNET_DVR_INPUT_SOURCE_RESOLUTION lpstruBuffer; //缓冲区指针
    DWORD dwBufferSize; //缓冲区大小
    BYTE  byRes[32];
}NET_DVR_INPUT_SOURCE_RESOLUTION_LIST, *LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

typedef struct tagNET_DVR_LED_AREA_COND
{
    DWORD dwSize;
    DWORD dwVideoWallNo; //电视墙编号
    DWORD dwLEDAreaNo; //LED区域编号
    BYTE   byRes[32];
}NET_DVR_LED_AREA_COND, *LPNET_DVR_LED_AREA_COND;

typedef struct tagNET_DVR_LED_AREA_INFO
{
    DWORD dwSize;
    DWORD dwLEDAreaNo; //LED区域编号
    NET_DVR_RECTCFG_EX struRect; //矩形区域
    DWORD dwaOutputNo[MAX_NUM_OUTPUT_CHANNEL]; //输出口列表
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO, *LPNET_DVR_LED_AREA_INFO;

typedef struct tagNET_DVR_LED_AREA_INFO_LIST
{
    DWORD dwSize;
    DWORD dwLEDAreaNum; //LED区域数量
    LPNET_DVR_LED_AREA_INFO lpstruBuffer; //缓冲区指针
    DWORD dwBufferSize; //缓冲区大小
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO_LIST, *LPNET_DVR_LED_AREA_INFO_LIST;

//呼叫等待参数
typedef struct tagNET_DVR_CALL_WAITTING_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用呼叫等待, 0--不启用，1--启用
    BYTE    byRes1;
    WORD    wWaitTime;//呼叫等待时间，单位秒
    BYTE    byRes[512];
}NET_DVR_CALL_WAITTING_CFG, *LPNET_DVR_CALL_WAITTING_CFG;

//警灯参数
typedef struct tagNET_DVR_ALARM_LAMP_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用警灯定时闪烁, 0--不启用，1--启用
    BYTE    byRes1;
    WORD   wFlashDuration;//警灯定时闪烁持续时间，单位秒
    WORD   wFlashIntervalTime;//警灯闪烁间隔时间，单位秒
    BYTE    byRes[510];
}NET_DVR_ALARM_LAMP_CFG, *LPNET_DVR_ALARM_LAMP_CFG;

//语音提示参数
typedef struct tagNET_DVR_VOICE_PROMPTION_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用语音提示, 0--不启用，1--启用
    BYTE    byRes1[3];
    BYTE    byCenterBusyFile[NAME_LEN];//中心繁忙提示语音文件名
    BYTE    byRefusedFile[NAME_LEN];//拒绝提示语音文件名
    BYTE    byHangUpFile[NAME_LEN];//对讲结束提示语音文件名
    BYTE    byCallWaittingFile[NAME_LEN];//呼叫等候音文件名
    BYTE    byRes[512];
}NET_DVR_VOICE_PROMPTION_CFG, *LPNET_DVR_VOICE_PROMPTION_CFG;

//紧急报警处理
typedef struct tagNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG
{
    DWORD   dwSize;        //结构体大小
    BYTE    byCommand;    //控制命令，0--centerbusy，1--refuse
    BYTE    byRes[511];
}NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG, *LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

///////////*网络参数配置_V50/////////////
typedef struct _tagNET_DVR_ALARMHOST_NETPARAM_V50
{
    DWORD     dwSize;
    NET_DVR_IPADDR  struIP;
    WORD     wPort;
    BYTE    byAddressType;    //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE    byEnable; //使能，0-不启用，1-启用
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //域名，GPRS参数配置、网络参数配置时该字段均有效
    BYTE    byReportProtocol;        //1-private 2-NAL2300
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //协议为NAL2300时有效
    BYTE    byRes2[64]; //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
} NET_DVR_ALARMHOST_NETPARAM_V50, *LPNET_DVR_ALARMHOST_NETPARAM_V50;

typedef struct _tagNET_DVR_ALARMHOST_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM_V50   struNetCenter[MAX_CENTERNUM];
    BYTE        byRes1[128];
} NET_DVR_ALARMHOST_NETCFG_V50, *LPNET_DVR_ALARMHOST_NETCFG_V50;
//目标封装格式类型
typedef enum tagSTREAM_TYPE{
    STREAM_PS    = 0x1,   //PS文件层，主要用于存储，也可用于传输
    STREAM_3GPP  = 0x2,   //3GPP文件层，用于存储
}STREAM_TYPE;
typedef enum tagNET_SDK_INIT_CFG_TYPE
{
    NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0, //增加对必须库的检查
    NET_SDK_INIT_CFG_ABILITY = 1   //sdk支持的业务的能力集
}NET_SDK_INIT_CFG_TYPE;

typedef struct tagNET_DVR_INIT_CHECK_MODULE_COM
{
    BYTE byEnable; //启用必须库检查机制 0-不启用，1-启用
    BYTE byRes[255];
}NET_DVR_INIT_CHECK_MODULE_COM, *LPNET_DVR_INIT_CHECK_MODULE_COM;

//SDK支持的最大路数能力集
typedef enum _INIT_CFG_MAX_NUM
{
    INIT_CFG_NUM_2048 = 2048,   // 2048路
    INIT_CFG_NUM_5120 = 5120,   //5120路
    INIT_CFG_NUM_10240 = 10240,   // 10240路
    INIT_CFG_NUM_15360 = 15360,   // 15360路
    INIT_CFG_NUM_20480 = 20480,   // 20480路
}INIT_CFG_MAX_NUM;

typedef struct tagNET_DVR_INIT_CFG_ABILITY
{
    INIT_CFG_MAX_NUM    enumMaxLoginUsersNum;                //最多允许的注册用户个数。
    INIT_CFG_MAX_NUM   enumMaxAlarmNum;                      //最大的告警路数
    BYTE    byRes[64];
}NET_DVR_INIT_CFG_ABILITY, *LPNET_DVR_INIT_CFG_ABILITY;

typedef struct tagNET_DVR_SDKMEMPOOL_CFG
{
    BYTE byRes[256];
}NET_DVR_SDKMEMPOOL_CFG, *LPNET_DVR_SDKMEMPOOL_CFG;

/********************************SDK接口函数声明*********************************/
NET_DVR_API BOOL __stdcall NET_DVR_Init();
NET_DVR_API BOOL __stdcall NET_DVR_Cleanup();

//NET_DVR_SetDVRMessage的扩展
#ifdef _WIN32
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessage(UINT nMessage,HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT nMessage, HWND hWnd, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
#elif defined(__linux__) || defined(__APPLE__)
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT reserved1, void* reserved2, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
/*Linux专有 */
#if defined(__linux__)
NET_DVR_API BOOL NET_DVR_DrawAreaInit(INITINFO InitInfo, DWORD iUseSDL = 1);
NET_DVR_API BOOL NET_DVR_DrawAreaRelease();
#endif
#endif

NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack(BOOL (CALLBACK *fMessCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_EX(BOOL (CALLBACK *fMessCallBack_EX)(LONG lCommand,LONG lUserID,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_NEW(BOOL (CALLBACK *fMessCallBack_NEW)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, WORD dwLinkDVRPort));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack(BOOL (CALLBACK *fMessageCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, DWORD dwUser), DWORD dwUser);
typedef void (CALLBACK *MSGCallBack)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V30(MSGCallBack fMessageCallBack, void* pUser);
typedef BOOL (CALLBACK *MSGCallBack_V31)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V31(MSGCallBack_V31 fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V50(int iIndex, MSGCallBack fMessageCallBack, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetConnectTime(DWORD dwWaitTime = 3000, DWORD dwTryTimes = 3);
NET_DVR_API BOOL __stdcall NET_DVR_SetReconnect(DWORD dwInterval = 30000, BOOL bEnableRecon = TRUE);
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKVersion();
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKBuildVersion();
NET_DVR_API int __stdcall NET_DVR_IsSupport();
NET_DVR_API BOOL __stdcall NET_DVR_StartListen(char *sLocalIP,WORD wLocalPort);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen();

NET_DVR_API LONG __stdcall NET_DVR_StartListen_V30(char *sLocalIP, WORD wLocalPort, MSGCallBack DataCallback, void* pUserData = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen_V30(LONG lListenHandle);
NET_DVR_API LONG __stdcall NET_DVR_Login(char *sDVRIP,WORD wDVRPort,char *sUserName,char *sPassword,LPNET_DVR_DEVICEINFO lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V30(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);

NET_DVR_API LONG __stdcall NET_DVR_Login_V40(LPNET_DVR_USER_LOGIN_INFO pLoginInfo,LPNET_DVR_DEVICEINFO_V40 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Login_Check(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Logout(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Logout_V30(LONG lUserID);
NET_DVR_API DWORD __stdcall NET_DVR_GetLastError();
NET_DVR_API char* __stdcall NET_DVR_GetErrorMsg(LONG *pErrorNo = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_SetShowMode(DWORD dwShowType,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRIPByResolveSvr(char *sServerIP, WORD wServerPort, BYTE *sDVRName,WORD wDVRNameLen,BYTE *sDVRSerialNumber,WORD wDVRSerialLen,char* sGetIP);
NET_DVR_API BOOL  __stdcall NET_DVR_GetDVRIPByResolveSvr_EX(char *sServerIP, WORD wServerPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP, DWORD *dwPort);

//预览相关接口
NET_DVR_API LONG __stdcall NET_DVR_PlayDirect(char *sDVRIP, char *sUserName, char *sPassword, \
                                              LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay(LONG lUserID,LPNET_DVR_CLIENTINFO lpClientInfo);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V30(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API BOOL __stdcall NET_DVR_StopRealPlay(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayDirect(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RigisterDrawFun(LONG lRealHandle,void (CALLBACK* fDrawFun)(LONG lRealHandle,HDC hDc,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayerBufNumber(LONG lRealHandle,DWORD dwBufNum);
NET_DVR_API BOOL __stdcall NET_DVR_ThrowBFrame(LONG lRealHandle,DWORD dwNum);
NET_DVR_API BOOL __stdcall NET_DVR_SetAudioMode(DWORD dwMode);
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_Volume(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData(LONG lRealHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopSaveRealData(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBack(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBack(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture(LONG lRealHandle,char *sPicFileName);//bmp
NET_DVR_API BOOL __stdcall NET_DVR_SetCapturePictureMode(DWORD dwCaptureMode);

//动态生成I帧
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrame(LONG lUserID, LONG lChannel);//主码流
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrameSub(LONG lUserID, LONG lChannel);//子码流

//云台控制相关接口
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_Other(LONG lUserID,LONG lChannel,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_Other(LONG lUserID,LONG lChannel,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_EX(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_EX(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_EX(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_EX(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_Other(LONG lUserID, LONG lChannel, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_EX(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_Other(LONG lUserID, LONG lChannel, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_EX(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCruise(LONG lUserID,LONG lChannel,LONG lCruiseRoute, LPNET_DVR_CRUISE_RET lpCruiseRet);


//文件查找与回放
NET_DVR_API LONG __stdcall NET_DVR_FindFile(LONG lUserID,LONG lChannel,DWORD dwFileType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile(LONG lFindHandle,LPNET_DVR_FIND_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V30(LONG lFindHandle, LPNET_DVR_FINDDATA_V30 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V40(LONG lFindHandle, LPNET_DVR_FINDDATA_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V30(LONG lUserID, LPNET_DVR_FILECOND pFindCond);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_V30(LONG lFindHandle);

NET_DVR_API BOOL __stdcall NET_DVR_LockFileByName(LONG lUserID, char *sLockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByName(LONG lUserID, char *sUnlockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByNameV40(LONG lUserID, BOOL bLock, const NET_DVR_LOCK_FILE_BY_NAME_PARA *lpLockFilePara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName(LONG lUserID,char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);

NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl(LONG lPlayHandle,DWORD dwControlCode,DWORD dwInValue,DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBack(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayBackESCallBack(LONG lPlayHandle, void (CALLBACK *fPlayESCallBack)(LONG lPlayHandle, NET_DVR_PACKET_INFO_EX *struPackInfo,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack_V40(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack_V40) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackSaveData(LONG lPlayHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBackSave(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlayBackOsdTime(LONG lPlayHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackCaptureFile(LONG lPlayHandle,char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName(LONG lUserID,char *sDVRFileName,char *sSavedFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetFile(LONG lFileHandle);
NET_DVR_API int __stdcall NET_DVR_GetDownloadPos(LONG lFileHandle);
NET_DVR_API int    __stdcall NET_DVR_GetPlayBackPos(LONG lPlayHandle);

//升级
NET_DVR_API LONG __stdcall NET_DVR_AdapterUpgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_VcalibUpgrade(LONG lUserID, LONG lChannel, char const *sFileName);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeState(LONG lUpgradeHandle);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeProgress(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseUpgradeHandle(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetNetworkEnvironment(DWORD dwEnvironmentLevel);
//远程格式化硬盘
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk(LONG lUserID,LONG lDiskNumber);
NET_DVR_API BOOL __stdcall NET_DVR_GetFormatProgress(LONG lFormatHandle, LONG *pCurrentFormatDisk,LONG *pCurrentDiskPos,LONG *pFormatStatic);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFormatHandle(LONG lFormatHandle);
//报警
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan(LONG lAlarmHandle);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V30(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan_V30(LONG lAlarmHandle);
//语音对讲
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_V30(LONG lUserID, DWORD dwVoiceChan, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceComClientVolume(LONG lVoiceComHandle, WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_StopVoiceCom(LONG lVoiceComHandle);
//语音转发
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR_V30(LONG lUserID, DWORD dwVoiceChan, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceComSendData(LONG lVoiceComHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress(LONG lUserID, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress_V50(LONG lUserID, LPNET_DVR_AUDIO_CHANNEL lpAudioChannel, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
//语音广播
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart();
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart_V30(void(CALLBACK *fVoiceDataCallBack)(char *pRecvDataBuffer, DWORD dwBufSize, void * pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStop();
NET_DVR_API BOOL __stdcall NET_DVR_AddDVR(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_AddDVR_V30(LONG lUserID, DWORD dwVoiceChan);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR_V30(LONG lVoiceHandle);
//透明通道设置
NET_DVR_API LONG __stdcall NET_DVR_SerialStart(LONG lUserID,LONG lSerialPort,void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle,char *pRecvDataBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
//485作为透明通道时，需要指明通道号，因为不同通道号485的设置可以不同(比如波特率)
NET_DVR_API LONG __stdcall NET_DVR_SerialStart_V40(LONG lUserID,void* lpInBuffer, LONG dwInBufferSize, void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle, LONG lCHannel, char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SerialSend(LONG lSerialHandle, LONG lChannel, char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SerialStop(LONG lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SendTo232Port(LONG lUserID, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SendToSerialPort(LONG lUserID, DWORD dwSerialPort, DWORD dwSerialIndex, char *pSendBuf, DWORD dwBufSize);

//解码 nBitrate = 16000
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder(int nBitrate = 16000);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *pDecHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
//编码
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);

//解码
NET_DVR_API void* __stdcall NET_DVR_InitG726Decoder(void** pDecMoudle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG726Frame(void *pDecMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
//编码
NET_DVR_API void* __stdcall NET_DVR_InitG726Encoder(void** pEncMoudle);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG726Frame(void *pEncMoudle,BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Encoder(void *pEncHandle);
//远程控制本地显示
NET_DVR_API BOOL __stdcall NET_DVR_ClickKey(LONG lUserID, LONG lKeyIndex);
//远程控制设备端手动录像
NET_DVR_API BOOL __stdcall NET_DVR_StartDVRRecord(LONG lUserID,LONG lChannel,LONG lRecordType);
NET_DVR_API BOOL __stdcall NET_DVR_StopDVRRecord(LONG lUserID,LONG lChannel);
//解码卡
NET_DVR_API BOOL __stdcall NET_DVR_InitDevice_Card(long *pDeviceTotalChan);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDevice_Card();
NET_DVR_API BOOL __stdcall NET_DVR_InitDDraw_Card(HWND hParent,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDraw_Card();
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card(LONG lUserID,LPNET_DVR_CARDINFO lpCardInfo,long lChannelNum);
NET_DVR_API BOOL __stdcall NET_DVR_ResetPara_Card(LONG lRealHandle,LPNET_DVR_DISPLAY_PARA lpDisplayPara);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_ClearSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_RestoreSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetVolume_Card(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_AudioPreview_Card(LONG lRealHandle,BOOL bEnable);
NET_DVR_API LONG __stdcall NET_DVR_GetCardLastError_Card();
NET_DVR_API HANDLE __stdcall NET_DVR_GetChanHandle_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_Card(LONG lRealHandle, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetSerialNum_Card(long lChannelNum,DWORD *pDeviceSerialNo);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog(LONG lLogHandle, LPNET_DVR_LOG lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V30(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, BOOL bOnlySmart = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V30(LONG lLogHandle, LPNET_DVR_LOG_V30 lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose_V30(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindAlarmHostLog(LONG lUserID, LONG lSelectMode, NET_DVR_ALARMHOST_SEARCH_LOG_PARAM *lpSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextAlarmHostLog(LONG lFindHandle, NET_DVR_ALARMHOST_LOG_RET *lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindAlarmHostLogClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByCard(LONG lUserID,LONG lChannel,DWORD dwFileType, int nFindType, BYTE *sCardNumber, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_NEW(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sJpegPicBuffer, DWORD dwPicSize,  LPDWORD lpSizeReturned);
NET_DVR_API int __stdcall NET_DVR_GetRealPlayerIndex(LONG lRealHandle);
NET_DVR_API int __stdcall NET_DVR_GetPlayBackPlayerIndex(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG(LONG lUserID, DWORD dwScale);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG(LONG lUserID, DWORD *lpOutScale);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_SetATMPortCFG(LONG lUserID, WORD wATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetATMPortCFG(LONG lUserID, WORD *LPOutATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_InitDDrawDevice();
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDrawDevice();
NET_DVR_API LONG __stdcall NET_DVR_GetDDrawDeviceTotalNums();
NET_DVR_API BOOL __stdcall NET_DVR_SetDDrawDevice(LONG lPlayPort, DWORD nDeviceNum);

NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn(LONG lRealHandle, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn_EX(LONG lUserID, LONG lChannel, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecode(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERINFO lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecode(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecoderState(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERSTATE lpDecoderState);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_DecPlayBackCtrl(LONG lUserID, LONG lChannel, DWORD dwControlCode, DWORD dwInValue,DWORD *LPOutValue, LPNET_DVR_PLAYREMOTEFILE lpRemoteFileInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlDec(LONG lUserID, LONG lChannel, DWORD dwControlCode);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlScreen(LONG lUserID, LONG lChannel, DWORD dwControl);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecCurLinkStatus(LONG lUserID, LONG lChannel, LPNET_DVR_DECSTATUS lpDecStatus);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DYNAMIC_DEC lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopDynamic(LONG lUserID, DWORD dwDecChanNum); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecEnable(LONG lUserID, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_STATUS lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetVideoStandard(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwVideoStandard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetVideoStandard(LONG lUserID, DWORD dwDecChanNum, DWORD dwVideoStandard);

//2007-12-22 增加支持接口 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlayControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwControlCode, DWORD dwInValue, DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetRemotePlayStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS lpOuter);
//2009-4-13 新增
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);

NET_DVR_API LONG __stdcall NET_DVR_MatrixStartPassiveDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_PASSIVEMODE lpPassiveMode /*, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser*/);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSendData(LONG lPassiveHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopPassiveDecode(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_DISP_LOGOCFG lpDispLogoCfg, char *sLogoBuffer);
#define    NET_DVR_SHOWLOGO            1        /*显示LOGO*/
#define    NET_DVR_HIDELOGO            2        /*隐藏LOGO*/  
NET_DVR_API BOOL __stdcall NET_DVR_LogoSwitch(LONG lUserID, DWORD dwDecChan, DWORD dwLogoSwitch);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus(LONG lUserID,  LPNET_DVR_DECODER_WORK_STATUS lpDecoderCfg);

#define    DISP_CMD_ENLARGE_WINDOW                1    /*显示通道放大某个窗口*/
#define    DISP_CMD_RENEW_WINDOW                2    /*显示通道窗口还原*/
#define    DISP_CMD_OPENAUDIO                    3    /*显示通道打开音频*/
#define    DISP_CMD_CLOSEAUDIO                    4    /*显示通道关闭音频*/

NET_DVR_API BOOL __stdcall NET_DVR_MatrixDiaplayControl(LONG lUserID, DWORD dwDispChanNum, DWORD dwDispChanCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPassiveDecodeControl(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PASSIVEDECODE_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_MatrixGetPassiveDecodeStatus(LONG lPassiveHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshPlay(LONG lPlayHandle);
//恢复默认值
NET_DVR_API BOOL __stdcall NET_DVR_RestoreConfig(LONG lUserID);
//保存参数
NET_DVR_API BOOL __stdcall NET_DVR_SaveConfig(LONG lUserID);
//重启
NET_DVR_API BOOL __stdcall NET_DVR_RebootDVR(LONG lUserID);
//关闭DVR
NET_DVR_API BOOL __stdcall NET_DVR_ShutDownDVR(LONG lUserID);

//参数配置 begin
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState_V30(LONG lUserID, LPNET_DVR_WORKSTATE_V30 lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState(LONG lUserID, LPNET_DVR_WORKSTATE lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_SetVideoEffect(LONG lUserID, LONG lChannel, DWORD dwBrightValue, DWORD dwContrastValue, DWORD dwSaturationValue, DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetVideoEffect(LONG lUserID, LONG lChannel, DWORD *pBrightValue, DWORD *pContrastValue, DWORD *pSaturationValue, DWORD *pHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_SetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmProtocol(LONG lUserID, LPNET_DVR_ATM_PROTOCOL lpAtmProtocol);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut_V30(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS_V30 lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmOut(LONG lUserID, LONG lAlarmOutPort,LONG lAlarmOutStatic);

//视频参数调节
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetVideoEffect(LONG lRealHandle,DWORD dwBrightValue,DWORD dwContrastValue, DWORD dwSaturationValue,DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetVideoEffect(LONG lRealHandle,DWORD *pBrightValue,DWORD *pContrastValue, DWORD *pSaturationValue,DWORD *pHueValue);

//配置文件
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_V30(LONG lUserID, char *sOutBuffer, DWORD dwOutSize, DWORD *pReturnSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_EX(LONG lUserID, char *sOutBuffer, DWORD dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile_EX(LONG lUserID, char *sInBuffer, DWORD dwInSize);

//启用日志文件写入接口
NET_DVR_API BOOL __stdcall NET_DVR_SetLogToFile(DWORD nLogLevel = 0, char * strLogDir = NULL, BOOL bAutoDel = TRUE);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKState(LPNET_DVR_SDKSTATE pSDKState);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKAbility(LPNET_DVR_SDKABL pSDKAbl);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol(LONG lUserID, NET_DVR_PTZCFG *pPtzcfg);
//前面板锁定
NET_DVR_API BOOL __stdcall NET_DVR_LockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_UnLockPanel(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_SetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpOutBuffer, DWORD dwOutBufferSize);

//能力集获取
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceAbility(LONG lUserID, DWORD dwAbilityType, char* pInBuf, DWORD dwInLength, char* pOutBuf, DWORD dwOutLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);

//智能
//设置/获取参数关键字
NET_DVR_API BOOL __stdcall NET_DVR_SetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int nValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int *pValue);

//获取/设置行为分析目标叠加接口
NET_DVR_API BOOL __stdcall NET_DVR_GetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);
NET_DVR_API BOOL __stdcall NET_DVR_SetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);

//球机跟踪模式设置接口
NET_DVR_API BOOL __stdcall NET_DVR_SetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);

//重启智能库
NET_DVR_API BOOL __stdcall NET_VCA_RestartLib(LONG lUserID, LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData_V30(LONG lRealHandle, DWORD dwTransType, char *sFileName);

NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V40(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V40  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V40(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET_V40 lpSearchEventRet);
//停止采用 NET_DVR_FindClose

NET_DVR_API LONG __stdcall NET_DVR_FindPDCInfo(LONG lUserID, LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPDCInfo(LONG lFindHandle,LPNET_DVR_PDC_QUERY lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindPDCClose(LONG lFindHandle);

// 标定校验 
#define NET_DVR_PDC_VERIFY_CALIBRATION          1    //当值为1是为PDC标定校验 pdc传入值为NET_VCA_POINT   传出值为 NET_VCA_RECT结构
#define NET_DVR_VERIFY_BEHAVIOR_CALIBRATION     2    // 行为分析标定线校验 
#define NET_DVR_VERIFY_ITS_CALIBRATION            3    // 智能交通标定校验 
#define NET_DVR_VERIFY_BV_CALIBRATION            5    //双目标定校验

NET_DVR_API BOOL __stdcall  NET_DVR_VerifyCalibration(LONG lUserID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOuterBuffer, DWORD dwOuterBufferSize);
NET_DVR_API BOOL __stdcall  NET_DVR_ResetCounter(LONG lUserID,LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_MATRIX(LONG lLogHandle, LPNET_DVR_LOG_MATRIX lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_Matrix(LONG lUserID, LONG lSelectMode, DWORD dwMajorType, DWORD dwMinorType, LPNET_DVR_VEDIOPLATLOG lpVedioPlatLog, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

NET_DVR_API BOOL __stdcall NET_DVR_ManualSnap(LONG lUserID, NET_DVR_MANUALSNAP const* lpInter, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol_Ex(LONG lUserID, LONG lChannel, NET_DVR_PTZCFG *pPtzcfg);

NET_DVR_API LONG __stdcall NET_DVR_StartEmailTest(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopEmailTest(LONG lEmailTestHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetEmailTestProgress(LONG lEmailTestHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST lpProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList_V41(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST_V41 lpProtoList);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch_V40(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM_V40 lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SearchNextInfo(LONG lSearchHandle, LPNET_DVR_SMART_SEARCH_RET lpSmartSearchRet);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearch(LONG lSearchHandle);

// IP San 文件目录查找
NET_DVR_API LONG __stdcall NET_DVR_FindIpSanDirectory(LONG lUserID, LPNET_DVR_IPSAN_SERACH_PARAM lpIpsanSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDirectory(LONG lFindHandle, LPNET_DVR_IPSAN_SERACH_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindDirectoryClose(LONG lFindHandle);

typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

NET_DVR_API LONG __stdcall NET_DVR_ZeroStartPlay(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL, BOOL bBlocked = TRUE);

NET_DVR_API BOOL __stdcall NET_DVR_ZeroStopPlay(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroMakeKeyFrame(LONG lUserID, LONG lZeroChan);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl_V40(LONG lPlayHandle,DWORD dwControlCode, LPVOID lpInBuffer = NULL, DWORD dwInLen = 0, LPVOID lpOutBuffer = NULL, DWORD *lpOutLen = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroTurnOver(LONG lUserID, LONG lChannel, BOOL bNextPreview);

NET_DVR_API BOOL __stdcall NET_DVR_GetDiskList(LONG lUserID, LPNET_DVR_DISKABILITY_LIST lpDiskList);
NET_DVR_API LONG __stdcall NET_DVR_Backup(LONG lUserID, DWORD dwBackupType, LPVOID lpBackupBuff, DWORD dwBackupBuffSize);
NET_DVR_API LONG __stdcall NET_DVR_BackupByName(LONG lUserID, LPNET_DVR_BACKUP_NAME_PARAM lpBackupByName);
NET_DVR_API LONG __stdcall NET_DVR_BackupByTime(LONG lUserID, LPNET_DVR_BACKUP_TIME_PARAM lpBackupBytime);
NET_DVR_API BOOL __stdcall NET_DVR_GetBackupProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopBackup(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_GetSadpInfoList(LONG lUserID, LPNET_DVR_SADPINFO_LIST lpSadpInfoList);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateSadpInfo(LONG lUserID, LPNET_DVR_SADP_VERIFY lpSadpVerify, LPNET_DVR_SADPINFO lpSadpInfo);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_SetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestDeleteFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCDWByFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpCdrwFile);
NET_DVR_API LONG __stdcall NET_DVR_InquestUploadFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_InquestUploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_InquestGetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStartCDW( LONG lUserID, BOOL bPause);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStopCDW(LONG lUserID, BOOL bCancelWrite);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDWState(LONG lUserID, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCheckSecretKey(LONG lUserID, BOOL *bSecretSet);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetSecretKey(LONG lUserID, LPNET_DVR_INQUEST_SECRET_INFO pSecretInfo);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStreamEncrypt(LONG lUserID, LONG lChannel, BOOL bEncrypt);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetEncryptState(LONG  lUserID, LONG lChannel, BOOL *bEncrypt);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindFile(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindNextFile(LONG lFindHandle, LPNET_DVR_INQUEST_FILEINFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_InquestFindClose(LONG lFindHandle);

// 9000RH
NET_DVR_API LONG __stdcall NET_DVR_RaidFastConfig(LONG lUserID, char *sName);
NET_DVR_API BOOL __stdcall NET_DVR_FastConfigProcess(LONG lHandle, DWORD *pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFastConfig(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetArraySpaceAlloc(LONG lUserID, DWORD dwSlot, LPNET_DVR_ARRAY_SPACE_ALLOC_INFO lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DelArray(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_CreateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CalcArraySize(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam, UINT64* lpArraySize);
NET_DVR_API BOOL __stdcall NET_DVR_MigrateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_RebuildArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVD(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM lpVDParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVDEx(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM_EX lpVDParamEx);
NET_DVR_API BOOL __stdcall NET_DVR_DelVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_RepairVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_SetSpareDisk(LONG lUserID, LPNET_DVR_SPARE_DISK_PARAM lpSpareDisk);
NET_DVR_API BOOL __stdcall NET_DVR_GetPDList(LONG lUserID, LPNET_DVR_PHY_DISK_LIST lpPDList);
NET_DVR_API BOOL __stdcall NET_DVR_GetArrayList(LONG lUserID, LPNET_DVR_ARRAY_LIST lpArrayList);
NET_DVR_API BOOL __stdcall NET_DVR_GetVDList(LONG lUserID, LPNET_DVR_VD_LIST lpVDList);
NET_DVR_API LONG __stdcall NET_DVR_ExpandDisk(LONG lUserID,DWORD dwVDSLot);
NET_DVR_API BOOL __stdcall NET_DVR_GetExpandProgress(LONG lExpandHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseExpandHandle(LONG lExpandHandle);
NET_DVR_API LONG __stdcall NET_DVR_AlgoDebugStart(LONG lUserID, LONG lCHannel, void(CALLBACK *fAlgoLibInfoCallBack)(LONG lHandle, LONG lChannel,char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugSend(LONG lHandle, LONG lChannel, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugStop(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrint(BOOL bLogPrint);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrintAction(DWORD nLogLevel, DWORD nToDevice, BOOL bEnable, int Reserve1, int Reserve2);

NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_SetSceneMode(LONG  lUserID, LONG lChannel, DWORD dwSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetSceneMode(LONG lUserID, LONG lChannel, DWORD  *pSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetVCAVersion(LONG lUserID, LONG lChannel, LPNET_DVR_VCA_VERSION lpVersion);

NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);     
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPicAdjust(LONG lUserID, DWORD dwDispChan, DWORD dwPicAdjust, DWORD dwCmdParam); 
NET_DVR_API BOOL __stdcall NET_DVR_AlarmJoinedRecord(LONG lUserID, DWORD dwChan, DWORD dwAlarmSeq, DWORD dwRecordTime, DWORD dwRes);
NET_DVR_API BOOL __stdcall NET_DVR_GetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_UNITEDMATRIXINFO lpInter);
typedef LONG(CALLBACK * REGCallBack)(LONG lUserID, LPNET_DVR_REGCALLBACKPARAM pRegCallbackParam, LPNET_DVR_LOGONREPONSEPARAM pInterParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRegisterCallBack(REGCallBack fRegCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewRequest(LONG lUserID, LONG lChannel, LPNET_DVR_PREVIEWPARAM lpPreviewParam, LPNET_DVR_DEVICENATINFO lpOuter);
typedef LONG(CALLBACK * PREVIEWRESPONSECallBack)(LONG lUserID, LONG lStreamHandle, LPNET_DVR_PREVIEWCALLBACKPARAM pPewviewCallbackParam,void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPreviewResponseCallBack(PREVIEWRESPONSECallBack fPreviewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlaybackRequest(LONG lUserID, LPNET_DVR_PLAYBACKREQUESTPARAM lpPlayBackRequestParam);
typedef LONG(CALLBACK * PLAYBACKRESPONSECallBack)(LONG lUserID, LONG lPlaybackHandle, LPNET_DVR_PLAYBACKCALLBACKPARAM lpPlaybackParam,void *pUser);     
NET_DVR_API BOOL __stdcall NET_DVR_SetPlaybackResponseCallBack(PLAYBACKRESPONSECallBack fPlaybackResponseCallBack, void *pUser);          
typedef LONG(CALLBACK * VOICERESPONSECallBack)(LONG lUserID, LONG lVoiceHandle, LONG lVoiceChannel, BYTE nAudioType, void *pUser);     
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceResponseCallBack(VOICERESPONSECallBack fVoiceResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceRequest(LONG lUserID, LPNET_DVR_VOICEREQUESTPARAM lpVoiceParam);           
NET_DVR_API BOOL __stdcall NET_DVR_AlarmSetupRequest(LONG lUserID, LPNET_DVR_ALARMSETUPREQUESTPARAM lpAlarmSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);                      
NET_DVR_API BOOL __stdcall NET_DVR_SetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsListInfo(LONG lUserID, LPNET_DVR_TIME_EX lpStartTime, LPNET_DVR_TIME_EX lpStopTime, LPNET_DVR_SMSLISTINFO lpSmsListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsContent(LONG lUserID, DWORD dwSmsIndex, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API BOOL __stdcall NET_DVR_SendSms(LONG lUserID, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API LONG __stdcall NET_DVR_StartServer(char *sLocalIP, WORD wLocalPort, BYTE byMode);
NET_DVR_API BOOL __stdcall NET_DVR_StopServer(LONG lServerHandle); 
NET_DVR_API LONG __stdcall NET_DVR_StartRecvNakedDataListen(NAKED_DATA_TYPE type, LPNET_DVR_NAKED_DATA_PARAM pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopRecvNakedDataListen(LONG lNakedDataRecvHandle);          
typedef void(CALLBACK * NAKEDDAtACALLBACK)(DWORD typeInfo, char *pInfo, DWORD dwInfoLen,DWORD dwIPLen, void* pUser);
NET_DVR_API BOOL __stdcall  NET_DVR_SetNakedDataRecvCallBack(LONG lNakedDataRecvHandle, void(CALLBACK *fNakedDataCallBack)(DWORD dwTypeInfo, NET_DVR_NAKED_DATA_INFO *pStruNakedDataInfo, char *pInfo, DWORD dwInfoLen, void* pUser), void* pUser);

typedef LONG(CALLBACK * ALARMSETUPRESPONSECallBack)(LONG lUserID, LONG lAlarmHandle, void * pUser);         
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSetupResponseCallBack(ALARMSETUPRESPONSECallBack fAlarmSetupResponseCallBack, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SpringJPEGPicture(LONG lUserID, LONG lChannel, NET_DVR_PUSHJPEGPARA const *lpJpegPara);
NET_DVR_API BOOL __stdcall NET_DVR_SetPushModeParam(LPNET_DVR_PUSHMODEPARAM pPushParam);

NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetupAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostCloseAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_BypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_UnBypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostAssistantControl(LONG lUserID, DWORD dwType, DWORD dwNumber, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceTypeList(LONG lUserID, NET_DVR_DEVICE_TYPE_LIST *lpDeviceTypeList);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceProtoList(LONG lUserID, LONG lDeviceType, NET_DVR_DEVICE_PROTO_LIST *lpDeviceProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetBatteryVoltage(LONG lUserID, float *pVoltage);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_ControlGateway(LONG lUserID, LONG lGatewayIndex, DWORD dwStaic);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmHostOut(LONG lUserID, LONG lAlarmOutPort, LONG lAlarmOutStatic);
typedef void(CALLBACK *fAlarmHostSerialDataCallBack)
(LONG lSerialHandle, LONG lPort, LONG lDateType, char *pRecvDataBuffer, DWORD  dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_AlarmHostSerialStart(LONG lUserID, LONG lSerialType, fAlarmHostSerialDataCallBack cbSerialDataCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialSend(LONG lSerialHandle,LONG lPort,char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialStop(LONG  lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetMatrixPuChan(LONG lUserID, LONG lChanType, NET_DVR_PU_CHAN_LIST* lpChanList);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmOffMonitor(LONG lUserID, DWORD dwMonID, DWORD dwCamID);
NET_DVR_API BOOL __stdcall NET_DVR_GetCameraListInfo(LONG lUserID, DWORD dwCamNum, DWORD dwStartCam, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetMonitorListInfo(LONG lUserID, DWORD dwMonNum, DWORD dwStartMon, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetGlobalNum(LONG lUserID, DWORD *dwCamNum, DWORD *dwMonNum); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);         
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSpanSwitch(LONG lUserID, BYTE nSwitchMode, LPNET_DVR_MATRIXSWITCH lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartSwitch(LONG lUserID, LPNET_DVR_MATRIXSWITCHCTRL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char *sInBuffer,  DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char  *sOutBuffer,  DWORD   dwOutSize,  DWORD   *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V40(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 lpInter);
typedef void (CALLBACK *FLOWTESTCALLBACK)(LONG lFlowHandle, LPNET_DVR_FLOW_INFO pFlowInfo, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartNetworkFlowTest(LONG lUserID, NET_DVR_FLOW_TEST_PARAM* pFlowTest,  FLOWTESTCALLBACK fFlowTestCallback, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_StopNetworkFlowTest(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindRecordLabel(LONG lUserID, LPNET_DVR_FIND_LABEL lpFindLabel);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLabel(LONG lFindHandle, LPNET_DVR_FINDLABEL_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_StopFindLabel(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_InsertRecordLabel(LONG lPlayHandle, NET_DVR_RECORD_LABEL* lpRecordLabel, NET_DVR_LABEL_IDENTIFY *lpLableIdentify);
NET_DVR_API BOOL __stdcall NET_DVR_DelRecordLabel(LONG lUserID, NET_DVR_DEL_LABEL_PARAM* lpDelLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_ModifyRecordLabel(LONG lUserID, NET_DVR_MOD_LABEL_PARAM * lpModLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock(LONG lPlayHandle, char *sPicFileName, DWORD dwTimeOut);
NET_DVR_API LONG __stdcall NET_DVR_FindPicture(LONG lUserID, NET_DVR_FIND_PICTURE_PARAM* pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture(LONG lFindHandle,LPNET_DVR_FIND_PICTURE lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V40(LONG lFindHandle,LPNET_DVR_FIND_PICTURE_V40 lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFindPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture(LONG lUserID,char *sDVRFileName,const char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V30(LONG lUserID, char *sDVRFileName, char *sSavedFileBuf, DWORD dwBufLen, DWORD *lpdwRetLen);
NET_DVR_API LONG __stdcall NET_DVR_BackupPicture(LONG lUserID, NET_DVR_BACKUP_PICTURE_PARAM *lpBackupPicture);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeStep(LONG lUpgradeHandle, LONG *pSubProgress);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetEncodeJoint(LONG lUserID, LONG lChannel, LPNET_DVR_ENCODE_JOINT_PARAM lpEncodeJoint);
NET_DVR_API BOOL  __stdcall NET_DVR_GetLocalIP(char strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL  __stdcall NET_DVR_SetValidIP(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetVcaDevWorkState(LONG lUserID, LPNET_DVR_VCA_DEV_WORKSTATUS lpWorkState);
NET_DVR_API BOOL  __stdcall NET_DVR_SetRecvTimeOut(DWORD nRecvTimeOut = 5000); //最小3000毫秒
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);              
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_ShutterCompensation(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CorrectDeadPixel(LONG lUserID, LONG lChannel, LPNET_DVR_CORRECT_DEADPIXEL_PARAM lpInParam);
NET_DVR_API BOOL __stdcall NET_DVR_CustomConfig(LONG lUserID, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricDataInfo(LONG lUserID, LONG lChannel, LPNET_DVR_HISTORICDATACFG lpHisData);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricData(LONG lUserID, LONG lChannel, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ClearHistoricData(LONG lUserID, LONG lChannel);
NET_DVR_API LONG  __stdcall NET_DVR_InquestUploadFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom,  char *sFileName);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestDeleteFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSendMessage(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_MESSAGE lpInquestMessage);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStartCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bNotBurn);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bCancelWrite);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetCDWState_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API LONG  __stdcall NET_DVR_InquestResumeEvent(LONG lUserID, LPNET_DVR_INQUEST_RESUME_EVENT lpResumeEvent);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetResumeProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopResume(LONG lHandle);
NET_DVR_API LONG  __stdcall NET_DVR_InquestFindFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM pInquestRoom);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetDeviceVersion(LONG lUserID, LPNET_DVR_INQUEST_DEVICE_VERSION lpVersionInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_SetSDKSecretKey(LONG lUserID, char *sSecretKey);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenZoomIn(LONG lUserID, LPNET_DVR_SCREENZOOM pStruScreen);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllCameraInfo(LONG lUserID, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleCameraInfo(LONG lUserID, DWORD dwCameraId, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddCamera(LONG lUserID, DWORD dwCameraNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModCameraInfo(LONG lUserID, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelCamera(LONG lUserID, DWORD dwCameraId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMonitorInfo(LONG lUserID, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleMonitorInfo(LONG lUserID, DWORD dwMonitorId, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddMonitor(LONG lUserID, DWORD dwMonitorNum, BYTE *pBuffer, DWORD dwBufLength);            
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModMonitorInfo(LONG lUserID, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelMonitor(LONG lUserID, DWORD dwMonitorId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMatrixInfo(LONG lUserID, LPNET_DVR_MATRIXLIST lpMatrixListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSingleMatrixInfo(LONG lUserID, DWORD dwMatrixId, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AddMatrix(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_ModMatrixInfo(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelMatrix(LONG lUserID, DWORD dwMatrixId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUartParam(LONG lUserID, DWORD dwSerialChan , LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUser(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUser(LONG lUserID, DWORD dwUserNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUserGroup (LONG lUserID, DWORD dwUserGroupNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllTrunkInfo(LONG lUserID, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTrunkInfo(LONG lUserID, DWORD dwTrunkNum, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddTrunk(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModTrunkInfo(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkCtrl(LONG lUserID, DWORD dwTrunkNum, BYTE byCtrlMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkStatusQuery(LONG lUserID, DWORD dwTrunkNum, BYTE *byTrunkStatus);

NET_DVR_API BOOL __stdcall NET_DVR_FindBackgroundPic(LONG lUserID, DWORD dwPicID, BYTE *pPicBuffer, DWORD *lpPicLen);
NET_DVR_API BOOL __stdcall NET_DVR_DetectImage(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_GetPictureModel(LONG lUserID, LPNET_VCA_REGISTER_PIC lpInBuf, LPNET_VCA_PICMODEL_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_AddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API LONG __stdcall NET_DVR_FindBlackList(LONG lUserID, LPNET_VCA_BLACKLIST_COND lpBlackListCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextBlackList(LONG lFindHandle,LPNET_VCA_BLACKLIST_INFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindBlackListClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetBlackListPicture(LONG lUserID, DWORD dwRegisterID, LPNET_VCA_BLACKLIST_PIC lpOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateBlackList(LONG lUserID,LONG lChannel, LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelBlackList(LONG lUserID,LONG lChannel, DWORD dwRegisterID);
NET_DVR_API LONG __stdcall NET_DVR_FindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSnapPic(LONG lFindHandle,LPNET_VCA_SUB_SNAPPIC_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindSnapPicClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_AdvanceFindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND_ADVANCE lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFaceMatchAlarm(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFaceMatchAlarm(LONG lFindHandle, LPNET_VCA_FACESNAP_MATCH_ALARM_LOG lpFaceMatchAlarmLog);
NET_DVR_API BOOL __stdcall NET_DVR_FindFaceMatchAlarmClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetFaceMatchPic(LONG lUserID, LPNET_VCA_FACEMATCH_PICCOND lpMatchCond, LPNET_VCA_FACEMATCH_PICTURE lpMatchPic);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_FASTREGISTER_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpVoutCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus_V41(LONG lUserID, LPNET_DVR_DECODER_WORK_STATUS_V41 lpDecoderCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSceneControl(LONG lUserID, DWORD dwSceneNum, DWORD dwCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCurrentSceneMode(LONG lUserID, DWORD *dwSceneNum);
NET_DVR_API BOOL __stdcall NET_DVR_GetAllValidWinInfo(LONG lUserID, LPNET_DVR_WINLIST lpWinListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenWinCtrl(LONG lUserID, DWORD dwWinIndex, DWORD dwCommand, LPNET_DVR_SCREEN_WINCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenInputStatus(LONG lUserID, LPNET_DVR_SCREENINPUTSTATUS lpStatus);
NET_DVR_API LONG __stdcall NET_DVR_PicUpload(LONG lUserID, char const *sFileName, LPNET_DVR_PICTURECFG lpPictureCfg);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadProgress(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall  NET_DVR_CloseUploadHandle(LONG lUploadHandle);        
NET_DVR_API BOOL __stdcall NET_DVR_PicControl(LONG lUserID, BYTE byUseType, BYTE byPicIndex, BYTE byCtrlCmd);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadState(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenCtrl(LONG lUserID, DWORD dwDeviceNum, LPNET_DVR_SCREEN_CONTROL lpStruScreenCtrl);
typedef void (CALLBACK *SCREENPICDATACB)(LONG nScreenPicHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartScreenPic(LONG nUserID, DWORD nInputNum, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopScreenPic(LONG nScreenPicHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FocusOnePush(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_ResetLens(LONG lUserID, LONG lChannel);

typedef void(CALLBACK *fRemoteConfigCallback)(DWORD dwType, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_StartRemoteConfig(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferLen, fRemoteConfigCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopRemoteConfig(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetNextRemoteConfig(LONG lHandle, void* lpOutBuff, DWORD dwOutBuffSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRemoteConfigState(LONG lHandle, void *pState);
NET_DVR_API BOOL __stdcall NET_DVR_SendRemoteConfig(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwBufSize);

typedef void(CALLBACK *fLongCfgStateCallback)(LONG lHandle,  DWORD dwState, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseLongCfgHandle(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_RaidPullDiskStart(LONG lUserID, LONG lRaidID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_ScanRaidStart(LONG lUserID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_SetAccessCameraInfo(LONG lUserID, DWORD dwChannel, LPNET_DVR_ACCESS_CAMERA_INFO lpCameraInfo, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);

NET_DVR_API BOOL __stdcall NET_DVR_InquiryRecordTimeSpan(LONG lUserID, DWORD dwChannel,  NET_DVR_RECORD_TIME_SPAN_INQUIRY const *lpInquiry, LPNET_DVR_RECORD_TIME_SPAN lpResult);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateRecordIndex(LONG lUserID, DWORD dwChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetUpnpNatState(LONG lUserID, LPNET_DVR_UPNP_NAT_STATE lpState);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_EX lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrunkListInfo(LONG lUserID, DWORD dwTrunkNum, DWORD dwStartTrunk, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo, DWORD *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemSetupAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemCloseAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostClearAlarm(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypass(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypassResume (LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetReportMode(LONG lUserID, LONG lCenterNum, LPVOID lpInputBuf, DWORD dwInputBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostGetReportMode(LONG lUserID, LPVOID lpOutputBuf, DWORD dwOutputBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadAudio(LONG lUserID, DWORD dwAudioNum, DWORD dwAudioType, char const *sAudioFileName);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadAudio(LONG lUserID, DWORD dwAudioNum, char const *sAudioFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopAudioOperate(LONG lAudioHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetAudioProgress(LONG lAudioHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AudioCtrl(LONG lUserID, DWORD dwAudioNum, DWORD dwCtrlParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpInParamBuffer, DWORD dwInParamBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_LockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_StartManualRecord(LONG lUserID, LPNET_DVR_MANUAL_RECORD_PARA lpManualRecPara);
NET_DVR_API BOOL __stdcall NET_DVR_StopManualRecord(LONG lUserID, LPNET_DVR_STREAM_INFO pIDInfo);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V40(LONG lUserID, NET_DVR_VOD_PARA const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByTime_V40(LONG lUserID, HWND hWnd, LPNET_DVR_PLAYCOND pPlayCond);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime_V40(LONG lUserID, char *sSavedFileName, LPNET_DVR_PLAYCOND  pDownloadCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V40(LONG lUserID, LPNET_DVR_FILECOND_V40 pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V41(LONG lUserID, LPNET_DVR_SETUPALARM_PARAM lpSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_AddDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindDataBase(LONG lUserID, LPNET_VCA_FIND_DATABASE_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDataBase(LONG lFindHandle, LPNET_VCA_DATABASE_PARAM lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FindDataBaseClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteDataBase(LONG lUserID, LPNET_VCA_DELETE_DATABASE_COND lpCond);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_InquireSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_INQUIRE_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireSnapDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_SNAPRECORD_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_SearchSnapDB(LONG lUserID, LPNET_VCA_SEARCH_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchSnapDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_AddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_FAST_DATARECORD_INFO lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_InquireFaceDBRecord(LONG lUserID, LPNET_VCA_DATARECORD_COND lpInBuf,fSearchDBCallBack cbInquireDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireFaceDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_RECORD_COND lpInBuf);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lSearchHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_SearchFaceDB(LONG lUserID, LPNET_VCA_SEARCH_FACEDB_COND lpInBuf,fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchFaceDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearchDB(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FindMatchPicture(LONG lUserID, LPNET_VCA_FIND_MATCHPIC_COND lpFindCond, LPNET_VCA_FIND_MATCHPIC_RESULT lpFindResult);
NET_DVR_API BOOL __stdcall NET_DVR_RemoteControl(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);

NET_DVR_API BOOL __stdcall NET_DVR_PicViewRequest(LONG lUserID, NET_DVR_PIC_VIEW_PARAM *lpPicViewParam);
typedef LONG (CALLBACK *PicViewCallBack)(LPNET_DVR_PICVIEW_CALLBACKPARAM pStruPicViewParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewResponseCallBack(PicViewCallBack fPicViewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewDataCallBack(LONG lPicViewHandle, SCREENPICDATACB fPicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDevList(LONG lUserID, LPNET_DVR_DEVLIST lpDevListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenList(LONG lUserID, LPNET_DVR_SCREENLIST lpScreenListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetScreenRelation(LONG lUserID, NET_DVR_DISP_SCREEN const* lpScreenInfo);
NET_DVR_API BOOL __stdcall NET_DVR_TextShowCtrl(LONG lUserID, DWORD dwDeviceIndex, LPNET_DVR_TEXTSHOW lpText);
NET_DVR_API LONG __stdcall NET_DVR_StartUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, DVCS_UPGRADESTATE_CB UpgradeStateCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AddNetSignal(LONG lUserID, LPNET_DVR_NETSIGNAL_INFO lpStruSignal, void* lpOutBuf , DWORD dwBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartPicPreview(LONG lUserID, NET_DVR_START_PIC_VIEW_INFO const* lpStruStartPicView, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceStatus(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlanList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_PLAN_LIST lpPlanList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList_V40(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);

NET_DVR_API LONG __stdcall NET_DVR_UploadFile(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char* sFileName);
NET_DVR_API LONG __stdcall NET_DVR_UploadFile_V40(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char const * sFileName, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_GetUploadResult(LONG lUploadHandle, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_UploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadFile(LONG lUserID, LPNET_DVR_UPLOAD_PARAM  lpStruUploadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopUploadFile (LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadFile(LONG lUserID, LPNET_DVR_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownloadFile (LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadControl(LONG lDownloadHandle, NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM enumDownloadType, void* lpInBuffer, DWORD dwInBufferLen, void* lpOutBuffer, DWORD dwOutBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_UploadSend(LONG lUploadHandle, const NET_DVR_SEND_PARAM_IN *pstruSendParamIN, void* lpOutBuffer);


NET_DVR_API BOOL __stdcall NET_DVR_GetMobileDevStatus(LONG lUserID, DWORD dwStatusType, LPNET_DVR_MB_MOBILEDEV_STATUS lpstruMobileDevStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceDataCallBack(LONG lVoiceComHandle, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize, char *sOutBuffer, DWORD dwOutSize);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, const void *lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, void* lpOutBuff);

NET_DVR_API LONG __stdcall NET_DVR_OpticalUpgrade(LONG lUserID, char const *sFileName, LPNET_DVR_OPTICAL_INFO lpOpticalInfo);
typedef void(CALLBACK *fGPSDataCallback)(LONG nHandle, DWORD dwState, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_GetVehicleGpsInfo(LONG nUserID, LPNET_DVR_GET_GPS_DATA_PARAM lpGPSDataParam, fGPSDataCallback cbGPSDataCallback, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_ClosePreview(LONG lUserID, DWORD nSessionID);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePlayBack(LONG lUserID, DWORD nSessionID);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V40(LONG lUserID, LPNET_DVR_PREVIEWINFO lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);

NET_DVR_API LONG __stdcall NET_DVR_StartDownload(LONG lUserID, DWORD dwDownloadType, LPVOID lpInBuffer, DWORD dwInBufferSize, const char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadState(LONG lDownloadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownload(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_V41 lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 lpOuter);

NET_DVR_API LONG __stdcall NET_DVR_StartT1Test(LONG lUserID, LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API BOOL __stdcall NET_DVR_StopTT1Test(BOOL lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetT1TestStatus(LONG lHandle, LONG *pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SendT1TestData(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwSendBufLen);

NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo_NEW(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadLogo(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer, DWORD dwLogoBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_StartPassiveTransCode(LONG lUserID, NET_DVR_STREAM_INFO const *pStreamInfo, NET_DVR_COMPRESSIONCFG_V30 const *pDstTransInfo, NET_DVR_PASSIVETRANSINFO const *pPassiveTransInfo, void(CALLBACK *fTransCodeDataCallBack) (LONG lPassiveHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_TransCodeInputData(LONG lPassiveHandle, BYTE *pBuffer, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_StopPassiveTransCode(LONG lPassiveHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPassiveTransChanNum(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfigEx(LONG lUserID, DWORD dwCommand, DWORD dwCount, NET_DVR_IN_PARAM *lpInParam, NET_DVR_OUT_PARAM *lpOutParam);

NET_DVR_API BOOL __stdcall NET_DVR_GetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSTDAbility(LONG lUserID, DWORD dwAbilityType, LPNET_DVR_STD_ABILITY  lpAbilityParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDControl(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONTROL lpControlParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V40(DWORD lUserID, DWORD dwUpgradeType, char const *sFileName, void *pInbuffer, DWORD dwBufferLen);

NET_DVR_API BOOL __stdcall NET_DVR_DetectImage_V50(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT_V50 lpOutBuf);

NET_DVR_API LONG __stdcall NET_DVR_SmartSearchPicture(LONG lUserID, NET_DVR_SMART_SEARCH_PIC_PARA * pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSmartPicture(LONG lFindHandle,LPNET_DVR_SMART_SEARCH_PIC_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSmartSearchPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetESCallBack(LONG iRealHandle, void (__stdcall *fnESCallback)(LONG lPreviewHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ActivateDevice(char* sDVRIP, WORD wDVRPort, LPNET_DVR_ACTIVATECFG    lpActivateCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetAddrInfoByServer(DWORD     dwQueryType, void* pInBuf, DWORD dwInBufLen, void* pOutBuf, DWORD dwOutBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_StartGetDevState(LPNET_DVR_CHECK_DEV_STATE pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetDevState();
NET_DVR_API BOOL __stdcall NET_DVR_RigisterPlayBackDrawFun(LONG lPlayHandle, void (__stdcall *fDrawFun)(LONG lPlayHandle, HDC hDc, DWORD dwUser), DWORD dwUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKInitCfg(NET_SDK_INIT_CFG_TYPE enumType, void* const lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseSDKMemPool(LPNET_DVR_SDKMEMPOOL_CFG lpSdkMemPoolCfg);


#endif //

